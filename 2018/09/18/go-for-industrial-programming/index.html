<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>go 工业级编程 | 朝着牛逼的道路一路狂奔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="golang">
  
  
  
  
  <meta name="description" content="原文(https://peter.bourgon.org/go-for-industrial-programming/) 我们不应该盲目地应用教条主义的建议，每次我们应该使用我们的判断。 互联网上的一些人发现，你在科技行业呆的时间越长，你的观点就会变得越好，这要看情况而定，我不确定，这些是不是很好。根据我的经验，如果你发现随着你事业的发展，你会变得越来越固执己见，那么你很有可能陷入一种窠臼，成为一">
<meta name="keywords" content="golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 工业级编程">
<meta property="og:url" content="https://jigangduan.github.io/2018/09/18/go-for-industrial-programming/index.html">
<meta property="og:site_name" content="朝着牛逼的道路一路狂奔">
<meta property="og:description" content="原文(https://peter.bourgon.org/go-for-industrial-programming/) 我们不应该盲目地应用教条主义的建议，每次我们应该使用我们的判断。 互联网上的一些人发现，你在科技行业呆的时间越长，你的观点就会变得越好，这要看情况而定，我不确定，这些是不是很好。根据我的经验，如果你发现随着你事业的发展，你会变得越来越固执己见，那么你很有可能陷入一种窠臼，成为一">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://peter.bourgon.org/go-for-industrial-programming/venn.png">
<meta property="og:image" content="https://peter.bourgon.org/go-for-industrial-programming/metrics.png">
<meta property="og:image" content="https://peter.bourgon.org/go-for-industrial-programming/logging.png">
<meta property="og:image" content="https://peter.bourgon.org/go-for-industrial-programming/tracing.png">
<meta property="og:updated_time" content="2020-07-25T02:57:18.203Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go 工业级编程">
<meta name="twitter:description" content="原文(https://peter.bourgon.org/go-for-industrial-programming/) 我们不应该盲目地应用教条主义的建议，每次我们应该使用我们的判断。 互联网上的一些人发现，你在科技行业呆的时间越长，你的观点就会变得越好，这要看情况而定，我不确定，这些是不是很好。根据我的经验，如果你发现随着你事业的发展，你会变得越来越固执己见，那么你很有可能陷入一种窠臼，成为一">
<meta name="twitter:image" content="https://peter.bourgon.org/go-for-industrial-programming/venn.png">
  
    <link rel="alternate" href="/atom.xml" title="朝着牛逼的道路一路狂奔" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css">
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-go-for-industrial-programming" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Go 工业级编程
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/18/go-for-industrial-programming/" class="article-date">
	  <time datetime="2018-09-17T23:49:35.000Z" itemprop="datePublished">2018-09-18</time>
	</a>

      
    <a class="article-category-link" href="/categories/golang/">golang</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://peter.bourgon.org/go-for-industrial-programming/" target="_blank" rel="noopener">原文(https://peter.bourgon.org/go-for-industrial-programming/)</a></p>
<p>我们不应该盲目地应用教条主义的建议，每次我们应该使用我们的判断。</p>
<p>互联网上的一些人发现，你在科技行业呆的时间越长，你的观点就会变得越好，这要看情况而定，我不确定，这些是不是很好。<br>根据我的经验，如果你发现随着你事业的发展，你会变得越来越固执己见，那么你很有可能陷入一种窠臼，成为一个专业的初学者。不太好了!</p>
<p>明确定义一个适用范围，就能给自己留出一点空间来形成一个明确的意见：</p>
<ul>
<li>在创业或公司环境中;</li>
<li>在一个工程师来来去去的团队中;</li>
<li>比任何一个工程师都长寿的代码;</li>
<li>服务高度可变的业务需求。</li>
</ul>
<h2 id="构造代码和存储库"><a href="#构造代码和存储库" class="headerlink" title="构造代码和存储库"></a>构造代码和存储库</h2><p>我们经常看到的一件事是对严格的项目结构的期望，通常在项目开始时就预先决定了。我认为这通常是问题多于帮助。要理解原因，请记住工业编程的第四个特性，或许也是最重要的一个特性:</p>
<blockquote>
<p>工业编程 … 提供<code>高度可变的业务需求</code></p>
</blockquote>
<p>惟一不变的是变更，惟一的业务需求规则是它们 <strong>永远不会收敛</strong>，它们只会_发散、增长和变异。因此，我们应该确保我们的代码能够适应生活中的这一事实，而不是不必要地将自己限制在其中。我们的repos，我们的抽象，我们的代码本身应该易于维护，易于修改，易于适应，<strong>最终，易于删除</strong>。</p>
<p>有几件事通常是好主意。如果您的项目有多个二进制文件，最好有一个<code>cmd/</code>子目录来保存它们。如果您的项目很大并且有重要的非Go代码，比如UI资产或复杂的构建工具，那么将Go代码隔离在<code>pkg/</code>子目录中可能是一个好主意。如果您要有多个包，那么最好围绕业务领域来定位它们，而不是围绕实现的意外情况。即:<code>包用户</code>;而非<code>包模型</code>。</p>
<p>当然，业务领域和实现并不总是严格分开的。例如，大型web应用程序往往混合了传输和核心业务关注点。GoBuffalo之类的框架鼓励使用诸如操作、资产、模型和模板之类的包名。当您知道只处理HTTP时，将所有精力都放在耦合上是有好处的。</p>
<p>还有建议我们根据依赖边界对齐包。也就是说，为RedisStore、MySQLStore等提供单独的包，以避免外部消费者必须包含和编译对他们不需要的东西的支持。在我看来，对于具有封闭的导入器集的包来说，这是一种不合适的优化，但是对于第三方(如Kubernetes)广泛导入的包来说，这种优化非常有意义，因为在第三方，编译单元的大小可能成为真正的瓶颈。</p>
<p>所以有一个适用范围。我认为最好的一般性建议是，一旦你觉得有必要，具体地说，只选择加入一点结构。我的大多数项目仍然以package main中的几个文件开始，它们捆绑在repo的根目录下。它们一直保持这种状态，直到它们变成至少几千行代码。我的许多项目，甚至大多数项目，都没有走到这一步。Go的一个好处是它能让人感觉很轻;我喜欢尽可能长时间地保存它。</p>
<h2 id="程序配置"><a href="#程序配置" class="headerlink" title="程序配置"></a>程序配置</h2><p><strong>Flags是最好的方式来配置您的项目</strong>,因为它们自我记录的方式来描述您的程序在运行时的配置。</p>
<p>这在工业上下文中尤其重要，在工业上下文中，无论谁在运行服务，都可能不是其原始作者。如果使用<code>-h</code>标志运行程序提供了控制其行为的旋钮和开关的完整列表，那么对于随叫随到的工程师来说，在发生事件时调整某些东西是非常容易的，或者对于新工程师来说，让它在他们的开发环境中运行也是非常容易的。这比在(可能已经过时的)文档中查找一组相关的环境变量，或者找出配置文件格式的语法和有效键名要容易得多。</p>
<p>这并不意味着永远不要使用env vars或配置文件。除了使用标志之外，还有很好的理由使用其中之一或两者。Env vars对于连接字符串和非秘密的auth令牌非常有用，尤其是在开发期间。配置文件对于声明详细的配置非常有用，而且是将秘密放入程序的最安全的方法。(系统的其他用户可以检查标志，env vars很容易设置和遗忘。)只要确保显式命令行标志(如果给定)具有最高优先级。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs myflag.FlagSet</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    foo = fs.String(<span class="string">"foo"</span>, <span class="string">"x"</span>, <span class="string">"foo val"</span>)</span><br><span class="line">    bar = fs.String(<span class="string">"bar"</span>, <span class="string">"y"</span>, <span class="string">"bar val"</span>, myflag.JSON(<span class="string">"bar"</span>))</span><br><span class="line">    baz = fs.String(<span class="string">"baz"</span>, <span class="string">"z"</span>, <span class="string">"baz val"</span>, myflag.JSON(<span class="string">"baz"</span>), myflag.Env(<span class="string">"BAZ"</span>))</span><br><span class="line">    cfg = fs.String(<span class="string">"cfg"</span>, <span class="string">""</span>, <span class="string">"JSON config file"</span>)</span><br><span class="line">)</span><br><span class="line">fs.Parse(os.Args, myflag.JSONVia(<span class="string">"cfg"</span>), myflag.EnvPrefix(<span class="string">"MYAPP_"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h2><p>工业编程意味着一次性编写代码并永久维护代码。维护是阅读和重构的持续实践。因此，工业编程压倒性地倾向于读，<strong>_在易读与易写之间</strong>，我们应该强烈地<code>偏向于前者</code>。</p>
<p>依赖注入是优化阅读理解的一个强大工具。这里我当然不是指<a href="https://github.com/facebook-go/inject" target="_blank" rel="noopener">facebook-go/inject</a>或<a href="https://github.com/uber-go/dig" target="_blank" rel="noopener">uber-go/dig</a>所使用的依赖容器方法，而是将依赖关系枚举为类型或构造函数的参数的简单得多的实践。</p>
<p>下面是最近流行的一个基于容器的依赖注入的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildContainer</span><span class="params">()</span> *<span class="title">dig</span>.<span class="title">Container</span></span> &#123;  </span><br><span class="line">    container := dig.New()</span><br><span class="line">    container.Provide(NewConfig)</span><br><span class="line">    container.Provide(ConnectDatabase)</span><br><span class="line">    container.Provide(NewPersonRepository)</span><br><span class="line">    container.Provide(NewPersonService)</span><br><span class="line">    container.Provide(NewServer)</span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    container := BuildContainer()</span><br><span class="line">    <span class="keyword">if</span> err := container.Invoke(<span class="function"><span class="keyword">func</span><span class="params">(server *Server)</span></span> &#123;</span><br><span class="line">        server.Run()</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数体结构紧凑，构建容器具有简洁、切中要点的外观。但是，提供方法需要反射来解释它的参数，而调用没有提供关于服务器实际需要做什么工作的线索。新员工必须在多个上下文之间跳转，以构建每个依赖项的心理模型、它们如何交互以及服务器如何使用它们。这代表了读理解和写理解之间的一个不好的权衡。</p>
<p>与本例要改进的代码的稍微修改过的版本相比:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    cfg := GetConfig()</span><br><span class="line">    db, err := ConnectDatabase(cfg.URN)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    repo := NewPersonRepository(db)</span><br><span class="line">    service := NewPersonService(cfg.AccessToken, repo)</span><br><span class="line">    server := NewServer(cfg.ListenAddr, service)</span><br><span class="line">    server.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数比较长，但是作为交换，我们得到了清晰的明确性。每个组件都按依赖顺序构造，并内联处理错误。每个构造函数都将其依赖项枚举为参数，从而允许新代码读取器快速、轻松地构建组件之间关系图的心智模型。在层层的间接性后面，没有什么是模糊的。</p>
<p>如果重构要求组件获得新的依赖项，则只需将其添加到构造函数中即可。下一个编译将触发错误，这些错误将精确地标识需要更新的参数列表，并且生成的PR中的差异将清楚地显示依赖关系的流。</p>
<p>我声称这严格优于前一种方法，在前一种方法中，从编写的代码中提取关系要困难得多，而且大部分故障检测延迟到运行时。我认为随着程序的大小(以及func main的大小)的增长，以及简单而显式的初始化复合函数的好处，它会变得越来越好。</p>
<p>当我们谈论阅读理解时，我喜欢思考我认为Go最重要的一个特性，那就是它本质上是非魔法的。除了极少数例外，对Go代码的直线阅读不会对定义、依赖关系或运行时行为产生歧义。这是伟大的。</p>
<p>但是有几种方法可以让魔法潜入其中。不幸的是，一种非常常见的方法是使用全局状态。包全局对象可以编码对外部调用者隐藏的状态和/或行为。调用这些全局变量的代码可能会产生令人惊讶的副作用，这将破坏读者理解并在心里为程序建模的能力</p>
<p>因此，考虑到读取优化和维护成本，我认为理想的Go程序几乎没有包全局状态，而是更喜欢通过构造函数显式地枚举依赖关系。由于func init的唯一工作就是初始化包的全局状态，所以我认为最好将其理解为几乎所有程序中的一个严重警告。多年来，我一直用这种方式编写程序，而在那段时间里，我只是越来越欣赏和提倡这种做法。</p>
<p>所以，我的现代Go理论是:</p>
<ol>
<li>显式的依赖关系</li>
<li>没有包级别变量</li>
<li>没有函数初始化</li>
</ol>
<h2 id="Goroutine生命周期管理"><a href="#Goroutine生命周期管理" class="headerlink" title="Goroutine生命周期管理"></a>Goroutine生命周期管理</h2><p>根据我的经验，不正确或过于复杂的启动、停止和检查goroutines的设计是新手和中级Go程序员面临挫折的最大原因。</p>
<p>我认为问题在于goroutine最终是一个非常低级的构建块，对于大多数人希望使用并发来完成的那种高阶任务几乎没有可用性。我们会说“永远不要在不知道如何停止的情况下开始吃goroutine”，但是如果没有具体的方法，这个建议就有点空洞了。我认为许多教程和大量示例代码，即使是在其他好的参考资料中，比如Go编程语言书籍，也会给我们带来不利影响，因为它们演示了并发概念，使用泄漏的<code>即发即弃</code> goroutines、全局状态和模式，即使是基本的代码检查也会失败。</p>
<p>我看到的大多数goroutine都是由我的同事启动的，它们并不是定义良好的并发算法的附带步骤。它们往往是结构化的，用模糊的终止语义管理长时间运行的东西，通常在程序开始时启动。我认为这些用例需要使用更强的约定。</p>
<p>想象一下，go关键字的正字法略有不同。如果我们不能启动goroutine，而不提供中断或停止它的功能，那该怎么办?实际上，强制执行约定，除非我们知道如何阻止goroutine，否则不应该启动它。</p>
<p>这是我在使用<a href="https://godoc.org/github.com/oklog/run" target="_blank" rel="noopener">package run</a>时遇到的问题，它是从我去年从事的一个更大的项目中提取出来的。这里是最重要的方法，添加:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Add</span><span class="params">(execute <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">interrupt</span> <span class="title">func</span><span class="params">(error)</span>)</span></span><br></pre></td></tr></table></figure>
<p>添加要运行的goroutine队列，但也跟踪一个函数，该函数将在需要杀死goroutine时中断goroutine。这为整个goroutine组提供了定义良好的终止语义。例如，当我有多个应该永远运行的服务器组件时，我最常使用它，然后添加一个goroutine来捕获ctrl-C并销毁所有内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> sig := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"received signal %s"</span>, sig)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">    cancel()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果您熟悉<a href="https://godoc.org/golang.org/x/sync/errgroup" target="_blank" rel="noopener">package errgroup</a>，那么这在高层上与包errgroup类似，但更糟糕的是:errgroup隐式地假设所有执行函数都将响应提供给组的父上下文，并且没有使之显式的功能。</p>
<p>最近有一篇clickbaity博客文章声称“go语句被认为是有害的”，并提倡使用一种称为托儿所的结构，即生命周期绑定线程。package run和 最近有一篇clickbaity博客文章声称“go语句被认为是有害的”，并提倡使用一种称为托儿所的结构，即生命周期绑定线程。packageerrgroup都是这个托儿所概念的稍微不同的实现解释。</p>
<h3 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h3><p>这是高阶结构的一种形式。但还有很多其他的!例如，你知道Go有Futures吗?它只是比其他语言更冗长一些。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">future := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; future &lt;- process() &#125;()</span><br><span class="line">result := &lt;-future</span><br></pre></td></tr></table></figure>
<p><code>future</code>的另一种发音方式是<code>async/ await</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- process() &#125;() <span class="comment">// async</span></span><br><span class="line">v := &lt;-c                       <span class="comment">// await</span></span><br></pre></td></tr></table></figure>
<h3 id="Scatter-gather"><a href="#Scatter-gather" class="headerlink" title="Scatter-gather"></a>Scatter-gather</h3><p>我们也有散集，我一直在用它，当我知道我需要处理多少单位的工作时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scatter</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> result, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c); i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        val, err := process()</span><br><span class="line">        c &lt;- result&#123;val, err&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gather</span></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(c); i++ &#123;</span><br><span class="line">    res := &lt;-c</span><br><span class="line">    <span class="keyword">if</span> res.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        total += res.val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个优秀的Go程序员会对这些高阶并发模式中的几个有很强的控制能力。一个优秀的Go程序员会主动地将这些模式传授给他们的同事。</p>
<h2 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h2><p>我们来谈谈可观察性。但在此之前，让我们先了解一下关于工业编程的另一种假设:我们编写的代码将运行在服务器上，为客户提供请求，并经历生命周期，而不会中断该服务。这不同于压缩包装并交付给客户的代码，也不同于作为批处理作业运行且不面向客户的代码。</p>
<p>在很大程度上，我同意Charity之前在节目中告诉我们的。特别是，我同意我们分布式工业系统的一个核心不变之处是，根本没有成本效益高的方法来进行全面集成或烟雾测试。集成或测试环境在很大程度上是一种浪费;更多的环境不会让事情变得更容易。对于我们的大多数系统来说，良好的可观察性比良好的测试更重要，因为良好的可观察性使明智的组织能够专注于快速部署和回滚，优化平均恢复时间(MTTR)，而不是平均故障间隔时间(MTBF)。</p>
<p>对我们来说，问题是:Go中一个恰当的可观测系统是什么样子的?我想没有一个单一的答案，没有一个包我可以告诉你进口来一劳永逸地解决问题。可观察性空间是破碎的，许多供应商为了他们独特的世界观而竞争。有很多事情值得兴奋，但胜利者还没有尘埃落定。在我们等待这一切发生的同时，我们能做些什么呢?</p>
<p>如果我们生活在一个更完美的世界里，这就无关紧要了。如果我们有一个完美的可观测性数据收集系统，所有的解释都可以在查询时间内完成，而且成本为零，那么我们就可以向它发射原始的观测数据，并提供无限的细节，然后用它来完成。但是，这个领域之所以有趣或具有挑战性，当然是因为没有这样的数据系统存在。所以我们不得不做出工程决策，妥协，赋予特定类型的观察以语义意义，以实现特定的可观察性工作流。</p>
<p><img src="https://peter.bourgon.org/go-for-industrial-programming/venn.png" alt="venn"></p>
<p>度量、日志记录和跟踪是使用可观察性数据的紧急模式，可观察性数据告知我们生成、发送和存储相应信号的方式。它们是一个优化函数的产物，介于运营商希望如何对自己的系统进行反省，以及技术是否能够大规模地满足这些需求之间。或许还有其他尚未被发现的消费模式，可能是由技术进步推动的，这将开启一个新的时代和可观察性分类。但这就是我们今天所处的位置，在可预见的未来也是如此。让我们看看如何在Go中最好地利用它们。</p>
<h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>度量是计数器、测量器和直方图，它们的观察结果在统计上结合起来，并报告给一个允许快速、实时导出总体系统行为的系统。度量电源指示板和警报。</p>
<p><img src="https://peter.bourgon.org/go-for-industrial-programming/metrics.png" alt="metrics"></p>
<p>到目前为止，大多数度量系统都提供了Go客户机库，并且标准的显示格式(如StatsD)已经很好地理解和实现了。如果您的组织已经拥有了关于给定系统的制度知识，请将其标准化;如果你只是刚刚开始或想要集中在一个系统上，<a href="https://prometheus.io" target="_blank" rel="noopener">Prometheus</a>是同类中最好的。</p>
<p>不再足够好的是基于主机或检查的系统，如Nagios、Icinga或Ganglia。这些会使您陷入监视范例中，而这些范例在很久以前就不再有意义了，并且会积极地阻碍使您的系统可见。</p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>日志是对收集系统完全真实地报告的离散事件流，用于稍后的分析、报告和调试。好的日志是结构化的，允许灵活的事后操作。</p>
<p><img src="https://peter.bourgon.org/go-for-industrial-programming/logging.png" alt="logging"></p>
<p>现在Go中有很多很棒的日志选项。好的日志库是面向日志程序接口的，而不是具体的日志程序对象。它们将日志记录器视为依赖项，避免了包的全局状态。并且在callsite上强制执行结构化日志记录。</p>
<p>日志是抽象的流，而不是具体的文件，所以要避免日志记录器在磁盘上写或旋转文件;这是另一个流程或编排平台的职责。而且日志记录可以快速地控制系统的运行时成本，所以在生成和发出日志时要谨慎和明智。捕获与请求路径相关的所有内容，但要深思熟虑，使用装饰器或中间件之类的模式。</p>
<h3 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h3><p>跟踪处理所有请求范围的性能数据，特别是当这些数据在分布式系统中跨流程和系统边界时。跟踪系统将元数据组织到树结构中，从而支持对特定异常或事件进行深度分类。</p>
<p><img src="https://peter.bourgon.org/go-for-industrial-programming/tracing.png" alt="tracing"></p>
<p>目前的跟踪实现主要围绕OpenTracing实现，OpenTracing是由Zipkin、Jaeger、Datadog等具体系统实现的客户端API标准。OpenCensus中也做了一些有趣的工作，它承诺提供一个更加集成的环境。</p>
<p>如果跟踪是有用的，那么它需要是全面的，并且在所有可观察性的支柱中，它拥有最严格的领域对象和谓词集。由于这些原因，正确实现跟踪的成本非常高，只有当分布式系统非常大(可能超过几十个微服务)时才有意义开始工作。</p>
<p>每个可观察性的支柱都有不同的优点和缺点。我认为我们可以沿着不同的轴比较它们:资本支出，开始测量和收集信号的初始成本;运营成本，运营支持基础设施的持续成本;反应，系统在发现和警报事件方面有多好;以及调查，系统能在多大程度上帮助对事件进行分类和调试。我的主观意见如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>Metrics</th>
<th>Logging</th>
<th>Tracing </th>
</tr>
</thead>
<tbody>
<tr>
<td>资本支出</td>
<td>Medium</td>
<td>Low</td>
<td>High</td>
</tr>
<tr>
<td>维护成本</td>
<td>Low</td>
<td>High</td>
<td>Medium</td>
</tr>
<tr>
<td>反应能力</td>
<td>High</td>
<td>Medium</td>
<td>Low</td>
</tr>
<tr>
<td>检测</td>
<td>Low</td>
<td>Medium</td>
<td>High</td>
</tr>
</tbody>
</table>
<p>就资本支出而言，日志系统是最容易启动的，在代码中添加日志工具比其他方法更容易、更直观。度量标准涉及的更多，但是大多数度量标准收集系统仍然是相对独立的，并且非常容易部署。与此相反，跟踪需要大量时间才能在整个机群中安装，而且跟踪收集系统通常很大，需要一些专门的数据库知识。</p>
<p>就OpEx而言，根据我的经验，让一个日志系统保持在线状态需要付出不成比例的努力，通常与相应的生产系统一样困难，甚至更困难——由于大多数组织都倾向于不加区别地进行过多的日志记录，这使其更加困难。跟踪系统可以从前期成本中获益，并且通常可以顺利地进行大量抽样和定期数据库维护。相反，度量系统受益于统计聚合所产生的自然数据压缩，并且通常具有非常低的维护成本。当然，如果你选择使用供应商，这些成本会直接转化为美元。</p>
<p>就反应能力而言，度量系统被显式地设计为服务于dashboard和警报用例，以及excel。日志系统经常使用一些工具来执行可以驱动仪表板和警报的聚合或滚动，只需要做一点工作。而跟踪系统通常没有能力定义、检测或发出异常信号。</p>
<p>然而，当涉及到调查时，形势发生了逆转。公制系统在设计上失去了数据的保真度，而且通常在检测到问题的根本原因后，无法提供深入研究问题根源的好方法。日志系统做得更好，特别是如果您使用结构化日志记录和具有丰富查询语言的日志系统。跟踪本质上是为针对特定请求或请求类的深入研究而设计的，有时是识别复杂的不适应行为的唯一方法。</p>
<p>这里的教训是，没有一个单一的可观察性范式能够解决您所有的可观察性需求;它们都是完整的可观察早餐的一部分。从他们独特的特点，我认为我们可以得出一些一般性的建议:</p>
<ol>
<li>首先，投资于基本的、全面的度量标准，为组件提供一组统一的仪表板和警报。在实践中，这通常足以发现并解决大量的问题。</li>
<li>接下来，投资于深度、高基数、结构化日志记录，以便对更复杂的问题进行事件分类和调试。</li>
<li>最后，当您拥有足够大的规模和定义良好的生产准备标准时，研究分布式跟踪。</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>尽管大型分布式系统的可观察性可能优于集成测试，但是单元和有限的集成测试仍然是任何软件项目的基础和必要的。特别是在工业环境中，我认为它最大的价值是为新的维护者提供一种健康检查层，使他们的更改具有预期的范围和效果。</p>
<p>因此，测试应该优化为易用性。如果初级开发人员在克隆repo之后无法立即运行项目的测试，那么就会出现一个严重的问题。在Go中，我认为这意味着在您的项目中运行普通的Go测试，而没有额外的设置工作，应该总是成功的，不会发生意外。也就是说，大多数测试不应该要求任何类型的测试环境、运行数据库等来正常运行并返回成功。这些测试是集成测试，它们应该通过测试标志或环境变量选择加入:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestComplex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    urn := os.Getenv(<span class="string">"TEST_DB_URN"</span>)</span><br><span class="line">    <span class="keyword">if</span> urn == <span class="string">""</span> &#123;</span><br><span class="line">        t.Skip(<span class="string">"set TEST_DB_URN to run this test"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    db, _ := connect(urn)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试金字塔是一个很好的通用建议，建议您应该将大部分精力集中在单元测试上。根据我的经验，理想的比率甚至比金字塔建议的还要极端:如果您具有良好的生产可观察性，那么您的测试工作的80-90%应该集中于单元测试。在Go中，我们知道好的单元测试是表驱动的，并且利用组件接受接口并返回结构的事实来提供依赖关系的伪实现或模拟实现，并且只测试被测试的东西。</p>
<p>米切尔桥本(Mitchell Hashimoto)去年在GopherCon上使用<a href="https://www.youtube.com/watch?v=8hQG7QlcLBk" target="_blank" rel="noopener">Go进行的高级测试</a>，可能是迄今为止我所见过的有关工业环境下的优秀Go程序设计的最佳信息来源。如果您的团队编写Go，那么它就是基本的背景材料。</p>
<p>关于这个问题没有太多可说的了。随着时间的推移，测试最佳实践的相对稳定性是一个受欢迎的缓刑。一如既往地:追求100%的测试覆盖率几乎肯定会适得其反，但50%似乎是一个很好的低水印;避免引入测试dsl或“帮助包”，除非您的团队从中获得明确的、具体的价值。</p>
<p>我需要多少接口?</p>
<p>当我们谈论测试时，我们谈论通过接口模拟依赖关系，但是我们通常并没有真正描述它在实践中是如何工作的。我认为很重要的一点是，围棋系统不是标称的，而是结构性的。将接口看作是对实现进行分类的一种方法是错误的;相反，将接口看作是一种识别期望公共行为集的代码的方法。换句话说，接口是消费者契约，而不是生产者(实现者)契约——因此，作为一个规则，我们应该在使用代码的callsite中定义接口，而不是在提供实现的包中定义接口。</p>
<p>您需要多少接口?嗯，有一个频谱。在您的callsite上尽可能的有意义，特别是为了帮助测试。在一种极端情况下，我们可以使用严格作用域的接口定义为每个函数的每个依赖关系建模。在有限的情况下，这可能是有意义的!例如，如果您的组件是粗粒度的、良好的，并且将来不太可能更改。</p>
<p>但是，特别是在工业上下文中，更有可能出现混合的抽象，这些抽象随时间而变化。在这种情况下，您可能希望在您的设计中尝试在“故障线”上定义接口。两个自然边界点位于func main和代码其余部分之间，以及包api之间。定义依赖接口有一个很好的起点，也有一个很好的起点来开始考虑定义单元测试。</p>
<p>上下文使用和误用</p>
<p>Go 1.7给我们带来了包上下文，从那时起，它就一直在影响我们的代码。这不是一件坏事!上下文是管理goroutine生命周期的一种很好理解且无处不在的方法，这是一个大而困难的问题。根据我的经验，这是它们最重要的功能。如果您有一个组件由于任何原因阻塞—通常是网络I/O，有时是磁盘I/O，可能是由于用户回调，等等—那么它可能应该将上下文作为其第一个参数。</p>
<p>这种模式无处不在，我从一开始就把它设计到我的服务器类型和接口中。下面是最近一个连接到谷歌云存储的项目的例子:Go 1.7给我们带来了包上下文，从那时起，它就一直在影响我们的代码。这不是一件坏事!上下文是管理goroutine生命周期的一种很好理解且无处不在的方法，这是一个大而困难的问题。根据我的经验，这是它们最重要的功能。如果您有一个组件由于任何原因阻塞—通常是网络I/O，有时是磁盘I/O，可能是由于用户回调，等等—那么它可能应该将上下文作为其第一个参数。</p>
<p>这种模式无处不在，我从一开始就把它设计到我的服务器类型和接口中。下面是最近一个连接到谷歌云存储的项目的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reportStore is a thin domain abstraction over GCS.</span></span><br><span class="line"><span class="keyword">type</span> reportStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    listTimes(ctx context.Context, from time.Time, n <span class="keyword">int</span>) ([]time.Time, error)</span><br><span class="line">    writeFile(ctx context.Context, ts time.Time, name <span class="keyword">string</span>, r io.Reader) error</span><br><span class="line">    serveFile(ctx context.Context, ts time.Time, name <span class="keyword">string</span>, w io.Writer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为生命周期语义编写上下文感知的组件很简单:只要确保代码响应ctx.Done即可。事实证明，使用上下文的值传播特性有点棘手。上下文的问题。值是键和值是无类型的，并且不能保证存在，这将使程序面临运行时成本和故障模式，否则这些问题是可以避免的。我的经验是开发人员过度使用上下文。值，这些值实际上应该是常规依赖项或函数参数。</p>
<p>所以，一个基本的经验是:只使用上下文。无法以任何其他方式通过程序传递的数据的值。实际上，这意味着只使用上下文。值，用于请求范围的信息，如请求id、用户身份验证令牌等，这些信息仅在请求时创建或在请求期间创建。如果该信息在程序启动时可用，比如数据库句柄或日志记录器，则不应通过上下文传递该信息。</p>
<p>同样，这个建议的基本原理归结为可维护性。如果一个组件以构造函数或函数参数的形式枚举它的需求(在编译时可检查)，这要比从一个只在运行时可检查的无类型、不透明的值包中提取信息好得多。后者不仅更加脆弱，而且使理解和调整代码变得更加困难。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我做这个最佳实践系列已经有六年了，虽然有一些技巧来来去去，特别是针对新出现的习惯用法和模式，但值得注意的是，作为一个有效的围棋程序员，所需的基础知识在这段时间内几乎没有改变。总的来说，我们并不追求设计趋势。我们有一个非常稳定的语言和生态系统，我相信我不仅仅是在为自己说话，当我说我真的很感激的时候。</p>
<p>我认为，在这样的会议上，我们能够彼此熟悉，这是很好的。但我认为我们在这里能做的最好的事情是建立对彼此的同理心。如果我们把工作做好，随着Go程序员数量的不断增长，社区将变得越来越多样化，具有不同的工作流、上下文和目标。我很高兴向大家介绍了我在Go上的一些体验报告，我也很高兴能听到并理解大家的感受。多谢!</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>段纪刚</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2018/09/18/go-for-industrial-programming/" target="_blank" title="Go 工业级编程">https://jigangduan.github.io/2018/09/18/go-for-industrial-programming/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/02/mysql-vscode/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          SQL Server - 使用Visual Studio Code创建和运行Transact-SQL脚本
        
      </div>
    </a>
  
  
    <a href="/2018/08/30/yeoman-authoring10/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">编写自己的Yeoman生成器-10.将Yeoman集成到其他工具中</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造代码和存储库"><span class="nav-number">1.</span> <span class="nav-text">构造代码和存储库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序配置"><span class="nav-number">2.</span> <span class="nav-text">程序配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件图"><span class="nav-number">3.</span> <span class="nav-text">组件图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutine生命周期管理"><span class="nav-number">4.</span> <span class="nav-text">Goroutine生命周期管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Futures"><span class="nav-number">4.1.</span> <span class="nav-text">Futures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scatter-gather"><span class="nav-number">4.2.</span> <span class="nav-text">Scatter-gather</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可观察性"><span class="nav-number">5.</span> <span class="nav-text">可观察性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#度量"><span class="nav-number">5.1.</span> <span class="nav-text">度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志记录"><span class="nav-number">5.2.</span> <span class="nav-text">日志记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跟踪"><span class="nav-number">5.3.</span> <span class="nav-text">跟踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试"><span class="nav-number">6.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2020 朝着牛逼的道路一路狂奔 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            朝着牛逼的道路一路狂奔
          </div>
          <div class="panel-body">
            Copyright © 2020 段纪刚 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>