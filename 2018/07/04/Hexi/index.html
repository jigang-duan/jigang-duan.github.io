<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>hexi | 朝着牛逼的道路一路狂奔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="javascriptpixijs游戏hexi">
  
  
  
  
  <meta name="description" content="Hexi是一种有趣而简单的方法，可以用纯JavaScript代码制作HTML5游戏或任何其他类型的交互媒体。看看开始的特性列表和示例文件夹。继续滚动，你会找到一个完整的快速入门指南和初学者指南。如果你以前从来没有做过游戏，教程是最好的开始。 Hexi有什么?您可以使用streamlined API获得WebGL呈现的所有功能，该API允许您以极简的、声明性的方式编写代码。它使得编写一款游戏像写诗">
<meta name="keywords" content="javascript,pixijs,游戏,hexi">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexi">
<meta property="og:url" content="https://jigangduan.github.io/2018/07/04/Hexi/index.html">
<meta property="og:site_name" content="朝着牛逼的道路一路狂奔">
<meta property="og:description" content="Hexi是一种有趣而简单的方法，可以用纯JavaScript代码制作HTML5游戏或任何其他类型的交互媒体。看看开始的特性列表和示例文件夹。继续滚动，你会找到一个完整的快速入门指南和初学者指南。如果你以前从来没有做过游戏，教程是最好的开始。 Hexi有什么?您可以使用streamlined API获得WebGL呈现的所有功能，该API允许您以极简的、声明性的方式编写代码。它使得编写一款游戏像写诗">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/logoAndIllustration.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/30.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/31.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/01.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/03.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/04.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/05.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/06.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/07.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/08.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/09.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/10.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/11.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/12.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/13.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/16.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/17.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/18.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/19.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/20.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/21.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/22.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/23.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/24.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/25.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/26.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/27.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/28.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/29.png">
<meta property="og:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/32.png">
<meta property="og:updated_time" content="2020-07-25T02:57:18.156Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexi">
<meta name="twitter:description" content="Hexi是一种有趣而简单的方法，可以用纯JavaScript代码制作HTML5游戏或任何其他类型的交互媒体。看看开始的特性列表和示例文件夹。继续滚动，你会找到一个完整的快速入门指南和初学者指南。如果你以前从来没有做过游戏，教程是最好的开始。 Hexi有什么?您可以使用streamlined API获得WebGL呈现的所有功能，该API允许您以极简的、声明性的方式编写代码。它使得编写一款游戏像写诗">
<meta name="twitter:image" content="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/logoAndIllustration.png">
  
    <link rel="alternate" href="/atom.xml" title="朝着牛逼的道路一路狂奔" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css">
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Hexi" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Hexi
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/07/04/Hexi/" class="article-date">
	  <time datetime="2018-07-04T12:11:28.000Z" itemprop="datePublished">2018-07-04</time>
	</a>

      
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><a class="article-category-link" href="/categories/JavaScript/Pixi-js/">Pixi.js</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/logoAndIllustration.png" alt="hexi"></p>
<p><a href="https://github.com/kittykatattack/hexi" target="_blank" rel="noopener">Hexi</a>是一种有趣而简单的方法，可以用纯JavaScript代码制作HTML5游戏或任何其他类型的交互媒体。看看开始的特性列表和<a href="https://github.com/kittykatattack/hexi/tree/master/examples" target="_blank" rel="noopener">示例</a>文件夹。继续滚动，你会找到一个完整的快速入门指南和初学者指南。如果你以前从来没有做过游戏，教程是最好的开始。</p>
<p>Hexi有什么?您可以使用streamlined API获得WebGL呈现的所有功能，该API允许您以<a href="https://en.wikipedia.org/wiki/Haiku" target="_blank" rel="noopener">极简的</a>、<a href="http://latentflip.com/imperative-vs-declarative/" target="_blank" rel="noopener">声明性</a>的方式编写代码。它使得编写一款游戏像写诗或画一样简单有趣。试一试!如果您需要任何帮助或有任何问题，请在此存储库的问题中发布一些内容。问题页面是Hexi友好的聊天室——不要害怕寻求帮助:)</p>
<p>使用Hexi: <a href="https://github.com/kittykatattack/hexi/blob/master/bin/hexi.min.js" target="_blank" rel="noopener">hexi.min.js</a>只需要从这个存储库中获取一个文件。这是所有!用<code>&lt;script&gt;</code>标签链接到您的HTML文档，然后开始!Hexi是在最新版本的JavaScript (ES6/7, 2005 /6)中从头开始编写的，但是它被编译成ES5(使用Babel)，这样它就可以在任何地方运行。在开始使用河西之前，你需要知道什么?您应该对HTML和JavaScript有合理的理解。你不必是一个专家，只是一个雄心勃勃的初学者和一个渴望学习的人。如果你不知道HTML和JavaScript，最好的开始学习它的地方是这本书:</p>
<p><a href="http://www.apress.com/9781430247166" target="_blank" rel="noopener">基于HTML5和JavaScript的基础游戏设计</a></p>
<p><a href="https://github.com/Zainking/learningPixi" target="_blank" rel="noopener">Pixi教程</a></p>
<p>好吧,明白了吗?您知道JavaScript变量、函数、数组和对象是什么以及如何使用它们吗?您知道JSON数据文件是什么吗?你使用过Canvas绘图API吗?然后你就可以开始使用Hexi了!</p>
<p>当然，河西是完全免费使用:为任何事，永远!它的作者是加拿大(多伦多，哈密顿)，印度(Kullu Valley, Ladakh)，尼泊尔(加德满都，Pokhara, Annapurna大本营)，泰国(Ko Phangan, Ko Tao)和南非(开普敦)，这是15年来对游戏设计的API可用性研究的结果。”Hexi” 这个名字来源于”Hex” + “Pixi”。<a href="https://www.youtube.com/watch?v=XYGmNs6274A" target="_blank" rel="noopener">它绝对没有其他意义</a>。</p>
<a id="more"></a>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>以下是Hexi的核心功能列表:</p>
<ul>
<li><p>你需要的所有最重要的精灵:矩形、圆圈、线条、文本、图像精灵和动画“MovieClip”样式精灵。您可以使用一行代码来创建这些精灵中的任何一个。您还可以创建自己的定制精灵类型。</p>
</li>
<li><p>完整的场景图，包含嵌套的子-父层次结构(包括<code>stage</code>和<code>addChild</code>/<code>removeChild</code>方法)、本地和全局坐标、深度层和旋转支点。</p>
</li>
<li><p>将精灵<code>分组</code>在一起制作游戏场景。</p>
</li>
<li><p>具有用户可定义的<code>fps</code>和完全可定制和完全可删除的简单游戏状态管理器的游戏循环。<code>暂停</code>并<code>恢复</code>在任何时候游戏循环。</p>
</li>
<li><p>Tileset (spritesheet)支持使用<code>frame</code>和<code>filmstrip</code>方法来使用Tileset框架制作精灵。</p>
</li>
<li><p>内置纹理图集支持流行的纹理包装格式。</p>
</li>
<li><p>精灵的关键帧动画和状态管理器。使用<code>show</code>显示精灵的图像状态。使用<code>playAnimation</code>来播放一系列的帧(如果您愿意，可以在<code>循环</code>中)。使用<code>show</code>显示特定的帧号。使用<code>fps</code>设置精灵动画的帧速率与游戏的帧速率无关。</p>
</li>
<li><p>交互按钮精灵有<code>up</code>,<code>over</code>和<code>down</code>的状态</p>
</li>
<li><p>可以将任何精灵设置为交互以接收鼠标和触摸操作。为按钮和交互精灵提供直观的<code>press</code>, <code>release</code>, <code>over</code>, <code>out</code>和<code>tap</code>方法</p>
</li>
<li><p>易于使用的键盘键绑定。使用<code>keyboard</code>方法轻松定义您自己的</p>
</li>
<li><p>一个内置的通用<code>指针</code>，可以同时使用鼠标和触摸。分配您自己的自定义<code>press</code>, <code>release</code>和<code>tap</code>方法或使用任何指针的内置属性:<code>isUp</code>、<code>isDown</code>、<code>tap</code>、<code>x</code>和<code>y</code>。(它也适用于等距地图!)</p>
</li>
<li><p>使用<code>putTop</code>, <code>putRight</code>, <code>putBottom</code>, <code>putLeft</code>和<code>putCenter</code>，方便地放置与其他精灵相对的位置。使用<code>flowRight</code>、<code>flowLeft</code>、<code>flowUp</code>或<code>flow</code>将精灵水平或垂直对齐。</p>
</li>
<li><p>用于预加载图像、字体、声音和JSON数据文件的通用资产加载程序。支持所有流行的文件格式。您可以在任何时候将新资产加载到游戏中。</p>
</li>
<li><p>可选的加载状态，允许您在加载资产时运行操作。可以使用load状态添加加载进度条。</p>
</li>
<li><p><a href="https://github.com/pixijs/pixi.js/" target="_blank" rel="noopener">基于pixi</a>的快速聚焦渲染引擎。如果Pixi能做到，那么Hexi也能做到! Hexi只是位于Pixi之上的一层薄薄的代码。您可以随时访问全局<code>PIXI</code>对象，如果您愿意，可以直接编写纯PIXI代码。Hexi包括最新稳定版本的Pixi v3.0自动绑定。</p>
</li>
<li><p>一个复杂的游戏循环，使用一个固定的时间步长，具有可变渲染和精灵插值。这意味着你可以在任何帧中获得光滑的精灵动画。</p>
</li>
<li><p>一个紧凑而强大的“俳句”风格的API，其核心是浅显的、可组合的组件。多做点事情，少写点代码。</p>
</li>
<li><p>使用内置的WebAudio API声音管理器导入和播放声音。用<code>play</code>、<code>pause</code>、<code>stop</code>、<code>restart</code>、<code>playFrom</code>、<code>fadeIn</code>和<code>fadeOut</code>方法控制声音。改变声音的<code>volume</code>和<code>pan</code>。</p>
</li>
<li><p>使用通用的<code>soundEffect</code>方法从纯代码生成您自己的自定义声音效果。</p>
</li>
<li><p>使用<code>shake</code>摇动精灵或场景。</p>
</li>
<li><p>精灵和场景转换的补间功能: <code>slide</code>、<code>fadeIn</code>、<code>fadeOut</code>、<code>pulse</code>、<code>breathe</code>、<code>wobble</code>、<code>strobe</code>和一些有用的低级补间方法，可以帮助您创建自定义补间。</p>
</li>
<li><p>按照<code>walkPath</code>和<code>walkCurve</code>的连接路径点序列创建一个精灵。</p>
</li>
<li><p>一些有用的方便函数:<code>followEase</code>, <code>followConstant</code>, <code>angle</code>, <code>distance</code>, <code>rotateAroundSprite</code>, <code>rotateAroundPoint</code>, <code>wait</code>, <code>randomInt</code>, <code>randomFloat</code>, <code>contains</code>和<code>outsideBounds</code>。</p>
</li>
<li><p>一种快速、通用的<code>hit</code>方法来处理所有类型的精灵的碰撞测试和反应(拦截和反弹)。对所有的东西都使用一种碰撞方法:矩形、圆形、点和精灵的数组。简单!</p>
</li>
<li><p>一套轻量级的、低级的2D几何碰撞方法。</p>
</li>
<li><p>游戏资产的加载进度条。</p>
</li>
<li><p>让精灵用<code>shoot</code>拍摄东西</p>
</li>
<li><p>很容易用<code>grid</code>绘制网格中的精灵</p>
</li>
<li><p>使用<code>tilingSprite</code>轻松创建无缝滚动背景</p>
</li>
<li><p><code>createParticles</code>函数，用于为游戏创建各种粒子效果。使用<code>particleEmitter</code>函数来创建一个恒定的粒子流</p>
</li>
<li><p>使用<code>scaleToWindow</code>使游戏自动缩放到它的最大尺寸，并使其与浏览器窗口内的最佳匹配</p>
</li>
<li><p>使用<code>makeTiledWorld</code>对编辑器的支持。在平铺编辑器中设计游戏，并直接访问游戏代码中的所有精灵、层和对象。这是一个非常有趣，快速和容易的方法来制作游戏。</p>
</li>
<li><p>一个通用的<code>hitTestTile</code>方法，用于处理基于瓷砖的游戏所需的所有碰撞检查。如果您愿意，您可以将它与任何二维几何碰撞方法结合使用，以优化大相位/窄相位碰撞检查。</p>
</li>
<li><p>使用<code>updateMap</code>保持基于瓷砖的世界地图数据数组与移动精灵最新</p>
</li>
<li><p>创建一个在滚动游戏世界中跟随精灵的<code>worldCamera</code>。</p>
</li>
<li><p>一个<code>lineOfSight</code>函数，告诉您一个精灵对另一个精灵是否可见</p>
</li>
<li><p>与HTML和CSS元素的无缝集成，以创建丰富的用户界面。使用Hexi也适用于<code>Angular</code>, <code>React</code>和<code>Elm</code>!</p>
</li>
<li><p>一套完整的工具，易于创建等距游戏世界，包括:等距鼠标/触摸指针，使用hitTestIsoTile的等距瓷砖碰撞，和使用makeIsoTiledWorld的全平铺编辑器等距地图支持。</p>
</li>
<li><p>shortestPath函数，用于通过类似迷宫这样的基于瓷砖的环境进行A-star寻路，tileBasedLineOfSight函数告诉你迷宫游戏环境中的精灵是否可以看到彼此。</p>
</li>
<li><p>是的，由于Pixi渲染器提供的可访问属性(yay Pixi!)， Hexi应用程序符合W3C的可访问性指南</p>
</li>
</ul>
<h1 id="Hexi的模块"><a href="#Hexi的模块" class="headerlink" title="Hexi的模块"></a>Hexi的模块</h1><p>Hexi包含了一个有用的模块集合，您可以使用这些模块的任何属性或方法在您的高级Hexi代码中。</p>
<ul>
<li><p><a href="https://github.com/pixijs/pixi.js/" target="_blank" rel="noopener">Pixi</a>:世界上最快的2D WebGL和canvas渲染器</p>
</li>
<li><p><a href="https://github.com/kittykatattack/bump" target="_blank" rel="noopener">Bump</a>:一套完整的2D游戏碰撞功能。</p>
</li>
<li><p><a href="https://github.com/kittykatattack/tink" target="_blank" rel="noopener">Tink</a>:拖放、按钮、通用指针和其他有用的交互性工具。</p>
</li>
<li><p><a href="https://github.com/kittykatattack/charm" target="_blank" rel="noopener">Charm</a>: 简单易用的Pixi精灵动画效果</p>
</li>
<li><p><a href="https://github.com/kittykatattack/dust" target="_blank" rel="noopener">Dust</a>:用于制造爆炸、火焰和魔法的粒子效应</p>
</li>
<li><p><a href="https://github.com/kittykatattack/spriteUtilities" target="_blank" rel="noopener">Sprite Utilities</a>:更简单、更直观的方法来创建和使用Pixi精灵，并添加状态机和动画播放器</p>
</li>
<li><p><a href="https://github.com/kittykatattack/gameUtilities" target="_blank" rel="noopener">Game Utilities</a>: 为游戏收集的有用方法.</p>
</li>
<li><p><a href="https://github.com/kittykatattack/tileUtilities" target="_blank" rel="noopener">Tile Utilities</a>: 一组有用的方法，用于制作以<a href="http://www.mapeditor.org/" target="_blank" rel="noopener">Tiled Editor</a>为基础的游戏世界。包括一套完整的等距地图实用程序。</p>
</li>
<li><p><a href="https://github.com/kittykatattack/sound.js" target="_blank" rel="noopener">Sound.js</a>: 用于加载、控制和生成声音和音乐效果的微型库。为游戏添加声音所需要的一切。</p>
</li>
<li><p><a href="https://github.com/kittykatattack/smoothie" target="_blank" rel="noopener">Smoothie</a>: 超光滑的精灵动画使用真正的三角时间插值。它还允许您指定游戏或应用程序运行的fps(每秒帧数)，并将精灵呈现循环与应用程序逻辑循环完全分开。</p>
</li>
</ul>
<p>阅读每个模块的代码库中的文档，了解如何使用它们，以及它们是如何工作的。因为它们都内置在Hexi中，你不需要自己安装它们——它们可以直接使用</p>
<p>Hexi允许您作为顶级对象访问这些模块方法和属性。例如，如果您想从Bump collision module访问hit方法，您可以这样做:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.hit(spriteOne, spriteTwo);</span><br></pre></td></tr></table></figure>
<p>但如果需要的话，也可以直接访问Bump模块，比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.bump.hit(spriteOne, spriteTwo);</span><br></pre></td></tr></table></figure>
<p>(假设你的Hexi实例被称为<code>g</code>);</p>
<p>只需使用<code>lowerCamelCase</code>引用模块名。这意味着您可以使用<code>smoothie</code>和Sprite实用程序模块作为<code>spriteUtilities</code>来访问Smoothie模块。</p>
<p>本公约有两个例外。您可以直接访问Pixi全局对象作为Pixi。此外，Sound.js模块中的函数也只能作为顶级全局对象访问。这样做是为了简化这些模块与Hexi集成的方式，并保持尽可能广泛的跨平台兼容性。</p>
<p>如果您是一名开发人员，并且希望为Hexi做贡献，最好的方法是为这些模块提供新的和改进的特性。或者，如果你真的很有野心，向Hexi开发团队提出一个新的模块(在这个repo的问题中，也许我们会把它添加到Hexi的核心中!)</p>
<h1 id="Hexi-快速启动"><a href="#Hexi-快速启动" class="headerlink" title="Hexi 快速启动"></a>Hexi 快速启动</h1><p>要快速开始使用Hexi，请查看<a href="https://github.com/kittykatattack/hexi/tree/master/examples" target="_blank" rel="noopener">Hexi示例文件夹</a>中的Quick start项目。这里是<a href="https://github.com/kittykatattack/hexi/blob/master/examples/01_quickStart.html" target="_blank" rel="noopener">HTML容器页面</a>，这里是<a href="https://github.com/kittykatattack/hexi/blob/master/examples/src/quickStart.js" target="_blank" rel="noopener">JavaScript源文件</a>。源代码得到了完整的注释并解释了所有的工作原理，因此，如果您想这样做，您可以直接跳转到该文件并阅读它。(您将在<a href="https://github.com/kittykatattack/hexi/tree/master/examples/bin" target="_blank" rel="noopener">bin文件夹</a>中找到已编译的ES5 JavaScript文件版本。)</p>
<p>快速启动项目是对所有Hexi的主要特性的访问，您可以将它用作创建您自己的新Hexi应用程序的模板。点击<a href="https://cdn.gitcdn.xyz/cdn/kittykatattack/hexi/a1713aa19bdcc9a0c661e67d079a205d7c221917/examples/01_quickStart.html" target="_blank" rel="noopener">这里</a>尝试一个工作例子:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/30.png" alt="quickstart"></p>
<p>您将首先看到一个加载栏，它显示正在加载的文件(声音和图像)的百分比。然后，您将看到一个旋转消息，要求您在屏幕上单击以创建猫。当音乐在背景中播放时，只要你点击鼠标，猫就会出现在屏幕上。(噢,对不起!我忘记警告你音乐了!文本字段会旋转并计算您创建的猫的数量。这些猫自己在屏幕上来回移动和反弹，同时在大小上进行缩放，并摆动它们的透明度。这里有一个你将看到的例子:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/31.png" alt="quickstart"></p>
<p>为什么是猫?<a href="http://motherboard.vice.com/blog/toxo-terror-are-our-brains-controlled-by-cat-loving-parasites" target="_blank" rel="noopener">因为</a>。</p>
<p>如果您知道这个快速启动应用程序是如何开发的，那么您就可以快速地使用Hexi来提高效率了——让我们来看看吧!</p>
<blockquote>
<p>(注意: 如果你是游戏编程新手，觉得需要一个更温和、更有条理的Hexi入门，请查看前面的教程部分。你将学习如何从头开始制作3个完整的游戏，并且每一个游戏逐渐建立在你在之前的游戏中学到的技能上。</p>
</blockquote>
<h1 id="HTML容器"><a href="#HTML容器" class="headerlink" title="HTML容器"></a>HTML容器</h1><p>惟一需要开始使用Hexi的文件是<a href="https://github.com/kittykatattack/hexi/blob/master/bin/hexi.min.js" target="_blank" rel="noopener">hexi.min.js</a>。它有一个非常简单的“安装”:只需将它链接到带有<code>&lt;script&gt;</code>标记的HTML页面。然后链接包含游戏或应用程序代码的主JavaScript文件。下面是一个典型的Hexi HTML容器页面:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Hexi&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="hexi.min.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"main.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>
<p>当然，您可以加载游戏所需的所有外部脚本文件。</p>
<p>如果您需要更精细的控制，您可以使用三个独立的文件来加载河西:Pixi渲染器、Hexi模块和Hexi <code>core.js</code>文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Hexi&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- Pixi renderer, Hexi's modules, and Hexi's core  --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="pixi.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"modules.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="core.js"&gt;&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Main application file --&gt;</span><br><span class="line">&lt;script src=<span class="string">"bin/quickStart.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>
<p>这样做的一个好处是，它允许您使用自己的自定义Pixi构建，或者您希望使用的特定版本的Pixi来交换Hexi的内部版本。或者你对Hexi的模块做了一些疯狂的修改，你想尝试一下。但通常，你可能永远都不需要这样做。</p>
<h1 id="Hexi-架构"><a href="#Hexi-架构" class="headerlink" title="Hexi 架构"></a>Hexi 架构</h1><p>所有的乐趣都发生在您的主JavaScript文件中。Hexi应用程序有一个非常简单但灵活的架构，您可以扩展到任何您需要的大小。小游戏用几百行代码或大游戏用几百个文件-河西可以做到!这是典型的Hexi应用的结构:</p>
<ol>
<li>启动Hexi</li>
<li><code>load</code>函数，在文件加载时运行</li>
<li><code>setup</code>函数，初始化你的游戏对象，变量和精灵。</li>
<li><code>play</code>函数，它是在循环中运行的游戏或应用程序逻辑。</li>
</ol>
<p>这是真实代码的样子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. Setting up and starting Hexi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//An array of files you want to load</span></span><br><span class="line"><span class="keyword">let</span> thingsToLoad = [<span class="string">"anyFiles"</span>, <span class="string">"youWant"</span>, <span class="string">"toLoad"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initialize and start Hexi</span></span><br><span class="line"><span class="keyword">let</span> g = hexi(canvasWidth, canvasHeight, setup, thingsToLoad, load);</span><br><span class="line">g.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. The `load` function that will run while your files are loading</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Display an optional loading bar</span></span><br><span class="line">  g.loadingBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. The `setup` function, which initializes your game objects, variables and sprites</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Create your game objects here</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the game state to `play` to start the game loop</span></span><br><span class="line">  g.state = play;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. The `play` function, which is your game or application logic that runs in a loop</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//This is your game loop, where you can move sprites and add your</span></span><br><span class="line">  <span class="comment">//game logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建任何类型的游戏或应用程序都需要这个简单的模型。您可以使用它作为您自己的项目的启动模板，同样的基本模型可以扩展到任何大小。</p>
<p>让我们了解如何使用这个体系结构模型来构建快速启动应用程序。</p>
<h2 id="建立和启动Hexi"><a href="#建立和启动Hexi" class="headerlink" title="建立和启动Hexi"></a>建立和启动Hexi</h2><p>首先，创建一个数组，列出要加载的所有文件。快速启动项目加载一个图像文件、一个字体文件和一个音乐文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thingsToLoad = [</span><br><span class="line">  <span class="string">"images/cat.png"</span>,</span><br><span class="line">  <span class="string">"fonts/puzzler.otf"</span>,</span><br><span class="line">  <span class="string">"sounds/music.wav"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>如果没有要加载的文件，请跳过这一步。</p>
<p>接下来，用<code>hexi</code>函数初始化Hexi。下面介绍如何初始化屏幕大小为512x512像素的Hexi应用程序。它告诉Hexi在<code>thingsToLoad</code>数组中加载文件，在加载时运行一个名为<code>load</code>的函数，然后在一切准备就绪时运行一个名为<code>setup</code>的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = hexi(<span class="number">512</span>, <span class="number">512</span>, setup, thingsToLoad, load);</span><br></pre></td></tr></table></figure>
<p>现在，您可以通过一个名为<code>g</code>的对象访问应用程序中的Hexi实例(不过，您可以给它取任何名称。我喜欢用“g”，因为它代表“game”，而且打字很短。</p>
<p><code>hexi</code>函数有5个参数，尽管只需要前3个参数。</p>
<ol>
<li>画布宽度</li>
<li>画布高度</li>
<li>setup函数</li>
<li>你在上面定义的thingsToLoad数组。可选</li>
<li>load函数。可选</li>
</ol>
<p>如果您跳过最后两个参数，Hexi将跳过加载过程并直接跳转到<code>setup</code>函数。</p>
<p>可选地设置游戏逻辑循环应该运行的每秒帧数。(精灵将被独立地呈现，并进行插值，达到60 fps)如果不设置<code>fps</code>, Hexi将默认为60 fps。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.fps = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>设置一个低于60的fps会给你带来更多的性能开销，你的游戏也会看起来很棒。</p>
<p>您还可以选择添加边框并设置背景颜色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g.border = <span class="string">"2px red dashed"</span>;</span><br><span class="line">g.backgroundColor = <span class="number">0x000000</span>;</span><br></pre></td></tr></table></figure>
<p>如果你想要缩放和对齐游戏屏幕到最大的浏览器窗口大小，你可以使用<code>scaleToWindow</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.scaleToWindow();</span><br></pre></td></tr></table></figure>
<p>最后，调用<code>start</code>方法使Hexi运行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.start();</span><br></pre></td></tr></table></figure>
<p>这是很重要的!如果不调用<code>start</code>方法，Hexi将不会启动!</p>
<h2 id="load函数，在加载时运行"><a href="#load函数，在加载时运行" class="headerlink" title="load函数，在加载时运行"></a>load函数，在加载时运行</h2><p>如果您在初始化时提供了一个名为<code>load</code>的函数，您可以显示一个加载栏并加载进度信息。只需创建一个名为<code>load</code>的函数，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//显示当前正在加载的文件</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`loading: <span class="subst">$&#123;g.loadingFile&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//显示当前加载的文件的百分比</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`progress: <span class="subst">$&#123;g.loadingProgress&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加可选的加载条</span></span><br><span class="line">  g.loadingBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setup函数，初始化并创建游戏对象"><a href="#setup函数，初始化并创建游戏对象" class="headerlink" title="setup函数，初始化并创建游戏对象"></a>setup函数，初始化并创建游戏对象</h2><p>现在您已经启动了Hexi，并加载了所有的文件，您可以开始制作东西了!这在setup函数中发生。如果您有任何对象或变量要跨多个函数使用，请在setup函数之外定义它们，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//These things will be used in more than one function</span></span><br><span class="line"><span class="keyword">let</span> cats, message;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Use the `setup` function to create things</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//... create things here! ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看安装函数中的代码是如何工作的。我们要做猫——很多的猫!-所以创建一个叫<code>cats</code>的<code>分组</code>来把它们放在一起是很有用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cats = g.group();</span><br></pre></td></tr></table></figure>
<p>在快速启动项目中，你可以用鼠标(或触摸)轻击屏幕来制作一个新的猫。所以，我们需要一个能为我们产生新的猫精灵的函数。(精灵是交互图形，你可以在屏幕上进行动画和移动。)Hexi允许您使用<code>sprite</code>方法创建一个新的精灵。只要为精灵提供您想要使用的文件名。应该使用<code>addChild</code>方法将创建的每个新的cat精灵定位并添加到cats组中。我们还希望猫用呼吸法使它的鳞片动起来，用<code>breathe</code>方法使它的透明度动起来。一个叫做<code>makeCats</code>的函数可以做到这一切。<code>makeCats</code>有两个参数:x和y的位置，相对于屏幕左上角，你希望猫出现的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeCat = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Create the cat sprite. Supply the `sprite` method with</span></span><br><span class="line">  <span class="comment">//the name of the loaded image that should be displayed</span></span><br><span class="line">  <span class="keyword">let</span> cat = g.sprite(<span class="string">"images/cat.png"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the cat's position</span></span><br><span class="line">  cat.setPosition(x, y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//You can alternatively set the position my modifying the sprite's `x` and</span></span><br><span class="line">  <span class="comment">//`y` properties directly, like this</span></span><br><span class="line">  <span class="comment">//cat.x = x;</span></span><br><span class="line">  <span class="comment">//cat.y = y;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Add some optional tween animation effects from the Hexi's</span></span><br><span class="line">  <span class="comment">//built-in tween library (called Charm). `breathe` makes the</span></span><br><span class="line">  <span class="comment">//sprite scale in and out. `pulse` oscillates its transparency</span></span><br><span class="line">  g.breathe(cat, <span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">  g.pulse(cat, <span class="number">10</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the cat's velocity to a random number between -10 and 10</span></span><br><span class="line">  cat.vx = g.randomInt(<span class="number">-10</span>, <span class="number">10</span>);</span><br><span class="line">  cat.vy = g.randomInt(<span class="number">-10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Add the cat to the `cats` group</span></span><br><span class="line">  cats.addChild(cat);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(在<a href="https://github.com/kittykatattack/hexi/tree/master/examples" target="_blank" rel="noopener">示例文件夹</a>中的<a href="https://github.com/kittykatattack/hexi/blob/master/examples/src/tweening.js" target="_blank" rel="noopener">tweening示例</a>中，您可以了解更多关于<code>breathe</code>和<code>pulse</code>方法如何工作以使cat具有动画效果的信息。)</p>
</blockquote>
<p>我们还需要创建一个文本精灵来显示”Tap for cats!”我们可以使用Hexi的<code>text</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = g.text(<span class="string">"Tap for cats!"</span>, <span class="string">"38px puzzler"</span>, <span class="string">"red"</span>);</span><br></pre></td></tr></table></figure>
<p><code>text</code>方法的参数是您想要显示的文本、字体大小和家族以及颜色(您可以使用任何HTML/CSS颜色字符串值、RGBA或HSLA值)。</p>
<p>使用Hexi的<code>putCenter</code>方法将文本居中</p>
<p><code>stage</code>是什么?它是所有Hexi精灵在第一次创建时都属于的根容器。</p>
<p>您还可以使用<code>putLeft</code>、<code>putRight</code>、<code>putTop</code>或<code>putBottom</code>方法来帮助您对齐相对于其他对象的对象。这些方法的可选的第2和第3个参数定义x和y偏移量，这有助于您微调定位。</p>
<p>因为我们希望文本消息围绕中心点旋转，所以我们必须将其<code>pivotX</code>和<code>pivotY</code>值设置为0.5。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message.pivotX = <span class="number">0.5</span>;</span><br><span class="line">message.pivotY = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p>0.5表示“精灵的中心”</p>
<p>您也可以使用这种替代语法来设置轴心点:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.setPivot(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<p>我们需要一些方法来告诉Hexi，当屏幕被点击或点击时，创建一个新的猫。我们还希望文本信息告诉我们当前屏幕上有多少只猫。Hexi有一个内建的指针对象和一个tap方法，我们可以通过编程来帮助我们做到这一点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g.pointer.tap = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Supply `makeCat` with the pointer's `x` and `y` coordinates.</span></span><br><span class="line">  makeCat(g.pointer.x, g.pointer.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make the `message.content` display the number of cats</span></span><br><span class="line">  message.content = <span class="string">`<span class="subst">$&#123;cats.children.length&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们还想要加载的音乐文件开始播放。我们可以使用Hexi的声音方法访问音乐声音对象。使用声音对象的循环方法使其连续循环，并使用<code>play</code>立即开始播放。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> music = g.sound(<span class="string">"sounds/music.wav"</span>);</span><br><span class="line">music.loop = <span class="literal">true</span>;</span><br><span class="line">music.play();</span><br></pre></td></tr></table></figure>
<p>我们现在已经把一切都安排好了!这意味着我们已经完成了应用程序的设置状态，现在可以切换到<code>play</code>。如何做到这一点:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.state = play;</span><br></pre></td></tr></table></figure>
<p><code>play</code>状态是一个在循环中运行的函数，它是我们所有应用程序逻辑的所在。下面我们来看看它是如何工作的。</p>
<h2 id="play函数-循环应用程序逻辑"><a href="#play函数-循环应用程序逻辑" class="headerlink" title="play函数:循环应用程序逻辑"></a>play函数:循环应用程序逻辑</h2><p>Hexi应用程序中最后需要的就是一个play函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//All this code will run in a loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>play</code>函数在一个连续循环中被调用，无论您设置什么fps(每秒帧数)值。这是您的游戏逻辑循环。(渲染循环将由Hexi在后台运行，在您的系统可以处理的最大fps中。)您可以使用<code>pause</code>方法随时暂停Hexi的游戏循环，并使用resume方法重新启动它。(查看<a href="https://github.com/kittykatattack/hexi/blob/master/tutorials/src/flappyFairy.js" target="_blank" rel="noopener">Flappy Fairy</a> 项目，了解如何使用<code>pause</code>和<code>resume</code>来管理状态复杂的应用程序。)</p>
<p>Quick Start项目的<code>play</code>功能只做两件事:它使文本旋转，并在屏幕上移动和反弹猫。这是整个<code>play</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Rotate the text</span></span><br><span class="line">  message.rotation += <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Loop through all of the cats to make them move and bounce off the</span></span><br><span class="line">  <span class="comment">//edges of the stage</span></span><br><span class="line">  cats.children.forEach(<span class="function"><span class="params">cat</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让猫从屏幕边缘反弹</span></span><br><span class="line">    <span class="keyword">let</span> collision = g.contain(cat, g.stage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Move the cat</span></span><br><span class="line">    g.move(cat);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是所有!与我们在设置函数中所做的所有工作相比，play函数实际上什么都不做!但是它是如何工作的呢?</p>
<p>它首先通过将消息文本精灵的<code>rotation</code>(旋转)属性更新0.1弧度，使文本围绕中心旋转。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.rotation += <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure>
<p>由于这个新的旋转值被应用到一个连续循环内的旧旋转值中，它逐渐增加了值并使文本旋转。</p>
<p>接下来，代码将遍历<code>cat</code>组的子数组中的所有精灵。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cats.children.forEach(<span class="function"><span class="params">cat</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//Loop through each `cat` sprite in the `chidren` array</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所有的Hexi组都有一个名为<code>children</code>的数组，它告诉你它们包含哪些精灵。无论何时使用<code>addChild</code>方法向组添加精灵，精灵都会被添加到组的子数组中。Hexi的根容器，叫做<code>stage</code>，它还有一个子数组，它包含了你的Hexi应用程序中的所有精灵和组。即使sprite对象也有一个子数组，这意味着您可以使用<code>addChild</code>与其他精灵分组来创建复杂的游戏对象。</p>
<p>当代码循环遍历每只猫时，它首先检查猫是否触碰了屏幕的边缘，如果触碰了，它会朝相反的方向反弹。Hexi <code>contain</code>方法可以帮助我们做到这一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collision = g.contain(cat, g.stage, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>将第三个参数设置为true是导致猫反弹的原因</p>
<p>猫在<code>move</code>方法的帮助下在屏幕上移动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.move(cat);</span><br></pre></td></tr></table></figure>
<p><code>move</code>方法通过其vx和vy速度值更新精灵的位置。(所有的Hexi精灵都有vx和vy值，初始化为0)。通过向move提供一个由逗号分隔的精灵列表，您可以一次移动多个精灵。您甚至可以为它提供包含您想要移动的所有精灵的数组。以下是移动实际上在幕后所做的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat.x += cat.vx;</span><br><span class="line">cat.y += cat.vy;</span><br></pre></td></tr></table></figure>
<p>这就是一切!这就是关于Quick Start应用程序的所有知识，以及关于Hexi所需的几乎所有知识!</p>
<h1 id="把它进一步"><a href="#把它进一步" class="headerlink" title="把它进一步"></a>把它进一步</h1><p>使用这个基本的Hexi架构，您可以创建任何东西。只需将Hexi的状态属性设置为任何其他函数，以切换应用程序的行为。方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.state = anyStateFunction;</span><br></pre></td></tr></table></figure>
<p>状态只是普通的旧JavaScript函数!很简单!</p>
<p>根据需要编写尽可能多的状态函数。如果是一个小项目，您可以将所有这些功能保存在一个文件中。但是，对于一个大项目，在需要时从外部JS文件加载函数。使用您喜欢的任何模块系统，如ES6模块、CommonJS、AMD或旧的HTML <code>&lt;script&gt;</code>标签。这个简单的架构模型可以扩展到任何大小，并且是您需要知道的唯一的体系结构模型。保持简单，保持快乐!</p>
<p>现在您已经大致了解了Hexi是如何工作的，请阅读教程来深入了解细节。</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>我们要做的第一个游戏是一个简单的对象收集和敌人躲避游戏叫做寻宝猎人。在web浏览器中打开文件01_treasurehunter.html。(您可以在Hexi的教程文件夹中找到它，您需要在webserver中运行它)。如果您不想费事设置一个webserver，请使用一个文本编辑器，比如方括号，它将自动为您启动一个方括号(请参阅方括号的文档)。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/01.png" alt="寻宝猎人"></p>
<p><a href="https://gitcdn.xyz/repo/kittykatattack/hexi/master/tutorials/01_treasureHunter.html" target="_blank" rel="noopener">游戏入口</a></p>
<blockquote>
<p>(按照上面的链接来玩这个游戏。)使用键盘移动资源管理器(蓝色方块)，收集宝藏(黄色方块)，避开怪物(红色方块)，到达出口(绿色方块)。是的，你现在必须发挥你的想象力。</p>
</blockquote>
<p>以下是完整的JavaScript源代码:</p>
<p><a href="https://github.com/kittykatattack/hexi/blob/master/tutorials/src/treasureHunter.js" target="_blank" rel="noopener">!寻宝猎人源码</a></p>
<p>不要被它表面上的简单所迷惑。寻宝者包含了游戏所需的一切:</p>
<ul>
<li>交互性</li>
<li>碰撞</li>
<li>精灵</li>
<li>游戏循环</li>
<li>场景</li>
<li>游戏逻辑</li>
<li>“Juice” (以声音的形式)</li>
</ul>
<p>(什么果汁?请观看<a href="https://www.youtube.com/watch?v=Fy0aCDmgnxg" target="_blank" rel="noopener">本视频</a>并<a href="http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1" target="_blank" rel="noopener">阅读本文</a>，以了解这一游戏设计要素。</p>
<p>如果你能做一个简单的游戏，如寻宝游戏，你几乎可以做任何其他类型的游戏。是的,真的!从寻宝人到Skyrim或塞尔达只是很多小步骤的事情;添加更多的细节。你想要加多少细节取决于你自己。</p>
<p>在本教程的第一阶段，您将了解如何制作基本的寻宝游戏，然后我们将添加一些有趣的特性，如图像和字符动画，这将使您全面了解Hexi如何工作。</p>
<p>如果你是一个经验丰富的游戏程序员和快速的自我启动者，你可能会发现在<a href="https://github.com/kittykatattack/hexi/tree/master/examples" target="_blank" rel="noopener">Hexi的例子文件夹</a>里的代码是一个更有效率的开始学习的地方——看看它。示例文件夹中的完整注释代码还详细说明了这些教程中没有涉及的特性的具体和高级用法。当您完成这些教程的学习后，这些示例将带您进入下一个阶段。</p>
<h1 id="设置HTML容器页面"><a href="#设置HTML容器页面" class="headerlink" title="设置HTML容器页面"></a>设置HTML容器页面</h1><p>在开始使用JavaScript编程之前，需要设置一个最小的HTML容器页面。HTML页面加载<code>hexi.min.js</code>是唯一需要使用Hexi所有特性的文件。它还装载了<code>treasureHunter.js</code>文件，即包含所有游戏代码的JavaScript文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Treasure hunter&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- Hexi --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="../</span>bin/hexi.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!-- Main application file --&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>bin/treasureHunter.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是<a href="http://stackoverflow.com/questions/9797046/whats-a-valid-html5-document" target="_blank" rel="noopener">有效的HTML5文档所需的HTML代码的最小数量</a>。</p>
<p>文件路径在您的系统上可能不同，这取决于您如何设置项目文件结构。</p>
<h1 id="初始化Hexi"><a href="#初始化Hexi" class="headerlink" title="初始化Hexi"></a>初始化Hexi</h1><p>下一步是编写一些JavaScript代码，根据指定的一些参数初始化和启动Hexi。下面这段代码初始化了一个屏幕大小为512×512像素的游戏。它还从<code>sounds</code>文件夹预先加载<code>chimes.wav</code>声音文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialize Hexi and load the chimes sound file</span></span><br><span class="line"><span class="keyword">let</span> g = hexi(<span class="number">512</span>, <span class="number">512</span>, setup, [<span class="string">"sounds/chimes.wav"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Scale the game canvas to the maximum size in the browser</span></span><br><span class="line">g.scaleToWindow();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Start the Hexi engine.</span></span><br><span class="line">g.start();</span><br></pre></td></tr></table></figure>
<p>你可以看到，<code>hexi</code>函数的结果被分配给一个叫做<code>g</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = hexi(<span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>现在，无论何时你想在游戏中使用Hexi的任何自定义方法或对象，只要在其前面加上g。(g很好，很短，很容易记住;g = “game”)</p>
<p>在本例中，Hexi创建一个大小为512×512像素的画布元素。由前两个参数指定:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">512</span>, <span class="number">512</span>, setup,</span><br></pre></td></tr></table></figure>
<p>第三个参数<code>setup</code>意味着只要Hexi初始化，它就应该在你的游戏代码中查找并运行一个叫做<code>setup</code>的函数。在<code>setup</code>函数中，任何代码都完全取决于您，您将很快看到如何使用它来初始化一个游戏。(你不必调用这个函数<code>setup</code>，你可以使用任何你喜欢的名字)</p>
<p>Hexi允许你用一个可选的第4个参数预加载游戏资产，它是一个文件名数组。在第一个示例中，您只需要预加载一个文件:<code>chimes.wav</code>，您可以看到将<code>chimes.wav</code>的完整文件路径作为一个字符串在初始化数组中列出:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sounds/chimes.wav"</span>]</span><br></pre></td></tr></table></figure>
<p>您可以在这里列出任意数量的游戏资产，包括图像、字体和JSON文件。在运行任何游戏代码之前，Hexi将为您加载所有这些资产。</p>
<p>Hexi实现了<a href="https://github.com/englercj/resource-loader" target="_blank" rel="noopener">Pixi的超级资源加载器</a>。您可以直接通过Hexi的loader属性访问加载器，您可以通过<code>resources</code>属性访问资源。或者,直接使用<code>PIXI.loader</code>，如果你想。您可以在这里了解更多关于<a href="https://github.com/kittykatattack/learningPixi#loading" target="_blank" rel="noopener">Pixi的加载程序是如何工作的</a>。</p>
<p>我们希望游戏画布能够扩展到浏览器窗口的最大大小，以便显示尽可能大的内容。我们可以使用一个叫做<code>scaleToWindow</code>的有用方法来为我们做这个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.scaleToWindow();</span><br></pre></td></tr></table></figure>
<p><code>scaleToWindow</code>将会在你的游戏中找到最适合的。长、宽的游戏屏幕垂直居中。高或方的屏幕水平居中。如果您想指定您自己的浏览器背景颜色来边框游戏，请提供<code>scaleToWindow</code>的参数，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.scaleToWindow(<span class="string">"seaGreen"</span>);</span><br></pre></td></tr></table></figure>
<p>最后你需要做的是调用河西的<code>start</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.start();</span><br></pre></td></tr></table></figure>
<p>这是打开Hexi引擎的开关</p>
<h1 id="定义你的全局变量"><a href="#定义你的全局变量" class="headerlink" title="定义你的全局变量"></a>定义你的<code>全局</code>变量</h1><p>在Hexi开始后，声明游戏函数需要使用的所有变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dungeon, player, treasure, enemies, chimes, exit,</span><br><span class="line">    healthBar, message, gameScene, gameOverScene;</span><br></pre></td></tr></table></figure>
<p>因为它们不包含在函数中，所以这些变量是“全局的”，因为你可以在所有的游戏函数中使用它们。(它们不一定是“全局的”，因为它们驻留在全局JavaScript名称空间中。如果您想确保它们不存在，那么<a href="http://stackoverflow.com/questions/17058606/why-using-self-executing-function-in-javascript" target="_blank" rel="noopener">将所有JavaScript代码封装在一个封闭的函数中，以将其与全局空间隔离开来</a>。或者，如果您想用一种奇特的方式，使用JavaScript ES6/2015<a href="http://exploringjs.com/es6/ch_modules.html" target="_blank" rel="noopener">模块</a>或<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类</a>来执行本地范围。</p>
<h1 id="用setup函数初始化游戏"><a href="#用setup函数初始化游戏" class="headerlink" title="用setup函数初始化游戏"></a>用setup函数初始化游戏</h1><p>只要Hexi启动，它就会在你的游戏代码中查找并运行一个叫setup的函数(或者你想给这个函数起的其他名字)。setup函数只运行一次，允许您为您的游戏执行一次设置任务。它是创建和初始化对象、创建精灵、游戏场景、填充数据数组或解析加载的JSON游戏数据的好地方。</p>
<p>这是《寻宝猎人》中setup函数的简要鸟瞰视图，以及它执行的任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Create the `chimes` sound object</span></span><br><span class="line">  <span class="comment">//Create the `gameScene` group</span></span><br><span class="line">  <span class="comment">//Create the `exit` door sprite</span></span><br><span class="line">  <span class="comment">//Create the `player` sprite</span></span><br><span class="line">  <span class="comment">//Create the `treasure` sprite</span></span><br><span class="line">  <span class="comment">//Make the enemies</span></span><br><span class="line">  <span class="comment">//Create the health bar</span></span><br><span class="line">  <span class="comment">//Add some text for the game over message</span></span><br><span class="line">  <span class="comment">//Create a `gameOverScene` group </span></span><br><span class="line">  <span class="comment">//Assign the player's keyboard controllers</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//set the game state to `play`</span></span><br><span class="line">  g.state = play;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一行代码<code>g.state = play</code>可能是最重要的，因为它启动了<code>play</code>函数。<code>play</code>函数在一个循环中运行所有的游戏逻辑。但是在我们看它如何工作之前，让我们看看setup函数中的特定代码是做什么的。</p>
<h2 id="创建chimes声音对象"><a href="#创建chimes声音对象" class="headerlink" title="创建chimes声音对象"></a>创建chimes声音对象</h2><p>从上面的代码中可以看到，我们在游戏中预装了一个名为<code>chimes.wav</code>的声音文件。在你可以在游戏中使用它之前，你必须使用Hexi的<code>sound</code>方法来引用它，比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chimes = g.sound(<span class="string">"sounds/chimes.wav"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="创建游戏场景"><a href="#创建游戏场景" class="headerlink" title="创建游戏场景"></a>创建游戏场景</h2><p>Hexi有一个有用的方法叫做group，它可以让你把游戏对象分组在一起，这样你就可以把它们作为一个单元来使用。组用于将称为 <strong>精灵</strong> 的特殊对象分组(您将在下一节中了解这些对象)。但它们也被用来制作游戏场景。</p>
<p>《寻宝猎人》使用了两个游戏场景:游戏主游戏<code>gameScene</code>和游戏结束时显示的<code>gameOverScene</code>。以下是使用<code>group</code>方法制作<code>gameScene</code>的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameScene = g.group();</span><br></pre></td></tr></table></figure>
<p>创建组之后，可以使用<code>addChild</code>方法向<code>gameScene</code>添加精灵(游戏对象)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameScene.addChild(anySprite);</span><br></pre></td></tr></table></figure>
<p>或者，您可以使用<code>add</code>方法一次添加多个精灵，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameScene.add(spriteOne, spriteTwo, spriteThree);</span><br></pre></td></tr></table></figure>
<p>或者，如果你喜欢，你可以在你完成所有的精灵之后创建游戏场景，然后用一行代码将所有的精灵分组，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameScene = g.group(spriteOne, spriteTwp, spriteThree);</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，您将看到一些如何向组添加精灵的不同示例。</p>
<p>但是什么是精灵，你是怎么做的呢?</p>
<h2 id="制作精灵"><a href="#制作精灵" class="headerlink" title="制作精灵"></a>制作精灵</h2><p>精灵是任何游戏中最重要的元素。精灵只是你可以用特殊属性控制的图形(形状或图像)。你能在游戏中看到的一切，比如游戏角色、对象和背景，都是精灵。Hexi允许你制作5种基本的精灵:矩形、圆形、直线、文本和精灵(基于图像的精灵)。你几乎可以用这些基本的精灵类型制作任何2D动作游戏。(如果还不够，还可以定义自己的自定义精灵类型。)第一个版本的宝藏猎人只使用矩形精灵。你可以做一个这样的矩形精灵:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = g.rectangle(</span><br><span class="line">  widthInPixels,</span><br><span class="line">  heightInPixels,</span><br><span class="line">  <span class="string">"fillColor"</span>,</span><br><span class="line">  <span class="string">"strokeColor"</span>,</span><br><span class="line">  lineWidth,</span><br><span class="line">  xPosition,</span><br><span class="line">  yPosition</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>你可以用Hexi circle方法做一个圆形精灵:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ball = g.circle(</span><br><span class="line">  diameterInPixels,</span><br><span class="line">  <span class="string">"fillColor"</span>,</span><br><span class="line">  <span class="string">"strokeColor"</span>,</span><br><span class="line">  lineWidth,</span><br><span class="line">  xPosition,</span><br><span class="line">  yPosition</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>仅仅使用矩形和圆形精灵来设计一个新游戏的原型通常很有用，因为这样可以帮助你以一种纯粹的、基本的方式专注于游戏的机制。这就是《寻宝猎人》的第一个版本。下面是创建出口、玩家和宝物精灵的setup函数的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The exit door</span></span><br><span class="line">exit = g.rectangle(<span class="number">48</span>, <span class="number">48</span>, <span class="string">"green"</span>);</span><br><span class="line">exit.x = <span class="number">8</span>;</span><br><span class="line">exit.y = <span class="number">8</span>;</span><br><span class="line">gameScene.addChild(exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">//The player sprite</span></span><br><span class="line">player = g.rectangle(<span class="number">32</span>, <span class="number">32</span>, <span class="string">"blue"</span>);</span><br><span class="line">player.x = <span class="number">68</span>;</span><br><span class="line">player.y = g.canvas.height / <span class="number">2</span> - player.halfHeight;</span><br><span class="line">gameScene.addChild(player);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create the treasure</span></span><br><span class="line">treasure = g.rectangle(<span class="number">16</span>, <span class="number">16</span>, <span class="string">"gold"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Position it next to the left edge of the canvas</span></span><br><span class="line">treasure.x = g.canvas.width - treasure.width - <span class="number">10</span>;</span><br><span class="line">treasure.y = g.canvas.height / <span class="number">2</span> - treasure.halfHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Alternatively, you could use Ga's built in convience method</span></span><br><span class="line"><span class="comment">//called `putCenter` to postion the sprite like this:</span></span><br><span class="line"><span class="comment">//g.stage.putCenter(treasure, 208, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在宝藏上创建一个“pickedUp”属性，帮助我们弄清楚这个宝藏是否被玩家捡走了</span></span><br><span class="line">treasure.pickedUp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Add the treasure to the `gameScene`</span></span><br><span class="line">gameScene.addChild(treasure);</span><br></pre></td></tr></table></figure>
<p>注意，在创建每个精灵之后，都使用<code>addChild</code>将其添加到<code>gameScene</code>中。以下是上述代码产生的结果:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/03.png" alt="v1"></p>
<p>让我们进一步了解这些精灵是如何定位在画布上的。</p>
<h2 id="定位精灵"><a href="#定位精灵" class="headerlink" title="定位精灵"></a>定位精灵</h2><p>所有精灵都有x和y属性，您可以使用它们来精确地定位画布上的精灵。x和y值指的是相对于画布左上角的精灵像素坐标。左上角的x和y值为0。这意味着你给精灵赋值的任何正的x和y值会将它们与那个角点的位置分别放在左边(x)和下面(y)。例如，这是位置在出口门(绿色方块)的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit.x = <span class="number">8</span>;</span><br><span class="line">exit.y = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>您可以看到，这段代码将门设置为右8像素，在画布左上角以下8像素。正<code>x</code>值将精灵定位在画布左边缘的右边。正<code>y</code>值将它们放置在画布的上边缘以下。</p>
<p>精灵也有<code>width</code>和<code>height</code>属性，以像素为单位告诉你它们的宽度和高度。如果你想知道精灵的一半宽度或一半高度是多少，可以使用<code>halfWidth</code>和<code>halfHeight</code>。</p>
<p>Hexi也有一些方便的方法，帮助您快速定位精灵相对于其他精灵的位置:<code>putTop</code>、<code>putRight</code>、<code>putBottom</code>、<code>putLeft</code>和<code>putCenter</code>。例如，下面是位于宝藏精灵(黄金盒)上面的代码行。代码将宝藏放置在画布右边缘左边的26像素处，并将其垂直居中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">treasure.x = g.canvas.width - treasure.width - <span class="number">10</span>;</span><br><span class="line">treasure.y = g.canvas.height / <span class="number">2</span> - treasure.halfHeight;</span><br></pre></td></tr></table></figure>
<p>这是一大堆复杂的定位代码。相反，您可以使用Hexi的内置<code>putCenter</code>方法来实现同样的效果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.stage.putCenter(treasure, <span class="number">220</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>(stage)舞台</strong> 是什么?它是所有精灵的根容器，与画布的尺寸完全相同。你可以把舞台想象成一个巨大的、看不见的精灵，和画布一样大，它包含了游戏中的所有精灵，以及那些精灵可能被分组的任何容器(比如<code>gameScene</code>)。<code>putCenter</code>的工作原理是将宝物放在舞台中心，然后将其x位置偏移220像素。以下是使用<code>putCenter</code>的格式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anySprite.putCenter(anyOtherSprite, xOffset, yOffset);</span><br></pre></td></tr></table></figure>
<p>您可以用同样的方式使用其他put方法。例如，如果您想将一个精灵直接定位到另一个精灵的左边，而没有任何偏移，您可以使用<code>putLeft</code>，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spriteOne.putLeft(spriteTwo);</span><br></pre></td></tr></table></figure>
<p>这将把<code>spriteTwo</code>直接放在<code>spriteOne</code>的左边，并垂直对齐它。</p>
<h2 id="分配动态属性"><a href="#分配动态属性" class="headerlink" title="分配动态属性"></a>分配动态属性</h2><p>在我们继续之前，您需要注意一个小细节。创建精灵的代码还向宝藏精灵添加了一个<code>pickedUp</code>属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">treasure.pickedUp = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>您将看到我们将如何在游戏逻辑中使用<code>treasure.pickedUp</code>，以帮助我们确定游戏的进度。如果需要，可以动态地将任何自定义属性或方法分配给这样的精灵。</p>
<h2 id="创建敌人精灵"><a href="#创建敌人精灵" class="headerlink" title="创建敌人精灵"></a>创建敌人精灵</h2><p>寻宝游戏中有6个敌人精灵(红色方块)。它们水平间隔，但有随机的初始垂直位置。所有的敌人精灵都是在一个<code>for</code>循环中使用这个代码在<code>setup</code>函数中创建的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Make the enemies</span></span><br><span class="line"><span class="keyword">let</span> numberOfEnemies = <span class="number">6</span>,</span><br><span class="line">    spacing = <span class="number">48</span>,</span><br><span class="line">    xOffset = <span class="number">150</span>,</span><br><span class="line">    speed = <span class="number">2</span>,</span><br><span class="line">    direction = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//An array to store all the enemies</span></span><br><span class="line">enemies = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Make as many enemies as there are `numberOfEnemies`</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numberOfEnemies; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Each enemy is a red rectangle</span></span><br><span class="line">  <span class="keyword">let</span> enemy = g.rectangle(<span class="number">32</span>, <span class="number">32</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Space each enemey horizontally according to the `spacing` value.</span></span><br><span class="line">  <span class="comment">//`xOffset` determines the point from the left of the screen</span></span><br><span class="line">  <span class="comment">//at which the first enemy should be added.</span></span><br><span class="line">  <span class="keyword">let</span> x = spacing * i + xOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Give the enemy a random y position</span></span><br><span class="line">  <span class="keyword">let</span> y = g.randomInt(<span class="number">0</span>, g.canvas.height - enemy.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the enemy's direction</span></span><br><span class="line">  enemy.x = x;</span><br><span class="line">  enemy.y = y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the enemy's vertical velocity. `direction` will be either `1` or</span></span><br><span class="line">  <span class="comment">//`-1`. `1` means the enemy will move down and `-1` means the enemy will</span></span><br><span class="line">  <span class="comment">//move up. Multiplying `direction` by `speed` determines the enemy's</span></span><br><span class="line">  <span class="comment">//vertical direction</span></span><br><span class="line">  enemy.vy = speed * direction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reverse the direction for the next enemy</span></span><br><span class="line">  direction *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Push the enemy into the `enemies` array</span></span><br><span class="line">  enemies.push(enemy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Add the enemy to the `gameScene`</span></span><br><span class="line">  gameScene.addChild(enemy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码产生的结果如下:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/04.png" alt="."></p>
<p>代码通过Hexi的<code>randomInt</code>方法给每个敌人一个随机的<code>y</code>位置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y = g.randomInt(<span class="number">0</span>, g.canvas.height - enemy.height);</span><br></pre></td></tr></table></figure>
<p><code>randomInt</code>将给出参数中提供的任意两个整数之间的随机数。(如果你需要一个随机小数，可以使用<code>randomFloat</code>来代替)。</p>
<p>所有的精灵都有称为vx和vy的属性。它们决定了精灵在水平方向(vx)和垂直方向(vy)移动的速度和方向。《寻宝人》中的敌人只是上下移动，所以他们只需要一个vy值。它们的vy是速度(2)乘以方向(1或-1)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enemy.vy = speed * direction;</span><br></pre></td></tr></table></figure>
<p>如果方向是1，敌人的vy就是2。这意味着敌人将以每帧2像素的速度移动屏幕。如果方向是-1，敌人的速度是-2。这意味着敌人将以每帧2像素的速度在屏幕上移动。</p>
<p>当敌人的vy被设置好后，方向就会颠倒，这样下一个敌人就会朝相反的方向移动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction *= <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>您可以看到，创建的每个敌人都被推进到一个称为<code>enemies</code>的数组中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enemies.push(enemy);</span><br></pre></td></tr></table></figure>
<p>在后面的代码中，您将看到我们将如何访问这个数组中的所有敌人，以确定他们是否正在触摸播放器。</p>
<h2 id="健康条"><a href="#健康条" class="headerlink" title="健康条"></a>健康条</h2><p>你会注意到当玩家触碰到一个敌人时，屏幕右上角的健康条的宽度会减小。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/05.png" alt="health bar"></p>
<p>这个健康条是怎么做的?它只是两个相同位置的矩形精灵:一个黑色的矩形在后面，一个绿色的矩形在前面。它们被组合在一起组成一个叫做healthBar的单一化合物sprite。然后将健康条添加到gameScene中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create the health bar</span></span><br><span class="line"><span class="keyword">let</span> outerBar = g.rectangle(<span class="number">128</span>, <span class="number">16</span>, <span class="string">"black"</span>),</span><br><span class="line">    innerBar = g.rectangle(<span class="number">128</span>, <span class="number">16</span>, <span class="string">"yellowGreen"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Group the inner and outer bars</span></span><br><span class="line">healthBar = g.group(outerBar, innerBar);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set the `innerBar` as a property of the `healthBar`</span></span><br><span class="line">healthBar.inner = innerBar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Position the health bar</span></span><br><span class="line">healthBar.x = g.canvas.width - <span class="number">148</span>;</span><br><span class="line">healthBar.y = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Add the health bar to the `gameScene`</span></span><br><span class="line">gameScene.addChild(healthBar);</span><br></pre></td></tr></table></figure>
<p>您可以看到一个名为<code>inner</code>的属性被添加到<code>healthBar</code>。它只是引用了<code>innerBar</code>(绿色矩形)，以便以后可以方便地访问它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">healthBar.inner = innerBar;</span><br></pre></td></tr></table></figure>
<p>你不需要这么做;但是,嘿,为什么不呢!这意味着如果你想控制内栏的宽度，你可以写一些流畅的代码，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">healthBar.inner.width = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>这是相当整洁和可读的，所以我们将保持它!</p>
<h2 id="游戏结束的场景"><a href="#游戏结束的场景" class="headerlink" title="游戏结束的场景"></a>游戏结束的场景</h2><p>如果玩家的生命值降至零，或者玩家设法将宝物带到出口，游戏结束，游戏在屏幕上显示。现场游戏只是显示“你赢了”或“你输了”的一些文本，这取决于结果。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/06.png" alt="you won"></p>
<p>这使得怎么样?文本由文本精灵构成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anyText = g.text(</span><br><span class="line">  <span class="string">"Hello!"</span>, <span class="string">"CSS font properties"</span>, <span class="string">"fillColor"</span>, xPosition, yPosition</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，第一个参数“Hello!”是要显示的文本内容。使用<code>content</code>属性稍后更改文本精灵的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anyText.content = <span class="string">"Some new content"</span>;</span><br></pre></td></tr></table></figure>
<p>以下是如何在<code>setup</code>函数中创建消息文本的游戏</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add some text for the game over message</span></span><br><span class="line">message = g.text(<span class="string">"Game Over!"</span>, <span class="string">"64px Futura"</span>, <span class="string">"black"</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">message.x = <span class="number">120</span>;</span><br><span class="line">message.y = g.canvas.height / <span class="number">2</span> - <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>接下来，创建一个名为<code>gameOverScene</code>的新组。消息文本被添加到其中。<code>gameOverScene</code>的可视属性设置为false，以便在游戏开始时不可见。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gameOverScene = g.group(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Make the `gameOverScene` invisible for now</span></span><br><span class="line">gameOverScene.visible = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>在游戏结束时，我们将设置游戏场景的可见属性为true以显示文本消息。我们还将<code>gameScene</code>的可见属性设置为false，以便所有的游戏精灵都隐藏起来。</p>
<h1 id="键盘交互"><a href="#键盘交互" class="headerlink" title="键盘交互"></a>键盘交互</h1><p>你用键盘箭头键控制玩家(蓝色方块)。Hexi有一个内置的箭头控制<code>arrowControl</code>方法，让您快速添加箭头键的交互性游戏。提供要作为第一个参数移动的精灵，以及作为第二个参数移动的每帧像素数。以下是如何使用<code>arrowControl</code>方法来帮助玩家在按下箭头键时每帧移动5个像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.arrowControl(player, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>arrowControl</code>是实现键盘交互性的一种简单而快速的方法，但是通常需要更好地控制按下键时发生的情况。Hexi有一个内置的<code>keyboard</code>方法，你可以定义自定义键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> customKey = g.keyboard(asciiCode);</span><br></pre></td></tr></table></figure>
<p>为要作为第一个参数使用的键提供<a href="http://www.asciitable.com/" target="_blank" rel="noopener">ascii码号</a></p>
<p>所有这些键都有可定义的<code>press</code>和<code>release</code>方法。以下是如何可选地创建和使用这些键盘对象来帮助移动宝藏猎人中的玩家角色。(您将在setup函数中定义此代码):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create some keyboard objects using Hexi's `keyboard` method.</span></span><br><span class="line"><span class="comment">//You would usually use this code in the `setup` function.</span></span><br><span class="line"><span class="comment">//Supply the ASCII key code value as the single argument</span></span><br><span class="line"><span class="keyword">let</span> leftArrow = g.keyboard(<span class="number">37</span>),</span><br><span class="line">    upArrow = g.keyboard(<span class="number">38</span>),</span><br><span class="line">    rightArrow = g.keyboard(<span class="number">39</span>),</span><br><span class="line">    downArrow = g.keyboard(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Left arrow key `press` method</span></span><br><span class="line">leftArrow.press = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//Change the player's velocity when the key is pressed</span></span><br><span class="line">  player.vx = <span class="number">-5</span>;</span><br><span class="line">  player.vy = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Left arrow key `release` method</span></span><br><span class="line">leftArrow.release = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//If the left arrow has been released, and the right arrow isn't down,</span></span><br><span class="line">  <span class="comment">//and the player isn't moving vertically:</span></span><br><span class="line">  <span class="comment">//Stop the player</span></span><br><span class="line">  <span class="keyword">if</span> (!rightArrow.isDown &amp;&amp; player.vy === <span class="number">0</span>) &#123;</span><br><span class="line">    player.vx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The up arrow</span></span><br><span class="line">upArrow.press = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  player.vy = <span class="number">-5</span>;</span><br><span class="line">  player.vx = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">upArrow.release = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!downArrow.isDown &amp;&amp; player.vx === <span class="number">0</span>) &#123;</span><br><span class="line">    player.vy = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The right arrow</span></span><br><span class="line">rightArrow.press = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  player.vx = <span class="number">5</span>;</span><br><span class="line">  player.vy = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">rightArrow.release = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!leftArrow.isDown &amp;&amp; player.vy === <span class="number">0</span>) &#123;</span><br><span class="line">    player.vx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The down arrow</span></span><br><span class="line">downArrow.press = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  player.vy = <span class="number">5</span>;</span><br><span class="line">  player.vx = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">downArrow.release = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!upArrow.isDown &amp;&amp; player.vx === <span class="number">0</span>) &#123;</span><br><span class="line">    player.vy = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>您可以看到玩家的vx和vy属性的值根据按下或释放的键而改变。一个正值的vx值将使玩家向右移动，一个负值将使玩家向左移动。一个正值的vy值会让玩家向下移动，一个负值会让玩家向上移动。</p>
<p>第一个参数是要控制的精灵:player。第二个参数是精灵移动每一帧的像素数:5。最后四个参数是顶键、右键、底键和左键的<a href="http://www.asciitable.com/" target="_blank" rel="noopener">ascii码</a>。(你可以记住这一点，因为它们的顺序是顺时针的，从顶部开始。)</p>
<h1 id="设置游戏状态"><a href="#设置游戏状态" class="headerlink" title="设置游戏状态"></a>设置游戏状态</h1><p><strong>游戏状态</strong> 是Hexi当前运行的函数。当Hexi第一次启动时，它会运行setup函数(或者你在Hexi的构造函数参数中指定的其他函数)。如果您想要更改游戏状态，请为Hexi的状态属性分配一个新函数。方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.state = anyFunction;</span><br></pre></td></tr></table></figure>
<p>在《寻宝游戏》中，当设置功能完成后，游戏状态设置为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.state = play;</span><br></pre></td></tr></table></figure>
<p>这使得Hexi查找并运行一个叫做play的函数。默认情况下，分配给游戏状态的任何函数都将以每秒60帧的速度连续循环运行。(您可以通过设置Hexi的fps属性随时改变帧速率)。游戏逻辑通常在一个连续循环中运行，这就是游戏循环。Hexi为您处理循环管理，所以您不必担心它是如何工作的。</p>
<blockquote>
<p>(如果您好奇，Hexi使用一个<code>requestAnimationFrame</code>循环，它具有一个<a href="http://gameprogrammingpatterns.com/game-loop.html" target="_blank" rel="noopener">固定的逻辑时间步长和可变渲染时间</a>。它也做雪碧位置插值，以消除任何不一致的峰值在帧率。它运行的是秘密的冰沙，所以你可以使用它的任何属性来调整你的Hexi应用游戏循环以获得最好的效果。</p>
</blockquote>
<p>如果您需要暂停循环，只需使用Hexi的暂停方法，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.pause();</span><br></pre></td></tr></table></figure>
<p>您可以使用resume方法再次启动游戏循环，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.resume();</span><br></pre></td></tr></table></figure>
<p>现在让我们来看看宝藏猎人的游戏功能是如何工作的。</p>
<h1 id="游戏逻辑与play函数循环"><a href="#游戏逻辑与play函数循环" class="headerlink" title="游戏逻辑与play函数循环"></a>游戏逻辑与play函数循环</h1><p>正如您刚刚学到的，play函数中的所有内容都是在一个连续循环中运行的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//This code loops from top to bottom 60 times per second  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是所有游戏逻辑发生的地方。这是有趣的部分，让我们看看play函数中的代码是做什么的。</p>
<h2 id="移动玩家精灵"><a href="#移动玩家精灵" class="headerlink" title="移动玩家精灵"></a>移动玩家精灵</h2><p>寻宝者在游戏中使用Hexi的<code>move</code>方法来移动精灵。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.move(player);</span><br></pre></td></tr></table></figure>
<p>这相当于这样写代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">player.x += player.vx;</span><br><span class="line">player.y += player.vy;</span><br></pre></td></tr></table></figure>
<p>它通过添加vx和vy速度值来更新玩家的x和y位置。使用move可以省去输入和查看这个标准的样板代码的麻烦。</p>
<p>您还可以通过提供数组作为参数来移动一个完整的精灵数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.move(arrayOfSprites);</span><br></pre></td></tr></table></figure>
<p>现在你可以很容易地移动玩家，但是当玩家到达屏幕边缘时会发生什么?</p>
<h2 id="包含屏幕边界内的精灵"><a href="#包含屏幕边界内的精灵" class="headerlink" title="包含屏幕边界内的精灵"></a>包含屏幕边界内的精灵</h2><p>使用Hexi’s contains方法将精灵保持在屏幕的边界内</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.contain(player, g.stage);</span><br></pre></td></tr></table></figure>
<p>第一个参数是要包含的精灵，第二个参数是任何带有x、y、width和height属性的JavaScript对象。</p>
<p>如前所述，stage是所有河西精灵的根容器对象，它的宽度和高度与画布相同</p>
<p>但是，您也可以使用自定义对象来提供包含方法，以执行相同的操作。方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g.contain(</span><br><span class="line">  player,</span><br><span class="line">  &#123;</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span>,</span><br><span class="line">    width: <span class="number">512</span>,</span><br><span class="line">    height: <span class="number">512</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这将包含玩家精灵到由对象的维度定义的区域。如果您想精确地调整对象应该包含的区域，这将非常方便。</p>
<p><code>contain</code>有一个特别有用的特性。如果精灵到达一个包含边，<code>contains</code>将返回一个JavaScript集，告诉您它到达了哪个边:“top”、“right”、“bottom”或“left”。以下是如何使用这个特性来找出精灵在画布上触碰的边缘:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> playerHitsEdges = g.contain(player, g.stage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(playerHitsEdges) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Find out on which side the collision happened</span></span><br><span class="line">  <span class="keyword">let</span> collisionSide;</span><br><span class="line">  <span class="keyword">if</span> (playerHitsEdges.has(<span class="string">"left"</span>)) collisionSide = <span class="string">"left"</span>;</span><br><span class="line">  <span class="keyword">if</span> (playerHitsEdges.has(<span class="string">"right"</span>)) collisionSide = <span class="string">"right"</span>;</span><br><span class="line">  <span class="keyword">if</span> (playerHitsEdges.has(<span class="string">"top"</span>)) collisionSide = <span class="string">"top"</span>;</span><br><span class="line">  <span class="keyword">if</span> (playerHitsEdges.has(<span class="string">"bottom"</span>)) collisionSide = <span class="string">"bottom"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Display the result in a text sprite</span></span><br><span class="line">  message.content = <span class="string">`The player hit the <span class="subst">$&#123;collisionSide&#125;</span> of the canvas`</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与敌人碰撞"><a href="#与敌人碰撞" class="headerlink" title="与敌人碰撞"></a>与敌人碰撞</h2><p>当玩家攻击被任何一个敌人时，健康栏的宽度会减少，玩家会变成半透明的。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/07.png" alt="collision"></p>
<h3 id="这是如何工作的呢"><a href="#这是如何工作的呢" class="headerlink" title="这是如何工作的呢?"></a>这是如何工作的呢?</h3><p>Hexi有一整套有用的二维几何和基于瓷砖的碰撞检测方法。Hexi实现了<a href="https://github.com/kittykatattack/bump" target="_blank" rel="noopener">Bump碰撞模块</a>，所以Bump的所有碰撞方法都和Hexi一起工作。</p>
<p>寻宝游戏只使用其中一种碰撞方法: <code>hitTestRectangle</code>。它用两个矩形的精灵告诉你它们是否重叠。如果是，它将返回<code>true</code>;如果不是，则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.hitTestRectangle(spriteOne, spriteTwo);</span><br></pre></td></tr></table></figure>
<p>下面是play函数中的代码如何使用<code>hitTestRectangle</code>检查任何敌人和玩家之间的冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set `playerHit` to `false` before checking for a collision</span></span><br><span class="line"><span class="keyword">let</span> playerHit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Loop through all the sprites in the `enemies` array</span></span><br><span class="line">enemies.forEach(<span class="function"><span class="params">enemy</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Move the enemy</span></span><br><span class="line">  g.move(enemy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Check the enemy's screen boundaries</span></span><br><span class="line">  <span class="keyword">let</span> enemyHitsEdges = g.contain(enemy, g.stage);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//If the enemy hits the top or bottom of the stage, reverse</span></span><br><span class="line">  <span class="comment">//its direction</span></span><br><span class="line">  <span class="keyword">if</span> (enemyHitsEdges) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enemyHitsEdges.has(<span class="string">"top"</span>) || enemyHitsEdges.has(<span class="string">"bottom"</span>)) &#123;</span><br><span class="line">      enemy.vy *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Test for a collision. If any of the enemies are touching</span></span><br><span class="line">  <span class="comment">//the player, set `playerHit` to `true`</span></span><br><span class="line">  <span class="keyword">if</span> (g.hitTestRectangle(player, enemy)) &#123;</span><br><span class="line">   playerHit = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//If the player is hit...</span></span><br><span class="line"><span class="keyword">if</span> (playerHit) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make the player semi-transparent</span></span><br><span class="line">  player.alpha = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reduce the width of the health bar's inner rectangle by 1 pixel</span></span><br><span class="line">  healthBar.inner.width -= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make the player fully opaque (non-transparent) if it hasn't been hit</span></span><br><span class="line">  player.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个名为<code>playerHit</code>的变量，该变量在<code>forEach</code>循环检查所有敌人是否发生冲突之前被初始化为<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> playerHit = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(因为<code>play</code>函数每秒运行60次，所以<code>playerHit</code>在每个新帧中将被重新初始化为<code>false</code>)</p>
</blockquote>
<p>如果<code>hitTestRectangle</code>返回<code>true</code>, <code>forEach</code>循环将<code>playerHit</code>设置为<code>true</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(g.hitTestRectangle(player, enemy)) &#123;</span><br><span class="line">  playerHit = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果玩家被击中，代码会将alpha值设置为0.5，使玩家半透明。它还可以将<code>healthBar</code>的内部精灵的宽度减少1像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(playerHit) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make the player semi-transparent</span></span><br><span class="line">  player.alpha = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reduce the width of the health bar's inner rectangle by 1 pixel</span></span><br><span class="line">  healthBar.inner.width -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make the player fully opaque (non-transparent) if it hasn't been hit</span></span><br><span class="line">  player.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以将精灵的<code>alpha</code>属性设置为<code>0</code>(完全透明)到<code>1</code>(完全不透明)之间的任何值。<code>0.5</code>的值使它成为半透明 (Alpha是一个久经考验的平面设计术语，只意味着透明)</p>
<p>这段代码还使用<code>move</code>方法来移动敌人，并包含在画布中。代码还使用<code>contain</code>的返回值来确定敌人是在攻击画布的顶部还是底部。如果它击中顶部或底部，敌人的方向会在以下代码的帮助下颠倒:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Check the enemy's screen boundaries</span></span><br><span class="line"><span class="keyword">let</span> enemyHitsEdges = g.contain(enemy, g.stage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//If the enemy hits the top or bottom of the stage, reverse</span></span><br><span class="line"><span class="comment">//its direction</span></span><br><span class="line"><span class="keyword">if</span> (enemyHitsEdges) &#123;</span><br><span class="line">  <span class="keyword">if</span> (enemyHitsEdges.has(<span class="string">"top"</span>) || enemyHitsEdges.has(<span class="string">"bottom"</span>)) &#123;</span><br><span class="line">    enemy.vy *= <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将敌人的<code>vy</code>(垂直速度)值乘以- 1会使它朝相反的方向前进。这是一个非常简单的反弹效应。</p>
<h2 id="碰撞的宝藏"><a href="#碰撞的宝藏" class="headerlink" title="碰撞的宝藏"></a>碰撞的宝藏</h2><p>如果玩家触摸到宝藏(黄色方块)，钟声就会响起。然后玩家可以把宝物带到出口。宝藏集中在玩家身上，并随之移动。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/08.png" alt="treasure"></p>
<p>这是<code>play</code>函数实现这些效果的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Check for a collision between the player and the treasure</span></span><br><span class="line"><span class="keyword">if</span> (g.hitTestRectangle(player, treasure)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//If the treasure is touching the player, center it over the player</span></span><br><span class="line">  treasure.x = player.x + <span class="number">8</span>;</span><br><span class="line">  treasure.y = player.y + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!treasure.pickedUp) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If the treasure hasn't already been picked up,</span></span><br><span class="line">    <span class="comment">//play the `chimes` sound</span></span><br><span class="line">    chimes.play();</span><br><span class="line">    treasure.pickedUp = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以看到代码在<code>if</code>语句中使用<code>hitTestRectangle</code>来测试玩家和宝藏之间的冲突</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g.hitTestRectangle(player, treasure)) &#123;</span><br></pre></td></tr></table></figure>
<p>如果这是真的，宝藏就集中在玩家身上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">treasure.x = player.x + <span class="number">8</span>;</span><br><span class="line">treasure.y = player.y + <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>treasure.pickedUp</code>是<code>false</code>，那么你知道宝藏还没有被取走，你可以播放钟声:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chimes.play();</span><br></pre></td></tr></table></figure>
<p>除了播放Hexi的声音对象，你还可以使用更多的方法来控制它们:暂停、重新启动和播放。(使用playFrom从声音文件中的特定秒开始播放声音，如:<code>soundObject.playFrom(5)</code>。这将使声音从5秒开始播放。</p>
<p>您还可以通过在0和1之间分配值来设置声音对象的音量。以下是如何将音量设置为中等(50%)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundObject.volume = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p>您可以通过将-1(左扬声器)值设置为1(右扬声器)来设置声音对象的<code>pan</code>。泛音值为0时，两个扬声器的音量都相等。以下是如何将<code>pan</code>设置为在左扬声器中稍微突出一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundObject.pan = <span class="number">-0.2</span>;</span><br></pre></td></tr></table></figure>
<p>如果您想要使一个声音连续重复，请将其loop属性设置为true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundObject.loop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>Hexi实现了<a href="https://github.com/kittykatattack/sound.js" target="_blank" rel="noopener">Sound.js模块</a>来控制声音，因此您可以在Hexi应用程序中使用Sound.js的任何属性和方法。</p>
<p>因为您不想在拾取宝藏后再播放一次钟声，所以代码在声音播放后将<code>treasure.pickedUp</code>设置为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">treasure.pickedUp = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>现在玩家拿起了宝物，你怎么能检查游戏的结局呢?</p>
<h2 id="结束游戏"><a href="#结束游戏" class="headerlink" title="结束游戏"></a>结束游戏</h2><p>游戏有两种结局。玩家的健康状况可能会耗尽，在这种情况下，比赛就会失败。或者，玩家可以成功地把宝物带到出口，这样游戏就赢了。如果满足这两个条件中的任何一个，游戏的状态将被设置为结束，消息文本的内容将显示结果。下面是play函数中的最后一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Does the player have enough health? If the width of the `innerBar`</span></span><br><span class="line"><span class="comment">//is less than zero, end the game and display "You lost!"</span></span><br><span class="line"><span class="keyword">if</span> (healthBar.inner.width &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  g.state = end;</span><br><span class="line">  message.content = <span class="string">"You lost!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//If the player has brought the treasure to the exit,</span></span><br><span class="line"><span class="comment">//end the game and display "You won!"</span></span><br><span class="line"><span class="keyword">if</span> (g.hitTestRectangle(treasure, exit)) &#123;</span><br><span class="line">  g.state = end;</span><br><span class="line">  message.content = <span class="string">"You won!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束函数非常简单。它只是隐藏了<code>gameScene</code>并显示了<code>gameOverScene</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gameScene.visible = <span class="literal">false</span>;</span><br><span class="line">  gameOverScene.visible = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是寻宝猎人!在继续之前，尝试使用这些相同的技术从头开始制作您自己的游戏。当你准备好了，继续读下去!</p>
<h1 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h1><p>在你的Hexi游戏中有三种主要的使用图像的方法</p>
<ul>
<li>为每个精灵使用单独的图像文件</li>
<li>使用一个 <strong>纹理地图集</strong> 。这是一个单独的图像文件，包含游戏中每个精灵的子图像。图像文件附带一个匹配的JSON数据文件，该文件描述每个子图像的名称、大小和位置</li>
<li>使用tileset(也称为spritesheet)。这也是一个单一的图像文件，包括每个精灵的子图像。然而，与纹理图集不同，它没有一个描述精灵数据的JSON文件。相反，您需要使用JavaScript在游戏代码中指定每个精灵的大小和位置。在某些情况下，这可以比纹理图集有一些优势</li>
</ul>
<p>这三种制作图像精灵的方法都使用了Hexi的<code>sprite</code>方法。这是使用它来制作图像精灵的最简单的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageSprite = g.sprite(<span class="string">"images/theSpriteImage.png"</span>);</span><br></pre></td></tr></table></figure>
<p>在下一节中，我们将使用图像精灵更新“宝藏猎人”，您将了解将图像添加到游戏中的三种方法。</p>
<blockquote>
<p>这部分的所有图片都是由Lanea Zimmerman创作的。你可以在<a href="http://opengameart.org/users/sharm" target="_blank" rel="noopener">这里</a>找到更多她的艺术作品。谢谢,Lanea !</p>
</blockquote>
<h2 id="个人形象"><a href="#个人形象" class="headerlink" title="个人形象"></a>个人形象</h2><p>打开并播放下一个版本的宝藏猎人:02_treasureHunterImages.html(在教程文件夹中可以找到)它和第一个版本完全一样，但是所有的彩色方块都被图像所取代。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/09.png" alt="2"></p>
<blockquote>
<p><a href="https://cdn.gitcdn.xyz/cdn/kittykatattack/hexi/7349658f295c120ca7f3bab94d31379a0c02952e/tutorials/02_treasureHunterImages.html" target="_blank" rel="noopener">(点击，点击链接玩游戏。)</a>看看源代码，你会发现游戏的逻辑和结构与游戏的第一个版本完全相同。唯一改变的是精灵的外表。这是如何做的呢?</p>
</blockquote>
<h2 id="加载图片文件"><a href="#加载图片文件" class="headerlink" title="加载图片文件"></a>加载图片文件</h2><p>游戏中的每个精灵都使用一个PNG图像文件。您将在教程的images子文件夹中找到所有的图像。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/10.png" alt="images"></p>
<p>在使用它们制作精灵之前，您需要预先将它们加载到Hexi的资产中。最简单的方法是在第一次初始化引擎时，在Hexi的资产数组中列出图像名称及其完整的文件路径。创建一个名为<code>thingsToLoad</code>的数组，列出要加载的文件名。然后提供该数组作为<code>hexi</code>方法的第四个参数。方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//An array that contains all the files you want to load</span></span><br><span class="line"><span class="keyword">let</span> thingsToLoad = [</span><br><span class="line">  <span class="string">"images/explorer.png"</span>,</span><br><span class="line">  <span class="string">"images/dungeon.png"</span>,</span><br><span class="line">  <span class="string">"images/blob.png"</span>,</span><br><span class="line">  <span class="string">"images/treasure.png"</span>,</span><br><span class="line">  <span class="string">"images/door.png"</span>,</span><br><span class="line">  <span class="string">"sounds/chimes.wav"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a new Hexi instance, and start it</span></span><br><span class="line"><span class="keyword">let</span> g = hexi(<span class="number">512</span>, <span class="number">512</span>, setup, thingsToLoad);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Start Hexi</span></span><br><span class="line">g.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在web浏览器中打开JavaScript控制台，就可以监视这些资产的加载进度</p>
</blockquote>
<p>现在你可以在你的游戏代码中访问这些图像:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.image(<span class="string">"images/blob.png"</span>)</span><br></pre></td></tr></table></figure>
<p>尽管预加载图像和其他资产是使它们进入游戏的最简单的方法，但是您也可以使用loader对象及其方法在任何其他时候加载资产。正如我前面提到的，加载程序只是运行在底层的Pixi加载程序的别名，您可以在<a href="https://github.com/kittykatattack/learningPixi#loading" target="_blank" rel="noopener">这里了解如何使用它</a>。</p>
<p>现在您已经将这些图像加载到游戏中，让我们看看如何使用它们来制作精灵。</p>
<h2 id="用图片制作精灵"><a href="#用图片制作精灵" class="headerlink" title="用图片制作精灵"></a>用图片制作精灵</h2><p>使用<code>sprite</code>方法创建一个图像精灵，使用您之前了解的格式。下面介绍如何使用<code>dungeon.png</code>映像创建精灵。(<code>dungeon.png</code>是512×512像素的背景图像)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dungeon = g.sprite(<span class="string">"images/dungeon.png"</span>);</span><br></pre></td></tr></table></figure>
<p>这是所有!现在，精灵不再显示为一个简单的彩色矩形，而是显示为一个512×512的图像。没有必要指定宽度或高度，因为Hexi根据图像的大小自动计算。您可以使用所有其他的精灵属性，如x、y、宽度和高度，就像使用普通矩形精灵一样。</p>
<p>下面是设置函数的代码，该函数创建了地牢背景、退出门、玩家和宝藏，并将它们全部添加到<code>gameScene</code>组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The dungeon background</span></span><br><span class="line">dungeon = g.sprite(<span class="string">"images/dungeon.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//The exit door</span></span><br><span class="line">exit = g.sprite(<span class="string">"images/door.png"</span>);</span><br><span class="line">exit.x = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The player sprite</span></span><br><span class="line">player = g.sprite(<span class="string">"images/explorer.png"</span>);</span><br><span class="line">player.x = <span class="number">68</span>;</span><br><span class="line">player.y = g.canvas.height / <span class="number">2</span> - player.halfWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create the treasure</span></span><br><span class="line">treasure = g.sprite(<span class="string">"images/treasure.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Position it next to the left edge of the canvas</span></span><br><span class="line"><span class="comment">//g.stage.putCenter(treasure, 208, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a `pickedUp` property on the treasure to help us Figure</span></span><br><span class="line"><span class="comment">//out whether or not the treasure has been picked up by the player</span></span><br><span class="line">treasure.pickedUp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create the `gameScene` group and add the sprites</span></span><br><span class="line">gameScene = g.group(dungeon, exit, player, treasure);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作为对该代码原始版本的稍微更有效的改进，<code>group</code>创建了<code>gameScene</code>并在单个步骤中对精灵进行分组</p>
</blockquote>
<p>看起来熟悉吗?没错，唯一改变的代码是创建精灵的行。这种模块化是Hexi的一个特性，它可以让你使用简单的形状创建快速的游戏原型，当你的游戏思想发展的时候，你可以很容易地把它换成详细的图片。游戏中的其余代码可以保持原样。</p>
<h2 id="微调控制区域"><a href="#微调控制区域" class="headerlink" title="微调控制区域"></a>微调控制区域</h2><p>这个新版本的宝藏猎人有一个小的改进，那就是精灵被包含在地牢里的新方式。它们以一种自然地与艺术品的2.5D视角相匹配的方式被包含在其中，如这张屏幕截图中的绿色方块所示:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/11.png" alt="perspective"></p>
<p>这是一个很容易修改的地方。您所需要做的就是提供包含一个定义包含矩形的大小和位置的自定义对象的包含方法。方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g.contain(</span><br><span class="line">  player,</span><br><span class="line">  &#123;</span><br><span class="line">    x: <span class="number">32</span>, <span class="attr">y</span>: <span class="number">16</span>,</span><br><span class="line">    width: g.canvas.width - <span class="number">32</span>,</span><br><span class="line">    height: g.canvas.height - <span class="number">32</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>只需调整x、y、宽度和高度值，这样包含的区域对于您正在制作的游戏来说就显得自然了。</p>
<h2 id="使用一个纹理地图集"><a href="#使用一个纹理地图集" class="headerlink" title="使用一个纹理地图集"></a>使用一个纹理地图集</h2><p>如果您正在开发一个大型、复杂的游戏，您将需要一种快速、高效的图像处理方法。纹理图谱可以帮助你做到这一点。一个纹理图集实际上是两个独立的文件，它们是紧密相关的:</p>
<ul>
<li>一个PNG tileset图像文件，其中包含您希望在游戏中使用的所有图像。(tileset图像有时被称为spritesheet)</li>
<li>一个JSON文件，描述这些子图像在tileset中的大小和位置</li>
</ul>
<p>使用纹理图集是一个很大的节省时间。您可以按任何顺序排列tileset的子图像，JSON文件将为您跟踪它们的大小和位置。这非常方便，因为这意味着子图像的大小和位置不会硬编码到游戏程序中。如果您对tileset做了更改，比如添加图像、调整它们的大小或删除它们，那么只需重新发布JSON文件，您的游戏将使用更新后的数据来正确显示图像。如果你要制作比一个小游戏更大的东西，你一定要使用纹理图集。</p>
<p>ileset JSON数据的实际标准是一种格式，这种格式由一种叫做<a href="https://www.codeandweb.com/texturepacker" target="_blank" rel="noopener">纹理包装器</a>的流行软件工具输出(纹理包装器的“基本”许可证是免费的)。即使您不使用纹理包装器，类似的工具如<a href="http://renderhjs.net/shoebox/" target="_blank" rel="noopener">Shoebox</a>以相同的格式输出JSON文件。让我们来看看如何使用它来制作一个纹理贴图，以及如何将它加载到游戏中。</p>
<h3 id="准备的图片"><a href="#准备的图片" class="headerlink" title="准备的图片"></a>准备的图片</h3><p>您首先需要为您的游戏中的每个图像提供单独的PNG图像。您已经为“寻宝者”找到了它们，所以您都已经设置好了。打开<a href="https://www.codeandweb.com/texturepacker" target="_blank" rel="noopener">Texture Packer</a>并选择<code>{JS}</code>配置选项。将你的游戏图像拖到它的工作区中。您还可以将纹理封隔器指向任何包含图像的文件夹。纹理封隔器将自动将图像排列在一个小块图像上，并为它们提供与原始图像文件名匹配的名称。默认情况下，它会给他们一个2像素的填充。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/12.png" alt="Texture Packer"></p>
<p>地图集中的每一个子图像都被称为帧。虽然只是一个大的图像，纹理图集有5帧。每个帧的名称都是它的原始PNG文件名:”dungeon.png”, “blob.png”, “explorer.png”, “treasure.png” 和 “door.png”。这些帧名用于帮助atlas引用每个子映像。</p>
<p>完成后，请确保数据格式设置为JSON(Hash)并单击Publish按钮。选择文件名和位置，并保存已发布的文件。您将得到一个PNG文件和一个JSON文件。在这个例子中，我的文件名是<code>treasureHunter.json</code>和<code>treasureHunter.png</code>。为了让你的生活更简单，只需将两个文件保存在项目的images文件夹中。(可以将JSON文件视为图像文件的额外元数据)</p>
<p>Texture Packer使用起来可能会很麻烦，因为您需要使所有这些设置都正确，以便在不告诉您有错误的情况下正确地发布。并且，它将试图通过使用不支持免费版本的默认设置来欺骗您升级到付费版本。因此，您需要显式地关闭这些(正如我上面所描述的)，以使其工作没有错误。尽管如此，最后的努力还是值得的——所以如果你遇到不可能的困难，继续尝试并在这个资源库中发布一个问题吧!</p>
<h3 id="加载纹理地图集"><a href="#加载纹理地图集" class="headerlink" title="加载纹理地图集"></a>加载纹理地图集</h3><p>要将纹理图集加载到游戏中，只需在初始化游戏时将JSON文件包含在Hexi的资产数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thingsToLoad = [</span><br><span class="line">  <span class="string">"images/treasureHunter.json"</span>,</span><br><span class="line">  <span class="string">"sounds/chimes.wav"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> g = hexi(<span class="number">512</span>, <span class="number">512</span>, setup, thingsToLoad);</span><br><span class="line">g.scaleToWindow();</span><br><span class="line">g.start();</span><br></pre></td></tr></table></figure>
<p>这是所有!你不必加载PNG文件- Hexi在后台自动完成。只需告诉Hexi显示哪个tileset帧(子图像)就可以了。</p>
<p>如果你想用纹理图谱的框架来制作精灵，你可以这样做:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anySprite = g.sprite(<span class="string">"frameName.png"</span>);</span><br></pre></td></tr></table></figure>
<p>Ga将创建精灵，并显示纹理贴图中正确的图像。</p>
<p>以下是如何使用纹理图集框架创建寻宝游戏中的精灵:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The dungeon background</span></span><br><span class="line">dungeon = g.sprite(<span class="string">"dungeon.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//The exit door</span></span><br><span class="line">exit = g.sprite(<span class="string">"door.png"</span>);</span><br><span class="line">exit.x = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The player sprite</span></span><br><span class="line">player = g.sprite(<span class="string">"explorer.png"</span>);</span><br><span class="line">player.x = <span class="number">68</span>;</span><br><span class="line">player.y = g.canvas.height / <span class="number">2</span> - player.halfWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create the treasure</span></span><br><span class="line">treasure = g.sprite(<span class="string">"treasure.png"</span>);</span><br></pre></td></tr></table></figure>
<p>Hexi知道这些是纹理地图集的帧名，而不是单独的图像，它直接显示它们来自tileset。</p>
<p>如果你需要在游戏中访问纹理地图集的JSON文件，你可以这样获取:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsonFile = g.json(<span class="string">"jsonFileName.json"</span>);</span><br></pre></td></tr></table></figure>
<p>查看教程文件夹中的<code>treasureHunterAtlas.js</code>文件，查看如何加载纹理图集并使用它制作精灵的工作示例。</p>
<h1 id="外星人武装"><a href="#外星人武装" class="headerlink" title="外星人武装"></a>外星人武装</h1><p>本系列教程中的下一个示例游戏是Alien Armada。你能在60个外星人着陆前摧毁他们并毁灭地球吗?点击下面的图片链接玩游戏:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/13.png" alt="alien armada"></p>
<p>使用箭头键移动并按空格键射击。随着游戏的进行，外星人越来越频繁地从屏幕顶端降落。游戏规则如下:</p>
<ul>
<li>加载并使用自定义字体。</li>
<li>在加载游戏资产时显示加载进度条。</li>
<li>射击子弹。</li>
<li>创建具有多个图像状态的精灵。</li>
<li>生成随机的敌人。</li>
<li>从游戏中移除精灵。</li>
<li>显示一个游戏分数。</li>
<li>重置并重新启动游戏。</li>
</ul>
<p>您将在教程文件夹中找到完整注释的外星无敌舰队源代码。请务必查看它，以便您能够在正确的上下文中看到所有这些代码。它的一般结构与《寻宝者》相同，并加入了这些新技术。让我们看看它们是如何实现的。</p>
<h2 id="加载并使用自定义字体"><a href="#加载并使用自定义字体" class="headerlink" title="加载并使用自定义字体"></a>加载并使用自定义字体</h2><p>Alien Armada使用自定义字体<code>emulogic.ttf</code>显示屏幕右上角的分数。字体文件预先加载了初始化游戏的资产数组中的其余资产文件(声音和图像)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thingsToLoad = [</span><br><span class="line">  <span class="string">"images/alienArmada.json"</span>,</span><br><span class="line">  <span class="string">"sounds/explosion.mp3"</span>,</span><br><span class="line">  <span class="string">"sounds/music.mp3"</span>,</span><br><span class="line">  <span class="string">"sounds/shoot.mp3"</span>,</span><br><span class="line">  <span class="string">"fonts/emulogic.ttf"</span> <span class="comment">//&lt;- The custom font</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> g = hexi(<span class="number">480</span>, <span class="number">320</span>, setup, thingsToLoad, load);</span><br><span class="line">g.scaleToWindow();</span><br><span class="line">g.start();</span><br></pre></td></tr></table></figure>
<p>要使用该字体，请在游戏的设置函数中创建一个文本精灵。text方法的第二个参数是一个字符串，描述字体的点大小和名称:“20px emulogic”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreDisplay = g.text(<span class="string">"0"</span>, <span class="string">"20px emulogic"</span>, <span class="string">"#00FF00"</span>, <span class="number">400</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>您可以加载和使用TTF、OTF、TTC或WOFF格式的任何字体</p>
<h2 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h2><p>外星人无敌舰队装载了3个MP3音频文件:一个射击声，一个爆炸声和音乐。音乐声音的大小约为2 MB，所以在网络连接缓慢的情况下，这种声音需要几秒钟才能被加载。当这种情况发生时，玩家只能看到空白的画布，而外星人的无敌舰队则装载。有些玩家可能会认为游戏已经冻结，所以游戏会有帮助地实现一个加载栏来通知玩家资产正在加载。它是一个从左向右展开的蓝色矩形，并显示一个数字，告诉您目前加载的游戏资产的百分比</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/16.png" alt="loading"></p>
<p>这是一个内置在Hexi引擎的特性。Hexi有一个可选的加载状态，在加载游戏资产时运行。在加载状态下，您可以决定要发生什么。您所需要做的就是编写一个函数，其中包含在加载资产时应该运行的代码，并告诉Hexi这个函数的名称。Hexi的引擎会自动在循环中运行这个函数，直到资产加载完成。</p>
<p>让我们来看看外星人无敌舰队是如何运作的。游戏代码告诉Hexi在加载状态下使用一个名为load的函数。它通过列出load作为Hexi的初始化构造函数的最后一个参数来实现这一点。(请在下面的代码中查找负载):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = hexi(<span class="number">480</span>, <span class="number">320</span>, setup, thingsToLoad, load); <span class="comment">//&lt;- It's here!</span></span><br></pre></td></tr></table></figure>
<p>这告诉Hexi在资产加载时在循环中运行<code>load</code>函数</p>
<p>这是来自外星舰队的<code>load</code>函数。它实现了一个<code>loadingBar</code>对象，它显示了正在扩展的blue bar和加载的文件的百分比。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  g.loadingBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资产加载后，setup状态自动运行</p>
<p>您将在Hexi的core.js文件中找到loadingBar代码。这是一个非常简单的例子，如果您愿意，您可以使用它作为编写自定义加载动画的基础。您可以在load函数中运行任何您喜欢的代码，因此完全由您决定什么应该发生，什么在您的游戏加载时显示。</p>
<h2 id="发射子弹"><a href="#发射子弹" class="headerlink" title="发射子弹"></a>发射子弹</h2><p>你怎么能让大炮射出子弹?</p>
<p>当你按下空格键时，大炮向敌人发射子弹。子弹从炮塔的末端开始，以每帧7像素的速度在画布上移动。如果他们撞到外星人，外星人就会爆炸。如果一颗子弹没有击中并飞过舞台顶部，游戏代码就会移除它。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/17.png" alt="Shooting"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bullets = [];</span><br></pre></td></tr></table></figure>
<p>此<code>bullets</code>数组在游戏的<code>setup</code>函数中初始化。</p>
<p>然后，您可以使用Here的自定义shoot方法来制作任意方向的精灵射击子弹。下面是实现shoot方法的一般格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">g.shoot(</span><br><span class="line">  cannon,            <span class="comment">//大炮</span></span><br><span class="line">  <span class="number">4.71</span>,              <span class="comment">//射击角度 (4.71 是向上)</span></span><br><span class="line">  cannon.halfWidth,  <span class="comment">//子弹在大炮上的x位置</span></span><br><span class="line">  <span class="number">0</span>,                 <span class="comment">//子弹在大炮上的y位置</span></span><br><span class="line">  g.stage,           <span class="comment">//应该添加子弹的容器</span></span><br><span class="line">  <span class="number">7</span>,                 <span class="comment">//子弹的速度 (像素每帧)</span></span><br><span class="line">  bullets,           <span class="comment">//用于存储子弹的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//A function that returns the sprite that should</span></span><br><span class="line">  <span class="comment">//be used to make each bullet</span></span><br><span class="line">  () =&gt; g.sprite(<span class="string">"bullet.png"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>第二个参数决定了子弹应该以弧度表示的角度。4.71弧度，在本例中使用，向上。0在右边，1.57在下面，3.14在左边。</p>
<p>第三和第四个参数是子弹在正典上的起始x和y位置。第5个参数是应该添加子弹的容器，第6个参数是应该放入子弹的数组。</p>
<p>最后一个参数是一个函数，它返回一个应该用作子弹的精灵。在这个例子中，子弹是使用游戏中加载的纹理图集中的”bullet.png”帧创建的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; g.sprite(<span class="string">"bullet.png"</span>)</span><br></pre></td></tr></table></figure>
<p>用您自己的函数替换此函数，以创建您可能需要的任何类型的自定义子弹。</p>
<p>你的子弹什么时候发射?您可以随时调用shoot方法，无论何时您想要创建项目符号，在代码中的任何位置。在外星无敌舰队中，当玩家按下空格键时，子弹会被发射。游戏通过在空格键的press方法中调用shoot来实现这一点。方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">g.spaceBar.press = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Shoot the bullet</span></span><br><span class="line">  g.shoot(</span><br><span class="line">    cannon,            <span class="comment">//The shooter</span></span><br><span class="line">    <span class="number">4.71</span>,              <span class="comment">//The angle at which to shoot (4.71 is up)</span></span><br><span class="line">    cannon.halfWidth,  <span class="comment">//Bullet's x position on the cannon</span></span><br><span class="line">    <span class="number">0</span>,                 <span class="comment">//Bullet's y position on the canon</span></span><br><span class="line">    g.stage,           <span class="comment">//The container to which the bullet should be added</span></span><br><span class="line">    <span class="number">7</span>,                 <span class="comment">//The bullet's speed (pixels per frame)</span></span><br><span class="line">    bullets,           <span class="comment">//The array used to store the bullets</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//A function that returns the sprite that should</span></span><br><span class="line">    <span class="comment">//be used to make each bullet</span></span><br><span class="line">    () =&gt; g.sprite(<span class="string">"bullet.png"</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Play the shoot sound.</span></span><br><span class="line">  shootSound.play();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>您可以看到<code>press</code>方法也使<code>shootSound</code>发挥作用。(上面的代码是在游戏的<code>setup</code>函数中初始化的)</p>
<p>还有一件事你需要做:你必须让子弹move。你可以在游戏循环play函数中使用一些代码。使用Hexi的move方法并提供子弹阵列作为参数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.move(bullets);</span><br></pre></td></tr></table></figure>
<p><code>move</code>方法自动循环遍历阵列中的所有精灵，并以其<code>vx</code>和<code>vy</code>速度值的值更新它们的x和y位置。</p>
<p>现在你知道子弹是如何创建和动画的了。但是当他们击中一个外星人会发生什么呢?</p>
<h2 id="精灵状态"><a href="#精灵状态" class="headerlink" title="精灵状态"></a>精灵状态</h2><p>当一颗子弹击中一个外星人时，会出现一个黄色的爆炸图像。这个简单的效果是通过给每个外星精灵两个状态来创造的:一个正常的状态和一个被破坏的状态。外星人被创造，他们的状态被设定为正常。如果他们被击中，他们的状态就会被摧毁。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/18.png" alt="staus"></p>
<p>这个系统是如何工作的?</p>
<p>首先，让我们来看看外星无敌舰队，这里展示的是:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/19.png" alt="alien"></p>
<p>您可以看到定义这两种状态的两个图像帧:alien.png和explosion.png。在创建sprite之前，首先创建一个数组来列出这两帧:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alienFrames = [</span><br><span class="line">  <span class="string">"alien.png"</span>,</span><br><span class="line">  <span class="string">"explosion.png"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>接下来使用<code>alienframe</code>数组初始化外星精灵</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien = g.sprite(alienFrames);</span><br></pre></td></tr></table></figure>
<p>如果你愿意，你可以把这两个步骤合并成一个，像这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien = g.sprite([</span><br><span class="line">  <span class="string">"alien.png"</span>, </span><br><span class="line">  <span class="string">"explosion.png"</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>这将为精灵加载两个帧。第0帧是alien.png 帧，第一帧是explosion.png帧。在第一次创建精灵时，默认显示第0帧。</p>
<p>您可以使用sprite的<code>show</code>方法在sprite上显示任何其他帧号，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien.show(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码将把外星人设置为第一帧，这就是explosion.png帧</p>
<p>为了使您的代码更具可读性，在一个特殊的状态对象中定义sprite的状态是一个好主意。给每个状态一个名称，其值对应于该状态的帧号。以下是如何定义外星人的两种状态: <code>normal</code>和<code>destroyed</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien.states = &#123;</span><br><span class="line">  normal: <span class="number">0</span>,</span><br><span class="line">  destroyed: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在<code>alien.states.normal</code>的值为0,<code>alien.states.destroyed</code>的值为1。这意味着你可以像这样显示外星人的<code>normal</code>状态:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien.show(alien.states.normal);</span><br></pre></td></tr></table></figure>
<p>展示外星人<code>destroyed</code>的状态:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien.show(alien.states.destroyed);</span><br></pre></td></tr></table></figure>
<p>这使您的代码可读性更强，因为您可以一眼看出哪个sprite状态正在显示</p>
<blockquote>
<p>注意:Hexi也有一个低级的<code>gotoAndStop</code>方法，它的功能和<code>show</code>一样。尽管你可以在游戏代码中自由使用<code>gotoAndStop</code>，但按照惯例，只有Hexi的渲染引擎在内部使用它</p>
</blockquote>
<h2 id="生成随机的外星人"><a href="#生成随机的外星人" class="headerlink" title="生成随机的外星人"></a>生成随机的外星人</h2><p>外星人无敌舰队在14个随机选择的位置中的任何一个产生外星人，就在舞台的顶部边界上。外星人最初出现的频率很低，但逐渐开始以越来越高的速度出现。随着游戏的进行，这使得游戏变得越来越困难。让我们看看这两个特性是如何实现的。</p>
<h3 id="外星人时机"><a href="#外星人时机" class="headerlink" title="外星人时机"></a>外星人时机</h3><p>当游戏开始时，第一个新的外星人在100帧后产生。在游戏的<code>setup</code>函数中初始化的一个叫做<code>alienFrequency</code>的变量用来帮助跟踪这个。初始化为100。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alienFrequency = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>另一个名为alienTimer的变量用于计算前面生成的外星人与下一个外星人之间经过的帧数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alienTimer = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在play函数(游戏循环)中，每个帧都更新了一个alienTimer。当alienTimer达到alienFrequency的值时，会产生一个新的异形精灵。这是play函数的代码。(此代码省略了生成外星精灵的实际代码——我们将在前面看到)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add one to the alienTimer</span></span><br><span class="line">alienTimer++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Make a new alien if `alienTimer` equals the `alienFrequency`</span></span><br><span class="line"><span class="keyword">if</span>(alienTimer === alienFrequency) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//... Create the alien: see ahead for the missing code that does this...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the `alienTimer` back to zero</span></span><br><span class="line">  alienTimer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reduce `alienFrequency` by one to gradually increase</span></span><br><span class="line">  <span class="comment">//the frequency that aliens are created</span></span><br><span class="line">  <span class="keyword">if</span>(alienFrequency &gt; <span class="number">2</span>)&#123;  </span><br><span class="line">    alienFrequency--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在上面的代码中看到，创建精灵之后，<code>alienFrequency</code>减少了1。这将使下一个外星人出现的时间比前一个外星人早1帧，这也是为什么下降的外星人的速度缓慢增加。您还可以看到，在创建精灵之后，<code>alienTimer</code>被设置为0，以便它可以重新计数，以生成下一个新的外星人。</p>
<h3 id="外星人的随机起始位置"><a href="#外星人的随机起始位置" class="headerlink" title="外星人的随机起始位置"></a>外星人的随机起始位置</h3><p>在生成任何外星人之前，我们需要一个数组来存储所有的外星人精灵。为此，在setup函数中初始化一个名为alien的空数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aliens = [];</span><br></pre></td></tr></table></figure>
<p>然后在<code>play</code>函数中创建每个异形，在相同的if语句中，我们看上面。这段代码有很多工作要做:</p>
<ul>
<li>它设置外星人的图像帧和状态。</li>
<li>它设定了外星人的速度(vx和vy)。</li>
<li>它将外星人定位在顶端边界上的任意水平位置。</li>
<li>最后，它把外星人推进了aliens的数组。</li>
</ul>
<p>这里有完整的代码来完成这一切:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add one to the alienTimer</span></span><br><span class="line">alienTimer++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Make a new alien if `alienTimer` equals the `alienFrequency`</span></span><br><span class="line"><span class="keyword">if</span>(alienTimer === alienFrequency) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Create the alien.</span></span><br><span class="line">  <span class="comment">//Assign two frames from the texture atlas as the</span></span><br><span class="line">  <span class="comment">//alien's two states</span></span><br><span class="line">  <span class="keyword">let</span> alienFrames = [</span><br><span class="line">    <span class="string">"alien.png"</span>, </span><br><span class="line">    <span class="string">"explosion.png"</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Initialize the alien sprite with the frames</span></span><br><span class="line">  <span class="keyword">let</span> alien = g.sprite(alienFrames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Define some states on the alien that correspond</span></span><br><span class="line">  <span class="comment">//to its two frames.</span></span><br><span class="line">  alien.states = &#123;</span><br><span class="line">    normal: <span class="number">0</span>,</span><br><span class="line">    destroyed: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Set its y position above the screen boundary</span></span><br><span class="line">  alien.y = <span class="number">0</span> - alien.height;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Assign the alien a random x position</span></span><br><span class="line">  alien.x = g.randomInt(<span class="number">0</span>, <span class="number">14</span>) * alien.width;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Set its speed</span></span><br><span class="line">  alien.vy = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Push the alien into the `aliens` array</span></span><br><span class="line">  aliens.push(alien);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the `alienTimer` back to zero</span></span><br><span class="line">  alienTimer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reduce `alienFrequency` by one to gradually increase</span></span><br><span class="line">  <span class="comment">//the frequency that aliens are created</span></span><br><span class="line">  <span class="keyword">if</span>(alienFrequency &gt; <span class="number">2</span>)&#123;  </span><br><span class="line">    alienFrequency--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在上面的代码中看到外星人的y位置将它放置在舞台的顶部边界上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien.y = <span class="number">0</span> - alien.height;</span><br></pre></td></tr></table></figure>
<p>它的x位置是随机的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien.x = g.randomInt(<span class="number">0</span>, <span class="number">14</span>) * alien.width;</span><br></pre></td></tr></table></figure>
<p>这段代码将其放置在15个可能的随机位置(0到14)之上。以下是这些立场的说明:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/20.png" alt="random"></p>
<p>最后，也是非常重要的一点，代码将外星人精灵推入aliens数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aliens.push(alien);</span><br></pre></td></tr></table></figure>
<p>所有这些代码开始以稳定增长的速度输出外星人</p>
<h3 id="移动外星人"><a href="#移动外星人" class="headerlink" title="移动外星人"></a>移动外星人</h3><p>我们如何让外星人移动?用让子弹移动的同样方式。您将在上面的代码中注意到，每个外星人都用vy(垂直速度)值1初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien.vy = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>当这个值应用到外星人的y位置时，它将使外星人以每帧1像素的速度向下移动，向舞台的底部移动。游戏中所有的外星人精灵都在外星人阵中。所以要让它们都移动，你需要遍历异形数组中的每个精灵每个帧并将它们的vy值添加到它们的y位置。在play函数中类似的一些代码可以工作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aliens.forEach(<span class="function"><span class="params">alien</span> =&gt;</span> &#123;</span><br><span class="line">  alien.y += alien.vy;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不过，使用Hexi便捷的内置移动功能更简单。只需提供你想要移动的精灵数组，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.move(aliens);</span><br></pre></td></tr></table></figure>
<p>这将自动使用速度更新外星人的位置</p>
<h3 id="让外星人爆炸"><a href="#让外星人爆炸" class="headerlink" title="让外星人爆炸"></a>让外星人爆炸</h3><p>既然你已经知道如何改变外星人的状态，你怎么能用这个技能创造爆炸效果呢?下面是来自外星舰队的简化代码，它向您展示了如何做到这一点。使用hittest矩形来检查外星人和子弹之间的碰撞。如果发现了碰撞，取出子弹，显示外星人被摧毁的状态，然后在一秒钟后移除外星人。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g.hitTestRectangle(alien, bullet)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Remove the bullet sprite.</span></span><br><span class="line">  g.remove(bullet);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Show the alien's `destroyed` state.</span></span><br><span class="line">  alien.show(alien.states.destroyed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Wait for 1 second (1000 milliseconds) then</span></span><br><span class="line">  <span class="comment">//remove the alien sprite.</span></span><br><span class="line">  g.wait(<span class="number">1000</span>, () =&gt; g.remove(alien));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用Hexi的万能remove函数从游戏中移除精灵，就像这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.remove(anySprite);</span><br></pre></td></tr></table></figure>
<p>您可以通过列出参数中要删除的精灵来选择一次删除多个精灵，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.remove(spriteOne, spriteTwo, spriteThree);</span><br></pre></td></tr></table></figure>
<p>您甚至可以使用它来删除一系列精灵中的精灵。只需提供sprite数组作为移除的唯一参数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.remove(arrayOfSprites);</span><br></pre></td></tr></table></figure>
<p>这将使精灵从屏幕中消失，并将它们从它们所在的数组中清空。</p>
<p>Hexi还有一个方便的方法叫wait，它可以在你指定的任何延迟(以毫秒为单位)之后运行一个函数。外星人的无敌舰队游戏代码使用等待移除外星人后的一个第二次延迟，像这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.wait(<span class="number">1000</span>, () =&gt; g.remove(alien));</span><br></pre></td></tr></table></figure>
<p>这允许外星人在它从游戏中消失之前显示它的爆炸图像状态一秒钟。</p>
<p>这些都是使外星人爆炸的基本技术，当他们碰撞时把外星人和子弹从游戏中移除。但是在《异形无敌舰队》中使用的实际代码要复杂一些。这是因为代码使用嵌套的<code>filter</code>循环遍历所有的子弹和异形，以便可以相互检查它们是否发生冲突。当发生碰撞时，代码也会播放爆炸声音，并将分数更新为1。这是游戏的<code>play</code>函数的所有代码。(如果您是JavaScript的<code>filter</code>循环的新手，您可以在<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">这里阅读如何使用它们</a>。)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Check for a collision between the aliens and the bullets.</span></span><br><span class="line"><span class="comment">//Filter through each alien in the `aliens` array.</span></span><br><span class="line">aliens = aliens.filter(<span class="function"><span class="params">alien</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//A variable to help check if the alien is</span></span><br><span class="line">  <span class="comment">//alive or dead.</span></span><br><span class="line">  <span class="keyword">let</span> alienIsAlive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Filter though all the bullets.</span></span><br><span class="line">  bullets = bullets.filter(<span class="function"><span class="params">bullet</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check for a collision between an alien and bullet.</span></span><br><span class="line">    <span class="keyword">if</span> (g.hitTestRectangle(alien, bullet)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Remove the bullet sprite.</span></span><br><span class="line">      g.remove(bullet);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Show the alien's `destroyed` state.</span></span><br><span class="line">      alien.show(alien.states.destroyed);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//You could alternatively use the frame number,</span></span><br><span class="line">      <span class="comment">//like this:</span></span><br><span class="line">      <span class="comment">//alien.show(1);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//Play the explosion sound.</span></span><br><span class="line">      explosionSound.play();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Stop the alien from moving.</span></span><br><span class="line">      alien.vy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Set `alienAlive` to false so that it can be</span></span><br><span class="line">      <span class="comment">//removed from the array.</span></span><br><span class="line">      alienIsAlive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Wait for 1 second (1000 milliseconds) then</span></span><br><span class="line">      <span class="comment">//remove the alien sprite.</span></span><br><span class="line">      g.wait(<span class="number">1000</span>, () =&gt; g.remove(alien));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Update the score.</span></span><br><span class="line">      score += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Remove the bullet from the `bullets array.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//If there's no collision, keep the bullet in the</span></span><br><span class="line">      <span class="comment">//bullets array.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Return the value of `alienIsAlive` back to the</span></span><br><span class="line">  <span class="comment">//filter loop. If it's `true`, the alien will be</span></span><br><span class="line">  <span class="comment">//kept in the `aliens` array. </span></span><br><span class="line">  <span class="comment">//If it's `false` it will be removed from the `aliens` array.</span></span><br><span class="line">  <span class="keyword">return</span> alienIsAlive;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>只要filter循环返回true，当前正在检查的sprite将保留在数组中。但是，如果发生碰撞，循环返回false，当前的外星人和子弹将从它们的数组中删除。</p>
<p>这就是游戏的碰撞原理!</p>
<h3 id="显示分数"><a href="#显示分数" class="headerlink" title="显示分数"></a>显示分数</h3><p>外星人无敌舰队引入的另一个新特性是动态分数显示。每次外星人被击中，游戏屏幕右上角的分数就会增加1分。这是如何工作的呢?</p>
<p>外星人无敌舰队初始化一个被称为<code>scoreDisplay</code>的文本精灵在游戏的<code>setup</code>功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreDisplay = g.text(<span class="string">"0"</span>, <span class="string">"20px emulogic"</span>, <span class="string">"#00FF00"</span>, <span class="number">400</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>你在前一节中看到，当一个外星人被击中时，游戏的得分变量会增加1:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>要明显地更新分数，您只需将分数值设置为记分显示器的内容，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoreDisplay.content = score;</span><br></pre></td></tr></table></figure>
<p>这就是一切!</p>
<h3 id="结束并重新设置游戏"><a href="#结束并重新设置游戏" class="headerlink" title="结束并重新设置游戏"></a>结束并重新设置游戏</h3><p>游戏有两种结局。要么玩家击落60个外星人，这样玩家就赢了。或者，其中一个外星人必须穿越舞台的底部边缘，这样外星人就赢了。</p>
<p>一个简单的if语句在播放函数检查这个。如果任一条件变为真，胜者将被设置为“玩家”或“外星人”，游戏的状态将被更改为结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The player wins if the score matches the value</span></span><br><span class="line"><span class="comment">//of `scoreNeededToWin`, which is 60</span></span><br><span class="line"><span class="keyword">if</span> (score === scoreNeededToWin) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the player as the winner.</span></span><br><span class="line">  winner = <span class="string">"player"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Change the game's state to `end`.</span></span><br><span class="line">  g.state = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The aliens win if one of them reaches the bottom of</span></span><br><span class="line"><span class="comment">//the stage.</span></span><br><span class="line">aliens.forEach(<span class="function"><span class="params">alien</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Check to see if the `alien`'s `y` position is greater</span></span><br><span class="line">  <span class="comment">//than the `stage`'s `height`</span></span><br><span class="line">  <span class="keyword">if</span> (alien.y &gt; g.stage.height) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set the aliens as the winner.</span></span><br><span class="line">    winner = <span class="string">"aliens"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Change the game's state to `end`.</span></span><br><span class="line">    g.state = end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结束函数暂停游戏，使动画冻结。然后它会显示游戏的信息，它要么是“地球被拯救”，要么是“地球毁灭!”取决于结果。另外，音乐音量也被设置为50%。然后在延迟3秒后，调用名为<code>reset</code>的函数。这是完成这一切的完整的结束函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Pause the game loop.</span></span><br><span class="line">  g.pause();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Create the game over message text.</span></span><br><span class="line">  gameOverMessage = g.text(<span class="string">""</span>, <span class="string">"20px emulogic"</span>, <span class="string">"#00FF00"</span>, <span class="number">90</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reduce the music volume by half.</span></span><br><span class="line">  <span class="comment">//1 is full volume, 0 is no volume, and 0.5 is half volume.</span></span><br><span class="line">  music.volume = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Display "Earth Saved!" if the player wins.</span></span><br><span class="line">  <span class="keyword">if</span> (winner === <span class="string">"player"</span>) &#123;</span><br><span class="line">    gameOverMessage.content = <span class="string">"Earth Saved!"</span>;</span><br><span class="line">    gameOverMessage.x = <span class="number">120</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Display "Earth Destroyed!" if the aliens win.</span></span><br><span class="line">  <span class="keyword">if</span> (winner === <span class="string">"aliens"</span>) &#123;</span><br><span class="line">    gameOverMessage.content = <span class="string">"Earth Destroyed!"</span>;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Wait for 3 seconds then run the `reset` function.</span></span><br><span class="line">  g.wait(<span class="number">3000</span>, () =&gt; reset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reset</code>函数将所有的游戏变量重置为它们的初始值。它还将音乐音量调回到1。它使用删除函数从异形和子弹数组中删除所有剩余的精灵，以便当游戏再次开始时可以重新填充这些数组。删除也用于删除gameOverMessage，加农炮精灵被重新集中在舞台的底部。最后，游戏状态被设置回播放，而游戏循环通过调用Hexi的恢复方法而停止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reset the game variables.</span></span><br><span class="line">  score = <span class="number">0</span>;</span><br><span class="line">  alienFrequency = <span class="number">100</span>;</span><br><span class="line">  alienTimer = <span class="number">0</span>;</span><br><span class="line">  winner = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set the music back to full volume.</span></span><br><span class="line">  music.volume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Remove any remaining alien and bullet sprites.</span></span><br><span class="line">  <span class="comment">//The universal `remove` method will loop through</span></span><br><span class="line">  <span class="comment">//all the sprites in an array of sprites, removed them</span></span><br><span class="line">  <span class="comment">//from their parent container, and splice them out of the array.</span></span><br><span class="line">  g.remove(aliens);</span><br><span class="line">  g.remove(bullets);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//You can also use the universal `remove` function to remove.</span></span><br><span class="line">  <span class="comment">//a single sprite.</span></span><br><span class="line">  g.remove(gameOverMessage);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Re-center the cannon.</span></span><br><span class="line">  g.stage.putBottom(cannon, <span class="number">0</span>, <span class="number">-40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Change the game state back to `play`.</span></span><br><span class="line">  g.state = play;</span><br><span class="line">  g.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是重新开始游戏所需的所有代码。你可以像你喜欢的那样玩外星无敌舰队，它会像这样不断地重置和重启自己。</p>
<h1 id="飞扬的仙女"><a href="#飞扬的仙女" class="headerlink" title="飞扬的仙女"></a>飞扬的仙女</h1><p>Flappy Fairy是对有史以来最臭名昭著的游戏之一的致敬:<a href="http://en.wikipedia.org/wiki/Flappy_Bird" target="_blank" rel="noopener">Flappy Bird</a>。点击<a href="https://gitcdn.xyz/repo/kittykatattack/hexi/master/tutorials/04_flappyFairy.html" target="_blank" rel="noopener">链接玩游戏</a>:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/21.png" alt="Flappy Fairy"></p>
<p>点击“Go”按钮，游戏将以全屏模式启动。点击屏幕上的任何地方，让仙女飞起来，帮助她通过15根柱子的缝隙到达终点。当仙女在迷宫中飞翔时，一串五颜六色的仙女尘埃尾随着她。如果她撞到一个绿色的街区，她就会在一阵尘土中爆炸。但如果她能在这15根柱子之间不断缩小的缝隙中穿行，她就能看到一个巨大的漂浮“终点”标志。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/22.png" alt="go"></p>
<p>如果你能做一个像Flappy Fairy一样的游戏，你几乎可以做任何其他类型的2D动作游戏。除了使用你已经学过的所有技巧外，Flappy Fairy还引入了一些令人兴奋的新技巧:</p>
<ul>
<li>以全屏模式启动游戏。</li>
<li>单击的按钮。</li>
<li>创建一个动画精灵。</li>
<li>使用tilingSprite来创建滚动背景。</li>
<li>使用粒子效果。</li>
</ul>
<p>您将在教程文件夹中找到完整注释的Flappy Fairy源代码。请务必查看它，以便您能够在正确的上下文中看到所有这些代码。它的总体结构与本教程中的其他游戏相同，并添加了这些新技术。让我们看看它们是如何实现的。</p>
<h2 id="制作按钮"><a href="#制作按钮" class="headerlink" title="制作按钮"></a>制作按钮</h2><p>当你按下“Go”按钮时，游戏就开始了。“Go”按钮是一种叫做“button”的特殊精灵。按钮精灵有3个图像帧状态:上、下、下。您可以创建一个按钮，有以下三种状态:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goButton = g.button([</span><br><span class="line">  <span class="string">"up.png"</span>,</span><br><span class="line">  <span class="string">"over.png"</span>,</span><br><span class="line">  <span class="string">"down.png"</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p><code>up.png</code> 是一个图像，它显示了当按钮不与指针交互时按钮应该是什么样子。<code>over.png</code>显示了指针在上面和向下时的按钮的样子。<code>down.png</code>是指针按下按钮时显示的图像。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/23.png" alt="button"></p>
<blockquote>
<p>(down.png图像被稍微向下偏移并向右偏移，因此它看起来像是被压下了。您可以将任何您喜欢的图像分配到这些状态，按钮将根据指针与这些状态的交互方式自动显示它们。<br>(注意:如果你的游戏是触控的，你可能只有两个按钮状态:向上和向下。在这种情况下，只需分配两个图像帧，Hexi将假设它们是指上下状态)</p>
</blockquote>
<p>按钮有可以定义的特殊方法:<code>press</code>, <code>release</code>, <code>over</code>, <code>out</code>, <code>tap</code>。您可以为这些方法指定任何代码。例如，当用户释放<code>playButton</code>时，如何更改游戏的状态:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goButton.release = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  g.state = setupGame;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按钮还有一个名为<code>enabled</code>的布尔<code>(true/false)</code>属性，如果想禁用按钮，可以将其设置为<code>false</code>。(设置为true以重新启用它。)您还可以使用按钮的<code>state</code>属性来确定按钮状态是否为<code>“up”</code>、<code>“over”</code>或<code>“down”</code>。(这些状态值是字符串。)</p>
<p>重要!只要将按钮的交互属性设置为true，就可以赋予任何精灵按钮的特性，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anySprite.interact = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>这将使sprite press, release, over, out和tap方法以及与普通按钮相同的状态属性。这意味着你可以让所有的精灵都可以点击，这对于各种各样的互动游戏来说是非常有用的。</p>
<p>你也可以让舞台对象互动，把整个游戏画面变成一个互动按钮:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.stage.interact = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>有关如何使用按钮的详细信息，请参见按钮。示例文件夹中的<code>buttons.html</code>文件。</p>
<h2 id="动画精灵"><a href="#动画精灵" class="headerlink" title="动画精灵"></a>动画精灵</h2><p>Flappy Fairy的一个奇妙特征是，当它飞起来的时候，精灵会拍打它的翅膀。这个动画是通过在连续循环中快速显示3个简单的图像而创建的。每个图像显示一个稍微不同的动画帧，如下图所示:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/24.png" alt="fairy"></p>
<p>这三张图片只是游戏纹理地图集中三个普通的帧，叫做0.png, 1.png 和 2.png。但是你怎么能把像这样的一系列帧变成精灵动画呢?</p>
<p>首先，创建一个定义动画帧的数组，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fairyFrames = [</span><br><span class="line">  <span class="string">"0.png"</span>,</span><br><span class="line">  <span class="string">"1.png"</span>,</span><br><span class="line">  <span class="string">"2.png"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>然后使用这些帧创建一个精灵，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fairy = g.sprite(fairyFrames);</span><br></pre></td></tr></table></figure>
<p>或者，如果你愿意的话，你可以把它合并成一个步骤:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fairy = g.sprite([</span><br><span class="line">  <span class="string">"0.png"</span>,</span><br><span class="line">  <span class="string">"1.png"</span>,</span><br><span class="line">  <span class="string">"2.png"</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>任何具有多个图像帧的精灵都会自动成为一个动画精灵。如果你想要动画帧开始播放，只需调用sprite的<code>playAnimation</code>方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fairy.playAnimation();</span><br></pre></td></tr></table></figure>
<p>帧将自动在一个连续循环中运行。如果不希望它们循环，则将<code>loop</code>设置为false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fairy.loop = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>使用stopAnimation方法停止动画:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fairy.stopAnimation();</span><br></pre></td></tr></table></figure>
<p>如果您想知道精灵的动画是否正在播放，请使用Boolean (true/false)的<code>playing</code>属性。</p>
<p>你希望动画播放的速度是快还是慢?你可以这样设置动画的帧/秒(<code>fps</code>):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fairy.fps = <span class="number">24</span>;</span><br></pre></td></tr></table></figure>
<p>精灵动画的帧速率与游戏的帧速率无关。这给你很大的灵活性来微调精灵动画。</p>
<p>如果您不想在动画中使用所有精灵的图像帧，只使用其中的一些帧，该怎么办?例如，假设您有一个带有30帧的精灵，但您只希望在动画的一部分中播放10到15帧。为playAnimation方法提供一个包含两个数字的数组:要播放的序列的第一帧和最后一帧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animatedSprite.playAnimation([<span class="number">10</span>, <span class="number">15</span>]);</span><br></pre></td></tr></table></figure>
<p>现在只有10到15之间的帧作为动画的一部分。为了使其更具可读性，您可以将序列定义为一个数组，该数组描述了这些动画帧的实际功能。例如，也许他们定义了一个角色的行走周期。你可以创建一个名为<code>walkCycle</code>的数组来定义这些帧:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> walkCycle = [<span class="number">10</span>, <span class="number">15</span>];</span><br></pre></td></tr></table></figure>
<p>然后使用<code>playAnimation</code>数组，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animatedSprite.playAnimation(walkCycle);</span><br></pre></td></tr></table></figure>
<p>这需要编写更多的代码，但是可读性更好!</p>
<p>有关Hexi的精灵动画系统的更多细节以及你可以用它做什么，请参阅示例文件夹中的keyframeAnimation.html,textureAtlasAnimation.html和animationStates.html文件。</p>
<p>让仙女飞</p>
<p>既然你已经知道如何让精灵动起来，那么当你点击游戏屏幕时，Flappy Fairy的飞行动画是如何触发的呢?</p>
<p>在play函数的每一帧中，从仙女的y位置中减去表示重力的0.05。这就是把仙女拉到屏幕底部的重力效应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fairy.vy += <span class="number">-0.05</span>;</span><br><span class="line">fairy.y -= fairy.vy;</span><br></pre></td></tr></table></figure>
<p>但当你轻击屏幕时，仙女就会飞起来。这要感谢Hexi的内置指针对象。它有一个tap方法，您可以定义它来执行您喜欢的任何操作。在Flappy Fairy中，tap方法增加了精灵的垂直速度vy，每次点击都增加了1.5像素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g.pointer.tap = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fairy.vy += <span class="number">1.5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Hexi的内置指针对象也有按下和释放的方法，你可以用同样的方法来定义。它还具有布尔(true/false) isUp、isDown和tap属性，如果需要，可以使用它来找到指针的状态。</p>
<p>但是你会注意到仙女只会在她开始飞起来的时候拍打她的翅膀，当她失去动力开始下降的时候停止拍打翅膀。要完成这项工作，您需要根据仙女垂直速度(vy)值的变化，知道仙女正在上升还是在下降。这个游戏采用了一种老掉牙的老把戏来帮助解决这个问题。play函数以一个名为oldVy的新值捕捉到当前帧中仙女的速度。但只有在仙女的位置发生变化后才会这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//... all of the code that moves the fairy comes first...</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Then, after the fairy's position has been changed, capture</span></span><br><span class="line">  <span class="comment">//her velocity for this current frame</span></span><br><span class="line">  fairy.oldVy = fairy.vy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，当下一个游戏帧在上下摆动时，oldVy仍然会存储前一帧中精灵的速度值。这意味着你可以用这个值计算出从前一帧到当前帧的速度变化量。如果她开始上升(如果vy比oldVy大)，播放仙女的动画:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fairy.vy &gt; fairy.oldVy) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!fairy.playing) &#123;</span><br><span class="line">    fairy.playAnimation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果她开始下降，停止动画，只显示精灵的第一帧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fairy.vy &lt; <span class="number">0</span> &amp;&amp; fairy.oldVy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fairy.playing) fairy.stopAnimation();</span><br><span class="line">  fairy.show(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是仙女怎么飞的!</p>
<p>做一个滚动的背景</p>
<p>Flappy Fairy的一个有趣的新特性是，它有一个无限滚动的背景云从右向左移动。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/25.png" alt="scrolling background"></p>
<p>背景的移动速度比绿色的柱子要慢，这给人一种云离得更远的错觉。(这是一种浅显的伪3D效果，叫做抛物线滚动。)</p>
<p>背景只是一个图像。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/26.png" alt="background"></p>
<p>这张照片的设计使得云平铺无缝:顶部和左边的云与右下角的云相匹配。这意味着您可以连接同一映像的多个实例，它们将显示为创建单个、连续的映像。(图片来自<a href="https://github.com/kittykatattack/hexi/blob/master/opengameart.org/content/cartoony-sky" target="_blank" rel="noopener">OpenGameArt</a>)</p>
<p>因为这对游戏非常有用，Hexi有一种精灵类型叫做<code>tilingSprite</code>，专为无限的滚动效果而设计。下面是如何创建<code>tilingSprite</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sky = g.tilingSprite(</span><br><span class="line">  <span class="string">"sky.png"</span>              <span class="comment">//The image to use</span></span><br><span class="line">  g.canvas.width,        <span class="comment">//The width</span></span><br><span class="line">  g.canvas.height,       <span class="comment">//The height</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>第一个参数是您想要使用的图像，最后两个参数是精灵的宽度和高度。</p>
<p>贴砖精灵与普通精灵具有相同的属性，增加了两个新属性:tileX和tileY。这两个属性允许您设置精灵左上角的图像偏移量。如果你想连续不断地制作一个平铺的精灵滚动条，只需在游戏循环的每一帧中增加少量的tileX值，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sky.tileX -= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这就是你做无限滚动背景所需要做的。</p>
<h2 id="粒子效果"><a href="#粒子效果" class="headerlink" title="粒子效果"></a>粒子效果</h2><p>你如何创造像火，烟，魔法和爆炸这样的效果?你制造了很多小精灵;有几十个，成百上千个。然后对这些精灵施加一些物理或重力约束，使它们的行为类似于你要模拟的元素。您还需要给他们一些规则，关于他们应该如何出现和消失，以及他们应该形成什么样的模式。这些小精灵被称为粒子。你可以用它们为游戏制作各种各样的特效。</p>
<p>Hexi有一种多功能的内置方法叫做<code>createParticles</code>，它可以制造游戏所需的大多数粒子效果。下面是使用它的格式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">createParticles(</span><br><span class="line">  pointer.x,                           <span class="comment">//The particle’s starting x position</span></span><br><span class="line">  pointer.y,                           <span class="comment">//The particle’s starting y position</span></span><br><span class="line">  () =&gt; sprite(<span class="string">"images/star.png"</span>),     <span class="comment">//Particle function</span></span><br><span class="line">  g.stage,                             <span class="comment">//The container to add the particles to</span></span><br><span class="line">  <span class="number">20</span>,                                  <span class="comment">//Number of particles</span></span><br><span class="line">  <span class="number">0.1</span>,                                 <span class="comment">//Gravity</span></span><br><span class="line">  <span class="literal">true</span>,                                <span class="comment">//Random spacing</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">6.28</span>,                             <span class="comment">//Min/max angle</span></span><br><span class="line">  <span class="number">12</span>, <span class="number">24</span>,                              <span class="comment">//Min/max size</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>,                                <span class="comment">//Min/max speed</span></span><br><span class="line">  <span class="number">0.005</span>, <span class="number">0.01</span>,                         <span class="comment">//Min/max scale speed</span></span><br><span class="line">  <span class="number">0.005</span>, <span class="number">0.01</span>,                         <span class="comment">//Min/max alpha speed</span></span><br><span class="line">  <span class="number">0.05</span>, <span class="number">0.1</span>                            <span class="comment">//Min/max rotation speed</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>您可以看到，大多数参数描述了最小值和最大值之间的范围，这些值应该用于更改精灵的速度、旋转、缩放或alpha。您还可以指定应该创建的粒子数，并添加可选的重力。通过定制第三个参数，您可以使用任何精灵生成粒子。只要提供一个函数，返回你想为每个粒子使用的精灵:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; (<span class="string">"images/star.png"</span>),</span><br></pre></td></tr></table></figure>
<p>如果你提供一个具有多个帧的精灵，<code>createParticles</code>方法会自动为每个粒子选择一个随机的帧。最小和最大角度值对于定义粒子从原点辐射出来时的圆形传播非常重要。对于完全圆形的爆炸效果，使用最小角度为0，最大角度为6.28。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">6.28</span>,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(这些值弧度;等于0和360。)0从3点钟方向开始，指向右边。3.14是9点的位置，6.28让你再次回到0点。如果你想把粒子范围限制在一个更窄的角度，只要提供描述这个范围的最小值和最大值。这里有一些值，你可以用来将角度限制在比萨斜面上，地壳指向左边。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.4</span>, <span class="number">3.6</span>,</span><br></pre></td></tr></table></figure>
<p>你可以使用像这样的受限角度范围来创建粒子流，就像那些用来创建喷泉或火箭引擎火焰的粒子流。(你马上就会知道怎么做了。)随机间隔值(第六个参数)决定了粒子在这个范围内的间隔是均匀的(假)还是随机的(真)。通过仔细地为粒子选择精灵并精细地调整每个参数，您可以使用这个通用的createparticle方法来模拟从液体到火焰的一切。在Flappy Fairy中，它被用来创造仙尘。</p>
<h3 id="仙女粉尘爆炸"><a href="#仙女粉尘爆炸" class="headerlink" title="仙女粉尘爆炸"></a>仙女粉尘爆炸</h3><p>当Flappy Fairy撞上一块木头时，它就消失在一阵尘土中。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/27.png" alt="explosions"></p>
<p>那效果如何呢?</p>
<p>在创建爆炸效果之前，我们必须定义一个数组，该数组列出了我们想要为每个粒子使用的图像。如前所述，如果精灵包含多个帧，那么createparticle方法将在精灵上随机显示一个帧。要完成这项工作，首先定义一组纹理图集框架，你想用它来应对仙女的尘埃爆炸:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dustFrames = [</span><br><span class="line">  <span class="string">"pink.png"</span>,</span><br><span class="line">  <span class="string">"yellow.png"</span>,</span><br><span class="line">  <span class="string">"green.png"</span>,</span><br><span class="line">  <span class="string">"violet.png"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>当仙女碰到一个绿色的方块时，爆炸就发生了。游戏循环在<code>hitTestRectangle</code>方法的帮助下实现了这一点。代码循环遍历这些块。对每个绿色块和精灵之间的冲突进行数组和测试。如果<code>hitTestRectangle</code>返回true，则循环退出，名为<code>fairyVsBlock</code>的冲突对象变为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fairyVsBlock = blocks.children.some(<span class="function"><span class="params">block</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> g.hitTestRectangle(fairy, block, <span class="literal">true</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>hitTestRectangle的第三个参数需要是true，这样就可以使用sprite的全局坐标(gx和gy)来完成碰撞检测。这是因为仙女是舞台的子元素，但是每个块都是块组的子元素。这意味着它们不共享相同的局部坐标空间。使用块精灵的全局坐标迫使hitTestRectangle使用它们相对于画布的位置。</p>
<p>如果fairyVsBlock是正确的，并且精灵现在是可见的，那么冲突代码就会运行。它使精灵隐形，产生粒子爆炸，并在延迟3秒后调用游戏的复位功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fairyVsBlock &amp;&amp; fairy.visible) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make the fairy invisible</span></span><br><span class="line">  fairy.visible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Create a fairy dust explosion</span></span><br><span class="line">  g.createParticles(</span><br><span class="line">    fairy.centerX, fairy.centerY, <span class="comment">//x and y position</span></span><br><span class="line">    () =&gt; g.sprite(dustFrames),   <span class="comment">//Particle sprite</span></span><br><span class="line">    g.stage,                      <span class="comment">//The container to add the particles to  </span></span><br><span class="line">    <span class="number">20</span>,                           <span class="comment">//Number of particles</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">//Gravity</span></span><br><span class="line">    <span class="literal">false</span>,                        <span class="comment">//Random spacing</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">6.28</span>,                      <span class="comment">//Min/max angle</span></span><br><span class="line">    <span class="number">16</span>, <span class="number">32</span>,                       <span class="comment">//Min/max size</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>                          <span class="comment">//Min/max speed</span></span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Stop the dust emitter that's trailing the fairy</span></span><br><span class="line">  dust.stop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Wait 3 seconds and then reset the game</span></span><br><span class="line">  g.wait(<span class="number">3000</span>, reset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用粒子发射器"><a href="#使用粒子发射器" class="headerlink" title="使用粒子发射器"></a>使用粒子发射器</h3><p>粒子发射器只是一个简单的计时器，以固定的间隔产生粒子。这意味着发送器不再只调用createParticles方法一次，而是周期性地调用它。Hexi有一个内置的粒子发射器方法让我们很容易做到这一点。下面是如何使用它的方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> particleStream = g.particleEmitter(</span><br><span class="line">  <span class="number">100</span>,                                      <span class="comment">//The interval</span></span><br><span class="line">  () =&gt; g.createParticles(                  <span class="comment">//The `particleEffect` function</span></span><br><span class="line">    <span class="comment">//Assign particle parameters...</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>粒子发射器法只是围绕着创造粒子法。它的第一个参数是一个以毫秒为单位的数字，它决定了粒子产生的频率。第二个参数是createparticle方法，您可以随意定制它。粒子发射器方法返回一个带有播放和停止方法的对象，您可以使用它来控制粒子流。你可以使用它们就像你用来控制精灵动画的游戏和停止方法一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">particleStream.play();</span><br><span class="line">particleStream.stop();</span><br></pre></td></tr></table></figure>
<p>发射器对象还有一个playing属性，根据发射器的当前状态，该属性可以为真，也可以为假。(参见示例文件夹中的particleEmitter .html文件，了解如何创建和使用粒子发射器的更多细节。</p>
<p>Flappy Fairy中使用了一个粒子发射器，当仙女拍打翅膀时，它就会发出一串五颜六色的粒子。粒子的角度被限制在2.4到3.6弧度之间，所以它们以一个锥形的楔形向仙女的左边发射。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/28.png" alt="emitter"></p>
<p>粒子流随机地发出粉色、黄色、绿色或紫色的粒子，每个粒子都是纹理图谱上的一个单独的框架。</p>
<p>以下是产生这种效果的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dustFrames = [</span><br><span class="line">  <span class="string">"pink.png"</span>,</span><br><span class="line">  <span class="string">"yellow.png"</span>,</span><br><span class="line">  <span class="string">"green.png"</span>,</span><br><span class="line">  <span class="string">"violet.png"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create the emitter</span></span><br><span class="line">dust = g.particleEmitter(</span><br><span class="line">  <span class="number">300</span>,                                   <span class="comment">//The interval</span></span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">      g.createParticles(                 <span class="comment">//The function</span></span><br><span class="line">      fairy.x + <span class="number">8</span>,                       <span class="comment">//x position</span></span><br><span class="line">      fairy.y + fairy.halfHeight + <span class="number">8</span>,    <span class="comment">//y position</span></span><br><span class="line">      () =&gt; g.sprite(dustFrames),        <span class="comment">//Particle sprite</span></span><br><span class="line">      g.stage,                           <span class="comment">//The container to add the particles to</span></span><br><span class="line">      <span class="number">3</span>,                                 <span class="comment">//Number of particles</span></span><br><span class="line">      <span class="number">0</span>,                                 <span class="comment">//Gravity</span></span><br><span class="line">      <span class="literal">true</span>,                              <span class="comment">//Random spacing</span></span><br><span class="line">      <span class="number">2.4</span>, <span class="number">3.6</span>,                          <span class="comment">//Min/max angle</span></span><br><span class="line">      <span class="number">12</span>, <span class="number">18</span>,                            <span class="comment">//Min/max size</span></span><br><span class="line">      <span class="number">1</span>, <span class="number">2</span>,                              <span class="comment">//Min/max speed</span></span><br><span class="line">      <span class="number">0.005</span>, <span class="number">0.01</span>,                       <span class="comment">//Min/max scale speed</span></span><br><span class="line">      <span class="number">0.005</span>, <span class="number">0.01</span>,                       <span class="comment">//Min/max alpha speed</span></span><br><span class="line">      <span class="number">0.05</span>, <span class="number">0.1</span>                          <span class="comment">//Min/max rotation speed</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>您现在可以使用play和stop方法控制尘埃发射器。</p>
<h2 id="创造和移动柱子"><a href="#创造和移动柱子" class="headerlink" title="创造和移动柱子"></a>创造和移动柱子</h2><p>你现在知道了Flappy Fairy如何实现了河西的一些特殊功能，以获得一些有趣和有用的效果。但是，如果你是游戏编程的新手，你可能也想知道，那个飘飘欲仙的世界是如何被创造出来的。让我们快速地看一下创建并移动精灵必须导航的绿色柱子的代码，以达到完成标记。</p>
<p>游戏中有15根绿色柱子。每隔5根柱子，顶部和底部之间的缝隙就会缩小。前五根柱子有四个街区的空隙，后五根柱子有三个街区的空隙，后五根柱子有两个街区的空隙。这使得这个游戏变得越来越困难，因为Flappy仙女飞得更远。每一根柱子上的空隙的确切位置都是随机的，每次游戏都是不同的。每根柱子的间距是384像素，这是它们相邻时的样子。</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/29.png" alt="blocks"></p>
<p>你可以看到这个缺口是如何从左到右逐渐缩小的。</p>
<p>构成柱子的所有砖块都属于一个叫做blocks的group。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blocks = g.group();</span><br></pre></td></tr></table></figure>
<p>嵌套的for循环创建每个块并将其添加到blocks容器中。外环运行15次;一次创建每个支柱。内循环运行8次;在柱子上每隔一段。这些块只有在它们没有占据被随机选择的距离时才会被添加。每五次外环运行一次，间隙的大小就会缩小一倍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//What should the initial size of the gap be between the pillars?</span></span><br><span class="line"><span class="keyword">let</span> gapSize = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//How many pillars?</span></span><br><span class="line"><span class="keyword">let</span> numberOfPillars = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Loop 15 times to make 15 pillars</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numberOfPillars; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Randomly place the gap somewhere inside the pillar</span></span><br><span class="line">  <span class="keyword">let</span> startGapNumber = g.randomInt(<span class="number">0</span>, <span class="number">8</span> - gapSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Reduce the `gapSize` by one after every fifth pillar. This is</span></span><br><span class="line">  <span class="comment">//what makes gaps gradually become narrower</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> === <span class="number">0</span>) gapSize -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Create a block if it's not within the range of numbers</span></span><br><span class="line">  <span class="comment">//occupied by the gap</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; startGapNumber || j &gt; startGapNumber + gapSize - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> block = g.sprite(<span class="string">"greenBlock.png"</span>);</span><br><span class="line">      blocks.addChild(block);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Space each pillar 384 pixels apart. The first pillar will be</span></span><br><span class="line">      <span class="comment">//placed at an x position of 512</span></span><br><span class="line">      block.x = (i * <span class="number">384</span>) + <span class="number">512</span>;</span><br><span class="line">      block.y = j * <span class="number">64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//After the pillars have been created, add the finish image</span></span><br><span class="line">  <span class="comment">//right at the end</span></span><br><span class="line">  <span class="keyword">if</span> (i === numberOfPillars - <span class="number">1</span>) &#123;</span><br><span class="line">    finish = g.sprite(<span class="string">"finish.png"</span>);</span><br><span class="line">    blocks.addChild(finish);</span><br><span class="line">    finish.x = (i * <span class="number">384</span>) + <span class="number">896</span>;</span><br><span class="line">    finish.y = <span class="number">192</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的最后一部分向世界添加了一个大型的finish精灵，Flappy Fairy将会看到它是否能够一直运行到最后。</p>
<p>游戏循环在每一帧中向右移动2个像素块组，但只在结束精灵不在屏幕上时:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (finish.gx &gt; <span class="number">256</span>) &#123;</span><br><span class="line">  blocks.x -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当完成的精灵滚动到画布的中心时，块容器将停止移动。注意，代码使用finish sprite的全局x位置(gx)来测试它是否在画布区域内。因为全局坐标是相对于画布的，而不是父容器的，所以对于这些需要在画布上找到嵌套精灵位置的情况，它们是非常有用的。</p>
<p>请确保在示例文件夹中检查完整的Flappy Fairy源代码，以便您能够在正确的上下文中看到所有这些代码。</p>
<h1 id="与HTML和CSS的集成"><a href="#与HTML和CSS的集成" class="headerlink" title="与HTML和CSS的集成"></a>与HTML和CSS的集成</h1><p>Hexi可以无缝地使用HTML和CSS。您可以自由地将Hexi精灵和代码与HTML元素混合，并使用Hexi的架构来构建一个基于HTML的应用程序。并且，您可以使用HTML为您的Hexi游戏构建一个丰富的用户界面。</p>
<p>它是如何工作的呢?河西采取了完全不干涉的方法。只需编写普通的旧HTML和CSS，然后在Hexi代码中引用HTML。这是所有!Hexi并没有重新发明轮子，所以你可以编写任何你喜欢的低水平的HTML/CSS代码，并将它混合到你的Hexi应用程序中。</p>
<p>您可以在这个代码存储库中的<a href="https://github.com/kittykatattack/hexi/tree/master/examples/38_html" target="_blank" rel="noopener">Hexi示例中找到一个html</a>文件夹中的工作示例。这是一个简单的数字猜谜游戏:</p>
<p><img src="https://github.com/kittykatattack/hexi/raw/master/tutorials/screenshots/32.png" alt></p>
<p>包含按钮和文本输入字段的灰色框是HTML元素。这些HTML元素(包括按钮)完全是使用CSS样式的。动态文本和图像是六次精灵。</p>
<p>还有一个无形的<code>&lt;div&gt;</code>元素，它的大小和Hexi的画布一样，位置也一样。大的<code>&lt;div&gt;</code>元素浮在画布上，包含灰色框、按钮和输入字段。</p>
<p>让我们快速地看看这是如何工作的。主要的。html文件如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Html integration<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- UI --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ui"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Guess!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"X..."</span> <span class="attr">maxlength</span>=<span class="string">"10"</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Hexi --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../src/modules/pixi.js/bin/pixi.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../bin/modules.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../bin/core.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Main application file --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重要的部分是UI部分，就在<code>&lt;body&gt;</code>标签下面。带有id ui的div用于封装框、按钮和输入。</p>
<p>魔术发生在<code>style.css</code>文件。以下是最重要的部分:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span></span><br><span class="line">  &#123; <span class="attribute">position </span>: relative</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ui</span></span><br><span class="line">  &#123; <span class="attribute">position </span>: absolute</span><br><span class="line">  ; <span class="attribute">left </span>: <span class="number">0</span></span><br><span class="line">  ; <span class="attribute">top </span>: <span class="number">0</span></span><br><span class="line">  ; <span class="attribute">width </span>: <span class="number">512px</span></span><br><span class="line">  ; <span class="attribute">height </span>: <span class="number">512px</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Important: set the z-index to 1 so that it appears above Hexi's canvas*/</span></span><br><span class="line">  ; <span class="attribute">z-index</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Hexi的画布被设置为相对，ui div被设置为绝对。ui也被设置为与Hexi的画布一样的宽度和高度512px。非常重要的是，ui的z-index为1，以迫使它在画布之上显示。其他HTML元素(框、按钮和输入字段)都是完全相对于ui div定位的——请检查完整的CSS代码以获得详细信息。</p>
<p>要访问你的Hexi代码中的按钮和输入字段，只需在河西的设置函数中创建对它们的引用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Html elements</span></span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>);</span><br><span class="line">  button.addEventListener(<span class="string">"click"</span>, buttonClickHandler, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">"#input"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...The rest of the setup code creates Hexi sprites...</span></span><br></pre></td></tr></table></figure>
<p>然后创建一个普通的函数来处理按钮点击，像这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buttonClickHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Capture the player's input from the HTML text input field</span></span><br><span class="line">  <span class="keyword">if</span> (input.value) playersGuess = <span class="built_in">parseInt</span>(input.value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...the rest of the code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input.value允许您访问用户在输入字段中输入的任何内容。这只是普通的Web API代码——没什么特别的!您可以使用该值来更改任何Hexi精灵属性。请查看源代码以获得详细信息，但这并不令人感到意外。</p>
<p>但是示例代码有一个诀窍，那就是它的袖子。整个Hexi应用程序在浏览器中进行扩展和对齐。这意味着，Hexi的画布和UI div的扩展和保持一致。如果用户改变浏览器窗口的大小，它们甚至会重新缩放和重新对齐。这是如何工作的呢?下面是实现此目的的JavaScript代码(在main.js文件中，就在Hexi的标准初始化代码之后):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scale Hexi's canvas</span></span><br><span class="line">g.scaleToWindow();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Scale the html UI &lt;div&gt; container</span></span><br><span class="line">scaleToWindow(<span class="built_in">document</span>.querySelector(<span class="string">"#ui"</span>));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  scaleToWindow(<span class="built_in">document</span>.querySelector(<span class="string">"#ui"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Hexi的canvas是由Hexi引擎在内部缩放的，但是UI层是使用全局scaleToWindow函数缩放的。(你可以在这里找到scaleToWindow函数。)</p>
<p>HTML和Hexi之间的松散集成意味着您可以随意定制它。如果你想的话，你可以做一些疯狂的低级HTML/CSS编程，把逻辑和你的Hexi精灵混合在一起，设计任何你需要的自定义布局。它只是HTML !而且，是的，如果你想的话，你可以用Angular, React或<a href="http://elm-lang.org/" target="_blank" rel="noopener">Elm</a>来编写你的HTML。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>段纪刚</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2018/07/04/Hexi/" target="_blank" title="Hexi">https://jigangduan.github.io/2018/07/04/Hexi/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexi/">hexi</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pixijs/">pixijs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/游戏/">游戏</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/12/cas/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          CAS企业单点登录
        
      </div>
    </a>
  
  
    <a href="/2018/06/06/WebApp或HybridApp和ReactNative/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">WebApp(或HybridApp)和React-Native比较</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#特性"><span class="nav-number">1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hexi的模块"><span class="nav-number">2.</span> <span class="nav-text">Hexi的模块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hexi-快速启动"><span class="nav-number">3.</span> <span class="nav-text">Hexi 快速启动</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML容器"><span class="nav-number">4.</span> <span class="nav-text">HTML容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hexi-架构"><span class="nav-number">5.</span> <span class="nav-text">Hexi 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#建立和启动Hexi"><span class="nav-number">5.1.</span> <span class="nav-text">建立和启动Hexi</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load函数，在加载时运行"><span class="nav-number">5.2.</span> <span class="nav-text">load函数，在加载时运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setup函数，初始化并创建游戏对象"><span class="nav-number">5.3.</span> <span class="nav-text">setup函数，初始化并创建游戏对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#play函数-循环应用程序逻辑"><span class="nav-number">5.4.</span> <span class="nav-text">play函数:循环应用程序逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#把它进一步"><span class="nav-number">6.</span> <span class="nav-text">把它进一步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#教程"><span class="nav-number">7.</span> <span class="nav-text">教程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设置HTML容器页面"><span class="nav-number">8.</span> <span class="nav-text">设置HTML容器页面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化Hexi"><span class="nav-number">9.</span> <span class="nav-text">初始化Hexi</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定义你的全局变量"><span class="nav-number">10.</span> <span class="nav-text">定义你的全局变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用setup函数初始化游戏"><span class="nav-number">11.</span> <span class="nav-text">用setup函数初始化游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建chimes声音对象"><span class="nav-number">11.1.</span> <span class="nav-text">创建chimes声音对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建游戏场景"><span class="nav-number">11.2.</span> <span class="nav-text">创建游戏场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#制作精灵"><span class="nav-number">11.3.</span> <span class="nav-text">制作精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定位精灵"><span class="nav-number">11.4.</span> <span class="nav-text">定位精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配动态属性"><span class="nav-number">11.5.</span> <span class="nav-text">分配动态属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建敌人精灵"><span class="nav-number">11.6.</span> <span class="nav-text">创建敌人精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#健康条"><span class="nav-number">11.7.</span> <span class="nav-text">健康条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#游戏结束的场景"><span class="nav-number">11.8.</span> <span class="nav-text">游戏结束的场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#键盘交互"><span class="nav-number">12.</span> <span class="nav-text">键盘交互</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设置游戏状态"><span class="nav-number">13.</span> <span class="nav-text">设置游戏状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#游戏逻辑与play函数循环"><span class="nav-number">14.</span> <span class="nav-text">游戏逻辑与play函数循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#移动玩家精灵"><span class="nav-number">14.1.</span> <span class="nav-text">移动玩家精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包含屏幕边界内的精灵"><span class="nav-number">14.2.</span> <span class="nav-text">包含屏幕边界内的精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与敌人碰撞"><span class="nav-number">14.3.</span> <span class="nav-text">与敌人碰撞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#这是如何工作的呢"><span class="nav-number">14.3.1.</span> <span class="nav-text">这是如何工作的呢?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#碰撞的宝藏"><span class="nav-number">14.4.</span> <span class="nav-text">碰撞的宝藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束游戏"><span class="nav-number">14.5.</span> <span class="nav-text">结束游戏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用图像"><span class="nav-number">15.</span> <span class="nav-text">使用图像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#个人形象"><span class="nav-number">15.1.</span> <span class="nav-text">个人形象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载图片文件"><span class="nav-number">15.2.</span> <span class="nav-text">加载图片文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用图片制作精灵"><span class="nav-number">15.3.</span> <span class="nav-text">用图片制作精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微调控制区域"><span class="nav-number">15.4.</span> <span class="nav-text">微调控制区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用一个纹理地图集"><span class="nav-number">15.5.</span> <span class="nav-text">使用一个纹理地图集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#准备的图片"><span class="nav-number">15.5.1.</span> <span class="nav-text">准备的图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载纹理地图集"><span class="nav-number">15.5.2.</span> <span class="nav-text">加载纹理地图集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#外星人武装"><span class="nav-number">16.</span> <span class="nav-text">外星人武装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加载并使用自定义字体"><span class="nav-number">16.1.</span> <span class="nav-text">加载并使用自定义字体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载进度条"><span class="nav-number">16.2.</span> <span class="nav-text">加载进度条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发射子弹"><span class="nav-number">16.3.</span> <span class="nav-text">发射子弹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精灵状态"><span class="nav-number">16.4.</span> <span class="nav-text">精灵状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成随机的外星人"><span class="nav-number">16.5.</span> <span class="nav-text">生成随机的外星人</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#外星人时机"><span class="nav-number">16.5.1.</span> <span class="nav-text">外星人时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外星人的随机起始位置"><span class="nav-number">16.5.2.</span> <span class="nav-text">外星人的随机起始位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动外星人"><span class="nav-number">16.5.3.</span> <span class="nav-text">移动外星人</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让外星人爆炸"><span class="nav-number">16.5.4.</span> <span class="nav-text">让外星人爆炸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示分数"><span class="nav-number">16.5.5.</span> <span class="nav-text">显示分数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结束并重新设置游戏"><span class="nav-number">16.5.6.</span> <span class="nav-text">结束并重新设置游戏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#飞扬的仙女"><span class="nav-number">17.</span> <span class="nav-text">飞扬的仙女</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#制作按钮"><span class="nav-number">17.1.</span> <span class="nav-text">制作按钮</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动画精灵"><span class="nav-number">17.2.</span> <span class="nav-text">动画精灵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#粒子效果"><span class="nav-number">17.3.</span> <span class="nav-text">粒子效果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#仙女粉尘爆炸"><span class="nav-number">17.3.1.</span> <span class="nav-text">仙女粉尘爆炸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用粒子发射器"><span class="nav-number">17.3.2.</span> <span class="nav-text">使用粒子发射器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创造和移动柱子"><span class="nav-number">17.4.</span> <span class="nav-text">创造和移动柱子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#与HTML和CSS的集成"><span class="nav-number">18.</span> <span class="nav-text">与HTML和CSS的集成</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2020 朝着牛逼的道路一路狂奔 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            朝着牛逼的道路一路狂奔
          </div>
          <div class="panel-body">
            Copyright © 2020 段纪刚 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>