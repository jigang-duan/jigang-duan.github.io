{"meta":{"title":"朝着牛逼的道路一路狂奔","subtitle":null,"description":null,"author":"段纪刚","url":"https://jigangduan.github.io","root":"/"},"pages":[],"posts":[{"title":"Numpy-100","slug":"numpy-100","date":"2020-10-23T14:12:30.000Z","updated":"2020-10-23T23:24:47.516Z","comments":true,"path":"2020/10/23/numpy-100/","link":"","permalink":"https://jigangduan.github.io/2020/10/23/numpy-100/","excerpt":"","text":"参考： 原文件地址 NumPy 中文 numpy Python数据分析 Numpy的详细教程 1. 导入numpy库并简写为 np1import numpy as np 2. 打印numpy的版本和配置说明12print(np.__version__)print(np.show_config()) 1.19.2 blas_mkl_info: NOT AVAILABLE blis_info: NOT AVAILABLE openblas_info: libraries = [&apos;openblas&apos;, &apos;openblas&apos;] library_dirs = [&apos;/usr/local/lib&apos;] language = c define_macros = [(&apos;HAVE_CBLAS&apos;, None)] blas_opt_info: libraries = [&apos;openblas&apos;, &apos;openblas&apos;] library_dirs = [&apos;/usr/local/lib&apos;] language = c define_macros = [(&apos;HAVE_CBLAS&apos;, None)] lapack_mkl_info: NOT AVAILABLE openblas_lapack_info: libraries = [&apos;openblas&apos;, &apos;openblas&apos;] library_dirs = [&apos;/usr/local/lib&apos;] language = c define_macros = [(&apos;HAVE_CBLAS&apos;, None)] lapack_opt_info: libraries = [&apos;openblas&apos;, &apos;openblas&apos;] library_dirs = [&apos;/usr/local/lib&apos;] language = c define_macros = [(&apos;HAVE_CBLAS&apos;, None)] None 3. 创建一个长度为10的空向量12Z = np.zeros(10)print(Z) [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] 4. 如何找到任何一个数组的内存大小？1print(\"%d bytes\" % (Z.size * Z.itemsize)) 80 bytes 5. 如何从命令行得到numpy中add函数的说明文档?1np.info(np.add) add(x1, x2, /, out=None, *, where=True, casting=&apos;same_kind&apos;, order=&apos;K&apos;, dtype=None, subok=True[, signature, extobj]) Add arguments element-wise. Parameters ---------- x1, x2 : array_like The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. where : array_like, optional This condition is broadcast over the input. At locations where the condition is True, the `out` array will be set to the ufunc result. Elsewhere, the `out` array will retain its original value. Note that if an uninitialized `out` array is created via the default ``out=None``, locations within it where the condition is False will remain uninitialized. **kwargs For other keyword-only arguments, see the :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`. Returns ------- add : ndarray or scalar The sum of `x1` and `x2`, element-wise. This is a scalar if both `x1` and `x2` are scalars. Notes ----- Equivalent to `x1` + `x2` in terms of array broadcasting. Examples -------- &gt;&gt;&gt; np.add(1.0, 4.0) 5.0 &gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3)) &gt;&gt;&gt; x2 = np.arange(3.0) &gt;&gt;&gt; np.add(x1, x2) array([[ 0., 2., 4.], [ 3., 5., 7.], [ 6., 8., 10.]]) 6. 创建一个长度为10并且除了第五个值为1的空向量123Z = np.zeros(10)Z[4] = 1print(Z) [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] 7. 创建一个值域范围从10到49的向量12Z = np.arange(10, 50)print(Z) [10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49] 8. 反转一个向量(第一个元素变为最后一个)123Z = np.arange(10)Z = Z[::-1]print(Z) [9 8 7 6 5 4 3 2 1 0] 9. 创建一个 3x3 并且值从0到8的矩阵12Z = np.arange(9).reshape(3, 3)print(Z) [[0 1 2] [3 4 5] [6 7 8]] 10. 找到数组[1,2,0,0,4,0]中非0元素的位置索引123nz = np.nonzero([1,2,0,0,4,0])print(nz)print(nz[0]) (array([0, 1, 4]),) [0 1 4] 11. 创建一个 3x3 的单位矩阵12Z = np.eye(3)print(Z) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] 12. 创建一个 3x3x3的随机数组12Z = np.random.random((3, 3, 3))print(Z) [[[0.88486955 0.5490597 0.59669197] [0.35137688 0.48379957 0.07091021] [0.62127269 0.51806167 0.03852795]] [[0.15854486 0.05115505 0.20431851] [0.11087782 0.21286826 0.80180936] [0.73353315 0.45160643 0.76325029]] [[0.3903262 0.44422448 0.95099903] [0.28599768 0.48745533 0.05721719] [0.47329799 0.00279801 0.07081437]]] 13. 创建一个 10x10 的随机数组并找到它的最大值和最小值123Z = np.random.random((10, 10))Zmax, Zmin = Z.max(), Z.min()print(Zmax, Zmin) 0.9916690090908562 0.0065094427825592716 14. 创建一个长度为30的随机向量并找到它的平均值12Z = np.random.random(30)print(Z.mean()) 0.5447235064512149 15. 创建一个二维数组，其中边界值为1，其余值为0123Z = np.ones((10, 10))Z[1:-1, 1:-1] = 0print(Z) [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] 16. 对于一个存在在数组，如何添加一个用0填充的边界?123Z = np.ones((5,5))Z = np.pad(Z, pad_width=1, mode='constant', constant_values=0)print(Z) [[0. 0. 0. 0. 0. 0. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 0. 0. 0. 0. 0. 0.]] 17. 以下表达式运行的结果分别是什么?10 * np.nan nan 1np.nan == np.nan False 1np.inf &gt; np.nan False 1np.nan - np.nan nan 10.3 == 3 * 0.1 False 18. 创建一个 5x5的矩阵，并设置值1,2,3,4落在其对角线下方位置12Z = np.diag(1+np.arange(4),k=-1)print(Z) [[0 0 0 0 0] [1 0 0 0 0] [0 2 0 0 0] [0 0 3 0 0] [0 0 0 4 0]] 19. 创建一个8x8 的矩阵，并且设置成棋盘样式1234Z = np.zeros((8,8),dtype=int)Z[1::2,::2] = 1Z[::2,1::2] = 1print(Z) [[0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0]] 20. 考虑一个 (6,7,8) 形状的数组，其第100个元素的索引(x,y,z)是什么?1print(np.unravel_index(100,(6,7,8))) (1, 5, 4) 21. 用tile函数去创建一个 8x8的棋盘样式矩阵(★☆☆)12Z = np.tile( np.array([[0,1],[1,0]]), (4,4))print(Z) [[0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0]] 22. 对一个5x5的随机矩阵做归一化123456Z = np.random.random((5,5))print(Z)Zmax, Zmin = Z.max(), Z.min()Z = (Z - Zmin)/(Zmax - Zmin)print('归一化:')print(Z) [[0.38425685 0.53708226 0.6652044 0.53846365 0.52572921] [0.35578247 0.56376841 0.51732071 0.64696521 0.48704011] [0.71386634 0.11482216 0.35562303 0.49511748 0.94909796] [0.61600517 0.55368581 0.23454672 0.05183324 0.06497491] [0.9731188 0.89971985 0.67555374 0.70371238 0.97471339]] 归一化: [[0.36020237 0.52579853 0.6646271 0.52729535 0.51349677] [0.32934854 0.55471469 0.50438561 0.64486377 0.47157463] [0.71735545 0.06825255 0.32917577 0.48032698 0.97224404] [0.61131658 0.54378954 0.19798181 0. 0.01423985] [0.99827216 0.91873968 0.67584128 0.70635297 1. ]] 23. 创建一个将颜色描述为(RGBA)四个无符号字节的自定义dtype？12345color = np.dtype([(\"r\", np.ubyte), (\"g\", np.ubyte), (\"b\", np.ubyte), (\"a\", np.ubyte)])color dtype([(&apos;r&apos;, &apos;u1&apos;), (&apos;g&apos;, &apos;u1&apos;), (&apos;b&apos;, &apos;u1&apos;), (&apos;a&apos;, &apos;u1&apos;)]) 24. 一个5x3的矩阵与一个3x2的矩阵相乘，实矩阵乘积是什么？1234Z1, Z2 = np.ones((5, 3)), np.ones((3, 2))print(np.dot(Z1, Z2))print('----或-----')print(Z1@Z2) [[3. 3.] [3. 3.] [3. 3.] [3. 3.] [3. 3.]] ----或----- [[3. 3.] [3. 3.] [3. 3.] [3. 3.] [3. 3.]] 25. 给定一个一维数组，对其在3到8之间的所有元素取反123Z = np.arange(11)Z[(3 &lt; Z) &amp; (Z &lt;= 8)] *= -1print(Z) [ 0 1 2 3 -4 -5 -6 -7 -8 9 10] 26. 下面脚本运行后的结果是什么?1print(sum(range(5),-1)) 9 1print(np.sum(range(5),-1)) 10 27. 考虑一个整数向量Z,下列表达合法的是哪个?12Z = np.arange(5)Z ** Z [0 1 2 3 4] array([ 1, 1, 4, 27, 256]) 12Z = np.arange(5)2 &lt;&lt; Z &gt;&gt; 2 array([0, 1, 2, 4, 8]) 12Z = np.arange(5)Z &lt;- Z array([False, False, False, False, False]) 12Z = np.arange(5)1j*Z array([0.+0.j, 0.+1.j, 0.+2.j, 0.+3.j, 0.+4.j]) 12Z = np.arange(5)Z/1/1 array([0., 1., 2., 3., 4.]) 12Z = np.arange(5)Z&lt;Z&gt;Z --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-82-287e9cf34c9f&gt; in &lt;module&gt; 1 Z = np.arange(5) ----&gt; 2 Z&lt;Z&gt;Z ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() 28. 下列表达式的结果分别是什么?1np.array(0) / np.array(0) /Users/admin/.virtualenvs/numpy/lib/python3.7/site-packages/ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in true_divide &quot;&quot;&quot;Entry point for launching an IPython kernel. nan 1np.array(0) // np.array(0) /Users/admin/.virtualenvs/numpy/lib/python3.7/site-packages/ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in floor_divide &quot;&quot;&quot;Entry point for launching an IPython kernel. 0 1np.array([np.nan]).astype(int).astype(float) array([-9.22337204e+18]) 29. 如何从零位对浮点数组做舍入 ?12Z = np.random.uniform(-10,+10,10)np.copysign(np.ceil(np.abs(Z)), Z) array([ 6., -10., -9., 8., 5., -10., 4., 5., -2., -1.]) 30. 如何找到两个数组中的共同元素?123Z1 = np.random.randint(0,10,10)Z2 = np.random.randint(0,10,10)print(np.intersect1d(Z1,Z2)) [1 6 7 9] 31. 如何忽略所有的 numpy 警告(尽管不建议这么做)?123456# 自杀模式defaults = np.seterr(all=\"ignore\") Z = np.ones(1) / 0 # 恢复理智 _ = np.seterr(**defaults) 12with np.errstate(divide='ignore'): Z = np.ones(1) / 0 32. 下面的表达式是正确的吗?1np.sqrt(-1) == np.emath.sqrt(-1) False 33. 如何得到昨天，今天，明天的日期?123456yesterday = np.datetime64('today', 'D') - np.timedelta64(1, 'D')today = np.datetime64('today', 'D')tomorrow = np.datetime64('today', 'D') + np.timedelta64(1, 'D')print (\"昨天 \" + str(yesterday))print (\"今天 \" + str(today))print (\"明天 \"+ str(tomorrow)) 昨天 2020-10-22 今天 2020-10-23 明天 2020-10-24 34. 如何得到所有与2016年7月对应的日期？1np.arange('2016-07', '2016-08', dtype='datetime64[D]') array([&apos;2016-07-01&apos;, &apos;2016-07-02&apos;, &apos;2016-07-03&apos;, &apos;2016-07-04&apos;, &apos;2016-07-05&apos;, &apos;2016-07-06&apos;, &apos;2016-07-07&apos;, &apos;2016-07-08&apos;, &apos;2016-07-09&apos;, &apos;2016-07-10&apos;, &apos;2016-07-11&apos;, &apos;2016-07-12&apos;, &apos;2016-07-13&apos;, &apos;2016-07-14&apos;, &apos;2016-07-15&apos;, &apos;2016-07-16&apos;, &apos;2016-07-17&apos;, &apos;2016-07-18&apos;, &apos;2016-07-19&apos;, &apos;2016-07-20&apos;, &apos;2016-07-21&apos;, &apos;2016-07-22&apos;, &apos;2016-07-23&apos;, &apos;2016-07-24&apos;, &apos;2016-07-25&apos;, &apos;2016-07-26&apos;, &apos;2016-07-27&apos;, &apos;2016-07-28&apos;, &apos;2016-07-29&apos;, &apos;2016-07-30&apos;, &apos;2016-07-31&apos;], dtype=&apos;datetime64[D]&apos;) 35. 如何直接在位计算(A+B)*(-A/2)(不建立副本)?1234A = np.ones(3)*1B = np.ones(3)*2C = np.ones(3)*3np.add(A,B,out=B) array([3., 3., 3.]) 1np.divide(A,2,out=A) array([0.5, 0.5, 0.5]) 1np.negative(A,out=A) array([-0.5, -0.5, -0.5]) 1np.multiply(A,B,out=A) array([-1.5, -1.5, -1.5]) 36. 用五种不同的方法去提取一个随机数组的整数部分12Z = np.random.uniform(0,10,10)print(Z) [9.65002236 2.02077988 7.90182176 0.95615672 2.4638734 0.74263585 5.99876609 7.14737062 6.2959432 3.42980839] 1print (Z - Z%1) [9. 2. 7. 0. 2. 0. 5. 7. 6. 3.] 1print (np.floor(Z)) [9. 2. 7. 0. 2. 0. 5. 7. 6. 3.] 1print (np.ceil(Z)-1) [9. 2. 7. 0. 2. 0. 5. 7. 6. 3.] 1print (Z.astype(int)) [9 2 7 0 2 0 5 7 6 3] 1print (np.trunc(Z)) [9. 2. 7. 0. 2. 0. 5. 7. 6. 3.] 37. 创建一个5x5的矩阵，其中每行的数值范围从0到4123Z = np.zeros((5,5))Z += np.arange(5)print (Z) [[0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.]] 38. 通过考虑一个可生成10个整数的函数，来构建一个数组12345def generate(): for x in range(10): yield xZ = np.fromiter(generate(),dtype=float,count=-1)print (Z) [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] 39. 创建一个长度为10的随机向量，其值域范围从0到1，但是不包括0和112Z = np.linspace(0,1,11,endpoint=False)[1:]print (Z) [0.09090909 0.18181818 0.27272727 0.36363636 0.45454545 0.54545455 0.63636364 0.72727273 0.81818182 0.90909091] 40. 创建一个长度为10的随机向量，并将其排序123Z = np.random.random(10)Z.sort()print (Z) [0.0824115 0.08352975 0.3346753 0.40580722 0.44177301 0.50663776 0.59050701 0.75991226 0.87806887 0.9703208 ] 41.对于一个小数组，如何用比 np.sum更快的方式对其求和？12Z = np.arange(10)np.add.reduce(Z) 45 42. 对于两个随机数组A和B，检查它们是否相等123456789A = np.random.randint(0,2,5)B = np.random.randint(0,2,5)# 假设数组具有相同的形状和值比较的容忍度equal = np.allclose(A,B)print(equal)# 检查形状和元素值，没有公差(值必须完全相等)equal = np.array_equal(A,B)print(equal) False False 43. 创建一个只读数组(read-only)123Z = np.zeros(10) Z.flags.writeable = False Z[0] = 1 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-116-29348be95821&gt; in &lt;module&gt; 1 Z = np.zeros(10) 2 Z.flags.writeable = False ----&gt; 3 Z[0] = 1 ValueError: assignment destination is read-only 44. 将笛卡尔坐标下的一个10x2的矩阵转换为极坐标形式1234567Z = np.random.random((10,2))X,Y = Z[:,0], Z[:,1]R = np.sqrt(X**2+Y**2)T = np.arctan2(Y,X)print(Z)print (R)print (T) [[0.99192868 0.50024495] [0.02988894 0.01550554] [0.27221793 0.89725926] [0.60590261 0.12484057] [0.98140292 0.25029343] [0.18798725 0.41865512] [0.36612678 0.3256918 ] [0.1141495 0.31578922] [0.547363 0.59282924] [0.29013267 0.12039521]] [1.11093093 0.03367151 0.93764427 0.61863005 1.0128171 0.45892409 0.49002446 0.33578704 0.8068784 0.31412095] [0.467094 0.47855207 1.27623394 0.20319708 0.24971312 1.14875224 0.7270172 1.22393672 0.82525299 0.39334121] 45. 创建一个长度为10的向量，并将向量中最大值替换为0123Z = np.random.random(10)Z[Z.argmax()] = 0print (Z) [0.55832328 0.4353952 0.13261811 0.60633258 1. 0.46403717 0.37241254 0.38561917 0.82815613 0.88807826] 46. 创建一个结构化数组，并实现 x 和 y 坐标覆盖 [0,1]x[0,1] 区域12345Z = np.zeros((5,5), [('x',float),('y',float)])print(Z)print(Z.dtype)Z['x'], Z['y'] = np.meshgrid(np.linspace(0,1,5), np.linspace(0,1,5))Z [[(0., 0.) (0., 0.) (0., 0.) (0., 0.) (0., 0.)] [(0., 0.) (0., 0.) (0., 0.) (0., 0.) (0., 0.)] [(0., 0.) (0., 0.) (0., 0.) (0., 0.) (0., 0.)] [(0., 0.) (0., 0.) (0., 0.) (0., 0.) (0., 0.)] [(0., 0.) (0., 0.) (0., 0.) (0., 0.) (0., 0.)]] [(&apos;x&apos;, &apos;&lt;f8&apos;), (&apos;y&apos;, &apos;&lt;f8&apos;)] array([[(0. , 0. ), (0.25, 0. ), (0.5 , 0. ), (0.75, 0. ), (1. , 0. )], [(0. , 0.25), (0.25, 0.25), (0.5 , 0.25), (0.75, 0.25), (1. , 0.25)], [(0. , 0.5 ), (0.25, 0.5 ), (0.5 , 0.5 ), (0.75, 0.5 ), (1. , 0.5 )], [(0. , 0.75), (0.25, 0.75), (0.5 , 0.75), (0.75, 0.75), (1. , 0.75)], [(0. , 1. ), (0.25, 1. ), (0.5 , 1. ), (0.75, 1. ), (1. , 1. )]], dtype=[(&apos;x&apos;, &apos;&lt;f8&apos;), (&apos;y&apos;, &apos;&lt;f8&apos;)]) 47. 给定两个数组X和Y，构造Cauchy矩阵C (Cij =1/(xi - yj))1234X = np.arange(8)Y = X + 0.5C = 1.0 / np.subtract.outer(X, Y)print(np.linalg.det(C)) 3638.163637117973 48. 打印每个numpy标量类型的最小值和最大值？12345678for dtype in [np.int8, np.int32, np.int64]: print(np.iinfo(dtype).min) print(np.iinfo(dtype).max)for dtype in [np.float32, np.float64]: print(np.finfo(dtype).min) print(np.finfo(dtype).max) print(np.finfo(dtype).eps) -128 127 -2147483648 2147483647 -9223372036854775808 9223372036854775807 -3.4028235e+38 3.4028235e+38 1.1920929e-07 -1.7976931348623157e+308 1.7976931348623157e+308 2.220446049250313e-16 49. 如何打印一个数组中的所有数值?123p.set_printoptions(threshold=np.nan)Z = np.zeros((16,16))print (Z) --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-136-16a071ac8100&gt; in &lt;module&gt; ----&gt; 1 p.set_printoptions(threshold=np.nan) 2 # Z = np.zeros((16,16)) 3 # print (Z) NameError: name &apos;p&apos; is not defined 50. 给定标量时，如何找到数组中最接近标量的值？1234Z = np.arange(100)v = np.random.uniform(0,100)index = (np.abs(Z-v)).argmin()print (Z[index]) 59 51. 创建一个表示位置(x,y)和颜色(r,g,b)的结构化数组123456Z = np.zeros(10, [ ('position', [ ('x', float), ('y', float)]), ('color', [ ('r', float), ('g', float), ('b', float)])])Z array([((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.))], dtype=[(&apos;position&apos;, [(&apos;x&apos;, &apos;&lt;f8&apos;), (&apos;y&apos;, &apos;&lt;f8&apos;)]), (&apos;color&apos;, [(&apos;r&apos;, &apos;&lt;f8&apos;), (&apos;g&apos;, &apos;&lt;f8&apos;), (&apos;b&apos;, &apos;&lt;f8&apos;)])]) 52. 对一个表示坐标形状为(100,2)的随机向量，找到点与点的距离1234Z = np.random.random((10,2))X,Y = np.atleast_2d(Z[:,0], Z[:,1])D = np.sqrt( (X-X.T)**2 + (Y-Y.T)**2)print (D) [[0. 0.68605697 0.62122652 0.40530072 0.73015265 0.09355197 0.56261515 0.51426855 0.41227321 0.85367183] [0.68605697 0. 0.10265723 0.28166536 0.64689843 0.73311637 0.80907921 0.32712431 0.60162844 0.50010966] [0.62122652 0.10265723 0. 0.2312003 0.55079669 0.65895081 0.70673619 0.34824116 0.5011675 0.43109473] [0.40530072 0.28166536 0.2312003 0. 0.61033959 0.45844664 0.64946237 0.22328532 0.42686992 0.59168416] [0.73015265 0.64689843 0.55079669 0.61033959 0. 0.69214416 0.33216102 0.8274823 0.32343075 0.28094981] [0.09355197 0.73311637 0.65895081 0.45844664 0.69214416 0. 0.49087977 0.59249732 0.36881779 0.84414133] [0.56261515 0.80907921 0.70673619 0.64946237 0.33216102 0.49087977 0. 0.8673326 0.22259532 0.59768751] [0.51426855 0.32712431 0.34824116 0.22328532 0.8274823 0.59249732 0.8673326 0. 0.64545461 0.77079322] [0.41227321 0.60162844 0.5011675 0.42686992 0.32343075 0.36881779 0.22259532 0.64545461 0. 0.50877578] [0.85367183 0.50010966 0.43109473 0.59168416 0.28094981 0.84414133 0.59768751 0.77079322 0.50877578 0. ]] 53. 如何将32位的浮点数(float)转换为对应的整数(integer)?123Z = np.arange(10, dtype=np.int32)Z = Z.astype(np.float32, copy=False)print (Z) [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] 54. 如何读取以下文件?55. 对于numpy数组，enumerate的等价操作是什么？12345Z = np.arange(9).reshape(3,3)for index, value in np.ndenumerate(Z): print (index, value)for index in np.ndindex(Z.shape): print (index, Z[index]) (0, 0) 0 (0, 1) 1 (0, 2) 2 (1, 0) 3 (1, 1) 4 (1, 2) 5 (2, 0) 6 (2, 1) 7 (2, 2) 8 (0, 0) 0 (0, 1) 1 (0, 2) 2 (1, 0) 3 (1, 1) 4 (1, 2) 5 (2, 0) 6 (2, 1) 7 (2, 2) 8 56. 生成一个通用的二维Gaussian-like数组12345X, Y = np.meshgrid(np.linspace(-1,1,10), np.linspace(-1,1,10))D = np.sqrt(X*X+Y*Y)sigma, mu = 1.0, 0.0G = np.exp(-( (D-mu)**2 / ( 2.0 * sigma**2 ) ) )print (G) [[0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944] [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944]] 57. 对一个二维数组，如何在其内部随机放置p个元素?12345n = 10p = 3Z = np.zeros((n,n))np.put(Z, np.random.choice(range(n*n), p, replace=False),1)print (Z) [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.]] 58. 减去一个矩阵中的每一行的平均值1234X = np.random.rand(5, 10)# Recent versions of numpyY = X - X.mean(axis=1, keepdims=True)print(Y) [[-0.22370269 0.29733747 0.03664633 -0.11929707 0.38934825 -0.2316397 -0.27949186 0.10002169 0.27864595 -0.24786837] [-0.00062429 0.37487829 -0.02288536 -0.49889723 -0.39944991 0.01501358 -0.00573352 0.38315633 0.33032148 -0.17577937] [-0.37684235 0.09168961 0.32210956 -0.25418135 -0.14166652 0.39539008 -0.18467775 0.14629638 -0.26168209 0.26356442] [ 0.29264838 -0.14639492 0.1428065 0.27245024 -0.03056353 -0.03918195 -0.16229655 0.00562351 -0.05273503 -0.28235666] [-0.2284848 -0.28808201 -0.15736303 -0.05439054 -0.22746016 0.1996868 -0.19907649 0.55945475 0.50459159 -0.10887613]] 方法2 123# Older versions of numpyY = X - X.mean(axis=1).reshape(-1, 1)print (Y) [[-0.22370269 0.29733747 0.03664633 -0.11929707 0.38934825 -0.2316397 -0.27949186 0.10002169 0.27864595 -0.24786837] [-0.00062429 0.37487829 -0.02288536 -0.49889723 -0.39944991 0.01501358 -0.00573352 0.38315633 0.33032148 -0.17577937] [-0.37684235 0.09168961 0.32210956 -0.25418135 -0.14166652 0.39539008 -0.18467775 0.14629638 -0.26168209 0.26356442] [ 0.29264838 -0.14639492 0.1428065 0.27245024 -0.03056353 -0.03918195 -0.16229655 0.00562351 -0.05273503 -0.28235666] [-0.2284848 -0.28808201 -0.15736303 -0.05439054 -0.22746016 0.1996868 -0.19907649 0.55945475 0.50459159 -0.10887613]] 59. 如何通过第n列对一个数组进行排序?123Z = np.random.randint(0,10,(3,3))print (Z)Z[Z[:,1].argsort()] [[5 4 8] [1 0 2] [3 1 9]] array([[1, 0, 2], [3, 1, 9], [5, 4, 8]]) 60. 如何检查一个二维数组是否有空列？12Z = np.random.randint(0,3,(3,10))print ((~Z.any(axis=0)).any()) False 61. 从数组中的给定值中找出最近的值1234Z = np.random.uniform(0,1,10)z = 0.5m = Z.flat[np.abs(Z - z).argmin()]print (m) 0.5589928708513087 62. 如何用迭代器(iterator)计算两个分别具有形状(1,3)和(3,1)的数组?123456A = np.arange(3).reshape(3,1)B = np.arange(3).reshape(1,3)it = np.nditer([A,B,None])for x,y,z in it: z[...] = x + yprint (it.operands[2]) [[0 1 2] [1 2 3] [2 3 4]] 63. 创建一个具有name属性的数组类1234567891011class NamedArray(np.ndarray): def __new__(cls, array, name=\"no name\"): obj = np.asarray(array).view(cls) obj.name = name return obj def __array_finalize__(self, obj): if obj is None: return self.info = getattr(obj, 'name', \"no name\")Z = NamedArray(np.arange(10), \"range_10\")print (Z.name) range_10 64. 考虑一个给定的向量，如何对由第二个向量索引的每个元素加1(小心重复的索引)?1234Z = np.ones(10)I = np.random.randint(0,len(Z),20)Z += np.bincount(I, minlength=len(Z))print(Z) [3. 2. 2. 2. 3. 3. 3. 5. 1. 6.] 方法2 12np.add.at(Z, I, 1)print(Z) [ 5. 3. 3. 3. 5. 5. 5. 9. 1. 11.] 65. 根据索引列表(I)，如何将向量(X)的元素累加到数组(F)?1234X = [1,2,3,4,5,6]I = [1,3,9,3,4,1]F = np.bincount(I,X)print (F) [0. 7. 0. 6. 5. 0. 0. 0. 0. 3.] 66. 考虑一个(dtype=ubyte) 的 (w,h,3)图像，计算其唯一颜色的数量1234567w,h = 16,16I = np.random.randint(0,2,(h,w,3)).astype(np.ubyte)#Note that we should compute 256*256 first. #Otherwise numpy will only promote F.dtype to 'uint16' and overfolw will occurF = I[...,0]*(256*256) + I[...,1]*256 +I[...,2]n = len(np.unique(F))print (n) 8 67. 考虑一个四维数组，如何一次性计算出最后两个轴(axis)的和？1234A = np.random.randint(0,10,(3,4,3,4))# solution by passing a tuple of axes (introduced in numpy 1.7.0)sum = A.sum(axis=(-2,-1))print (sum) [[35 63 58 52] [64 43 51 40] [32 61 61 67]] 方法2 12sum = A.reshape(A.shape[:-2] + (-1,)).sum(axis=-1)print (sum) [[35 63 58 52] [64 43 51 40] [32 61 61 67]] 68. 考虑一个一维向量D，如何使用相同大小的向量S来计算D子集的均值？123456D = np.random.uniform(0,1,100)S = np.random.randint(0,10,100)D_sums = np.bincount(S, weights=D)D_counts = np.bincount(S)D_means = D_sums / D_countsprint (D_means) [0.40003185 0.74168757 0.53029708 0.57672923 0.55116799 0.55260023 0.5413465 0.37198828 0.57577261 0.54925535] 方法2 12# import pandas as pd# print(pd.Series(D).groupby(S).mean()) 69. 如何获得点积 dot prodcut的对角线?1234A = np.random.uniform(0,1,(5,5))B = np.random.uniform(0,1,(5,5))# # slow versionnp.diag(np.dot(A, B)) array([1.90221076, 0.73114449, 0.73911389, 0.71844659, 1.71777083]) 方法2 1np.sum(A * B.T, axis=1) array([1.90221076, 0.73114449, 0.73911389, 0.71844659, 1.71777083]) 方法3 1np.einsum(\"ij,ji-&gt;i\", A, B) array([1.90221076, 0.73114449, 0.73911389, 0.71844659, 1.71777083]) 70. 考虑一个向量[1,2,3,4,5],如何建立一个新的向量，在这个新向量中每个值之间有3个连续的零？12345Z = np.array([1,2,3,4,5])nz = 3Z0 = np.zeros(len(Z) + (len(Z)-1)*(nz))Z0[::nz+1] = Zprint (Z0) [1. 0. 0. 0. 2. 0. 0. 0. 3. 0. 0. 0. 4. 0. 0. 0. 5.] 71. 考虑一个维度(5,5,3)的数组，如何将其与一个(5,5)的数组相乘？123A = np.ones((5,5,3))B = 2*np.ones((5,5))print (A * B[:,:,None]) [[[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]]] 72. 如何对一个数组中任意两行做交换?123A = np.arange(25).reshape(5,5)A[[0,1]] = A[[1,0]]print (A) [[ 5 6 7 8 9] [ 0 1 2 3 4] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] 73. 考虑一个可以描述10个三角形的triplets，找到可以分割全部三角形的line segment1234567faces = np.random.randint(0,100,(10,3))F = np.roll(faces.repeat(2,axis=1),-1,axis=1)F = F.reshape(len(F)*3,2)F = np.sort(F,axis=1)G = F.view( dtype=[('p0',F.dtype),('p1',F.dtype)] )G = np.unique(G)print (G) [(11, 33) (11, 44) (13, 25) (13, 87) (14, 39) (14, 55) (16, 84) (16, 96) (17, 84) (17, 95) (18, 35) (18, 81) (21, 42) (21, 49) (23, 92) (23, 98) (25, 87) (33, 44) (35, 81) (39, 55) (42, 49) (49, 80) (49, 92) (59, 70) (59, 77) (70, 77) (80, 92) (84, 95) (84, 96) (92, 98)] 74. 给定一个二进制的数组C，如何产生一个数组A满足np.bincount(A)==C123C = np.bincount([1,1,2,3,4,4,6])A = np.repeat(np.arange(len(C)), C)print (A) [1 1 2 3 4 4 6] 75. 如何通过滑动窗口计算一个数组的平均数?1234567def moving_average(a, n=3) : ret = np.cumsum(a, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / nZ = np.arange(20)print(moving_average(Z, n=3)) [ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.] 76. 考虑一个一维数组Z，构建一个二维数组，其第一行为(Z[0]，Z[1]，Z[2])，然后每个后续行移动1(最后一行应该为(Z[-3]，Z[-2]，Z[-1])123456789from numpy.lib import stride_tricksdef rolling(a, window): shape = (a.size - window + 1, window) strides = (a.itemsize, a.itemsize) return stride_tricks.as_strided(a, shape=shape, strides=strides)Z = rolling(np.arange(10), 3)print (Z) [[0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9]] 77. 如何对布尔值取反，或者原位(in-place)改变浮点数的符号(sign)？12Z = np.random.randint(0,2,100)np.logical_not(Z, out=Z) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0]) 12Z = np.random.uniform(-1.0,1.0,100)np.negative(Z, out=Z) array([ 0.23689681, -0.1057382 , -0.57698282, -0.83485527, -0.56592412, 0.52906058, 0.87636873, 0.79456037, -0.84943243, -0.02862234, -0.27874639, 0.53982869, -0.92819707, -0.84933822, -0.72655128, -0.27991263, -0.38821443, -0.89064306, -0.6238352 , -0.70331099, 0.33032683, -0.62906234, -0.60486077, 0.19187415, -0.07665583, 0.94393027, 0.94226737, 0.78399481, 0.03917581, -0.97886888, 0.3023522 , 0.8854273 , 0.43260069, -0.5108798 , 0.08447692, 0.8094311 , -0.02961588, 0.43797035, 0.53489813, -0.23148178, 0.50132491, -0.11907561, -0.41351587, 0.77849175, -0.08522882, 0.01426253, 0.52019255, -0.10827315, -0.37614668, 0.77433187, 0.36585315, -0.68845912, -0.59425059, 0.79725862, 0.8208273 , -0.71978436, -0.02122081, 0.19379665, -0.06794473, -0.3887197 , -0.32546326, 0.73797113, -0.17697576, -0.21162741, 0.71927392, -0.6944913 , 0.05130906, 0.87329243, 0.65334172, 0.73613569, -0.27170543, 0.10374602, -0.24059875, -0.72685295, 0.46246967, 0.0853352 , 0.38266084, -0.18466922, -0.1979213 , -0.24355838, -0.4658587 , -0.65447698, -0.21552133, 0.60630034, 0.76115048, -0.45606078, -0.89412734, 0.5211218 , 0.37955327, 0.42356571, 0.7953681 , -0.43269998, -0.9698459 , 0.95951107, -0.24806371, 0.35883848, 0.17046673, -0.31071932, -0.23371407, -0.45192508]) 78. 考虑两组点集P0和P1去描述一组线(二维)和一个点p,如何计算点p到每一条线 i (P0[i],P1[i])的距离？12345678910111213def distance(P0, P1, p): T = P1 - P0 L = (T**2).sum(axis=1) U = -((P0[:,0]-p[...,0])*T[:,0] + (P0[:,1]-p[...,1])*T[:,1]) / L U = U.reshape(len(U),1) D = P0 + U*T - p return np.sqrt((D**2).sum(axis=1))P0 = np.random.uniform(-10,10,(10,2))P1 = np.random.uniform(-10,10,(10,2))p = np.random.uniform(-10,10,( 1,2))print (distance(P0, P1, p)) [6.73003936 3.25658553 8.43503749 8.03999863 2.52898731 2.10311161 1.37978063 0.66841085 6.59364144 1.56923099] 79.考虑两组点集P0和P1去描述一组线(二维)和一组点集P，如何计算每一个点 j(P[j]) 到每一条线 i (P0[i],P1[i])的距离？12345# based on distance function from previous questionP0 = np.random.uniform(-10, 10, (10,2))P1 = np.random.uniform(-10,10,(10,2))p = np.random.uniform(-10, 10, (10,2))print (np.array([distance(P0,P1,p_i) for p_i in p])) [[13.07041481 0.34376075 16.58732696 14.87969545 4.11962738 5.42144091 12.11842537 3.68644762 12.40317974 3.09689636] [ 8.31670675 10.27424599 3.2826011 3.52519444 10.00075179 2.84898481 9.65299862 11.41398094 7.30142854 1.88829117] [ 6.77924397 10.58975518 1.62351305 1.82484002 8.59935901 1.34441665 8.19193867 9.71657604 6.60203043 3.04720539] [ 5.31162447 7.15368953 10.15848703 9.47767034 2.94628246 5.49623871 3.86868708 0.27595815 2.83153155 6.28099959] [ 3.44438221 4.17789976 7.58912946 6.50592271 7.00008457 1.4819549 2.34424003 3.25599879 3.70548935 2.2971877 ] [ 2.36688408 3.25851654 1.37656162 0.17449453 12.04923635 3.97454356 3.20458239 9.51687426 0.88033642 1.81179476] [ 1.4752091 12.1742076 4.20617443 4.21460366 3.31482283 4.26452794 3.19931119 3.57944931 4.51890055 7.53817263] [ 5.46643964 8.63921896 10.63642071 10.15728999 1.48642797 6.87406001 3.8756232 1.27141727 1.93560503 7.84232163] [ 6.41793965 0.50870998 9.88281153 8.29794915 8.17165084 0.78199922 5.58269127 2.40028245 7.90280833 0.28608886] [10.37689182 3.50154975 14.62120512 13.43886767 2.58517684 6.4955299 9.13465077 3.20719531 8.25437731 5.43698872]] 80.考虑一个任意数组，编写一个函数来提取形状固定且以给定元素为中心的子部分(必要时使用填充值填充)12345678910111213141516171819202122232425Z = np.random.randint(0,10,(10,10))shape = (5,5)fill = 0position = (1,1)R = np.ones(shape, dtype=Z.dtype)*fillP = np.array(list(position)).astype(int)Rs = np.array(list(R.shape)).astype(int)Zs = np.array(list(Z.shape)).astype(int)R_start = np.zeros((len(shape),)).astype(int)R_stop = np.array(list(shape)).astype(int)Z_start = (P-Rs//2)Z_stop = (P+Rs//2)+Rs%2R_start = (R_start - np.minimum(Z_start,0)).tolist()Z_start = (np.maximum(Z_start,0)).tolist()R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,0))).tolist()Z_stop = (np.minimum(Z_stop,Zs)).tolist()r = [slice(start,stop) for start,stop in zip(R_start,R_stop)]z = [slice(start,stop) for start,stop in zip(Z_start,Z_stop)]R[r] = Z[z]print (Z)print (R) [[1 8 6 0 0 3 1 3 0 5] [6 3 1 0 6 4 4 0 4 1] [1 4 8 9 6 5 0 8 1 2] [7 5 6 8 6 1 1 8 4 0] [7 9 1 4 9 5 1 5 8 1] [3 0 8 9 1 7 2 5 6 7] [7 5 0 1 1 3 8 7 0 4] [5 0 1 4 6 8 7 3 7 7] [0 9 7 4 8 4 9 0 0 6] [5 5 9 7 5 4 4 1 8 5]] [[0 0 0 0 0] [0 1 8 6 0] [0 6 3 1 0] [0 1 4 8 9] [0 7 5 6 8]] /Users/admin/.virtualenvs/numpy/lib/python3.7/site-packages/ipykernel_launcher.py:23: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. 81. 考虑一个数组Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14],如何生成一个数组R = [[1,2,3,4], [2,3,4,5], [3,4,5,6], …,[11,12,13,14]]?123Z = np.arange(1,15,dtype=np.uint32)R = stride_tricks.as_strided(Z,(11,4),(4,4))print (R) [[ 1 2 3 4] [ 2 3 4 5] [ 3 4 5 6] [ 4 5 6 7] [ 5 6 7 8] [ 6 7 8 9] [ 7 8 9 10] [ 8 9 10 11] [ 9 10 11 12] [10 11 12 13] [11 12 13 14]] 82. 计算一个矩阵的秩1234Z = np.random.uniform(0,1,(10,10))U, S, V = np.linalg.svd(Z) # Singular Value Decompositionrank = np.sum(S &gt; 1e-10)print (rank) 10 83. 如何找到一个数组中出现频率最高的值？12Z = np.random.randint(0,10,50)print (np.bincount(Z).argmax()) 3 84. 从一个10x10的矩阵中提取出连续的3x3区块123456Z = np.random.randint(0,5,(10,10))n = 3i = 1 + (Z.shape[0]-3)j = 1 + (Z.shape[1]-3)C = stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)print (C) [[[[3 2 0] [2 2 2] [1 1 4]] [[2 0 3] [2 2 2] [1 4 4]] [[0 3 1] [2 2 2] [4 4 4]] [[3 1 3] [2 2 2] [4 4 2]] [[1 3 1] [2 2 0] [4 2 0]] [[3 1 1] [2 0 1] [2 0 1]] [[1 1 3] [0 1 3] [0 1 3]] [[1 3 0] [1 3 2] [1 3 1]]] [[[2 2 2] [1 1 4] [3 2 0]] [[2 2 2] [1 4 4] [2 0 2]] [[2 2 2] [4 4 4] [0 2 4]] [[2 2 2] [4 4 2] [2 4 3]] [[2 2 0] [4 2 0] [4 3 1]] [[2 0 1] [2 0 1] [3 1 3]] [[0 1 3] [0 1 3] [1 3 2]] [[1 3 2] [1 3 1] [3 2 4]]] [[[1 1 4] [3 2 0] [0 4 3]] [[1 4 4] [2 0 2] [4 3 1]] [[4 4 4] [0 2 4] [3 1 4]] [[4 4 2] [2 4 3] [1 4 4]] [[4 2 0] [4 3 1] [4 4 4]] [[2 0 1] [3 1 3] [4 4 2]] [[0 1 3] [1 3 2] [4 2 1]] [[1 3 1] [3 2 4] [2 1 1]]] [[[3 2 0] [0 4 3] [4 2 3]] [[2 0 2] [4 3 1] [2 3 0]] [[0 2 4] [3 1 4] [3 0 1]] [[2 4 3] [1 4 4] [0 1 4]] [[4 3 1] [4 4 4] [1 4 2]] [[3 1 3] [4 4 2] [4 2 3]] [[1 3 2] [4 2 1] [2 3 3]] [[3 2 4] [2 1 1] [3 3 2]]] [[[0 4 3] [4 2 3] [4 1 2]] [[4 3 1] [2 3 0] [1 2 4]] [[3 1 4] [3 0 1] [2 4 3]] [[1 4 4] [0 1 4] [4 3 4]] [[4 4 4] [1 4 2] [3 4 2]] [[4 4 2] [4 2 3] [4 2 1]] [[4 2 1] [2 3 3] [2 1 1]] [[2 1 1] [3 3 2] [1 1 3]]] [[[4 2 3] [4 1 2] [4 2 3]] [[2 3 0] [1 2 4] [2 3 4]] [[3 0 1] [2 4 3] [3 4 2]] [[0 1 4] [4 3 4] [4 2 4]] [[1 4 2] [3 4 2] [2 4 0]] [[4 2 3] [4 2 1] [4 0 3]] [[2 3 3] [2 1 1] [0 3 0]] [[3 3 2] [1 1 3] [3 0 4]]] [[[4 1 2] [4 2 3] [1 1 2]] [[1 2 4] [2 3 4] [1 2 1]] [[2 4 3] [3 4 2] [2 1 0]] [[4 3 4] [4 2 4] [1 0 3]] [[3 4 2] [2 4 0] [0 3 4]] [[4 2 1] [4 0 3] [3 4 0]] [[2 1 1] [0 3 0] [4 0 2]] [[1 1 3] [3 0 4] [0 2 4]]] [[[4 2 3] [1 1 2] [1 1 4]] [[2 3 4] [1 2 1] [1 4 3]] [[3 4 2] [2 1 0] [4 3 4]] [[4 2 4] [1 0 3] [3 4 3]] [[2 4 0] [0 3 4] [4 3 0]] [[4 0 3] [3 4 0] [3 0 2]] [[0 3 0] [4 0 2] [0 2 0]] [[3 0 4] [0 2 4] [2 0 1]]]] 85. 创建一个满足 Z[i,j] == Z[j,i]的子类123456789101112class Symetric(np.ndarray): def __setitem__(self, index, value): i,j = index super(Symetric, self).__setitem__((i,j), value) super(Symetric, self).__setitem__((j,i), value)def symetric(Z): return np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric)S = symetric(np.random.randint(0,10,(5,5)))S[2,3] = 42print (S) [[ 2 12 8 13 5] [12 9 13 12 7] [ 8 13 0 42 6] [13 12 42 6 5] [ 5 7 6 5 1]] 86. 考虑p个 nxn 矩阵和一组形状为(n,1)的向量，如何直接计算p个矩阵的乘积(n,1)？12345678910p, n = 10, 20M = np.ones((p,n,n))V = np.ones((p,n,1))S = np.tensordot(M, V, axes=[[0, 2], [0, 1]])print (S)# It works, because:M is (p,n,n)V is (p,n,1)# Thus, summing over the paired axes 0 and 0 (of M and V independently),# and 2 and 1, to remain with a (n,1) vector. [[200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.]] False 87. 对于一个16x16的数组，如何得到一个区域(block-sum)的和(区域大小为4x4)?12345Z = np.ones((16,16))k = 4S = np.add.reduceat(np.add.reduceat(Z, np.arange(0, Z.shape[0], k), axis=0), np.arange(0, Z.shape[1], k), axis=1)print (S) [[16. 16. 16. 16.] [16. 16. 16. 16.] [16. 16. 16. 16.] [16. 16. 16. 16.]] 88. 如何利用numpy数组实现Game of Life?(提示: Game of Life) 12345678910111213141516def iterate(Z): # Count neighbours N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] + Z[1:-1,0:-2] + Z[1:-1,2:] + Z[2: ,0:-2] + Z[2: ,1:-1] + Z[2: ,2:]) # Apply rules birth = (N==3) &amp; (Z[1:-1,1:-1]==0) survive = ((N==2) | (N==3)) &amp; (Z[1:-1,1:-1]==1) Z[...] = 0 Z[1:-1,1:-1][birth | survive] = 1 return ZZ = np.random.randint(0,2,(50,50))for i in range(100): Z = iterate(Z)print (Z) [[0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] ... [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0]] 89. 如何找到一个数组的第n个最大值?123456Z = np.arange(10000)np.random.shuffle(Z)n = 5# Slowprint (Z[np.argsort(Z)[-n:]]) [9995 9996 9997 9998 9999] 方法2 12# # Fastprint (Z[np.argpartition(-Z,n)[:n]]) [9999 9998 9997 9996 9995] 90. 给定任意个数向量，创建笛卡尔积(每一个元素的每一种组合)12345678910111213def cartesian(arrays): arrays = [np.asarray(a) for a in arrays] shape = (len(x) for x in arrays) ix = np.indices(shape, dtype=int) ix = ix.reshape(len(arrays), -1).T for n, arr in enumerate(arrays): ix[:, n] = arrays[n][ix[:, n]] return ixprint (cartesian(([1, 2, 3], [4, 5], [6, 7]))) [[1 4 6] [1 4 7] [1 5 6] [1 5 7] [2 4 6] [2 4 7] [2 5 6] [2 5 7] [3 4 6] [3 4 7] [3 5 6] [3 5 7]] 91. 如何从一个正常数组创建记录数组(record array)?123456Z = np.array([(\"Hello\", 2.5, 3), (\"World\", 3.6, 2)])R = np.core.records.fromarrays(Z.T, names='col1, col2, col3', formats = 'S8, f8, i8')print (R) [(b&apos;Hello&apos;, 2.5, 3) (b&apos;World&apos;, 3.6, 2)] 92. 考虑一个大向量Z, 用三种不同的方法计算它的立方12x = np.random.rand()np.power(x,3) 0.000911010785045678 方法2 1x*x*x 0.000911010785045678 93. 考虑两个形状分别为(8,3) 和(2,2)的数组A和B. 如何在数组A中找到满足包含B中元素的行？(不考虑B中每行元素顺序)？123456A = np.random.randint(0,5,(8,3))B = np.random.randint(0,5,(2,2))C = (A[..., np.newaxis, np.newaxis] == B)rows = np.where(C.any((3,1)).all(1))[0]print (rows) [1 4 6 7] 94. 考虑一个10x3的矩阵，分解出有不全相同值的行 (如 [2,2,3])1234567Z = np.random.randint(0,5,(10,3))print (Z)# solution for arrays of all dtypes (including string arrays and record arrays)E = np.all(Z[:,1:] == Z[:,:-1], axis=1)U = Z[~E]print (U) [[2 2 4] [2 0 4] [1 1 2] [3 0 2] [0 1 1] [2 4 0] [1 2 0] [1 3 2] [3 3 3] [3 1 1]] [[2 2 4] [2 0 4] [1 1 2] [3 0 2] [0 1 1] [2 4 0] [1 2 0] [1 3 2] [3 1 1]] 方法2 123# soluiton for numerical arrays only, will work for any number of columns in ZU = Z[Z.max(axis=1) != Z.min(axis=1),:]print (U) [[2 2 4] [2 0 4] [1 1 2] [3 0 2] [0 1 1] [2 4 0] [1 2 0] [1 3 2] [3 1 1]] 95. 将一个整数向量转换为matrix binary的表现形式123I = np.array([0, 1, 2, 3, 15, 16, 32, 64, 128])B = ((I.reshape(-1,1) &amp; (2**np.arange(8))) != 0).astype(int)print(B[:,::-1]) [[0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 1] [0 0 0 0 0 0 1 0] [0 0 0 0 0 0 1 1] [0 0 0 0 1 1 1 1] [0 0 0 1 0 0 0 0] [0 0 1 0 0 0 0 0] [0 1 0 0 0 0 0 0] [1 0 0 0 0 0 0 0]] 方法2 1# print (np.unpackbits(I[:, np.newaxis], axis=1)) 96. 给定一个二维数组，如何提取出唯一的(unique)行?12345Z = np.random.randint(0,2,(6,3))T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[1])))_, idx = np.unique(T, return_index=True)uZ = Z[idx]print (uZ) [[0 0 0] [0 1 0] [1 0 1] [1 1 0] [1 1 1]] 97. 考虑两个向量A和B，写出用einsum等式对应的inner, outer, sum, mul函数1234A = np.random.uniform(0,1,10)B = np.random.uniform(0,1,10)print ('sum')print (np.einsum('i-&gt;', A))# np.sum(A) sum 3.9854151671792284 12print ('A * B')print (np.einsum('i,i-&gt;i', A, B)) # A * B A * B [0.28888653 0.60418484 0.41649239 0.09110476 0.06966387 0.43890848 0.05302467 0.37448688 0.10099565 0.2354905 ] 12print ('inner')print (np.einsum('i,i', A, B)) # np.inner(A, B) inner 2.673238575659151 12print ('outer')print (np.einsum('i,j-&gt;ij', A, B)) # np.outer(A, B) outer [[0.28888653 0.27775195 0.21538512 0.20511293 0.3347668 0.20453934 0.24313786 0.25523188 0.3137035 0.30699418] [0.62840553 0.60418484 0.4685203 0.44617553 0.7282074 0.44492782 0.52888994 0.55519766 0.68238908 0.66779451] [0.5586228 0.53709175 0.41649239 0.39662895 0.64734194 0.39551979 0.47015815 0.49354447 0.60661162 0.59363774] [0.12831438 0.12336875 0.09566735 0.09110476 0.14869296 0.09084999 0.10799425 0.11336603 0.1393373 0.13635723] [0.06011633 0.05779927 0.04482093 0.04268333 0.06966387 0.04256396 0.05059619 0.05311291 0.06528066 0.06388448] [0.61990396 0.59601095 0.46218178 0.44013931 0.71835562 0.43890848 0.52173469 0.54768651 0.67315718 0.65876005] [0.06300176 0.06057348 0.04697222 0.04473201 0.07300755 0.04460692 0.05302467 0.05566219 0.06841396 0.06695076] [0.42386639 0.40752927 0.31602205 0.30095027 0.49118384 0.30010867 0.35674204 0.37448688 0.46027889 0.45043469] [0.09300592 0.08942119 0.06934242 0.06603533 0.1077769 0.06585067 0.07827731 0.08217094 0.10099565 0.09883561] [0.2216004 0.21305924 0.16521861 0.15733897 0.25679445 0.15689898 0.18650731 0.19578444 0.24063712 0.2354905 ]] 98. 考虑一个由两个向量描述的路径(X,Y)，如何用等距样例(equidistant samples)对其进行采样(sample)?12345678910111213phi = np.arange(0, 10*np.pi, 0.1)a = 1x = a*phi*np.cos(phi)y = a*phi*np.sin(phi)dr = (np.diff(x)**2 + np.diff(y)**2)**.5 # segment lengthsr = np.zeros_like(x)r[1:] = np.cumsum(dr) # integrate pathr_int = np.linspace(0, r.max(), 200) # regular spaced pathx_int = np.interp(r_int, r, x) # integrate pathy_int = np.interp(r_int, r, y)print(x_int)print(y_int) [ 0.00000000e+00 -3.73131229e-01 -2.59817608e+00 -3.26212050e+00 -2.18442687e+00 -2.98929946e-02 2.42923642e+00 4.54913599e+00 5.92318348e+00 6.35117933e+00 5.82369277e+00 4.46259540e+00 2.47320794e+00 1.09577220e-01 -2.36575300e+00 -4.71261671e+00 -6.72701769e+00 -8.25541575e+00 -9.18486120e+00 -9.46381505e+00 -9.11085788e+00 -8.12875279e+00 -6.63306046e+00 -4.69271059e+00 -2.44736165e+00 -2.05444585e-02 2.46101146e+00 4.86841760e+00 7.08937968e+00 9.02539126e+00 1.05948609e+01 1.17357250e+01 1.24068974e+01 1.25885805e+01 1.22815267e+01 1.15053927e+01 1.02963689e+01 8.70429550e+00 6.78948686e+00 4.61716636e+00 2.25853448e+00 -1.98731680e-01 -2.68040566e+00 -5.11543300e+00 -7.41973991e+00 -9.53891040e+00 -1.14237629e+01 -1.29919305e+01 -1.42355069e+01 -1.51243232e+01 -1.56061571e+01 -1.57219415e+01 -1.54217066e+01 -1.47579136e+01 -1.37255236e+01 -1.23634834e+01 -1.07024632e+01 -8.78327367e+00 -6.65029558e+00 -4.35514246e+00 -1.94290275e+00 5.28038914e-01 3.00985904e+00 5.45450275e+00 7.80093594e+00 1.00179639e+01 1.20595602e+01 1.38732623e+01 1.54564938e+01 1.67497894e+01 1.77435802e+01 1.84439878e+01 1.87990820e+01 1.88271003e+01 1.85472755e+01 1.79378850e+01 1.70105456e+01 1.58085777e+01 1.43501808e+01 1.26222364e+01 1.06905445e+01 8.58498641e+00 6.33562529e+00 3.96179025e+00 1.51802643e+00 -9.61699044e-01 -3.44349301e+00 -5.88951759e+00 -8.26006582e+00 -1.05270865e+01 -1.26610269e+01 -1.46343020e+01 -1.64206033e+01 -1.79708499e+01 -1.92894561e+01 -2.03605967e+01 -2.11716587e+01 -2.17133504e+01 -2.19797677e+01 -2.19626531e+01 -2.16476737e+01 -2.10622561e+01 -2.02145809e+01 -1.91158467e+01 -1.77800930e+01 -1.62239930e+01 -1.44666197e+01 -1.25291882e+01 -1.04347777e+01 -8.20773276e+00 -5.86978851e+00 -3.45563299e+00 -9.92556869e-01 1.49191203e+00 3.97031733e+00 6.41557503e+00 8.80126359e+00 1.11019001e+01 1.32931995e+01 1.53523150e+01 1.72580567e+01 1.89910866e+01 2.05340895e+01 2.18719167e+01 2.29917039e+01 2.38829603e+01 2.45376309e+01 2.49501314e+01 2.51173551e+01 2.50386548e+01 2.47157984e+01 2.41529019e+01 2.33563391e+01 2.23346314e+01 2.10983193e+01 1.96598169e+01 1.80332532e+01 1.62343003e+01 1.42799934e+01 1.21885425e+01 9.97914013e+00 7.67176574e+00 5.28699023e+00 2.84441658e+00 3.68190102e-01 -2.11846865e+00 -4.59426061e+00 -7.03829202e+00 -9.43024209e+00 -1.17505186e+01 -1.39803999e+01 -1.61021634e+01 -1.80991985e+01 -1.99561058e+01 -2.16587804e+01 -2.31850397e+01 -2.45166960e+01 -2.56568097e+01 -2.65976904e+01 -2.73332424e+01 -2.78589555e+01 -2.81718833e+01 -2.82706110e+01 -2.81552119e+01 -2.78066635e+01 -2.72341677e+01 -2.64578863e+01 -2.54844118e+01 -2.43214986e+01 -2.29779690e+01 -2.14636172e+01 -1.97837046e+01 -1.79341987e+01 -1.59545785e+01 -1.38585628e+01 -1.16602783e+01 -9.37416511e+00 -7.01488958e+00 -4.59184632e+00 -2.12995331e+00 3.50691071e-01 2.83498918e+00 5.30813450e+00 7.75565814e+00 1.01522531e+01 1.24813227e+01 1.47337756e+01 1.68973642e+01 1.89604991e+01 2.09071945e+01 2.26943693e+01 2.43420179e+01 2.58422998e+01 2.71881423e+01 2.83731992e+01 2.93376609e+01 3.01222558e+01 3.07280750e+01 3.11531219e+01 3.13960177e+01] [ 0.00000000e+00 1.74026724e+00 9.81816584e-01 -1.34251287e+00 -3.53191891e+00 -4.70449474e+00 -4.59573427e+00 -3.33831870e+00 -1.28956083e+00 1.14234685e+00 3.55645601e+00 5.62188218e+00 7.09389488e+00 7.82951803e+00 7.78700678e+00 6.99685666e+00 5.55535240e+00 3.60417006e+00 1.30506373e+00 -1.15819722e+00 -3.61328132e+00 -5.89130465e+00 -7.87065053e+00 -9.41689057e+00 -1.04714836e+01 -1.09903787e+01 -1.09354306e+01 -1.03330912e+01 -9.22690166e+00 -7.67489830e+00 -5.75257980e+00 -3.54832201e+00 -1.15854355e+00 1.31709956e+00 3.78023622e+00 6.13780326e+00 8.30540149e+00 1.02098724e+01 1.17910419e+01 1.29972950e+01 1.37774249e+01 1.41319792e+01 1.40585758e+01 1.35636816e+01 1.26345244e+01 1.13409083e+01 9.72216360e+00 7.79464305e+00 5.64544223e+00 3.32503222e+00 8.88107041e-01 -1.59329248e+00 -4.05992507e+00 -6.45313746e+00 -8.71327144e+00 -1.07900854e+01 -1.26380653e+01 -1.42147006e+01 -1.54892299e+01 -1.64390858e+01 -1.70351433e+01 -1.72938948e+01 -1.71685631e+01 -1.67219979e+01 -1.59044166e+01 -1.47824153e+01 -1.33665280e+01 -1.16678134e+01 -9.75246391e+00 -7.63091465e+00 -5.35345831e+00 -2.96905840e+00 -5.09631905e-01 1.97507060e+00 4.44430515e+00 6.85344809e+00 9.15903461e+00 1.13337844e+01 1.33467125e+01 1.51336120e+01 1.66966787e+01 1.80162922e+01 1.90746708e+01 1.98127969e+01 2.02634499e+01 2.04221761e+01 2.02877631e+01 1.98449702e+01 1.90974465e+01 1.80799531e+01 1.68069397e+01 1.52959771e+01 1.35665801e+01 1.16227312e+01 9.51601869e+00 7.27388893e+00 4.92519240e+00 2.49981337e+00 2.82932820e-02 -2.45817963e+00 -4.92460367e+00 -7.34030894e+00 -9.67635928e+00 -1.19050601e+01 -1.40002645e+01 -1.59376556e+01 -1.76950019e+01 -1.92523833e+01 -2.05923861e+01 -2.16995543e+01 -2.25478860e+01 -2.31432552e+01 -2.34800725e+01 -2.35556687e+01 -2.33702741e+01 -2.29269662e+01 -2.22315865e+01 -2.12926288e+01 -2.01211000e+01 -1.87303570e+01 -1.71359212e+01 -1.53552740e+01 -1.34076356e+01 -1.13137308e+01 -9.09554383e+00 -6.77606668e+00 -4.37904252e+00 -1.92870828e+00 5.50461201e-01 3.03400451e+00 5.49771780e+00 7.91788934e+00 1.02715222e+01 1.25365431e+01 1.46919953e+01 1.67182148e+01 1.85969872e+01 2.03116866e+01 2.18473923e+01 2.31909872e+01 2.43312337e+01 2.52588296e+01 2.59664444e+01 2.64391214e+01 2.66748505e+01 2.66796333e+01 2.64545680e+01 2.60026765e+01 2.53288265e+01 2.44396400e+01 2.33433894e+01 2.20498837e+01 2.05703459e+01 1.89172843e+01 1.71043584e+01 1.51396391e+01 1.30387952e+01 1.08294252e+01 8.52903617e+00 6.15551380e+00 3.72697869e+00 1.26164946e+00 -1.22228693e+00 -3.70679651e+00 -6.17014862e+00 -8.59028675e+00 -1.09516293e+01 -1.32379536e+01 -1.54338179e+01 -1.75246263e+01 -1.94966815e+01 -2.13317519e+01 -2.29952001e+01 -2.44987532e+01 -2.58335652e+01 -2.69919481e+01 -2.79673583e+01 -2.87543764e+01 -2.93186910e+01 -2.96679958e+01 -2.98181354e+01 -2.97693731e+01 -2.95229769e+01 -2.90811595e+01 -2.84133854e+01 -2.75430665e+01 -2.64934034e+01 -2.52713717e+01 -2.38845608e+01 -2.23353782e+01 -2.06051319e+01 -1.87442619e+01 -1.67635423e+01 -1.46739620e+01 -1.24866789e+01 -1.01933401e+01 -7.83474328e+00 -5.42495146e+00 -2.97607515e+00 -5.00072086e-01] 99. 给定一个整数n和一个二维数组X，从X中选择可以解释为从n度的多项分布中提取的行，即只包含整数且和为n的行1234567X = np.asarray([[1.0, 0.0, 3.0, 8.0], [2.0, 0.0, 1.0, 1.0], [1.5, 2.5, 1.0, 0.0]])n = 4M = np.logical_and.reduce(np.mod(X, 1) == 0, axis=-1)M &amp;= (X.sum(axis=-1) == n)print (X[M]) [[2. 0. 1. 1.]] 100. 对于一个一维数组X，计算它boostrapped之后的95%置信区间的平均值123456X = np.random.randn(100) # random 1D arrayN = 1000 # number of bootstrap samplesidx = np.random.randint(0, X.size, (N, X.size))means = X[idx].mean(axis=1)confint = np.percentile(means, [2.5, 97.5])print (confint) [-0.18822493 0.15997818]","categories":[{"name":"Numpy","slug":"Numpy","permalink":"https://jigangduan.github.io/categories/Numpy/"},{"name":"Python","slug":"Numpy/Python","permalink":"https://jigangduan.github.io/categories/Numpy/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://jigangduan.github.io/tags/numpy/"}]},{"title":"反爬 __极限滑块验证码__ 分析过程","slug":"geetest-slider","date":"2020-09-13T04:10:30.000Z","updated":"2020-10-23T23:32:08.477Z","comments":true,"path":"2020/09/13/geetest-slider/","link":"","permalink":"https://jigangduan.github.io/2020/09/13/geetest-slider/","excerpt":"","text":"某企业信用信息 使用了极限验证码，包括 滑块和点选 验证，这里尝试分析滑块验证 极限文档 搭建极限 demo 环境 下载 demo 1git clone https://github.com/GeeTeam/gt3-server-python-flask-sdk.git 运行 demo 123cd gt3-server-python-flask-sdksudo pip install -r requirements.txtsudo python3 app.py 在浏览器中访问http://localhost:5000即可看到demo界面。 验证操作点击验证会出现滑动块(也可以不是滑动块验证，不是就重新刷新) 滑动滑块，失败一次，查看请求: 123456789101112131415161718192021222324252627282930Request URL: http://api.geetest.com/ajax.php?gt=c9c4facd1a6feeb80802222cbb74ca8e&amp;challenge=0963aaa034f481209bcc2cea856f028ckm&amp;lang=zh-cn&amp;pt=0&amp;client_type=web&amp;w=lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHooIvkLJO(kx)4iwEXmKgB(pzX8hmTXVr7s0Cd8zlzLFRKByaxL9Xqebj4jpMbuGxSjMGbCucdrYjEs7hKdhGEHXxIHIrPbJCgS)HCfRtmiI3GeCdF7K7STWgxKzOpzF(osbFpJlFPHPyTq21Haj4LlTwW4PgOYeh(59qOX4aQrDVTLp6M2AonfdeXHlTi652p88Bh9o)blgbRptCo(Btz7JTkPgWBh4bRlBWzWwjxHtogBzRTKiFaQwe4HgvyTwAnxQRPFXt1iWmC7tOr6Ega)MGFZ941TfoV2Ky1yOPOvHAjWbIcCreU3NqYUCTlu3muFqfbdzgynuXQAd04ohUbNS(1MMsLsouhLxs(S4j0wHJWxOT(OBUrVWZ1NYzHNtJ71YoCpwu7LkEaL91cRO9XIYK(ahdEFL9RzWqavlNA(GZTPb8o6yZAEtbCZWFaQoThxcyrlkDluQDOavBCgVJ6LuJxCCjnXINAcNcQk4U6U6mWumJwwZKDGa1UEb2NuIi5Wa)VTMU5gI4YGA)r)FVhWQP9VFvW87MaeGUeDTIylzL1Ic3F7lzU6YqAlL65VzsNETMLw0aLy7x1ofwuZgYmMYrYJYkR1fKLjQULN7BJgH0m6m(TLOLKAt5FQeygWCuaJx54Fzg61XDE8qARsEuhotwezFFdxWUZ1rBQ0yGGfnurouJwsJYooujy(DMSaPeoSLs32ZdxUAdxWHGlnx3uwKLbNwM)KZfEMNyTD))C5ao96cxA3RwKrzH52CE7N9L4.3527385ff911fb8a8f47ab5b6b5b93632dbe721f7d4e80a60e3a4ff7ff8bc037ccffc02d460a5cd6851e6812fe9f15b39fe9dc0cbf2fefc740e2460efe9c4b31be06448b52eb98304bd65f43773f067579743e4f1f978d0bf66347f49f83d965132642922f49e9ef4d192470ef844824d6df28f0c271b9d7d6e47462c13c4a76&amp;callback=geetest_1600681650648Request Method: GETStatus Code: 200 OKRemote Address: 203.107.32.16:80Referrer Policy: no-referrer-when-downgradeQuery String Parameters -&gt;gt: c9c4facd1a6feeb80802222cbb74ca8echallenge: f340a03dc45ca5a598ba928f6b103d54k5lang: zh-cnpt: 0client_type: webw: lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHooIvkLJO(kx)4iwEXmKgB(pzX8hmTXVr7s0Cd8zlzLFRKByaxL9Xqebj4jpMbuGxSjMGbCucdrYjEs7hKdhGEHXxIHIrPbJCgS)HCfRtmiI3GeCdF7K7STWgxKzOpzF(osbFpJlFPHPyTq21Haj4LlTwW4PgOYeh(59qOX4aQrDVTLp6M2AonfdeXHlTi652p88Bh9o)blgbRptCo(Btz7JTkPgWBh4bRlBWzWwjxHtogBzRTKiFaQwe4HgvyTwAnxQRPFXt1iWmC7tOr6Ega)MGFZ941TfoV2Ky1yOPOvHAjWbIcCreU3NqYUCTlu3muFqfbdzgynuXQAd04ohUbNS(1MMsLsouhLxs(S4j0wHJWxOT(OBUrVWZ1NYzHNtJ71YoCpwu7LkEaL91cRO9XIYK(ahdEFL9RzWqavlNA(GZTPb8o6yZAEtbCZWFaQoThxcyrlkDluQDOavBCgVJ6LuJxCCjnXINAcNcQk4U6U6mWumJwwZKDGa1UEb2NuIi5Wa)VTMU5gI4YGA)r)FVhWQP9VFvW87MaeGUeDTIylzL1Ic3F7lzU6YqAlL65VzsNETMLw0aLy7x1ofwuZgYmMYrYJYkR1fKLjQULN7BJgH0m6m(TLOLKAt5FQeygWCuaJx54Fzg61XDE8qARsEuhotwezFFdxWUZ1rBQ0yGGfnurouJwsJYooujy(DMSaPeoSLs32ZdxUAdxWHGlnx3uwKLbNwM)KZfEMNyTD))C5ao96cxA3RwKrzH52CE7N9L4.3527385ff911fb8a8f47ab5b6b5b93632dbe721f7d4e80a60e3a4ff7ff8bc037ccffc02d460a5cd6851e6812fe9f15b39fe9dc0cbf2fefc740e2460efe9c4b31be06448b52eb98304bd65f43773f067579743e4f1f978d0bf66347f49f83d965132642922f49e9ef4d192470ef844824d6df28f0c271b9d7d6e47462c13c4a76callback: geetest_1600681650648Response:Headers -&gt;Cache-Control: no-cache, no-store, must-revalidateConnection: keep-aliveContent-Length: 56Content-Type: text/javascript;charset=UTF-8Date: Mon, 21 Sep 2020 09:47:24 GMTEtag: &quot;1dbd74d80dd411079f44b61057458859a2970afd&quot;Expires: 0Pragma: no-cacheServer: openrestySet-Cookie: GeeTestAjaxUser=68748bcc8d5e210678ab924a2d2f1043; expires=Tue, 21 Sep 2021 09:47:24 GMT; Path=/Body -&gt;geetest_1600681650648(&#123;&quot;success&quot;: 0, &quot;message&quot;: &quot;fail&quot;&#125;) 滑动滑块到指定位置，成功验证，查看请求: 123456789101112131415161718192021222324252627282930Request URL: http://api.geetest.com/ajax.php?gt=c9c4facd1a6feeb80802222cbb74ca8e&amp;challenge=0963aaa034f481209bcc2cea856f028ckm&amp;lang=zh-cn&amp;pt=0&amp;client_type=web&amp;w=lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHpwPSUixa377V2sfcEsuY)g5K0mchqtk(AOV5EcQzckO9(fpM0Nmgc2DFA(lCFNEhCgIqgR7uVwzrEkAhRUyGGui90EXJPerk5aJtf(XTFPQIha9YoXFKWl8KMlhkc5Y3m6G1jFSr19sBF3Z8IGpU2QINew3Nmeb(04bYoYD(s6keOfCSqJvYos6(HbkL)EUDMoZXolzFtLq39fHDZMLdkkvUZy)IenedIr9EnVYk5sdw1BUHlzlbXOjuo1tHiDJcZEeK7RQdodzPFOi8XgTn)8LDNjJftVeKWsjZ7qN)vgvAHZTCjDJkqVwtJJWGJnFKRMlaBfwgf8SNtMWPFts8(DUldMyHMoxEZlHQymWykbweLRFQvUCc3ZbnpG1v14BEp)9EauzMum5I8w(5ENDWGTAtt7fE3CoCuaYK8j2wSKFnzBxssv1kZiJFEbthpk1pGFm8w)O1ZOlehVSePtBYmbGWd)sn1sLUYjB5YISR597W2FdizbmZR0EkXRcIVBZpA(X7moz(FVfGvmWUPDmUCHLjvzC5TY6PMxX6rshBvJx75OdpFlepmBpwM)dJhDvngX4MTiQiilZjEmOQA(gBDOhbSlu4hQuNvlD2R4OkqZp8zyXsCqZTKp0Z9mtd0rP3b(UXeFGfCdaq2gX)Ag0jK9gn)YF8D5KhqUQ6Gfsg8sZNYGAkcJm0tC5rGqewTsD0vM0618aiSZWNouqV7QTBB2G7EmqQt0w7YVc3gu4RmoJmoBU(Kcj8TqkeXLfHww3YeYt(w2vXKKXAt(6xqIbKxpidRTB2InYyhSQOvf5QWQK3r(PL583LQhR3XyOYhUJGSrkDWIzO4mhFMtkxsCRavcA0D365tEM5oHa9vsvY9PTTreDn8olXHqx7hh(e7hRHuNCgVKXzJ0yLIodXP4d5Xed4zuJ6opPB)z4eH5LVxzNQ..ab6515b108b14112eeb500e7c27231f168deded0c0e96572273be4913e1320bf1d485710462c57221e2b95a51a60ce3135a791ea47799450d05c6a0757339931a882b3711363be98f3adb3b0aa05e454b85a542e932553916d10f319db493284c8e038c3a358702df6928de72627d679534af60051172c6024e4c9e72bbebe17&amp;callback=geetest_1600681688549Request Method: GETStatus Code: 200 OKRemote Address: 203.107.32.16:80Referrer Policy: no-referrer-when-downgradeQuery String Parameters -&gt;gt: c9c4facd1a6feeb80802222cbb74ca8echallenge: f340a03dc45ca5a598ba928f6b103d54k5lang: zh-cnpt: 0client_type: webw: lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHpwPSUixa377V2sfcEsuY)g5K0mchqtk(AOV5EcQzckO9(fpM0Nmgc2DFA(lCFNEhCgIqgR7uVwzrEkAhRUyGGui90EXJPerk5aJtf(XTFPQIha9YoXFKWl8KMlhkc5Y3m6G1jFSr19sBF3Z8IGpU2QINew3Nmeb(04bYoYD(s6keOfCSqJvYos6(HbkL)EUDMoZXolzFtLq39fHDZMLdkkvUZy)IenedIr9EnVYk5sdw1BUHlzlbXOjuo1tHiDJcZEeK7RQdodzPFOi8XgTn)8LDNjJftVeKWsjZ7qN)vgvAHZTCjDJkqVwtJJWGJnFKRMlaBfwgf8SNtMWPFts8(DUldMyHMoxEZlHQymWykbweLRFQvUCc3ZbnpG1v14BEp)9EauzMum5I8w(5ENDWGTAtt7fE3CoCuaYK8j2wSKFnzBxssv1kZiJFEbthpk1pGFm8w)O1ZOlehVSePtBYmbGWd)sn1sLUYjB5YISR597W2FdizbmZR0EkXRcIVBZpA(X7moz(FVfGvmWUPDmUCHLjvzC5TY6PMxX6rshBvJx75OdpFlepmBpwM)dJhDvngX4MTiQiilZjEmOQA(gBDOhbSlu4hQuNvlD2R4OkqZp8zyXsCqZTKp0Z9mtd0rP3b(UXeFGfCdaq2gX)Ag0jK9gn)YF8D5KhqUQ6Gfsg8sZNYGAkcJm0tC5rGqewTsD0vM0618aiSZWNouqV7QTBB2G7EmqQt0w7YVc3gu4RmoJmoBU(Kcj8TqkeXLfHww3YeYt(w2vXKKXAt(6xqIbKxpidRTB2InYyhSQOvf5QWQK3r(PL583LQhR3XyOYhUJGSrkDWIzO4mhFMtkxsCRavcA0D365tEM5oHa9vsvY9PTTreDn8olXHqx7hh(e7hRHuNCgVKXzJ0yLIodXP4d5Xed4zuJ6opPB)z4eH5LVxzNQ..ab6515b108b14112eeb500e7c27231f168deded0c0e96572273be4913e1320bf1d485710462c57221e2b95a51a60ce3135a791ea47799450d05c6a0757339931a882b3711363be98f3adb3b0aa05e454b85a542e932553916d10f319db493284c8e038c3a358702df6928de72627d679534af60051172c6024e4c9e72bbebe17callback: geetest_1600681688549Response:Headers -&gt;Cache-Control: no-cache, no-store, must-revalidateConnection: keep-aliveContent-Length: 122Content-Type: text/javascript;charset=UTF-8Date: Mon, 21 Sep 2020 09:47:59 GMTEtag: &quot;4a84b96c134bca4790a492cd523901cacbd03e42&quot;Expires: 0Pragma: no-cacheServer: openrestySet-Cookie: GeeTestAjaxUser=1d06456d0b40269eb520a07cba20918d; expires=Tue, 21 Sep 2021 09:47:59 GMT; Path=/Body -&gt;geetest_1600681688549(&#123;&quot;validate&quot;: &quot;44829c7e0b5085bbab69eeb0946880d2&quot;, &quot;message&quot;: &quot;success&quot;, &quot;success&quot;: 1, &quot;score&quot;: &quot;12&quot;&#125;) 对比两个响应 成功响应 返回携带 validate validate验证码应该就是我们需要的，请求是通过 GET ajax.php获取，携带Query参数，看看几个参数： 1234567891011121314151617// 失败时gt: c9c4facd1a6feeb80802222cbb74ca8echallenge: f340a03dc45ca5a598ba928f6b103d54k5lang: zh-cnpt: 0client_type: webw: lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHooIvkLJO(kx)4iwEXmKgB(pzX8hmTXVr7s0Cd8zlzLFRKByaxL9Xqebj4jpMbuGxSjMGbCucdrYjEs7hKdhGEHXxIHIrPbJCgS)HCfRtmiI3GeCdF7K7STWgxKzOpzF(osbFpJlFPHPyTq21Haj4LlTwW4PgOYeh(59qOX4aQrDVTLp6M2AonfdeXHlTi652p88Bh9o)blgbRptCo(Btz7JTkPgWBh4bRlBWzWwjxHtogBzRTKiFaQwe4HgvyTwAnxQRPFXt1iWmC7tOr6Ega)MGFZ941TfoV2Ky1yOPOvHAjWbIcCreU3NqYUCTlu3muFqfbdzgynuXQAd04ohUbNS(1MMsLsouhLxs(S4j0wHJWxOT(OBUrVWZ1NYzHNtJ71YoCpwu7LkEaL91cRO9XIYK(ahdEFL9RzWqavlNA(GZTPb8o6yZAEtbCZWFaQoThxcyrlkDluQDOavBCgVJ6LuJxCCjnXINAcNcQk4U6U6mWumJwwZKDGa1UEb2NuIi5Wa)VTMU5gI4YGA)r)FVhWQP9VFvW87MaeGUeDTIylzL1Ic3F7lzU6YqAlL65VzsNETMLw0aLy7x1ofwuZgYmMYrYJYkR1fKLjQULN7BJgH0m6m(TLOLKAt5FQeygWCuaJx54Fzg61XDE8qARsEuhotwezFFdxWUZ1rBQ0yGGfnurouJwsJYooujy(DMSaPeoSLs32ZdxUAdxWHGlnx3uwKLbNwM)KZfEMNyTD))C5ao96cxA3RwKrzH52CE7N9L4.3527385ff911fb8a8f47ab5b6b5b93632dbe721f7d4e80a60e3a4ff7ff8bc037ccffc02d460a5cd6851e6812fe9f15b39fe9dc0cbf2fefc740e2460efe9c4b31be06448b52eb98304bd65f43773f067579743e4f1f978d0bf66347f49f83d965132642922f49e9ef4d192470ef844824d6df28f0c271b9d7d6e47462c13c4a76callback: geetest_1600681650648// 成功时gt: c9c4facd1a6feeb80802222cbb74ca8echallenge: f340a03dc45ca5a598ba928f6b103d54k5lang: zh-cnpt: 0client_type: webw: lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHpwPSUixa377V2sfcEsuY)g5K0mchqtk(AOV5EcQzckO9(fpM0Nmgc2DFA(lCFNEhCgIqgR7uVwzrEkAhRUyGGui90EXJPerk5aJtf(XTFPQIha9YoXFKWl8KMlhkc5Y3m6G1jFSr19sBF3Z8IGpU2QINew3Nmeb(04bYoYD(s6keOfCSqJvYos6(HbkL)EUDMoZXolzFtLq39fHDZMLdkkvUZy)IenedIr9EnVYk5sdw1BUHlzlbXOjuo1tHiDJcZEeK7RQdodzPFOi8XgTn)8LDNjJftVeKWsjZ7qN)vgvAHZTCjDJkqVwtJJWGJnFKRMlaBfwgf8SNtMWPFts8(DUldMyHMoxEZlHQymWykbweLRFQvUCc3ZbnpG1v14BEp)9EauzMum5I8w(5ENDWGTAtt7fE3CoCuaYK8j2wSKFnzBxssv1kZiJFEbthpk1pGFm8w)O1ZOlehVSePtBYmbGWd)sn1sLUYjB5YISR597W2FdizbmZR0EkXRcIVBZpA(X7moz(FVfGvmWUPDmUCHLjvzC5TY6PMxX6rshBvJx75OdpFlepmBpwM)dJhDvngX4MTiQiilZjEmOQA(gBDOhbSlu4hQuNvlD2R4OkqZp8zyXsCqZTKp0Z9mtd0rP3b(UXeFGfCdaq2gX)Ag0jK9gn)YF8D5KhqUQ6Gfsg8sZNYGAkcJm0tC5rGqewTsD0vM0618aiSZWNouqV7QTBB2G7EmqQt0w7YVc3gu4RmoJmoBU(Kcj8TqkeXLfHww3YeYt(w2vXKKXAt(6xqIbKxpidRTB2InYyhSQOvf5QWQK3r(PL583LQhR3XyOYhUJGSrkDWIzO4mhFMtkxsCRavcA0D365tEM5oHa9vsvY9PTTreDn8olXHqx7hh(e7hRHuNCgVKXzJ0yLIodXP4d5Xed4zuJ6opPB)z4eH5LVxzNQ..ab6515b108b14112eeb500e7c27231f168deded0c0e96572273be4913e1320bf1d485710462c57221e2b95a51a60ce3135a791ea47799450d05c6a0757339931a882b3711363be98f3adb3b0aa05e454b85a542e932553916d10f319db493284c8e038c3a358702df6928de72627d679534af60051172c6024e4c9e72bbebe17callback: geetest_1600681688549 参数 ok fail gt c9c4facd1a6feeb80802222cbb74ca8e c9c4facd1a6feeb80802222cbb74ca8e challenge f340a03dc45ca5a598ba928f6b103d54k5 f340a03dc45ca5a598ba928f6b103d54k5 lang zh-cn zh-cn pt 0 0 client_type web web w lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHooIvkLJO(kx)4iwEXmKgB(pzX8hmTXVr7s0Cd8zlzLFRKByaxL9Xqebj4jpMbuGxSjMGbCucdrYjEs7hKdhGEHXxIHIrPbJCgS)HCfRtmiI3GeCdF7K7STWgxKzOpzF(osbFpJlFPHPyTq21Haj4LlTwW4PgOYeh(59qOX4aQrDVTLp6M2AonfdeXHlTi652p88Bh9o)blgbRptCo(Btz7JTkPgWBh4bRlBWzWwjxHtogBzRTKiFaQwe4HgvyTwAnxQRPFXt1iWmC7tOr6Ega)MGFZ941TfoV2Ky1yOPOvHAjWbIcCreU3NqYUCTlu3muFqfbdzgynuXQAd04ohUbNS(1MMsLsouhLxs(S4j0wHJWxOT(OBUrVWZ1NYzHNtJ71YoCpwu7LkEaL91cRO9XIYK(ahdEFL9RzWqavlNA(GZTPb8o6yZAEtbCZWFaQoThxcyrlkDluQDOavBCgVJ6LuJxCCjnXINAcNcQk4U6U6mWumJwwZKDGa1UEb2NuIi5Wa)VTMU5gI4YGA)r)FVhWQP9VFvW87MaeGUeDTIylzL1Ic3F7lzU6YqAlL65VzsNETMLw0aLy7x1ofwuZgYmMYrYJYkR1fKLjQULN7BJgH0m6m(TLOLKAt5FQeygWCuaJx54Fzg61XDE8qARsEuhotwezFFdxWUZ1rBQ0yGGfnurouJwsJYooujy(DMSaPeoSLs32ZdxUAdxWHGlnx3uwKLbNwM)KZfEMNyTD))C5ao96cxA3RwKrzH52CE7N9L4.3527385ff911fb8a8f47ab5b6b5b93632dbe721f7d4e80a60e3a4ff7ff8bc037ccffc02d460a5cd6851e6812fe9f15b39fe9dc0cbf2fefc740e2460efe9c4b31be06448b52eb98304bd65f43773f067579743e4f1f978d0bf66347f49f83d965132642922f49e9ef4d192470ef844824d6df28f0c271b9d7d6e47462c13c4a76 lBwc475p8UVMBWJIGvguOBDGO2XBUVAWcyDMF(cCyHpwPSUixa377V2sfcEsuY)g5K0mchqtk(AOV5EcQzckO9(fpM0Nmgc2DFA(lCFNEhCgIqgR7uVwzrEkAhRUyGGui90EXJPerk5aJtf(XTFPQIha9YoXFKWl8KMlhkc5Y3m6G1jFSr19sBF3Z8IGpU2QINew3Nmeb(04bYoYD(s6keOfCSqJvYos6(HbkL)EUDMoZXolzFtLq39fHDZMLdkkvUZy)IenedIr9EnVYk5sdw1BUHlzlbXOjuo1tHiDJcZEeK7RQdodzPFOi8XgTn)8LDNjJftVeKWsjZ7qN)vgvAHZTCjDJkqVwtJJWGJnFKRMlaBfwgf8SNtMWPFts8(DUldMyHMoxEZlHQymWykbweLRFQvUCc3ZbnpG1v14BEp)9EauzMum5I8w(5ENDWGTAtt7fE3CoCuaYK8j2wSKFnzBxssv1kZiJFEbthpk1pGFm8w)O1ZOlehVSePtBYmbGWd)sn1sLUYjB5YISR597W2FdizbmZR0EkXRcIVBZpA(X7moz(FVfGvmWUPDmUCHLjvzC5TY6PMxX6rshBvJx75OdpFlepmBpwM)dJhDvngX4MTiQiilZjEmOQA(gBDOhbSlu4hQuNvlD2R4OkqZp8zyXsCqZTKp0Z9mtd0rP3b(UXeFGfCdaq2gX)Ag0jK9gn)YF8D5KhqUQ6Gfsg8sZNYGAkcJm0tC5rGqewTsD0vM0618aiSZWNouqV7QTBB2G7EmqQt0w7YVc3gu4RmoJmoBU(Kcj8TqkeXLfHww3YeYt(w2vXKKXAt(6xqIbKxpidRTB2InYyhSQOvf5QWQK3r(PL583LQhR3XyOYhUJGSrkDWIzO4mhFMtkxsCRavcA0D365tEM5oHa9vsvY9PTTreDn8olXHqx7hh(e7hRHuNCgVKXzJ0yLIodXP4d5Xed4zuJ6opPB)z4eH5LVxzNQ..ab6515b108b14112eeb500e7c27231f168deded0c0e96572273be4913e1320bf1d485710462c57221e2b95a51a60ce3135a791ea47799450d05c6a0757339931a882b3711363be98f3adb3b0aa05e454b85a542e932553916d10f319db493284c8e038c3a358702df6928de72627d679534af60051172c6024e4c9e72bbebe17 callback geetest_1600681650648 geetest_1600681688549 gt, challenge 是一样的，主要需要分析它们是来自哪里 lang, pt, client_type 是固定值 callback 是geetest_[时间戳]，返回响应就是对应的geetest_[时间戳] w 值很复杂，应该就是 滑块的运动轨迹相关生成的 分析参数来历刷新网页，查看Chrome的Network 请求 GET register:12345678910Request URL: http://0.0.0.0:5000/register?t=1600703538795Request Method: GETResponse:&#123; &quot;success&quot;:1, &quot;gt&quot;:&quot;c9c4facd1a6feeb80802222cbb74ca8e&quot;, &quot;challenge&quot;:&quot;f340a03dc45ca5a598ba928f6b103d54&quot;, &quot;new_captcha&quot;:true&#125; Query参数 t=1600703538795 可以看出register 请求里面有gt, challenge gt 是不变的，而且每次请求都是一样的 查看 gt3-server-python-flask-sdk 的 geetest_config.py: 12GEETEST_ID = \"c9c4facd1a6feeb80802222cbb74ca8e\"GEETEST_KEY = \"e4e298788aa8c768397639deb9b249a9\" 发现gt就是 GEETEST_ID 但challenge 值和 ajax.php 请求的值是不一样的 追踪ajax.php请求回调: 12345678u = &#123; \"\\u0067\\u0074\": o[$_CAICh(171)], \"\\u0063\\u0068\\u0061\\u006c\\u006c\\u0065\\u006e\\u0067\\u0065\": o[$_CAIBT(128)], \"\\u006c\\u0061\\u006e\\u0067\": i[$_CAICh(111)], \"\\u0070\\u0074\": r[$_CAICh(630)], \"\\u0063\\u006c\\u0069\\u0065\\u006e\\u0074\\u005f\\u0074\\u0079\\u0070\\u0065\": r[$_CAICh(663)], \"\\u0077\": _ + s&#125;; Unicode 字符串 \\u0067\\u0074 gt \\u0063\\u0068\\u0061\\u006c\\u006c\\u0065\\u006e\\u0067\\u0065 challenge \\u006c\\u0061\\u006e\\u0067 lang \\u0070\\u0074 pt \\u0063\\u006c\\u0069\\u0065\\u006e\\u0074\\u005f\\u0074\\u0079\\u0070\\u0065 client_type \\u0077 w 查看gt 1234&gt; $_CAICh(171)\"gt\"&gt; o[$_CAICh(171)]\"c9c4facd1a6feeb80802222cbb74ca8e\" gt 就是取o对象中的 gt 属性，等效 u.gt = o.gt 查看challenge: 1234&gt; $_CAIBT(128)\"challenge\"&gt; o[$_CAIBT(128)]\"f5ec9b7bf21fa0e8bcc78bad646a60298e\" 在此challenge已经生成好了，但它是怎么生成的呢？ 123456789o = r[$_CAIBT(24)]&gt; $_CAIBT(24)\"$_IGz\"o = r.$_IGz&gt; r.$_IGz$_GIK 搜索$_GIK相关的代码 challenge 的Unicode值是\\u0063\\u0068\\u0061\\u006c\\u006c\\u0065\\u006e\\u0067\\u0065 1AGWEz.$_Cc(128) == `challenge` 源码有challenge 相关的属性都是其它对象的challenge的属性获得猜测需要的challenge可能是从服务器返回对象中获得 查看其它请求，发现get.php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Request URL: http://api.geetest.com/get.php?is_next=true&amp;type=slide3&amp;gt=c9c4facd1a6feeb80802222cbb74ca8e&amp;challenge=f7efd292522ee8db244f04e74d95e7f4&amp;lang=zh-cn&amp;https=false&amp;protocol=http%3A%2F%2F&amp;offline=false&amp;product=embed&amp;api_server=api.geetest.com&amp;isPC=true&amp;width=100%25&amp;callback=geetest_1600829591801Request Method: GETStatus Code: 200 OKQuery Parameters:is_next: truetype: slide3gt: c9c4facd1a6feeb80802222cbb74ca8echallenge: f7efd292522ee8db244f04e74d95e7f4lang: zh-cnhttps: falseprotocol: http://offline: falseproduct: embedapi_server: api.geetest.comisPC: truewidth: 100%callback: geetest_1600829591801Response:Headers -&gt;Cache-Control: no-cache, no-store, must-revalidateConnection: keep-aliveContent-Length: 1546Content-Type: text/javascript;charset=UTF-8Date: Wed, 23 Sep 2020 02:53:07 GMTEtag: \"974d863efd7b406d9d1d80807c5d9db5960ed5ef\"Expires: 0Pragma: no-cacheServer: openrestySet-Cookie: GeeTestUser=7dd27d058b44300de889a2f9ac14a0d1; expires=Thu, 23 Sep 2021 02:53:07 GMT; Path=/Body -&gt;geetest_1600829591801(&#123; \"benchmark\": false, \"c\": [12, 58, 98, 36, 43, 95, 62, 15, 12], \"id\": \"af7efd292522ee8db244f04e74d95e7f4\", \"version\": \"6.0.9\", \"show_delay\": 250, \"mobile\": true, \"challenge\": \"f7efd292522ee8db244f04e74d95e7f4fn\", \"bg\": \"pictures/gt/d49a453dc/bg/655b485ef.jpg\", \"clean\": false, \"static_servers\": [\"static.geetest.com/\", \"dn-staticdown.qbox.me/\"], \"type\": \"multilink\", \"fullbg\": \"pictures/gt/d49a453dc/d49a453dc.jpg\", \"theme\": \"ant\", \"gt\": \"c9c4facd1a6feeb80802222cbb74ca8e\", \"so\": 0, \"xpos\": 0, \"s\": \"62775164\", \"theme_version\": \"1.2.4\", \"api_server\": \"http://api.geetest.com/\", \"template\": \"\", \"hide_delay\": 800, \"link\": \"\", \"ypos\": 65, \"i18n_labels\": &#123; \"fail\": \"\\u8bf7\\u6b63\\u786e\\u62fc\\u5408\\u56fe\\u50cf\", \"voice\": \"\\u89c6\\u89c9\\u969c\\u788d\", \"loading\": \"\\u52a0\\u8f7d\\u4e2d...\", \"feedback\": \"\\u5e2e\\u52a9\\u53cd\\u9988\", \"close\": \"\\u5173\\u95ed\\u9a8c\\u8bc1\", \"error\": \"\\u8bf7\\u91cd\\u8bd5\", \"logo\": \"\\u7531\\u6781\\u9a8c\\u63d0\\u4f9b\\u6280\\u672f\\u652f\\u6301\", \"slide\": \"\\u62d6\\u52a8\\u6ed1\\u5757\\u5b8c\\u6210\\u62fc\\u56fe\", \"cancel\": \"\\u53d6\\u6d88\", \"success\": \"sec \\u79d2\\u7684\\u901f\\u5ea6\\u8d85\\u8fc7 score% \\u7684\\u7528\\u6237\", \"refresh\": \"\\u5237\\u65b0\\u9a8c\\u8bc1\", \"read_reversed\": false, \"forbidden\": \"\\u602a\\u7269\\u5403\\u4e86\\u62fc\\u56fe\\uff0c\\u8bf7\\u91cd\\u8bd5\", \"tip\": \"\\u8bf7\\u5b8c\\u6210\\u4e0b\\u65b9\\u9a8c\\u8bc1\" &#125;, \"slice\": \"pictures/gt/d49a453dc/slice/655b485ef.png\", \"logo\": true, \"width\": \"100%\", \"feedback\": \"http://www.geetest.com/contact#report\", \"product\": \"embed\", \"height\": 160, \"https\": false, \"fullpage\": false&#125;) 响应的challenge值即为需要的 get.php请求发送了两次，两次的请求参数不一样，第一次的响应没有携带challenge值第一次是刷新 查看lang: 1234&gt; $_CAICh(111)\"lang\"&gt; i[$_CAICh(111)]\"zh-cn\" 查看pt: 1234&gt; $_CAICh(630)\"$_CDGy\"&gt; r[$_CAICh(630)]0 查看client_type: 1234&gt; $_CAICh(663)\"$_CDHI\"&gt; r[$_CAICh(663)]\"web\" 查看w: 1234var s = r[$_CAIBT(795)]() , a = AES[$_CAIBT(339)](gjson[$_CAICh(242)](i), r[$_CAICh(774)]()) , _ = Base64[$_CAICh(725)](a)w = _ + s 查看对应的值: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt; $_CAIBT(795)\"$_CIAc\"&gt; $_CAIBT(339)\"encrypt\"&gt; $_CAICh(725)\"$_BBAI\"&gt; $_CAICh(242)\"stringify\"&gt; $_CAICh(774)\"$_CIBb\"&gt; i&#123; \"lang\":\"zh-cn\", \"userresponse\":\"aa4a49166\", \"passtime\":610, \"imgload\":15915, \"aa\":\"Lw(!!Ktsyttstststsossts:sss(!!($*H2191111203/4/3827?-$-6\", \"ep\":&#123; \"v\":\"7.7.4\", \"te\":false, \"me\":true, \"tm\":&#123; \"a\":1600754998393, \"b\":1600754998444, \"c\":1600754998444, \"d\":0, \"e\":0, \"f\":1600754998398, \"g\":1600754998398, \"h\":1600754998398, \"i\":1600754998398, \"j\":1600754998398, \"k\":0, \"l\":1600754998419, \"m\":1600754998436, \"n\":1600754998438, \"o\":1600754998493, \"p\":1600755004551, \"q\":1600755004551, \"r\":1600755004553, \"s\":1600755004574, \"t\":1600755004574, \"u\":1600755004574 &#125;, \"td\":-1 &#125;, \"rp\":\"af19f9fedba491ac4c017780ca07db72\"&#125; 简单的反混淆后的代码： 1234var s = r.$_CIAc(), a = AES.encrypt(gjson.stringify(i), r.$_CIBb()), _ = Base64.$_BBAI(a)w = _ + s 获取s值的函数： 12&gt; r.$_CIAcƒ (t)&#123;var $_CBEGF=AGWEz.$_Cc,$_CBEFR=['$_CBEJN'].concat($_CBEGF),$_CBEHp=$_CBEFR[1];$_CBEFR.shift();var $_CBEIS=$_CBEFR[0];var e=new RSAKey()[$_CBEHp(339)](this[$_CBEHp(774)](t));while(!e||256!==e[$_CB… 点击函数可以跳转的函数对应的位置： 1234567891011\"\\u0024\\u005f\\u0043\\u0049\\u0041\\u0063\": function(t) &#123; var $_CBEGF = AGWEz.$_Cc , $_CBEFR = ['$_CBEJN'].concat($_CBEGF) , $_CBEHp = $_CBEFR[1]; $_CBEFR.shift(); var $_CBEIS = $_CBEFR[0]; var e = new RSAKey()[$_CBEHp(339)](this[$_CBEHp(774)](t)); while (!e || 256 !== e[$_CBEGF(124)]) e = new RSAKey()[$_CBEHp(339)](this[$_CBEGF(774)](!0)); return e;&#125; 翻译一下: 123456$_CIAc: function(t) &#123; var e = new RSAKey().encrypt(this.$_CIBb(t)); while (!e || 256 !== e.length) e = new RSAKey().encrypt(this.$_CIBb(true)); return e;&#125; 当var s = r.$_CIAc(), t == undefined 可以简化： 123$_CIAc: function() &#123; return new RSAKey().encrypt(this.$_CIBb(true));;&#125; this.$_CIBb 函数: 123456789101112131415161718192021function(t) &#123; var $_CBEBD = AGWEz.$_Cc , $_CBEA_ = ['$_CBEEQ'].concat($_CBEBD) , $_CBECX = $_CBEA_[1]; $_CBEA_.shift(); var $_CBEDZ = $_CBEA_[0]; return !0 === t &amp;&amp; (Ez = $_DJn()), Ez;&#125;// 翻译function(t) &#123; return true === t &amp;&amp; (Ez = $_DJn()), Ez;&#125;function $_DJn() &#123; return Gr() + Gr() + Gr() + Gr();&#125;function Gr() &#123; return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);&#125; 获取a值的函数： 1234a = AES.encrypt(gjson.stringify(i), r.$_CIBb())// 翻译a = AES.encrypt(gjson.stringify(i), randomKey()) 以中i的值: 123456789101112131415161718192021// r = $_GGL的实例i = &#123; \"\\u006c\\u0061\\u006e\\u0067\": o[$_CAIBT(111)] || $_CAIBT(198), \"\\u0075\\u0073\\u0065\\u0072\\u0072\\u0065\\u0073\\u0070\\u006f\\u006e\\u0073\\u0065\": $_DDc(t, o[$_CAIBT(128)]), \"\\u0070\\u0061\\u0073\\u0073\\u0074\\u0069\\u006d\\u0065\": n, \"\\u0069\\u006d\\u0067\\u006c\\u006f\\u0061\\u0064\": r[$_CAICh(790)], \"\\u0061\\u0061\": e, \"\\u0065\\u0070\": r[$_CAIBT(757)]()&#125;;i[$_CAICh(729)] = $_DCF(o[$_CAIBT(171)] + o[$_CAICh(128)][$_CAICh(62)](0, 32) + i[$_CAIBT(722)]);// 翻译i = &#123; lang: \"zh-cn\", userresponse: $_DDc(t, o.challenge), passtime: n, imgload: r.$_CGDi, aa: e, ep: r.$_CHJF()&#125;i.rp = $_DCF(o.gt) + o.challenge.slice(0, 32) + i.passtime o.challenge 是第二次请求get.php获取的challenge值e, n 来自函数参数， 通过 Call Stack 向上追踪 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185var a = n[$_CJHHV(844)] , _ = e ? n[$_CJHHV(999)][$_CJHHV(351)] : t[$_CJHHV(936)]() / a - n[$_CJHGj(935)] , u = e ? n[$_CJHHV(999)][$_CJHGj(385)] : n[$_CJHGj(995)] - t[$_CJHHV(945)]() / a;n[$_CJHHV(808)] = $_EGb() - n[$_CJHHV(937)], n[$_CJHHV(981)][$_CJHGj(994)]([Math[$_CJHHV(293)](_), Math[$_CJHHV(293)](u), n[$_CJHGj(808)]]);l = n[$_CJHHV(981)][$_CJHHV(980)](n[$_CJHHV(981)][$_CJHHV(903)](), n[$_CJHHV(24)][$_CJHHV(1071)], n[$_CJHGj(24)][$_CJHGj(343)]); // en[$_CJHHV(808)] // n// 翻译var a = n.$_DBBS // 1 , _ = e ? n.lastPoint.x : t.$_CCAe() / a - n.$_DDHK , u = e ? n.lastPoint.y : n.$_DDIF - t.$_CCBs() / a;n._DAAt = new Date().getTime - n.$_DDGR, n.$_DDJm.$_BHFA([Math.round(_), Math.round(u), n.$_DAAt);l = n.$_DDJm.$_BHGu(n.$_DDJm.$_BAJk(), n.$_IGz.c, n.$_IGz.s) // en.$_DAAt // n// 输出&gt; n.$_IGz.c(9) [12, 58, 98, 36, 43, 95, 62, 15, 12]&gt; n.$_IGz.s\"52657746\"&gt; n.$_DDHK567.26953125&gt; n.$_DDGR1600852141886\"\\u0024\\u005f\\u0042\\u0048\\u0047\\u0075\": function(t, e, n) &#123; var $_BEJGY = AGWEz.$_Cc , $_BEJF_ = ['$_BEJJh'].concat($_BEJGY) , $_BEJHQ = $_BEJF_[1]; $_BEJF_.shift(); var $_BEJIP = $_BEJF_[0]; if (!e || !n) return t; var r, o = 0, i = t, s = e[0], a = e[2], _ = e[4]; while (r = n[$_BEJHQ(283)](o, 2)) &#123; o += 2; var u = parseInt(r, 16) , c = String[$_BEJHQ(273)](u) , l = (s * u * u + a * u + _) % t[$_BEJHQ(124)]; i = i[$_BEJGY(283)](0, l) + c + i[$_BEJGY(283)](l); &#125; return i;&#125;// 翻译：// \"T(!!Gtttsyttsss(!!($)R5-6,30111$.b\", [12, 58, 98, 36, 43, 95, 62, 15, 12], \"52657746\"$_BHGu: function(aa, e, n) &#123; if (!e || !n) return aa; var r, index = 0, str = aa, s = e[0], a = e[2], _ = e[4]; while (r = n.substr(index, 2)) &#123; index += 2; var u = parseInt(r, 16) , c = String.fromCharCode(u) , l = (s * u * u + a * u + _) % aa.length; str = str.substr(0, l) + c + str.substr(l); &#125; return str;&#125;// \"\\u0024\\u005f\\u0042\\u0041\\u004a\\u006b\": function() &#123;$_BAJk: function() &#123; function n(t) &#123; var e = \"()*,-./0123456789:?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqr\", n = e.length, r = \"\", o = Math.abs(t), i = parseInt(o / n); n &lt;= i &amp;&amp; (i = n - 1), i &amp;&amp; (r = e.charAt(i)); var s = \"\"; return t &lt; 0 &amp;&amp; (s += \"!\"), r &amp;&amp; (s += \"$\", s + r + e.charAt(o %= n); &#125; var t = function(t) &#123; for (var e, n, r, o = [], i = 0, s = 0, a = t.length - 1; s &lt; a; s++) &#123; e = Math.round(t[s + 1][0] - t[s][0]), n = Math.round(t[s + 1][1] - t[s][1]), r = Math.round(t[s + 1][2] - t[s][2]), 0 == e &amp;&amp; 0 == n &amp;&amp; 0 == r || (0 == e &amp;&amp; 0 == n ? i += r : (o.push([e, n, r + i]), i = 0)); &#125; return 0 !== i &amp;&amp; o.push([e, n, i]), o; &#125;(this.$_BDA_), r = [], o = [], i = []; return new $_FAU(t).$_HFd(function(t) &#123; var e = function(t) &#123; for (var e = [ [1, 0], [2, 0], [1, -1], [1, 1], [0, 1], [0, -1], [3, 0], [2, -1], [2, 1] ], n = 0, r = e.length; n &lt; r; n++) if (t[0] == e[n][0] &amp;&amp; t[1] == e[n][1]) return \"stuvwxyz~\"[n]; return 0; &#125;(t); e ? o.push(e) : (r.push(n(t[0])), o.push(n(t[1]))), i.push(n(t[2])); &#125;), r.join(\"\") + \"!!\" + o.join(\"\") + \"!!\" + i.join(\"\");&#125;,function $_FAU(e) &#123; this.$_BHIa = e || [];&#125;// $_FAU.prototype.$_HFd// f 回调函数//\"\\u0024\\u005f\\u0048\\u0046\\u0064\": function(t) &#123;$_HFd: function(f) &#123; var e = this.$_BHIa; // 是 Array(26) if (e.map) return new $_FAU(e.map(f)); for (var n = [], r = 0, o = e.length; r &lt; o; r += 1) n[r] = f(e[r], r, this); return new $_FAU(n);&#125;,// 整理：$_BHGu: function(aa, e, n) &#123; if (!e || !n) return aa; var r, index = 0, str = aa, s = e[0], a = e[2], _ = e[4]; while (r = n.substr(index, 2)) &#123; index += 2; var u = parseInt(r, 16) , c = String.fromCharCode(u) , l = (s * u * u + a * u + _) % aa.length; str = str.substr(0, l) + c + str.substr(l); &#125; return str;&#125;// \"\\u0024\\u005f\\u0042\\u0041\\u004a\\u006b\": function() &#123;$_BAJk: function() &#123; function n(t) &#123; var e = \"()*,-./0123456789:?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqr\", n = e.length, r = \"\", o = Math.abs(t), i = parseInt(o / n); n &lt;= i &amp;&amp; (i = n - 1), i &amp;&amp; (r = e.charAt(i)); var s = \"\"; return t &lt; 0 &amp;&amp; (s += \"!\"), r &amp;&amp; (s += \"$\", s + r + e.charAt(o %= n); &#125; var t = function(t) &#123; for (var e, n, r, o = [], i = 0, s = 0, a = t.length - 1; s &lt; a; s++) &#123; e = Math.round(t[s + 1][0] - t[s][0]), n = Math.round(t[s + 1][1] - t[s][1]), r = Math.round(t[s + 1][2] - t[s][2]), 0 == e &amp;&amp; 0 == n &amp;&amp; 0 == r || (0 == e &amp;&amp; 0 == n ? i += r : (o.push([e, n, r + i]), i = 0)); &#125; return 0 !== i &amp;&amp; o.push([e, n, i]), o; &#125;(this.$_BDA_), r = [], o = [], i = []; return t.map(function(t) &#123; var e = function(t) &#123; for (var e = [ [1, 0], [2, 0], [1, -1], [1, 1], [0, 1], [0, -1], [3, 0], [2, -1], [2, 1] ], n = 0, r = e.length; n &lt; r; n++) if (t[0] == e[n][0] &amp;&amp; t[1] == e[n][1]) return \"stuvwxyz~\"[n]; return 0; &#125;(t); e ? o.push(e) : (r.push(n(t[0])), o.push(n(t[1]))), i.push(n(t[2])); &#125;), r.join(\"\") + \"!!\" + o.join(\"\") + \"!!\" + i.join(\"\");&#125;, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&gt; this.$_BDA_0: (3) [-36, -27, 0]1: (3) [0, 0, 0]2: (3) [1, 0, 226]3: (3) [3, 0, 233]4: (3) [6, 0, 241]5: (3) [6, 0, 249]6: (3) [7, 0, 257]7: (3) [9, 0, 265]8: (3) [10, 0, 274]9: (3) [11, 0, 283]10: (3) [12, 0, 289]11: (3) [13, 0, 299]12: (3) [14, 0, 305]13: (3) [15, 0, 316]14: (3) [16, 0, 321]15: (3) [17, 0, 333]16: (3) [18, 0, 338]17: (3) [20, 0, 350]18: (3) [21, 0, 354]19: (3) [22, 0, 367]20: (3) [23, 0, 370]21: (3) [24, 0, 383]22: (3) [25, 0, 386]23: (3) [25, 0, 394]24: (3) [26, 0, 402]25: (3) [26, 0, 412]26: (3) [27, 0, 418]27: (3) [27, 0, 427]28: (3) [28, 0, 434]29: (3) [28, 0, 443]30: (3) [28, 0, 450]31: (3) [28, 0, 475]32: (3) [29, 0, 533]33: (3) [29, 0, 588]length: 34&gt; t = t(this.$_BDA_)&gt; t0: (3) [36, 27, 0]1: (3) [1, 0, 226]2: (3) [2, 0, 7]3: (3) [3, 0, 8]4: (3) [1, 0, 16]5: (3) [2, 0, 8]6: (3) [1, 0, 9]7: (3) [1, 0, 9]8: (3) [1, 0, 6]9: (3) [1, 0, 10]10: (3) [1, 0, 6]11: (3) [1, 0, 11]12: (3) [1, 0, 5]13: (3) [1, 0, 12]14: (3) [1, 0, 5]15: (3) [2, 0, 12]16: (3) [1, 0, 4]17: (3) [1, 0, 13]18: (3) [1, 0, 3]19: (3) [1, 0, 13]20: (3) [1, 0, 3]21: (3) [1, 0, 16]22: (3) [1, 0, 16]23: (3) [1, 0, 16]24: (3) [1, 0, 99]25: (3) [0, 0, 55]length: 26 n.$_IGz.c: 第二次 get.php请求的 c属性 n.$_IGz.s: 第二次 get.php请求的 s属性 n._DAAt: 12345var a = n.$_DBBS // 1 , _ = e ? n.lastPoint.x : t.$_CCAe() / a - n.$_DDHK , u = e ? n.lastPoint.y : n.$_DDIF - t.$_CCBs() / a;n._DAAt = new Date().getTime - n.$_DDGR, n.$_DDJm.$_BHFA([Math.round(_), Math.round(u), n.$_DAAt); 1234567891011121314151617181920212223// \"\\u0024\\u005f\\u0043\\u0043\\u0041\\u0065\": function() &#123;$_CCAe: function() &#123; var t = this.$_BBIM; // PointerEvent &#123;isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0.5, …&#125; if (\"number\" == typeof (t.clientX)) return t.clientX; var e = t.changedTouches &amp;&amp; t.changedTouches[0]; return e ? e.clientX : -1;&#125;,// \"\\u0024\\u005f\\u0043\\u0043\\u0042\\u0073\": function() &#123;$_CCBs: : function() &#123; var t = this.$_BBIM; // PointerEvent &#123;isTrusted: true, pointerId: 1, width: 1, height: 1, pressure: 0, …&#125; if (\"number\" == typeof (t.clientY)) return t.clientY; var e = t.changedTouches &amp;&amp; t.changedTouches[0]; return e ? e.clientY : -1;&#125;,// \"\\u0024\\u005f\\u0042\\u0048\\u0046\\u0041\": function(t) &#123;// t -&gt; [22, -2, 8911]$_BHFA: function(t) &#123; return this.$_BDA_.push(t), this; // &#125;, 猜测 鼠标落下时事件的值:n.$_DDHK 就是获取 PointerEvent的clientXn.$_DDIF 就是获取 PointerEvent的clientYn.$_DDGR 是new Date().getTime 整理： 12345678910111213141516171819202122i = &#123; lang: \"zh-cn\", userresponse: $_DDc(t, o.challenge), passtime: n, imgload: r.$_CGDi, aa: e, ep: r.$_CHJF()&#125;i.rp = $_DCF(o.gt) + o.challenge.slice(0, 32) + i.passtimevar s = new RSAKey().encrypt(randomKey()), a = AES.encrypt(gjson.stringify(i), randomKey()), _ = Base64.$_BBAI(a)w = _ + s function randomKey() &#123; return Gr() + Gr() + Gr() + Gr();&#125;function Gr() &#123; return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);&#125; 滑块 js逆向技巧分享 极验验证码破解之selenium 极验证码识别http接口(打码平台) 极验证码文档 极验验证码破解 反爬经验 学web安全去哪里找各种各样的靶场？ CTF-Platforms JS逆向：极验滑块验证码加密分析 夜幕爬虫安全论坛 尼古拉斯 赵四大神的博客","categories":[{"name":"Crawler","slug":"Crawler","permalink":"https://jigangduan.github.io/categories/Crawler/"},{"name":"Python","slug":"Crawler/Python","permalink":"https://jigangduan.github.io/categories/Crawler/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://jigangduan.github.io/tags/爬虫/"}]},{"title":"反爬 __验证码类型__ 分析过程","slug":"geetest-type","date":"2020-09-12T14:12:30.000Z","updated":"2020-10-23T23:32:03.083Z","comments":true,"path":"2020/09/12/geetest-type/","link":"","permalink":"https://jigangduan.github.io/2020/09/12/geetest-type/","excerpt":"","text":"某企业信用信息 使用了极限验证码，包括 滑块和点选 验证，这里尝试分析滑块验证 极限文档 准备工作搭建极限 demo 环境 下载 demo 1git clone https://github.com/GeeTeam/gt3-server-python-flask-sdk.git 运行 demo 123cd gt3-server-python-flask-sdksudo pip install -r requirements.txtsudo python3 app.py 在浏览器中访问http://localhost:5000即可看到demo界面。 js反混淆请求文件中fullpage.9.0.0.js 和 slide.7.7.4.js 是经过代码混淆的，我们先对其进行反混淆。 反混淆是AST(抽象语法树)的方式进行代码的修改，AST使用 bable bable 工程搭建我们直接引用bable相关库，使用代码的方式进行工作。 首先安装bable相关库: 1yarn add @babel/&#123;parser,traverse,types,generator&#125; -D 简单运行一个模版文件，看能不能正常运行: 1234567891011121314151617181920212223242526272829303132333435const generator = require('@babel/generator');const parser = require(\"@babel/parser\");const traverse = require(\"@babel/traverse\");const t = require(\"@babel/types\");function compile(code) &#123; // 1. parse const ast = parser.parse(code); // 2. traverse const visitor = &#123; CallExpression(path) &#123; const &#123; callee &#125; = path.node; if (t.isMemberExpression(callee) &amp;&amp; callee.object.name === 'console' &amp;&amp; callee.property.name === 'log') &#123; const funcPath = path.findParent(p =&gt; p.isFunctionDeclaration()); path.node.arguments.unshift(t.stringLiteral(`[$&#123;funcPath.node.id.name&#125;]`)); &#125; &#125; &#125;; traverse.default(ast, visitor); // 3. generate return generator.default(ast, &#123; /* options */ &#125;, code);&#125;const code = `function foo(params) &#123; console.log('bar');&#125;`;const result = compile(code);console.log(result.code); 运行: 1234&gt; node index.jsfunction foo(params) &#123; console.log(\"[foo]\", 'bar');&#125; AST反混淆fullpage.9.0.0.js首先使用beautifier对代码进行美化一下 js文件代码中有eval相关语句 12345678eval(qFPY(535) + obj + pdkg(501))eval(QgmM(535) + text + QgmM(501))eval(AojHo.DoT(1559));eval(AojHo.DoT(1596));eval(AojHo.DoT(1569));eval(AojHo.DoT(1521));eval(AojHo.DoT(1518));eval(AojHo.DoT(1560)); 调试可以得到相关内容： 12345678910111213141516&gt; AojHo.DoT(535)\"(\"&gt; AojHo.DoT(501)\")\"&gt; AojHo.DoT(1559)\"var ZAIc=AojHo.DoT,YwQmXB=['cgKSx'].concat(ZAIc),aUfu=YwQmXB[1];YwQmXB.shift();var bKyE=YwQmXB[0];if(e[ZAIc(1300)]===true)&#123;return;&#125;e[ZAIc(1300)]=true;e[ZAIc(1325)]();\"&gt; AojHo.DoT(1596)\"var jEBf=AojHo.DoT,ioGlKk=['mDVyD'].concat(jEBf),kuip=ioGlKk[1];ioGlKk.shift();var lFYm=ioGlKk[0];PuTO(e[jEBf(1340)]);if(!e[kuip(1318)]&amp;&amp;e[jEBf(1302)])&#123;e[kuip(1340)]=OvZL(function()&#123;var oTmT=AojHo.DoT,nVmzEQ=['rAIfE'].concat(oTmT),pJtT=nVmzEQ[1];nVmzEQ.shift();var qSAl=nVmzEQ[0];e[pJtT(1318)]=true;e[oTmT(1251)][oTmT(668)]();e[oTmT(1325)]();&#125;,2e3);&#125;else if(!e[kuip(1318)]&amp;&amp;e[kuip(1349)]&amp;&amp;!e[jEBf(1315)])&#123;e[kuip(1315)]=true;e[jEBf(1340)]=OvZL(function()&#123;var tkME=AojHo.DoT,sGBWXk=['wGaIz'].concat(tkME),uXIp=sGBWXk[1];sGBWXk.shift();var vdBD=sGBWXk[0];e[tkME(1325)]();&#125;,500);&#125;else&#123;e[kuip(1300)]=false;e[kuip(1315)]=false;e[kuip(1200)]();&#125;\"&gt; AojHo.DoT(1569)\"var EUts=AojHo.DoT,DncKMW=['HOYYd'].concat(EUts),FFNm=DncKMW[1];DncKMW.shift();var GaAn=DncKMW[0];r[FFNm(112)]=e[EUts(112)];r[FFNm(107)]=e[EUts(107)];r[EUts(203)]=e[EUts(203)]||FFNm(193);r[EUts(133)]=t[FFNm(1273)];r[FFNm(1328)]=t[EUts(1261)];r[EUts(607)]=t[EUts(1386)];\"&gt; AojHo.DoT(1521)\"var JuFF=AojHo.DoT,IQAxxl=['MMmxz'].concat(JuFF),KGvV=IQAxxl[1];IQAxxl.shift();var LrZb=IQAxxl[0];nAGc(t[JuFF(259)],ZDoq[JuFF(152)](JuFF(1370)),r)[JuFF(28)](function(e)&#123;var OTWD=AojHo.DoT,NVcCAn=['RmxTS'].concat(OTWD),PDmr=NVcCAn[1];NVcCAn.shift();var QMQO=NVcCAn[0];if(e[OTWD(67)]===oWfH)&#123;return FEDB(DZue(e,t,OTWD(1331)));&#125;t[OTWD(1390)](e[OTWD(310)]);&#125;,function()&#123;var TPhp=AojHo.DoT,SALdfO=['Wq_aL'].concat(TPhp),UmIM=SALdfO[1];SALdfO.shift();var VOfk=SALdfO[0];return FEDB(CvFn(UmIM(1385),t));&#125;);\"&gt; AojHo.DoT(1518)\"var dnCX=AojHo.DoT,clKCMn=['gSjXV'].concat(dnCX),eJPX=clKCMn[1];clKCMn.shift();var flRB=clKCMn[0];var e=_[dnCX(1222)][eJPX(1095)]();var t=_[eJPX(1222)][eJPX(1319)]();var r=_[eJPX(1247)][dnCX(1319)]();var n=_[dnCX(1272)][eJPX(1095)]();var i=_[dnCX(259)];var o=lgpy()-Nnni;_[dnCX(1350)]=eJPX(95);var a=[[dnCX(203),i[dnCX(203)]||eJPX(193)],[dnCX(284),eJPX(1399)],[eJPX(1353),tMcx(e,i[eJPX(681)],i[dnCX(274)])||-1],[eJPX(1310),n||-1],[eJPX(274),sdFN(ZDoq[eJPX(731)](t))],[eJPX(1375),sdFN(ZDoq[dnCX(731)](r))],[eJPX(1317),sdFN(r)],[eJPX(1303),sdFN(_[dnCX(1212)])],[dnCX(1341),_[eJPX(1341)]||-1],[eJPX(1345),_[dnCX(1345)]||-1],[eJPX(1364),_[eJPX(1346)]()||-1],[dnCX(1379),o||-1],[eJPX(1378),sdFN(i[eJPX(112)]+i[eJPX(107)]+o)]];for(var s=0;s&lt;a[eJPX(43)];s++)&#123;_[dnCX(1350)]+=eJPX(571)+a[s][0]+dnCX(587)+yoVX[dnCX(80)](a[s][1])+dnCX(576);&#125;\"&gt; AojHo.DoT(1560)\"var iLEU=AojHo.DoT,hYtVmn=['lUtzp'].concat(iLEU),johT=hYtVmn[1];hYtVmn.shift();var kfeu=hYtVmn[0];var r=EcBk();function HyII()&#123;var DFV=AojHo.EsV()[0][7];for(;DFV!==AojHo.EsV()[3][6];)&#123;switch(DFV)&#123;case AojHo.EsV()[0][7]:var t=[johT(1366)];return function(e)&#123;var neYH=AojHo.DoT,mleLzP=['qmxxX'].concat(neYH),oV_n=mleLzP[1];mleLzP.shift();var pNOV=mleLzP[0];t[neYH(69)](e[neYH(155)]());var IhbN=oV_n(95);(function addHash(e,t)&#123;var sUwm=AojHo.DoT,rICcKm=['vHniQ'].concat(sUwm),tjnR=rICcKm[1];rICcKm.shift();var uUeH=rICcKm[0];function JYxL(e)&#123;var ETt=AojHo.EsV()[3][7];for(;ETt!==AojHo.EsV()[0][6];)&#123;switch(ETt)&#123;case AojHo.EsV()[3][7]:var t=5381;var r=e[sUwm(43)],n=0;while(r--)&#123;t=(t&lt;&lt;5)+t+e[tjnR(23)](n++);&#125;t&amp;=~(1&lt;&lt;31);return t;break;&#125;&#125;&#125;new Date()[tjnR(332)]()-t[sUwm(332)]()&gt;100&amp;&amp;(e=tjnR(1311));IhbN=sUwm(512)+_[sUwm(1350)]+tjnR(1377)+JYxL(addHash[tjnR(155)]()+JYxL(JYxL[tjnR(155)]())+JYxL(e[tjnR(155)]()))+sUwm(571)+tjnR(536);&#125;(t[neYH(1283)](),new Date()));_[oV_n(1386)]=ZDoq[oV_n(1287)](r[neYH(388)](IhbN,_[oV_n(1223)]()));&#125;;break;&#125;&#125;&#125;_[iLEU(1362)]=HyII();_[iLEU(1362)](johT(95));_[iLEU(1362)](iLEU(1376));_[johT(1362)](johT(1342));_[iLEU(1362)](johT(1363));_[johT(1362)](iLEU(1314));\" 直接使用 内容替换。 AST去掉unicode格式的编码代码中很多unicode格式的函数命名 12&gt; \"\\u0064\\u0079\\u0048\\u006a\"\"dyHj\" 在ast在线编辑网站astexplorer上可以看到unicode编码就是因为有extra这个属性，我们只需把这个属性删掉，就能展示原来的值了（16进制同理） 注意，astexplorer 网站上的解析器选择@babel/parser 实现代码，如下： 123456789101112131415161718192021222324252627282930313233const generator = require('@babel/generator');const parser = require(\"@babel/parser\");const traverse = require(\"@babel/traverse\");const t = require(\"@babel/types\");const fs = require('fs');var jscode = fs.readFileSync(\"../clone/fullpage.9.0.0-no_eval.js\", &#123; encoding: \"utf-8\"&#125;);function replace_unicode(path) &#123; delete path.node.extra;&#125;function compile(code) &#123; // 1. parse const ast = parser.parse(code); // 2. traverse const visitor = &#123; StringLiteral: &#123; enter: [replace_unicode] //遍历所有StringLiteral属性 &#125; &#125;; traverse.default(ast, visitor); // 3. generate return generator.default(ast, &#123; /* options */ &#125;, code);&#125;const result = compile(jscode);// console.log(result.code);fs.writeFile('../clone/fullpage.9.0.0-out.js', result.code, (err) =&gt; &#123;&#125;); 查看输出文件，还有两处正则表达式的unicode没有修改 12var Etot = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;var FQoK = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; 里面是一些特殊符号我们先不管它。 AojHo.DoT 字符串编码1AojHo.DoT = function () &#123; ... &#125; 代码中很多AojHo.DoT(n)，主要是传参一个数值，返回一段字符串 12&gt; AojHo.DoT(0)\"dyrk\" 它像是保存字符串的数组。代码中对象属性使用这种方式。 AojHo.DoT 有两种用法，一种是直接用，一种是间接用我们先看看直接使用的 看看AST的结构: 思路就是这样: 123456789101112131415161718192021222324252627function replace_DoT(path)&#123; var node = path.node; if(node.callee == undefined || node.callee.property ==undefined ) return; if (node.callee.property.name == \"DoT\")&#123; let arg = node.arguments[0].value; let value = AojHo.DoT(arg); PathToLiteral(path,value) &#125;&#125;function PathToLiteral(path,value)&#123; switch (typeof value) &#123; case 'boolean': path.replaceWith(t.booleanLiteral(value)); break; case 'string': path.replaceWith(t.stringLiteral(value)); break; case 'number': path.replaceWith(t.numericLiteral(value)); break; default: console.log(\"出现其他类型\" + value + \"类型:\" +typeof value); console.log(value); break &#125;&#125; 这样AojHo.DoT直接使用的被替换了 但在函数体里面还有很多间接使用的: 12345var AemB = AojHo.DoT, yikWjA = [\"DH_Ev\"].concat(AemB), BmSB = yikWjA[1];yikWjA.shift();var CFhI = yikWjA[0]; 给很多随机名称的变量赋值后，在通过这个变量去拿数组中的真实值 1AojHo.DoT === AemB === BmSB === CFhI // TODO AojHo.EsV 控制流平坦化// TODO Chrome插件ReRes 验证 关于ReRes： 能够根据特定url规则拦截符合规则的网页资源，并让网页加载用户自己指定的某个地址的资源。 使用例子： 当网站读取 foo.com/bar.js 资源时，使其加载自己本地电脑上的 file:///d:/reres/foo.com/bar.js 文件，以此实现修改网站js代码功能的能力。 对比TamperMonkey： TamperMonkey可以直接输入js代码到网页中，但TamperMonkey某些情况下会出现注入无效的问题（可能是网站有反注入机制，原因不明） 并且在使用网页自带的全局变量时不方便（如在页面加载后N秒才会加载的一些脚本为网页添加的变量），ReRes避开了这个问题 此外ReRes不仅仅可以拦截.js，也可以拦截.css或者.jpg等文件，实现较丰富的DIY 关于Stylus： 如果懒得使用ReRes拦截，就使用Stylus来进行css的修改，这是一款可以方便地注入自己的css到网页的插件。 注意，需要在chrome 打开ReRes 访问文件网站的权限 JS追踪验证类型追踪点击验证按钮，会请求相应类型的js文件，比如 点选图片验证 的需求/static/js/click.2.9.3.js 发出请求后，在Chrome devtool 中查看 Network 上相关请求的Initiator 找到相应的调用栈 最后可以追踪到 发现存储在 UI.yZmO 中: 1234&gt; e[\"yZmO\"]\"click\"&gt; eUI &#123;SrUd: Rvdq, LetQ: Gchs, vLVR: KoNj, uwIQ: Config, uIED: &#123;…&#125;, …&#125; 在yZmO被赋值的地方设置断点 UI.yZmO &lt;== Gchs.yZmO 来自于第一次 ajax.php请求的返回 123456789101112131415Request URL: http://api.geetest.com/ajax.php?gt=c9c4facd1a6feeb80802222cbb74ca8e&amp;challenge=79bb431287f4764279352c3366223bff&amp;lang=zh-cn&amp;pt=0&amp;client_type=web&amp;w=F03AGaPlz4FsAto3NTZQ05Q5qowONcavPHAkO8u3eAWHmdHqQmw9iehH6zIkDY2bCdenq5t1moPyoT6wJKE2dT6onvGf1ZCqYw8ycrumKDzIkQGnvI3XFFX8cixtumkTu6VVIxgG1cW5bm)lCUaCTt1iEmy4FimZ0jYjEk)lzHSg18Np)943cDmgj)1unS9BGqIigGDIWtBZMf5j9No0rZ4yAirUReaFaZFRo2KPYZ8mFeChkM56o0OXrSzDpJxiqSDAB0CoUPhggZI9NW82IXZ)O(Ep49CF9PATlTYsTm)vRjwuu9yqn69heuohUT1Ko9KBbCgQJpOBGrUlKGALxkT7PLATO3rpoA3G4nVJbpcf06u3hndJhAQGVdhclG03MN909MmxHv9ahWcsyZcs8tQAMyt4p)y1Z7xjPjZv4v9YZWt7OgogKvaoYbLb))J5rSZKXWYPD4xJyE2xyzzqv387KUYNskM(f9(qBcSKn1WIzXPUlTaIwVKWNaRQDw22Tf0xcwhsjc9ctce25x3E3MzdO8yTHoHag33)J5JQkONZ1Qo9BqbqiBQ5FnXGqVWs3UybxAA9bc3GSzGhhuCUrL4XSbWZEomIW0Y9b7Xnj6iKVbhwxiFBhUqbTe7kqOdJ3NX8ntaeOU9VL8Nvjf1M1E3)UplRGUUWbstIlwPOZjUJx8byJeXfQgEWtxHC7A4PeabO8pHAoVs9W4xRkTEowKUAYaCNAOUIaTZgEP5cwH3tWDdwJLkaVoH1SEcbTHj7AyopZwXwj0H7yCczDCP2cSSr5hjGNkBBU(7Y9HPf1vYTImKGzCJ)TX0TGtwgNy(QVVyDnl0Ton)c5)oyRzAfiQZ6)fQVWTe6MkLK7Sz(Mjz7vTS8Q5X6rSFL6YEGvhdF5vv(vV9gqlT5OOqNMnRskMmFWGyE4CC5Z7KGfBJ8JGNIpTOvdmA6wthjGoI4D)uVCME7tM((ikBAIv0yQ1aYh(yTOUjLwa)3xudmXiLYddOPR6dzkHpgvg5uT5IMPWjvjZlJsQJWk8Q9Ga(XUwrdiMRFknmuDdEHYagrCjUzsPqGf1QyNQUop5dFdyaYcZ55IN258FSKI7DF2lqsG7OkWlhsCOxUSX1JYeG8ZLFWjPz71TJMc7rzu8zLGEbsClnLp1Dw)UFYKwh2xAE6GKaeMv4zkgYSfDxx3MpNTqXjIPt4adz9)0BF7mNGZ)uKctYiQltMWKk4JjX1ftJD)9QwAFFEkk2pzPHOGkd2S800RISB6x4l(4mqPB(8pQ4kdMQBZNeTz8kPSbQywA8xLnoog7j2vu6w9o6OclRJWt1l5hndUYZr52epjqPuPJ6(hgOqd(hQyktZDRWJvYXZK39f3LrH3vWAOKxEv1ffqP3uQTziLZYaE7X5UQ2BjlaN8AbW1BFaMe3IFHIOrHuBVNiT1B4LIwBnlLBoBn)pSWatQuacGHqPx9eDTPDFPwz4PnIioYeKkDlhXZ2YnuLTL6lBRnycN4LziLXzm)MexYVjl24.&amp;callback=geetest_1601011261270Request Method: GETStatus Code: 200 OKQuery Parameters:gt: c9c4facd1a6feeb80802222cbb74ca8echallenge: 79bb431287f4764279352c3366223bfflang: zh-cnpt: 0client_type: webw: F03AGaPlz4FsAto3NTZQ05Q5qowONcavPHAkO8u3eAWHmdHqQmw9iehH6zIkDY2bCdenq5t1moPyoT6wJKE2dT6onvGf1ZCqYw8ycrumKDzIkQGnvI3XFFX8cixtumkTu6VVIxgG1cW5bm)lCUaCTt1iEmy4FimZ0jYjEk)lzHSg18Np)943cDmgj)1unS9BGqIigGDIWtBZMf5j9No0rZ4yAirUReaFaZFRo2KPYZ8mFeChkM56o0OXrSzDpJxiqSDAB0CoUPhggZI9NW82IXZ)O(Ep49CF9PATlTYsTm)vRjwuu9yqn69heuohUT1Ko9KBbCgQJpOBGrUlKGALxkT7PLATO3rpoA3G4nVJbpcf06u3hndJhAQGVdhclG03MN909MmxHv9ahWcsyZcs8tQAMyt4p)y1Z7xjPjZv4v9YZWt7OgogKvaoYbLb))J5rSZKXWYPD4xJyE2xyzzqv387KUYNskM(f9(qBcSKn1WIzXPUlTaIwVKWNaRQDw22Tf0xcwhsjc9ctce25x3E3MzdO8yTHoHag33)J5JQkONZ1Qo9BqbqiBQ5FnXGqVWs3UybxAA9bc3GSzGhhuCUrL4XSbWZEomIW0Y9b7Xnj6iKVbhwxiFBhUqbTe7kqOdJ3NX8ntaeOU9VL8Nvjf1M1E3)UplRGUUWbstIlwPOZjUJx8byJeXfQgEWtxHC7A4PeabO8pHAoVs9W4xRkTEowKUAYaCNAOUIaTZgEP5cwH3tWDdwJLkaVoH1SEcbTHj7AyopZwXwj0H7yCczDCP2cSSr5hjGNkBBU(7Y9HPf1vYTImKGzCJ)TX0TGtwgNy(QVVyDnl0Ton)c5)oyRzAfiQZ6)fQVWTe6MkLK7Sz(Mjz7vTS8Q5X6rSFL6YEGvhdF5vv(vV9gqlT5OOqNMnRskMmFWGyE4CC5Z7KGfBJ8JGNIpTOvdmA6wthjGoI4D)uVCME7tM((ikBAIv0yQ1aYh(yTOUjLwa)3xudmXiLYddOPR6dzkHpgvg5uT5IMPWjvjZlJsQJWk8Q9Ga(XUwrdiMRFknmuDdEHYagrCjUzsPqGf1QyNQUop5dFdyaYcZ55IN258FSKI7DF2lqsG7OkWlhsCOxUSX1JYeG8ZLFWjPz71TJMc7rzu8zLGEbsClnLp1Dw)UFYKwh2xAE6GKaeMv4zkgYSfDxx3MpNTqXjIPt4adz9)0BF7mNGZ)uKctYiQltMWKk4JjX1ftJD)9QwAFFEkk2pzPHOGkd2S800RISB6x4l(4mqPB(8pQ4kdMQBZNeTz8kPSbQywA8xLnoog7j2vu6w9o6OclRJWt1l5hndUYZr52epjqPuPJ6(hgOqd(hQyktZDRWJvYXZK39f3LrH3vWAOKxEv1ffqP3uQTziLZYaE7X5UQ2BjlaN8AbW1BFaMe3IFHIOrHuBVNiT1B4LIwBnlLBoBn)pSWatQuacGHqPx9eDTPDFPwz4PnIioYeKkDlhXZ2YnuLTL6lBRnycN4LziLXzm)MexYVjl24.callback: geetest_1601011261270Response:geetest_1601011261270(&#123;&quot;status&quot;: &quot;success&quot;, &quot;data&quot;: &#123;&quot;result&quot;: &quot;slide&quot;&#125;&#125;) 修改验证类型试试: 12345678910\"AnzP\": function (e) &#123; var t = this; var r = t[\"$\"]; var n = t[\"vLVR\"]; var i = t[\"SrUd\"]; // t[\"yZmO\"] = e; t.yZmO = \"slide\"; ...&#125; 修改后： 点选验证的时候 验证会出不来 感应验证不走这里 所以，不能直接修改验证类型 追踪ajax.php请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647\"NyMy\": function (e) &#123; var t = this; if (!t[\"vLVR\"][\"aeskey\"] || e) &#123; t[\"vLVR\"][\"aeskey\"] = jKCV(); &#125; return t[\"vLVR\"][\"aeskey\"];&#125;,var jKCV = function () &#123; function S4() &#123; return ((1 + Math[\"random\"]()) * 65536 | 0)[\"toString\"](16)[\"substring\"](1); &#125; return function () &#123; return S4() + S4() + S4() + S4(); &#125;;&#125;();function HyII() &#123; var t = [\"bbOy\"]; return function (e) &#123; t[\"push\"](e[\"toString\"]()); var IhbN = \"\"; (function addHash(e, t) &#123; function JYxL(e) &#123; var t = 5381; var r = e[\"length\"], n = 0; while (r--) &#123; t = (t &lt;&lt; 5) + t + e[\"charCodeAt\"](n++); &#125; t &amp;= ~(1 &lt;&lt; 31); return t; &#125; new Date()[\"getTime\"]() - t[\"getTime\"]() &gt; 100 &amp;&amp; (e = \"qwe\"); IhbN = \"&#123;\" + _[\"gMyn\"] + \"\\\"captcha_token\\\":\\\"\" + JYxL(addHash[\"toString\"]() + JYxL(JYxL[\"toString\"]()) + JYxL(e[\"toString\"]())) + \"\\\"\" + \"&#125;\"; &#125;)(t[\"shift\"](), new Date()); _[\"evlb\"] = ZDoq[\"gove\"](r[\"encrypt\"](IhbN, _[\"NyMy\"]())); &#125;;&#125; _[&quot;NyMy&quot;]() 对应的值(早就生成好了,存储在KoNj的aeskey属性中): 123456&gt; t.vLVR.aeskey\"6d6aeecb5d4e5647\"&gt; t.vLVRKoNj &#123; ... &#125;&gt; IhbN\"&#123;\"lang\":\"zh-cn\",\"type\":\"fullpage\",\"tt\":\"M-h8Pjp8N:3(@9(9-AQ)A99(BAA(::()-9(.(E:F*Dbc@cjFAB-2./.6Z)-C0Lp0UC?AK)5?-c/Z99-n7C.8-:S?cn7D/D-N-ED,g)(:fV.5/:5?p)M*o(-f((n(9cb,((85ifjT:XU-61hOe/,bE4)(96E.Jl),i/E-3jAS))jc4F?M9/0()N1(E-(((j((,Mq*k55I(q8b(,bbb8ne69M925M9Km:G))/-RbE4)ME/(/,M1-)MM(N2)An-*b9-)M9(?bE-N,)(E-(bC9/)()M9(E/((Lqq\",\"light\":\"DIV_0\",\"s\":\"c7c3e21112fe4f741921cb3e4ff9f7cb\",\"h\":\"a178bb3fcf33918eda2cf5b882a53091\",\"hh\":\"13c3753ac17e20c349344bce7d8f04e6\",\"hi\":\"03b38445dba1cf046d4ad55a36a87339\",\"vip_order\":-1,\"ct\":-1,\"ep\":&#123;\"v\":\"9.0.0\",\"de\":false,\"te\":false,\"me\":true,\"ven\":\"Intel Inc.\",\"ren\":\"Intel(R) Iris(TM) Graphics 6100\",\"fp\":[\"move\",125,53,1601022140801,\"pointermove\"],\"lp\":[\"up\",503,78,1601022142895,\"pointerup\"],\"em\":&#123;\"ph\":0,\"cp\":0,\"ek\":\"11\",\"wd\":0,\"nt\":0,\"si\":0,\"sc\":0&#125;,\"tm\":&#123;\"a\":1601022137903,\"b\":1601022137961,\"c\":1601022137961,\"d\":0,\"e\":0,\"f\":1601022137907,\"g\":1601022137907,\"h\":1601022137907,\"i\":1601022137907,\"j\":1601022137907,\"k\":0,\"l\":1601022137927,\"m\":1601022137944,\"n\":1601022137947,\"o\":1601022137969,\"p\":1601022138181,\"q\":1601022138181,\"r\":1601022138214,\"s\":1601022138248,\"t\":1601022138248,\"u\":1601022138248&#125;,\"by\":0&#125;,\"passtime\":4270,\"rp\":\"c7b740399e3b941a851a3099ddfa6d27\",\"captcha_token\":\"987243730\"&#125;\" 修改代码captcha_token给固定值987243730试试，是可以正常验证的 看看_.gMyn: 整理后的： pxDM = 300 1234567891011121314151617181920212223242526var e = _[\"sWVy\"][\"xMxC\"]();var t = _[\"sWVy\"][\"yhrd\"]();var r = _[\"lVwU\"][\"yhrd\"]();var n = _[\"KLSY\"][\"xMxC\"]();var i = _[\"vLVR\"];var o = currentTimeMillis() - startTime;_[\"gMyn\"] = \"\";var a = [ [\"lang\", \"zh-cn\"], [\"type\", \"fullpage\"], [\"tt\", tMcx(e, i.c, i.s) || -1], [\"light\", n || -1], [\"s\", sdFN(ZDoq.fXPz(t))], [\"h\", sdFN(ZDoq.fXPz(r))], [\"hh\", sdFN(r)], [\"hi\", sdFN(_[\"Lg_n\"])], [\"vip_order\", -1], [\"ct\", -1], [\"ep\", _[\"hfAl\"]() || -1], [\"passtime\", o || -1], [\"rp\", sdFN(i.gt + i.challenge + o)]];for (var s = 0; s &lt; a.length; s++) &#123; _.gMyn += \"\\\"\" + a[s][0] + \"\\\":\" + yoVX.stringify(a[s][1]) + \",\";&#125; tMcx, sdFN, ZDoq.fXPz 都是 编码方式 1234567function HyII() &#123; return function (e) &#123; var word = \"&#123;\" + _.gMyn + \"\\\"captcha_token\\\":\\\"\" + \"987243730\" + \"\\\"\" + \"&#125;\"; var aeskey = _.NyMy(); _.evlb = ZDoq.gove(r.encrypt(word, aeskey)); &#125;;&#125; 参考： AST 团队分享 JS反混淆|AST突破极验JS反混淆 JS逆向：AST还原极验混淆JS实战 Python爬虫进阶必备 | 关于 ReRes 的一篇教程 工具： astexplorer beautifier 扩展： JS逆向抓取 | 安卓群控抓取 | APP逆向抓取 | 爬虫社会工程 | 52讲轻松搞定网络爬虫","categories":[{"name":"Crawler","slug":"Crawler","permalink":"https://jigangduan.github.io/categories/Crawler/"},{"name":"Python","slug":"Crawler/Python","permalink":"https://jigangduan.github.io/categories/Crawler/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://jigangduan.github.io/tags/爬虫/"}]},{"title":"反爬(某企业信用信息) Js逆向分析过程","slug":"gsxtgov","date":"2020-09-11T08:20:33.000Z","updated":"2020-10-23T23:31:29.469Z","comments":true,"path":"2020/09/11/gsxtgov/","link":"","permalink":"https://jigangduan.github.io/2020/09/11/gsxtgov/","excerpt":"","text":"请先关闭 ROBOTSTXT_OBEY 如果 ROBOTSTXT_OBEY 是打开的，下载器会先请求 http://www.gsxt.gov.cn/robots.txt, 第一次请求会被服务器携带 Set-Cookie 用 scrapy shell 启动第一次请求携带User-Agent 头: 1scrapy shell -s USER_AGENT=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0\" 'http://www.gsxt.gov.cn/' 分析响应： Header: Set-Cookie 12&gt;&gt;&gt; response.headers['Set-Cookie']b'__jsluid_h=f088bf0fa4b4588e67d2978a7d0f294c; max-age=31536000; path=/; HttpOnly' 1jsluid_h = response.headers['Set-Cookie'].decode('utf-8').split('=')[1].split(';')[0] body 12&gt;&gt;&gt; view(response)True 1234&lt;script&gt; document.cookie=('_')+('_')+('j')+('s')+('l')+('_')+('c')+('l')+('e')+('a')+('r')+('a')+('n')+('c')+('e')+('=')+(-~&#123;&#125;+'')+(6+'')+(~~false+'')+((+false)+'')+(-~[2]+'')+((2^1)+'')+((1|2)+'')+(-~(4)+'')+(0+1+0+1+'')+(~~&#123;&#125;+'')+('.')+(6+'')+('|')+('-')+(-~[]+'')+('|')+('t')+('A')+('i')+('Q')+('L')+('L')+('f')+(1+6+'')+('k')+('d')+('c')+('f')+('Y')+('N')+('f')+('b')+('J')+('Z')+(9-1*2+'')+('f')+('R')+('Q')+('O')+('o')+('M')+('g')+('c')+('%')+((1+[2]&gt;&gt;2)+'')+('D')+(';')+('m')+('a')+('x')+('-')+('a')+('g')+('e')+('=')+((1|2)+'')+(';')+('p')+('a')+('t')+('h')+('=')+('/'); location.href=location.pathname+location.search&lt;/script&gt; 解析： 12345678import execjsjs_src = response.css('script::text').get()js_func_body = js_src.replace('document.cookie', 'let cookie').replace('location.href=location.pathname+location.search', 'return cookie;')js_func = 'function getCookie() &#123;' + js_func_body + '&#125;'jscontext = execjs.compile(js_func)cookie_str = jscontext.call(\"getCookie\")jsl_clearance = cookie_str.split('=')[1].split(';')[0] 整理： 123456789101112import execjsdef getJsCookie1T(self, response): jsluid_h = response.headers['Set-Cookie'].decode('utf-8').split('=')[1].split(';')[0] js_src = response.css('script::text').get() js_func_body = js_src.replace('document.cookie', 'let cookie').replace('location.href=location.pathname+location.search', 'return cookie;') js_func = 'function getCookie() &#123;' + js_func_body + '&#125;' jscontext = execjs.compile(js_func) cookie_str = jscontext.call(\"getCookie\") jsl_clearance = cookie_str.split('=')[1].split(';')[0] js_cookie = f\"__jsluid_h=&#123;jsluid_h&#125;; __jsl_clearance=&#123;jsl_clearance&#125;\" return js_cookie 第二次请求携带User-Agent 和 第一次生成的 Cookie: 12345&gt;&gt;&gt; request = request.replace(headers=&#123;'User-Agent': request.headers['User-Agent'], 'Cookie': js_cookie&#125;)&gt;&gt;&gt; request&lt;GET http://www.gsxt.gov.cn/&gt;&gt;&gt;&gt; fetch(request)&gt;&gt;&gt; body 1&lt;script&gt;var _0x1e2d=['woXDjngl','Q25WXA==','Wm0zFg==','w58hwojCuQ==','HsOMMGg=','KMOwPlM=','PcO6AGg=','eFc0KQ==','wqMRBcKq','w73DvcKuMg==','wpZafMOQ','w7/CnnNQ','wqomw5HDpw==','BcKsw7bDhA==','w5LDrsK+Gw==','wqoOBsKX','w7XDssOaw6c=','aWDDtR4=','wokowq1+','w5PDswRu','w6Vbw4zDuQ==','w6PDnsOHw6A=','JExpwrY=','Lxlyw4E=','EMOsTMKA','w6twwqkG','w79dw5HCpQ==','w5zDjsK2wo0=','wr05OMK6','TjPCn8O4','BcK6BHA=','w6oSFVE=','wpgfEcKn','wpPCggMu','dhfCtnw=','w7nClSrDlA==','woYHw4TDpg==','FMOpZcKE','V3h9ew==','Fy0s','w7nCvlx0','w4jDjMK3fA==','w6dsw7vCkg==','wpXChMOFw60=','AFZNwrI=','5oGG55q66K2C5rCh','FcKow7/Dhg==','w7N4w6jChQ==','w41laEo=','wpXCoMOFw5M=','TkpVTQ==','wo9Sw7gl','w6TDscKKGA==','JsKsLkA=','w7dIZFc=','wpETw7fDqg==','w7t+w7bCjg==','wr5fw7kF','BcKow57Dgw==','UzfCv24=','wrcSw5HDvA==','HsKYwrLDhg==','wp8rF8KU','wqTDoiUP','OsK3w4zDmQ==','wpPCr8O2Kw==','Nm13wqE=','w5TDmsKYwrw=','UMOZwrDDnQ==','woNsw7Qr','PcK7Dg==','w4TCuwLDlg==','w7/DrMOJw6Y=','w71cw4XCjQ==','OhUfwoA=','w5tOw6/Dsg==','woUaKMKz','w5/Drwpr','ZQfDhsKA','w6DClGNR','VErDlMOG','w6VKwok8','w7t7wqIX','w6vDlMOdw5I=','wq8Xw5PDsg==','w77ClGFQ','VwrCgUw=','G8O8CHs=','w6Vyw7rCgg==','Ailiw40=','Kgxhw7k=','w5YlA0Y=','ZRPChsON','wrxZwps=','wroOw5jDrA==','TRHDicKn','wpfDgHwp','VEhgQQ==','wpbCtScx','wqPCiHU=','ewnDmsKY','STfCo1Y=','w7nDrgR4','wqogaRg=','DWVCwq4=','wq7CjcOkHQ==','woQlw5HDlw==','IsOpQcKw','w7IXEmM=','w5vDoRFv','BicTwpY=','E8Kbw7DDtg==','wqvCucOQw5g=','bnhaZw==','ayDCiUY=','ZsObwqLDrQ==','U1XCk8K5','wq0bwrzDmA==','w6DDtsOjw4k=','w6AkD0I=','wp4Sw7vDpg==','UDXCu20=','E1hBwrE=','IcOhXMKC','w5vCsQzDmg==','wocEwptP','DsKuLUo=','wqHCnsO1FA==','a2HDoRg=','wq7CgSUJ','w5LDvMKNMw==','ZTbDlcK3','Qi/DncKV','HBcowoI=','RVoywrs=','wqA0w5rDiQ==','wo7DgmAA','Xh59wo0=','LsKPwp3Drg==','IcOhQ8KZ','w6rDmsK9wpw=','w7jDlsKIwoI=','BsKtQsO6','w57CsFlg','w68ED3k=','wrl+wqTDkA==','I8KTwrDDug==','wqgPw4nDjA==','w6fCkAHDvw==','LsKPE3A=','wojCgCMP','w6vChVN9','w6zDtcKFXQ==','w5M6wqjCmQ==','wqPCvz0/','w4/DtQdz','TloNwoQ=','w6Jqw7rDsw==','FVRowpk=','w5YFDWQ=','w75dw73CrQ==','RATDocKF','w4FJw6vCug==','fHTDjsOT','U2HDliI=','772H6KyN56iV56+m','w7bDrcKICA==','w5k3J3s=','w5PDjcKLwqc=','w6rDk8KPwrs=','dj/ClWU=','HsKTdcOZ','w5Fmw4zDmw==','w6jDvcKBKA==','wpoJFcKj','cnTDoCc=','wr/CmMOIw5A=','HEVKwrk=','woEZw43Djg==','w7wIBUE=','w4MbA1A=','fcOZwoPDog==','BHBbwrk=','wo1qfsO1','FA9Aw4w=','wrcrwoVL','b35Gag==','wq0Gwo9A','5q285Zym6ai+6K6t','wpjDjR8O','QX5JYA==','dSvCvMOy','HcOKMHI=','wqtBe8O8','IsKJw6zDlQ==','w4jDjMOew48=','wrvDr2UN','woU3w5nDnA==','bzPCgkA=','QjTDp8K1','wodQw5EG','T2/Dvgo=','wqrChcOENA==','w6nDhMKXXg==','w4LCgxLDgA==','w7TDt8KEZg==','wow/wqFx','VRzCg34=','wprDmHYM','w5FRwr8m','w5kJCFI=','wpHCrQQJ','w7ArwoLCuw==','HsKjCUw=','RcOZwq3Drw==','w6HDrsKpOQ==','w4PDvsOhw68=','w6jCoMOuw5A=','w6jDm8O3w4s=','wq3Dlw8f','TXQKwpY=','w6HDi8K7Hw==','McOOK04=','w7vDs8KwbQ==','w4JCw6fDuA==','wrdPU8OU','wpdGwp7DgA==','w4rDriJy','wrFhw5ER','w4UpJHo=','dX0qwqg=','w5pqw5TDvg==','D8OCwpko','woLClcOsw7c=','YnvDgsO5','w7hfw4/DvQ==','UDbCu0s=','S2cMCQ==','YSTDqMKX','w70/Llg=','eDTDmMKk','wqfCkjc6','w6XDsgpo','w63DowZw','woc5wrA=','EcOOwoEq','w4V+w5fCnQ==','D8Okwrka','w5cEOmI=','GMKKw57Dnw==','wo1Ww5QR','Zl7Dlx4=','O8KJwp3DuA==','w7XDlsK9PQ==','w6dAw6bDrA==','w7o2w5vDvA==','w7kfC3k=','QGMLFQ==','w67DtMKvwp4=','W00xKg==','wq1GwrDDpA==','w7fDncKnwrc=','wrPCqsOCw4U=','6K6R5rGj6aqD6Kyg','QCZLw7Y=','wrwbIcKg','w5o8Hk8=','D2RWwoY=','w6/DkcO+w4g=','w78PBGg=','UWnCmMKe','ZWTDngY=','E8OVHFo=','w7xKw5HDlw==','wpHDqUw5','YXnDisO2','ATJrw6s=','wp3Djmg6','b8Ovw6XDlQ==','w65KwpgB','XikZwp0=','w7TDvcO5w4o=','wqEUwrV8','wpLCozQJ','w7k+wqrCmQ==','w5rCpFl3','w55Yw7bDpQ==','EcKKdsON','w57DmcOlw7s=','woM1w6vDmQ==','ZhvCpls=','HsOrRMK9','DQY4wpg=','Uw0Swp4=','wpo6bw4=','wqtWw5sG','TjnCt2E=','w7fCpXBK','w57DkMKcOA==','w7HCgwXDog==','RWbCvcKM','aWgZHg==','H8OrEFQ=','woR6w5Qk','J8OpJkw=','V0nDksO0','w4EiDw==','bjHCsnk=','NcOOwo4p','TV7DowA=','w5V+w7bCmA==','w7U8C3k=','w7d/X1g=','w5M4Omw=','B8OYJXk=','wrY3w5nDlg==','wo3Cs8OFw5k=','wqPDrm0r','G8KMw4TDgA==','w6LCvA7DkA==','w4jCkTHDkA==','CsKYG1w=','w4/DrA51','wpzCj8OvGQ==','wofDrwIc','w7cdLXI=','w75OwqkQ'];(function(_0x11c8af,_0x1e2d46)&#123;var _0x2a36e1=function(_0x2deff6)&#123;while(--_0x2deff6)&#123;_0x11c8af['push'](_0x11c8af['shift']());&#125;&#125;;_0x2a36e1(++_0x1e2d46);&#125;(_0x1e2d,0xae));var _0x2a36=function(_0x11c8af,_0x1e2d46)&#123;_0x11c8af=_0x11c8af-0x0;var _0x2a36e1=_0x1e2d[_0x11c8af];if(_0x2a36['psKvjD']===undefined)&#123;(function()&#123;var _0x4a8f21=function()&#123;var _0x1ff210;try&#123;_0x1ff210=Function('return\\x20(function()\\x20'+'&#123;&#125;.constructor(\\x22return\\x20this\\x22)(\\x20)'+');')();&#125;catch(_0x4c5d5d)&#123;_0x1ff210=window;&#125;return _0x1ff210;&#125;;var _0xfc5d6=_0x4a8f21();var _0x188c96='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0xfc5d6['atob']||(_0xfc5d6['atob']=function(_0x3187ab)&#123;var _0x5ce0e1=String(_0x3187ab)['replace'](/=+$/,'');var _0x1d557c='';for(var _0x1b84f3=0x0,_0x4be7a4,_0x4f43fc,_0x2758b0=0x0;_0x4f43fc=_0x5ce0e1['charAt'](_0x2758b0++);~_0x4f43fc&amp;&amp;(_0x4be7a4=_0x1b84f3%0x4?_0x4be7a4*0x40+_0x4f43fc:_0x4f43fc,_0x1b84f3++%0x4)?_0x1d557c+=String['fromCharCode'](0xff&amp;_0x4be7a4&gt;&gt;(-0x2*_0x1b84f3&amp;0x6)):0x0)&#123;_0x4f43fc=_0x188c96['indexOf'](_0x4f43fc);&#125;return _0x1d557c;&#125;);&#125;());var _0x589164=function(_0xdbee88,_0x63b65c)&#123;var _0x474830=[],_0x357f79=0x0,_0x2ed50a,_0x255f5d='',_0x8ff92a='';_0xdbee88=atob(_0xdbee88);for(var _0x391402=0x0,_0x42bac6=_0xdbee88['length'];_0x391402&lt;_0x42bac6;_0x391402++)&#123;_0x8ff92a+='%'+('00'+_0xdbee88['charCodeAt'](_0x391402)['toString'](0x10))['slice'](-0x2);&#125;_0xdbee88=decodeURIComponent(_0x8ff92a);var _0x376a21;for(_0x376a21=0x0;_0x376a21&lt;0x100;_0x376a21++)&#123;_0x474830[_0x376a21]=_0x376a21;&#125;for(_0x376a21=0x0;_0x376a21&lt;0x100;_0x376a21++)&#123;_0x357f79=(_0x357f79+_0x474830[_0x376a21]+_0x63b65c['charCodeAt'](_0x376a21%_0x63b65c['length']))%0x100;_0x2ed50a=_0x474830[_0x376a21];_0x474830[_0x376a21]=_0x474830[_0x357f79];_0x474830[_0x357f79]=_0x2ed50a;&#125;_0x376a21=0x0;_0x357f79=0x0;for(var _0x33ae0c=0x0;_0x33ae0c&lt;_0xdbee88['length'];_0x33ae0c++)&#123;_0x376a21=(_0x376a21+0x1)%0x100;_0x357f79=(_0x357f79+_0x474830[_0x376a21])%0x100;_0x2ed50a=_0x474830[_0x376a21];_0x474830[_0x376a21]=_0x474830[_0x357f79];_0x474830[_0x357f79]=_0x2ed50a;_0x255f5d+=String['fromCharCode'](_0xdbee88['charCodeAt'](_0x33ae0c)^_0x474830[(_0x474830[_0x376a21]+_0x474830[_0x357f79])%0x100]);&#125;return _0x255f5d;&#125;;_0x2a36['nxKrzs']=_0x589164;_0x2a36['UiEgdJ']=&#123;&#125;;_0x2a36['psKvjD']=!![];&#125;var _0x2deff6=_0x2a36['UiEgdJ'][_0x11c8af];if(_0x2deff6===undefined)&#123;if(_0x2a36['ocpJYT']===undefined)&#123;_0x2a36['ocpJYT']=!![];&#125;_0x2a36e1=_0x2a36['nxKrzs'](_0x2a36e1,_0x1e2d46);_0x2a36['UiEgdJ'][_0x11c8af]=_0x2a36e1;&#125;else&#123;_0x2a36e1=_0x2deff6;&#125;return _0x2a36e1;&#125;;function hash(_0x35c1cd)&#123;var _0xf34289=&#123;&#125;;_0xf34289[_0x2a36('0x74','pbz1')+'f']=function(_0x1f0188,_0x4ac636)&#123;return _0x1f0188&lt;&lt;_0x4ac636;&#125;;_0xf34289[_0x2a36('0x29','g$*4')+'i']=function(_0x38f103,_0x12efab)&#123;return _0x38f103&gt;&gt;&gt;_0x12efab;&#125;;_0xf34289[_0x2a36('0x91','fj6o')+'w']=function(_0xf343,_0x114e91)&#123;return _0xf343-_0x114e91;&#125;;_0xf34289[_0x2a36('0x43','0hl%')+'I']=function(_0x1474c9,_0x223269)&#123;return _0x1474c9&amp;_0x223269;&#125;;_0xf34289[_0x2a36('0x58','1W0i')+'v']=function(_0x1a673f,_0x1cb0ee)&#123;return _0x1a673f|_0x1cb0ee;&#125;;_0xf34289[_0x2a36('0x97','@GHf')+'S']=function(_0x450deb,_0xd5bbe6)&#123;return _0x450deb^_0xd5bbe6;&#125;;_0xf34289[_0x2a36('0x1','RX*q')+'S']=function(_0xe0fdca,_0x35e756)&#123;return _0xe0fdca^_0x35e756;&#125;;_0xf34289[_0x2a36('0x135','hp^w')+'E']=function(_0x3d6d08,_0x242474)&#123;return _0x3d6d08^_0x242474;&#125;;_0xf34289[_0x2a36('0xc7','ET&amp;B')+'a']=function(_0x1c85f9,_0x58e7a8)&#123;return _0x1c85f9^_0x58e7a8;&#125;;_0xf34289[_0x2a36('0xc4','1W0i')+'b']=function(_0x451449,_0x12e8bd)&#123;return _0x451449^_0x12e8bd;&#125;;_0xf34289[_0x2a36('0x71','*VyA')+'T']=function(_0x23a788,_0x49e51f)&#123;return _0x23a788^_0x49e51f;&#125;;_0xf34289[_0x2a36('0xd3','ET&amp;B')+'H']=function(_0x390f3d,_0x432bf5)&#123;return _0x390f3d&amp;_0x432bf5;&#125;;_0xf34289[_0x2a36('0x42','Um^)')+'J']=function(_0x41c1a4,_0x3f0211)&#123;return _0x41c1a4+_0x3f0211;&#125;;_0xf34289[_0x2a36('0xf1','(Gcy')+'x']=function(_0x579556,_0x242cdc)&#123;return _0x579556|_0x242cdc;&#125;;_0xf34289[_0x2a36('0x93','w@7h')+'w']=function(_0x2a0b11,_0x9010d4)&#123;return _0x2a0b11^_0x9010d4;&#125;;_0xf34289[_0x2a36('0x140','@GHf')+'U']=function(_0x409885,_0x704bba,_0x37a21f)&#123;return _0x409885(_0x704bba,_0x37a21f);&#125;;_0xf34289[_0x2a36('0x4d','RX*q')+'w']=function(_0x261197,_0x5f3c73,_0x234f30)&#123;return _0x261197(_0x5f3c73,_0x234f30);&#125;;_0xf34289[_0x2a36('0xea','RKPm')+'N']=_0x2a36('0x111','nHo#')+'h';_0xf34289[_0x2a36('0x2f','g$*4')+'J']=function(_0x4320c3,_0x35b352,_0x3021b5)&#123;return _0x4320c3(_0x35b352,_0x3021b5);&#125;;_0xf34289[_0x2a36('0x39','WUwR')+'d']=function(_0x438b8c,_0xc5f374,_0x59b4c7)&#123;return _0x438b8c(_0xc5f374,_0x59b4c7);&#125;;_0xf34289[_0x2a36('0x44','#XP9')+'Q']=function(_0x2898b7,_0x11b9ec,_0x12a8a9,_0x681d1b)&#123;return _0x2898b7(_0x11b9ec,_0x12a8a9,_0x681d1b);&#125;;_0xf34289[_0x2a36('0xf','74L%')+'M']=function(_0x5c2181,_0x551ed1,_0x584c0d)&#123;return _0x5c2181(_0x551ed1,_0x584c0d);&#125;;_0xf34289[_0x2a36('0x12a','XR!r')+'w']=function(_0x118b0d,_0x486489)&#123;return _0x118b0d/_0x486489;&#125;;_0xf34289[_0x2a36('0xb0','MJC2')+'r']=function(_0x3de0b7,_0x1d9340)&#123;return _0x3de0b7%_0x1d9340;&#125;;_0xf34289[_0x2a36('0xac','#XP9')+'c']=function(_0x33e29b,_0x1c7898)&#123;return _0x33e29b*_0x1c7898;&#125;;_0xf34289[_0x2a36('0x6c','Mza$')+'R']=function(_0x5d9c01,_0x2f24ff)&#123;return _0x5d9c01%_0x2f24ff;&#125;;_0xf34289[_0x2a36('0x13f','g$*4')+'F']=function(_0x5f5181,_0xb502d7)&#123;return _0x5f5181!==_0xb502d7;&#125;;_0xf34289[_0x2a36('0x21','pbz1')+'i']=function(_0x4296d6,_0x36439d)&#123;return _0x4296d6+_0x36439d;&#125;;_0xf34289[_0x2a36('0xbf','54hK')+'X']=function(_0xa0a146,_0x1cc99c)&#123;return _0xa0a146/_0x1cc99c;&#125;;_0xf34289[_0x2a36('0xd5','NK!y')+'o']=function(_0x5804e4,_0x531ca7)&#123;return _0x5804e4-_0x531ca7;&#125;;_0xf34289[_0x2a36('0xe0','fj6o')+'H']=function(_0x207b6f,_0x57dd46)&#123;return _0x207b6f%_0x57dd46;&#125;;_0xf34289[_0x2a36('0xed','NK!y')+'L']=function(_0x38cfd1,_0x4f618c)&#123;return _0x38cfd1(_0x4f618c);&#125;;_0xf34289[_0x2a36('0xe5','!lad')+'k']=function(_0x484790,_0x448098)&#123;return _0x484790&lt;_0x448098;&#125;;_0xf34289[_0x2a36('0xae','8mW]')+'b']=function(_0x29977d,_0x2198dc)&#123;return _0x29977d*_0x2198dc;&#125;;_0xf34289[_0x2a36('0x31','&amp;1fo')+'v']=function(_0x36ddc4,_0x345d57)&#123;return _0x36ddc4|_0x345d57;&#125;;_0xf34289[_0x2a36('0xb1','CT)o')+'D']=function(_0x57cb55,_0x4be60d)&#123;return _0x57cb55-_0x4be60d;&#125;;_0xf34289[_0x2a36('0xef','pbz1')+'P']=function(_0x460203,_0xbcdbc9)&#123;return _0x460203&amp;_0xbcdbc9;&#125;;_0xf34289[_0x2a36('0x11c','Um^)')+'H']=function(_0xed0374,_0x284a97)&#123;return _0xed0374&gt;&gt;&gt;_0x284a97;&#125;;_0xf34289[_0x2a36('0x104','CT)o')+'F']=function(_0x44e43a,_0x34aa1a)&#123;return _0x44e43a+_0x34aa1a;&#125;;_0xf34289[_0x2a36('0x24','w*YK')+'Y']=function(_0x4f6764,_0x3e66ce)&#123;return _0x4f6764+_0x3e66ce;&#125;;_0xf34289[_0x2a36('0x35','#XP9')+'p']=function(_0x501ecf)&#123;return _0x501ecf();&#125;;_0xf34289[_0x2a36('0x2e','hp^w')+'S']=function(_0x3db756,_0x422431)&#123;return _0x3db756&lt;_0x422431;&#125;;_0xf34289[_0x2a36('0x13b','(Gcy')+'J']=function(_0x242d9d,_0x1582cc)&#123;return _0x242d9d+_0x1582cc;&#125;;_0xf34289[_0x2a36('0xbd','nHo#')+'t']=function(_0x5304f3,_0x251af6,_0x291883,_0x2af5ad,_0x23d468,_0x39a52b,_0x3abfee,_0x19e686)&#123;return _0x5304f3(_0x251af6,_0x291883,_0x2af5ad,_0x23d468,_0x39a52b,_0x3abfee,_0x19e686);&#125;;_0xf34289[_0x2a36('0x137','k9V8')+'f']=function(_0xee2df3,_0x3b43a4)&#123;return _0xee2df3+_0x3b43a4;&#125;;_0xf34289[_0x2a36('0x10c','8sr^')+'g']=function(_0x18c11b,_0xe8adca)&#123;return _0x18c11b+_0xe8adca;&#125;;_0xf34289[_0x2a36('0x115','fj6o')+'d']=function(_0xa2e388,_0x26e10d,_0x160212,_0x4a73b3,_0x108d7e,_0x299234,_0x5041c6,_0x28ca4d)&#123;return _0xa2e388(_0x26e10d,_0x160212,_0x4a73b3,_0x108d7e,_0x299234,_0x5041c6,_0x28ca4d);&#125;;_0xf34289[_0x2a36('0x130','6dCB')+'M']=function(_0x5a48d3,_0x4b1a01,_0x3f3811,_0x570205,_0xe19c31,_0xeba9ab,_0x1f2395,_0x361a29)&#123;return _0x5a48d3(_0x4b1a01,_0x3f3811,_0x570205,_0xe19c31,_0xeba9ab,_0x1f2395,_0x361a29);&#125;;_0xf34289[_0x2a36('0xb','Mza$')+'Z']=function(_0x42dc91,_0x51eb99)&#123;return _0x42dc91+_0x51eb99;&#125;;_0xf34289[_0x2a36('0x32','WUwR')+'C']=function(_0x420979,_0xd6741)&#123;return _0x420979+_0xd6741;&#125;;_0xf34289[_0x2a36('0x8b','@GHf')+'Z']=function(_0x374544,_0x49e039)&#123;return _0x374544+_0x49e039;&#125;;_0xf34289[_0x2a36('0xcf','xz]x')+'c']=function(_0x548a02,_0xefd572)&#123;return _0x548a02+_0xefd572;&#125;;_0xf34289[_0x2a36('0x6d','0hl%')+'v']=function(_0x168f6f,_0x528579,_0xefc5d6,_0x1a0609,_0x41371d,_0x566757,_0xc834fe,_0x17937e)&#123;return _0x168f6f(_0x528579,_0xefc5d6,_0x1a0609,_0x41371d,_0x566757,_0xc834fe,_0x17937e);&#125;;_0xf34289[_0x2a36('0x133','0hl%')+'W']=function(_0x25e10a,_0x389eef,_0x39ba1f,_0x3ab948,_0x16fe0e,_0x5b6959,_0xb2ef61,_0x53035f)&#123;return _0x25e10a(_0x389eef,_0x39ba1f,_0x3ab948,_0x16fe0e,_0x5b6959,_0xb2ef61,_0x53035f);&#125;;_0xf34289[_0x2a36('0xd6','jG(h')+'j']=function(_0x51cd2d,_0xe10455,_0x3e55b4,_0x53339c,_0x1455d4,_0x4786dc,_0x1c85c0,_0x286f66)&#123;return _0x51cd2d(_0xe10455,_0x3e55b4,_0x53339c,_0x1455d4,_0x4786dc,_0x1c85c0,_0x286f66);&#125;;_0xf34289[_0x2a36('0x2d','74L%')+'s']=function(_0x9ef83c,_0x2c1f81,_0x208f1c,_0x38edc7,_0x31ce4,_0x4e3243,_0x12cc5d,_0x9b8fd8)&#123;return _0x9ef83c(_0x2c1f81,_0x208f1c,_0x38edc7,_0x31ce4,_0x4e3243,_0x12cc5d,_0x9b8fd8);&#125;;_0xf34289[_0x2a36('0x70','WUwR')+'t']=function(_0x1c3b1f,_0x479043)&#123;return _0x1c3b1f+_0x479043;&#125;;_0xf34289[_0x2a36('0x116','Mza$')+'Y']=function(_0x4397e0,_0x372c49,_0x2e4496,_0x188e89,_0x4b2a24,_0x1f994f,_0x160c27,_0xe750b8)&#123;return _0x4397e0(_0x372c49,_0x2e4496,_0x188e89,_0x4b2a24,_0x1f994f,_0x160c27,_0xe750b8);&#125;;_0xf34289[_0x2a36('0x72','8mW]')+'J']=function(_0x5c6b39,_0x514ddb,_0x313c86,_0x1660c1,_0x5e0720,_0x1e701c,_0x33189b,_0x3d256c)&#123;return _0x5c6b39(_0x514ddb,_0x313c86,_0x1660c1,_0x5e0720,_0x1e701c,_0x33189b,_0x3d256c);&#125;;_0xf34289[_0x2a36('0x11f','hp^w')+'x']=function(_0x437093,_0x4df60e,_0x3abedb,_0x353657,_0x5eee29,_0x67a1a2,_0x379851,_0x2ad8c9)&#123;return _0x437093(_0x4df60e,_0x3abedb,_0x353657,_0x5eee29,_0x67a1a2,_0x379851,_0x2ad8c9);&#125;;_0xf34289[_0x2a36('0x38','hp^w')+'u']=function(_0x1a217c,_0x155aa7,_0xdf6d5f,_0x3c8493,_0xc1379b,_0x2e2252,_0x51a743,_0x4d1cf2)&#123;return _0x1a217c(_0x155aa7,_0xdf6d5f,_0x3c8493,_0xc1379b,_0x2e2252,_0x51a743,_0x4d1cf2);&#125;;_0xf34289[_0x2a36('0x6a','7TrD')+'O']=function(_0x1ae7bb,_0x5c4c1d,_0x3b6dfc,_0x430d65,_0x1df203,_0x31cfb1,_0x2a9267,_0x5e07b1)&#123;return _0x1ae7bb(_0x5c4c1d,_0x3b6dfc,_0x430d65,_0x1df203,_0x31cfb1,_0x2a9267,_0x5e07b1);&#125;;_0xf34289[_0x2a36('0xff','#XP9')+'N']=function(_0x5a031b,_0x16a75f,_0x42b492,_0x5dca1e,_0x4a0598,_0x12f5fd,_0x47f3f4,_0x2f087a)&#123;return _0x5a031b(_0x16a75f,_0x42b492,_0x5dca1e,_0x4a0598,_0x12f5fd,_0x47f3f4,_0x2f087a);&#125;;_0xf34289[_0x2a36('0x22','KohP')+'y']=function(_0x416f55,_0x16de1c)&#123;return _0x416f55+_0x16de1c;&#125;;_0xf34289[_0x2a36('0x51','qlka')+'V']=function(_0x59c9de,_0x28f024)&#123;return _0x59c9de+_0x28f024;&#125;;_0xf34289[_0x2a36('0x13','SKmL')+'B']=function(_0x4c1e1d,_0x340417)&#123;return _0x4c1e1d+_0x340417;&#125;;_0xf34289[_0x2a36('0x4f','g$*4')+'I']=function(_0x542e6b,_0x519dd8,_0x3e4ae1,_0x1370d0,_0x368a0b,_0x16bdf5,_0x2102f6,_0x5beb42)&#123;return _0x542e6b(_0x519dd8,_0x3e4ae1,_0x1370d0,_0x368a0b,_0x16bdf5,_0x2102f6,_0x5beb42);&#125;;_0xf34289[_0x2a36('0x85','pbz1')+'O']=function(_0x9c14c4,_0x2027d7)&#123;return _0x9c14c4+_0x2027d7;&#125;;_0xf34289[_0x2a36('0x6','@GHf')+'Q']=function(_0xcd73e9,_0x52d0ce,_0x4a459c,_0xc5028d,_0x199d20,_0x503b04,_0x561dd1,_0x1c75f1)&#123;return _0xcd73e9(_0x52d0ce,_0x4a459c,_0xc5028d,_0x199d20,_0x503b04,_0x561dd1,_0x1c75f1);&#125;;_0xf34289[_0x2a36('0xbb','pbz1')+'s']=function(_0x43a6fb,_0x188636,_0x47e2e8,_0x734299,_0x4de0a0,_0x3c9246,_0x4124d9,_0x17dbde)&#123;return _0x43a6fb(_0x188636,_0x47e2e8,_0x734299,_0x4de0a0,_0x3c9246,_0x4124d9,_0x17dbde);&#125;;_0xf34289[_0x2a36('0x12d','fj6o')+'w']=function(_0x3d7b8e,_0x584185)&#123;return _0x3d7b8e+_0x584185;&#125;;_0xf34289[_0x2a36('0xb3','(Gcy')+'x']=function(_0x2220c3,_0x14c718)&#123;return _0x2220c3+_0x14c718;&#125;;_0xf34289[_0x2a36('0xa1','!lad')+'i']=function(_0xbf8950,_0x9a943a)&#123;return _0xbf8950+_0x9a943a;&#125;;_0xf34289[_0x2a36('0x41','@GHf')+'k']=function(_0x3a4375,_0x703ed4,_0x142dbc,_0x5088be,_0x3ec027,_0x25eff9,_0x5e487b,_0x15be78)&#123;return _0x3a4375(_0x703ed4,_0x142dbc,_0x5088be,_0x3ec027,_0x25eff9,_0x5e487b,_0x15be78);&#125;;_0xf34289[_0x2a36('0x3','k9V8')+'V']=function(_0x3830c6,_0x2848c0,_0x2e2955,_0x20539b,_0x5e062a,_0x4fc418,_0x3031fe,_0x624e53)&#123;return _0x3830c6(_0x2848c0,_0x2e2955,_0x20539b,_0x5e062a,_0x4fc418,_0x3031fe,_0x624e53);&#125;;_0xf34289[_0x2a36('0xa','MJC2')+'x']=function(_0xe78a19,_0x1c9fdc)&#123;return _0xe78a19+_0x1c9fdc;&#125;;_0xf34289[_0x2a36('0x121','KohP')+'p']=function(_0x22aeb4,_0x24b03b,_0x1271ab,_0x485402,_0x3163df,_0xd70fb1,_0x11fb17,_0x75ac14)&#123;return _0x22aeb4(_0x24b03b,_0x1271ab,_0x485402,_0x3163df,_0xd70fb1,_0x11fb17,_0x75ac14);&#125;;_0xf34289[_0x2a36('0x9','SKmL')+'L']=function(_0xe98eaa,_0x47a8ba,_0x598c80)&#123;return _0xe98eaa(_0x47a8ba,_0x598c80);&#125;;_0xf34289[_0x2a36('0xc1','6dCB')+'C']=function(_0x27ec67,_0x135c80)&#123;return _0x27ec67+_0x135c80;&#125;;_0xf34289[_0x2a36('0x62','8ePc')+'r']=function(_0x5317c2,_0x9a7e11)&#123;return _0x5317c2+_0x9a7e11;&#125;;_0xf34289[_0x2a36('0x3b','1W0i')+'g']=function(_0x384a33,_0x2d2d92)&#123;return _0x384a33(_0x2d2d92);&#125;;_0xf34289[_0x2a36('0x110','@GHf')+'E']=function(_0x2a70de,_0x1b0808)&#123;return _0x2a70de(_0x1b0808);&#125;;var _0x27b846=_0xf34289;function _0x34fe6c(_0x4bcb59,_0xb09178)&#123;return _0x27b846[_0x2a36('0xb6','[WEF')+'f'](_0x4bcb59,_0xb09178)|_0x27b846[_0x2a36('0xc5','k9V8')+'i'](_0x4bcb59,_0x27b846[_0x2a36('0x25','0hl%')+'w'](0x20,_0xb09178));&#125;function _0x10618e(_0x4e10e7,_0x13e40d)&#123;var _0x1f127a=(_0x2a36('0x122','^EXY')+_0x2a36('0x10e','qlka')+_0x2a36('0xdb','hp^w')+_0x2a36('0xfc','fj6o'))[_0x2a36('0x3d','WUwR')+'t']('|');var _0x3dac0d=0x0;while(!![])&#123;switch(_0x1f127a[_0x3dac0d++])&#123;case'0':_0x36dc0d=_0x27b846[_0x2a36('0x30','8ePc')+'I'](_0x13e40d,0x40000000);continue;case'1':var _0x57768b,_0x36dc0d,_0x174eaf,_0x2969b3,_0x148e5a;continue;case'2':if(_0x27b846[_0x2a36('0x9b','MWa5')+'v'](_0x57768b,_0x36dc0d))&#123;if(_0x148e5a&amp;0x40000000)return _0x27b846[_0x2a36('0x77','7TrD')+'S'](_0x27b846[_0x2a36('0x1','RX*q')+'S'](_0x27b846[_0x2a36('0xd','Mza$')+'E'](_0x148e5a,0xc0000000),_0x174eaf),_0x2969b3);else return _0x27b846[_0x2a36('0xbe','CT)o')+'a'](_0x27b846[_0x2a36('0x103','NK!y')+'a'](_0x148e5a,0x40000000),_0x174eaf)^_0x2969b3;&#125;else return _0x27b846[_0x2a36('0x88','(Gcy')+'a'](_0x148e5a,_0x174eaf)^_0x2969b3;continue;case'3':_0x57768b=_0x4e10e7&amp;0x40000000;continue;case'4':if(_0x27b846[_0x2a36('0x9a','54hK')+'I'](_0x57768b,_0x36dc0d))return _0x27b846[_0x2a36('0x128','6dCB')+'b'](_0x27b846[_0x2a36('0x95','G]I%')+'T'](_0x148e5a,0x80000000)^_0x174eaf,_0x2969b3);continue;case'5':_0x2969b3=_0x27b846[_0x2a36('0xf3','MJC2')+'H'](_0x13e40d,0x80000000);continue;case'6':_0x148e5a=_0x27b846[_0x2a36('0xd7','!lad')+'J'](_0x27b846[_0x2a36('0x48','(Gcy')+'H'](_0x4e10e7,0x3fffffff),_0x27b846[_0x2a36('0x7e','Oo24')+'H'](_0x13e40d,0x3fffffff));continue;case'7':_0x174eaf=_0x27b846[_0x2a36('0xd3','ET&amp;B')+'H'](_0x4e10e7,0x80000000);continue;&#125;break;&#125;&#125;function _0x548d4d(_0x42b0d7,_0x2d08d2,_0x58fa82)&#123;return _0x27b846[_0x2a36('0x3c','Fn7$')+'x'](_0x42b0d7&amp;_0x2d08d2,~_0x42b0d7&amp;_0x58fa82);&#125;function _0x342dc2(_0x3b78fb,_0xc85404,_0x3d4292)&#123;return _0x27b846[_0x2a36('0xa4','6dCB')+'x'](_0x27b846[_0x2a36('0xf3','MJC2')+'H'](_0x3b78fb,_0x3d4292),_0xc85404&amp;~_0x3d4292);&#125;function _0xb30f20(_0x2c79ef,_0x5589c0,_0x15f056)&#123;return _0x27b846[_0x2a36('0x5c','w*YK')+'w'](_0x2c79ef,_0x5589c0)^_0x15f056;&#125;function _0x171e10(_0x32dd0d,_0x1e6891,_0x55e3bb)&#123;return _0x1e6891^_0x27b846[_0x2a36('0x7a','pbz1')+'x'](_0x32dd0d,~_0x55e3bb);&#125;function _0x5f1ec4(_0x2adac3,_0x2b5312,_0x3d740e,_0x4d809a,_0x578f9a,_0x306271,_0xdd5166)&#123;_0x2adac3=_0x27b846[_0x2a36('0x1c','G]I%')+'U'](_0x10618e,_0x2adac3,_0x27b846[_0x2a36('0x89','w*YK')+'w'](_0x10618e,_0x27b846[_0x2a36('0x7b','6dCB')+'w'](_0x10618e,_0x548d4d(_0x2b5312,_0x3d740e,_0x4d809a),_0x578f9a),_0xdd5166));return _0x10618e(_0x34fe6c(_0x2adac3,_0x306271),_0x2b5312);&#125;function _0x50d58f(_0x50e7d8,_0x19ec48,_0x58f2b0,_0x9f6805,_0x34e2d5,_0x18c4ab,_0x5a033d)&#123;if(_0x27b846[_0x2a36('0xde','D##Z')+'N']!==_0x27b846[_0x2a36('0x80','8ePc')+'N'])&#123;sleepT=0x5dc;&#125;else&#123;_0x50e7d8=_0x27b846[_0x2a36('0x69','RKPm')+'J'](_0x10618e,_0x50e7d8,_0x10618e(_0x10618e(_0x342dc2(_0x19ec48,_0x58f2b0,_0x9f6805),_0x34e2d5),_0x5a033d));return _0x10618e(_0x27b846[_0x2a36('0x2f','g$*4')+'J'](_0x34fe6c,_0x50e7d8,_0x18c4ab),_0x19ec48);&#125;&#125;function _0x4d85c0(_0x587fa0,_0x5bba53,_0x4962af,_0x238436,_0x29fed9,_0x48f6c5,_0x40f965)&#123;_0x587fa0=_0x27b846[_0x2a36('0xc2','&amp;1fo')+'J'](_0x10618e,_0x587fa0,_0x27b846[_0x2a36('0x99','KohP')+'d'](_0x10618e,_0x27b846[_0x2a36('0x28','8sr^')+'d'](_0x10618e,_0x27b846[_0x2a36('0xb7','w@7h')+'Q'](_0xb30f20,_0x5bba53,_0x4962af,_0x238436),_0x29fed9),_0x40f965));return _0x10618e(_0x27b846[_0x2a36('0x90','ET&amp;B')+'M'](_0x34fe6c,_0x587fa0,_0x48f6c5),_0x5bba53);&#125;function _0x50f986(_0x4dee58,_0x2f9b3b,_0x55cd5d,_0x54d151,_0x1774d9,_0x3849e3,_0x32576b)&#123;_0x4dee58=_0x27b846[_0x2a36('0x9f','8ePc')+'M'](_0x10618e,_0x4dee58,_0x10618e(_0x10618e(_0x171e10(_0x2f9b3b,_0x55cd5d,_0x54d151),_0x1774d9),_0x32576b));return _0x10618e(_0x34fe6c(_0x4dee58,_0x3849e3),_0x2f9b3b);&#125;function _0x431328(_0x4b4a2b)&#123;if(_0x27b846[_0x2a36('0xa3','SKmL')+'F'](_0x2a36('0x18','pbz1')+'i',_0x2a36('0x125','WWZM')+'i'))&#123;_0x579c3d=_0x27b846[_0x2a36('0xec','8mW]')+'w'](_0x3c2446-_0x27b846[_0x2a36('0x10b','pbz1')+'r'](_0x3c2446,0x4),0x4);_0x26725c=_0x27b846[_0x2a36('0x12','8ePc')+'c'](_0x27b846[_0x2a36('0x83','Fn7$')+'R'](_0x3c2446,0x4),0x8);_0x408946[_0x579c3d]=_0x408946[_0x579c3d]|_0x27b846[_0x2a36('0x7c','g$*4')+'f'](_0x4b4a2b[_0x2a36('0xcd','g$*4')+_0x2a36('0x9c','sCn1')+'At'](_0x3c2446),_0x26725c);_0x3c2446++;&#125;else&#123;var _0x579c3d;var _0x1c2489=_0x4b4a2b[_0x2a36('0xab','Mza$')+'th'];var _0x5d877a=_0x27b846[_0x2a36('0x11d','Um^)')+'i'](_0x1c2489,0x8);var _0x249490=_0x27b846[_0x2a36('0x17','nHo#')+'X'](_0x27b846[_0x2a36('0xfb','0hl%')+'o'](_0x5d877a,_0x27b846[_0x2a36('0x4','nHo#')+'H'](_0x5d877a,0x40)),0x40);var _0x5be1ef=(_0x249490+0x1)*0x10;var _0x408946=_0x27b846[_0x2a36('0x19','Um^)')+'L'](Array,_0x5be1ef-0x1);var _0x26725c=0x0;var _0x3c2446=0x0;while(_0x27b846[_0x2a36('0x11a','0hl%')+'k'](_0x3c2446,_0x1c2489))&#123;_0x579c3d=(_0x3c2446-_0x3c2446%0x4)/0x4;_0x26725c=_0x3c2446%0x4*0x8;_0x408946[_0x579c3d]=_0x408946[_0x579c3d]|_0x4b4a2b[_0x2a36('0xb2','RKPm')+_0x2a36('0x78','!N^6')+'At'](_0x3c2446)&lt;&lt;_0x26725c;_0x3c2446++;&#125;_0x579c3d=_0x27b846[_0x2a36('0xb9','!lad')+'X'](_0x3c2446-_0x3c2446%0x4,0x4);_0x26725c=_0x27b846[_0x2a36('0xf2','MJC2')+'b'](_0x3c2446%0x4,0x8);_0x408946[_0x579c3d]=_0x27b846[_0x2a36('0x2a','cnTb')+'v'](_0x408946[_0x579c3d],_0x27b846[_0x2a36('0x23','RKPm')+'f'](0x80,_0x26725c));_0x408946[_0x27b846[_0x2a36('0x64','KohP')+'D'](_0x5be1ef,0x2)]=_0x1c2489&lt;&lt;0x3;_0x408946[_0x5be1ef-0x1]=_0x27b846[_0x2a36('0x7d','fj6o')+'i'](_0x1c2489,0x1d);return _0x408946;&#125;&#125;function _0x52ae0b(_0x368d8f)&#123;var _0x2a3d68='',_0x2e71d2='',_0x4fabb0,_0x27bea1;for(_0x27bea1=0x0;_0x27bea1&lt;=0x3;_0x27bea1++)&#123;_0x4fabb0=_0x27b846[_0x2a36('0xf7','nHo#')+'P'](_0x27b846[_0x2a36('0x127','*VyA')+'H'](_0x368d8f,_0x27b846[_0x2a36('0x5e','cnTb')+'b'](_0x27bea1,0x8)),0xff);_0x2e71d2=_0x27b846[_0x2a36('0xba','0hl%')+'F']('0',_0x4fabb0[_0x2a36('0x114','CT)o')+_0x2a36('0x65','Fn7$')](0x10));_0x2a3d68=_0x27b846[_0x2a36('0x11b','g$*4')+'Y'](_0x2a3d68,_0x2e71d2[_0x2a36('0x8d','NK!y')+'tr'](_0x2e71d2[_0x2a36('0x12f','0hl%')+'th']-0x2,0x2));&#125;return _0x2a3d68;&#125;var _0x37f8ef=_0x27b846[_0x2a36('0xaa','RX*q')+'p'](Array);var _0x9ad472,_0x57eb7c,_0x31e09a,_0x428396,_0x57da6b,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7;var _0x6254a0=0x7,_0x4cfc14=0xc,_0xed0099=0x11,_0xfea25=0x16;var _0x21742d=0x5,_0x3aeb97=0x9,_0x357b3b=0xe,_0x5ac8da=0x14;var _0x5b5acd=0x4,_0x306674=0xb,_0x27e21a=0x10,_0x10ffae=0x17;var _0x57f0c7=0x6,_0x27805b=0xa,_0x1fa884=0xf,_0x420e72=0x15;_0x37f8ef=_0x431328(_0x35c1cd);_0x33f877=0x67452301;_0x2b3b86=0xefcdab89;_0x250aaf=0x98badcfe;_0x46dbc7=0x10325476;for(_0x9ad472=0x0;_0x27b846[_0x2a36('0x75','CT)o')+'S'](_0x9ad472,_0x37f8ef[_0x2a36('0x47','u)Zx')+'th']);_0x9ad472+=0x10)&#123;_0x57eb7c=_0x33f877;_0x31e09a=_0x2b3b86;_0x428396=_0x250aaf;_0x57da6b=_0x46dbc7;_0x33f877=_0x5f1ec4(_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0xda','G]I%')+'J'](_0x9ad472,0x0)],_0x6254a0,0xd76aa478);_0x46dbc7=_0x27b846[_0x2a36('0xd0','NK!y')+'t'](_0x5f1ec4,_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x82','8ePc')+'J'](_0x9ad472,0x1)],_0x4cfc14,0xe8c7b756);_0x250aaf=_0x27b846[_0x2a36('0xa0','MWa5')+'t'](_0x5f1ec4,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0xc3','(Gcy')+'f'](_0x9ad472,0x2)],_0xed0099,0x242070db);_0x2b3b86=_0x27b846[_0x2a36('0x6f','6dCB')+'t'](_0x5f1ec4,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x12e','w@7h')+'g'](_0x9ad472,0x3)],_0xfea25,0xc1bdceee);_0x33f877=_0x5f1ec4(_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0xb5','!lad')+'g'](_0x9ad472,0x4)],_0x6254a0,0xf57c0faf);_0x46dbc7=_0x5f1ec4(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x2c','8mW]')+'g'](_0x9ad472,0x5)],_0x4cfc14,0x4787c62a);_0x250aaf=_0x27b846[_0x2a36('0xfa','54hK')+'t'](_0x5f1ec4,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0x6],_0xed0099,0xa8304613);_0x2b3b86=_0x27b846[_0x2a36('0x4b','ET&amp;B')+'d'](_0x5f1ec4,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0x7],_0xfea25,0xfd469501);_0x33f877=_0x5f1ec4(_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x8],_0x6254a0,0x698098d8);_0x46dbc7=_0x27b846[_0x2a36('0x6e','sCn1')+'M'](_0x5f1ec4,_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x117','w@7h')+'Z'](_0x9ad472,0x9)],_0x4cfc14,0x8b44f7af);_0x250aaf=_0x27b846[_0x2a36('0x56','XR!r')+'M'](_0x5f1ec4,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xa],_0xed0099,0xffff5bb1);_0x2b3b86=_0x5f1ec4(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0xb],_0xfea25,0x895cd7be);_0x33f877=_0x27b846[_0x2a36('0xf8','Um^)')+'M'](_0x5f1ec4,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0x143','pbz1')+'C'](_0x9ad472,0xc)],_0x6254a0,0x6b901122);_0x46dbc7=_0x5f1ec4(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0xb4','WWZM')+'Z'](_0x9ad472,0xd)],_0x4cfc14,0xfd987193);_0x250aaf=_0x5f1ec4(_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0x5d','k9V8')+'c'](_0x9ad472,0xe)],_0xed0099,0xa679438e);_0x2b3b86=_0x5f1ec4(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0xf],_0xfea25,0x49b40821);_0x33f877=_0x50d58f(_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0xe2','(Gcy')+'c'](_0x9ad472,0x1)],_0x21742d,0xf61e2562);_0x46dbc7=_0x50d58f(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0xf0','8ePc')+'c'](_0x9ad472,0x6)],_0x3aeb97,0xc040b340);_0x250aaf=_0x27b846[_0x2a36('0xa8','!lad')+'M'](_0x50d58f,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xb],_0x357b3b,0x265e5a51);_0x2b3b86=_0x27b846[_0x2a36('0xe1','8mW]')+'M'](_0x50d58f,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x136','WUwR')+'c'](_0x9ad472,0x0)],_0x5ac8da,0xe9b6c7aa);_0x33f877=_0x27b846[_0x2a36('0x14','ET&amp;B')+'v'](_0x50d58f,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x5],_0x21742d,0xd62f105d);_0x46dbc7=_0x50d58f(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x9ad472+0xa],_0x3aeb97,0x2441453);_0x250aaf=_0x27b846[_0x2a36('0xe9','Fn7$')+'W'](_0x50d58f,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xf],_0x357b3b,0xd8a1e681);_0x2b3b86=_0x27b846[_0x2a36('0x1d','&amp;1fo')+'W'](_0x50d58f,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x7','8sr^')+'c'](_0x9ad472,0x4)],_0x5ac8da,0xe7d3fbc8);_0x33f877=_0x27b846[_0x2a36('0x105','@GHf')+'W'](_0x50d58f,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x9],_0x21742d,0x21e1cde6);_0x46dbc7=_0x27b846[_0x2a36('0x113','k9V8')+'j'](_0x50d58f,_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x107','^EXY')+'c'](_0x9ad472,0xe)],_0x3aeb97,0xc33707d6);_0x250aaf=_0x27b846[_0x2a36('0x2','1W0i')+'s'](_0x50d58f,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0x0','!lad')+'t'](_0x9ad472,0x3)],_0x357b3b,0xf4d50d87);_0x2b3b86=_0x27b846[_0x2a36('0x66','MJC2')+'s'](_0x50d58f,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0x8],_0x5ac8da,0x455a14ed);_0x33f877=_0x27b846[_0x2a36('0x12c','nHo#')+'s'](_0x50d58f,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0xd],_0x21742d,0xa9e3e905);_0x46dbc7=_0x27b846[_0x2a36('0x4a','@GHf')+'Y'](_0x50d58f,_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x9ad472+0x2],_0x3aeb97,0xfcefa3f8);_0x250aaf=_0x27b846[_0x2a36('0xdd','8sr^')+'J'](_0x50d58f,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0x1e','fj6o')+'t'](_0x9ad472,0x7)],_0x357b3b,0x676f02d9);_0x2b3b86=_0x27b846[_0x2a36('0xf9','KohP')+'x'](_0x50d58f,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0xe3','^EXY')+'t'](_0x9ad472,0xc)],_0x5ac8da,0x8d2a4c8a);_0x33f877=_0x4d85c0(_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x5],_0x5b5acd,0xfffa3942);_0x46dbc7=_0x27b846[_0x2a36('0xd8','74L%')+'u'](_0x4d85c0,_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x9ad472+0x8],_0x306674,0x8771f681);_0x250aaf=_0x27b846[_0x2a36('0x94','#XP9')+'u'](_0x4d85c0,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xb],_0x27e21a,0x6d9d6122);_0x2b3b86=_0x27b846[_0x2a36('0x132','sCn1')+'O'](_0x4d85c0,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0xa7','g$*4')+'t'](_0x9ad472,0xe)],_0x10ffae,0xfde5380c);_0x33f877=_0x4d85c0(_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x1],_0x5b5acd,0xa4beea44);_0x46dbc7=_0x4d85c0(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x9ad472+0x4],_0x306674,0x4bdecfa9);_0x250aaf=_0x4d85c0(_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0x7],_0x27e21a,0xf6bb4b60);_0x2b3b86=_0x4d85c0(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0xa],_0x10ffae,0xbebfbc70);_0x33f877=_0x27b846[_0x2a36('0x7f','MWa5')+'N'](_0x4d85c0,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0xcb','54hK')+'y'](_0x9ad472,0xd)],_0x5b5acd,0x289b7ec6);_0x46dbc7=_0x4d85c0(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x11','[WEF')+'V'](_0x9ad472,0x0)],_0x306674,0xeaa127fa);_0x250aaf=_0x27b846[_0x2a36('0x123','jG(h')+'N'](_0x4d85c0,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0x8','k9V8')+'V'](_0x9ad472,0x3)],_0x27e21a,0xd4ef3085);_0x2b3b86=_0x4d85c0(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x13d','RX*q')+'B'](_0x9ad472,0x6)],_0x10ffae,0x4881d05);_0x33f877=_0x27b846[_0x2a36('0x49','u)Zx')+'I'](_0x4d85c0,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0xa6','ET&amp;B')+'O'](_0x9ad472,0x9)],_0x5b5acd,0xd9d4d039);_0x46dbc7=_0x4d85c0(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x45','#XP9')+'O'](_0x9ad472,0xc)],_0x306674,0xe6db99e5);_0x250aaf=_0x4d85c0(_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xf],_0x27e21a,0x1fa27cf8);_0x2b3b86=_0x4d85c0(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x73','nHo#')+'O'](_0x9ad472,0x2)],_0x10ffae,0xc4ac5665);_0x33f877=_0x27b846[_0x2a36('0x98','RKPm')+'Q'](_0x50f986,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x0],_0x57f0c7,0xf4292244);_0x46dbc7=_0x50f986(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x9ad472+0x7],_0x27805b,0x432aff97);_0x250aaf=_0x27b846[_0x2a36('0x5','@GHf')+'s'](_0x50f986,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xe],_0x1fa884,0xab9423a7);_0x2b3b86=_0x50f986(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0x5],_0x420e72,0xfc93a039);_0x33f877=_0x27b846[_0x2a36('0x67','KohP')+'s'](_0x50f986,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0x37','@GHf')+'w'](_0x9ad472,0xc)],_0x57f0c7,0x655b59c3);_0x46dbc7=_0x50f986(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x101','k9V8')+'x'](_0x9ad472,0x3)],_0x27805b,0x8f0ccc92);_0x250aaf=_0x50f986(_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x9ad472+0xa],_0x1fa884,0xffeff47d);_0x2b3b86=_0x27b846[_0x2a36('0x40','Um^)')+'s'](_0x50f986,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x50','WUwR')+'i'](_0x9ad472,0x1)],_0x420e72,0x85845dd1);_0x33f877=_0x27b846[_0x2a36('0x8e','1W0i')+'k'](_0x50f986,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x9ad472+0x8],_0x57f0c7,0x6fa87e4f);_0x46dbc7=_0x27b846[_0x2a36('0x12b','jG(h')+'k'](_0x50f986,_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x9ad472+0xf],_0x27805b,0xfe2ce6e0);_0x250aaf=_0x27b846[_0x2a36('0xa2','g$*4')+'V'](_0x50f986,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0x146','g$*4')+'x'](_0x9ad472,0x6)],_0x1fa884,0xa3014314);_0x2b3b86=_0x50f986(_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x27b846[_0x2a36('0x13c','Fn7$')+'x'](_0x9ad472,0xd)],_0x420e72,0x4e0811a1);_0x33f877=_0x27b846[_0x2a36('0xce','w@7h')+'V'](_0x50f986,_0x33f877,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x37f8ef[_0x27b846[_0x2a36('0x16','KohP')+'x'](_0x9ad472,0x4)],_0x57f0c7,0xf7537e82);_0x46dbc7=_0x50f986(_0x46dbc7,_0x33f877,_0x2b3b86,_0x250aaf,_0x37f8ef[_0x27b846[_0x2a36('0x3e','pbz1')+'x'](_0x9ad472,0xb)],_0x27805b,0xbd3af235);_0x250aaf=_0x27b846[_0x2a36('0x145','WUwR')+'p'](_0x50f986,_0x250aaf,_0x46dbc7,_0x33f877,_0x2b3b86,_0x37f8ef[_0x27b846[_0x2a36('0xa5','NK!y')+'x'](_0x9ad472,0x2)],_0x1fa884,0x2ad7d2bb);_0x2b3b86=_0x27b846[_0x2a36('0x9e','8ePc')+'p'](_0x50f986,_0x2b3b86,_0x250aaf,_0x46dbc7,_0x33f877,_0x37f8ef[_0x9ad472+0x9],_0x420e72,0xeb86d391);_0x33f877=_0x10618e(_0x33f877,_0x57eb7c);_0x2b3b86=_0x27b846[_0x2a36('0x139','(Gcy')+'L'](_0x10618e,_0x2b3b86,_0x31e09a);_0x250aaf=_0x10618e(_0x250aaf,_0x428396);_0x46dbc7=_0x27b846[_0x2a36('0x81','D##Z')+'L'](_0x10618e,_0x46dbc7,_0x57da6b);&#125;var _0xff4062=_0x27b846[_0x2a36('0x55','MWa5')+'C'](_0x27b846[_0x2a36('0xcc','D##Z')+'r'](_0x27b846[_0x2a36('0x108','ET&amp;B')+'g'](_0x52ae0b,_0x33f877),_0x52ae0b(_0x2b3b86)),_0x27b846[_0x2a36('0x10d','Oo24')+'g'](_0x52ae0b,_0x250aaf))+_0x27b846[_0x2a36('0x144','*VyA')+'E'](_0x52ae0b,_0x46dbc7);return _0xff4062[_0x2a36('0x124','CT)o')+_0x2a36('0x63','WUwR')+_0x2a36('0xdf','w@7h')]();&#125;;function go(_0x31cf1f)&#123;var _0x1266c2=&#123;&#125;;_0x1266c2[_0x2a36('0x138','w*YK')+'N']=_0x2a36('0x142','WWZM')+_0x2a36('0x84','@GHf');_0x1266c2[_0x2a36('0xc','54hK')+'j']=function(_0x3eac44,_0x259c4e)&#123;return _0x3eac44&lt;_0x259c4e;&#125;;_0x1266c2[_0x2a36('0x131','&amp;1fo')+'q']=function(_0x11f903,_0x2b4b3f)&#123;return _0x11f903!=_0x2b4b3f;&#125;;_0x1266c2[_0x2a36('0xd2','D##Z')+'M']=function(_0x472edd,_0x23ca5e)&#123;return _0x472edd+_0x23ca5e;&#125;;_0x1266c2[_0x2a36('0x5f','w*YK')+'J']=function(_0xf90608,_0xb8fa65)&#123;return _0xf90608&gt;_0xb8fa65;&#125;;_0x1266c2[_0x2a36('0x10f','8mW]')+'M']=_0x2a36('0xe','RX*q')+_0x2a36('0xc6','D##Z')+_0x2a36('0x13e','*VyA')+'。';_0x1266c2[_0x2a36('0x60','Oo24')+'p']=function(_0x161533,_0x291075)&#123;return _0x161533-_0x291075;&#125;;_0x1266c2[_0x2a36('0xd9','ET&amp;B')+'Z']=_0x2a36('0x5a','MJC2')+_0x2a36('0x2b','1W0i')+'=';_0x1266c2[_0x2a36('0xe7','Um^)')+'s']=function(_0x400cb1,_0x5523ff,_0x57272c)&#123;return _0x400cb1(_0x5523ff,_0x57272c);&#125;;_0x1266c2[_0x2a36('0x126','WWZM')+'D']=_0x2a36('0x59','k9V8')+'失败';var _0x396bf6=_0x1266c2;function _0x57eb87()&#123;var _0x55895e=window[_0x2a36('0x6b','8mW]')+_0x2a36('0x3f','MWa5')+'r'][_0x2a36('0x52','w*YK')+_0x2a36('0x10','54hK')+'t'],_0x1a8a3f=[_0x396bf6[_0x2a36('0x1f','&amp;1fo')+'N']];for(var _0x4248e4=0x0;_0x396bf6[_0x2a36('0x112','pbz1')+'j'](_0x4248e4,_0x1a8a3f[_0x2a36('0x13a','Um^)')+'th']);_0x4248e4++)&#123;if(_0x396bf6[_0x2a36('0x27','w@7h')+'q'](_0x55895e[_0x2a36('0x1a','D##Z')+_0x2a36('0xc0','^EXY')](_0x1a8a3f[_0x4248e4]),-0x1))&#123;return!![];&#125;&#125;if(window[_0x2a36('0xa9','cnTb')+_0x2a36('0x4e','jG(h')+_0x2a36('0xf6','XR!r')]||window[_0x2a36('0x34','XR!r')+_0x2a36('0xad','WUwR')]||window[_0x2a36('0x86','u)Zx')+_0x2a36('0x53','MWa5')]||window[_0x2a36('0x10a','54hK')+_0x2a36('0x118','G]I%')+'r'][_0x2a36('0x8f','KohP')+_0x2a36('0x3a','u)Zx')+'r']||window[_0x2a36('0xdc','WWZM')+_0x2a36('0xc8','(Gcy')+'r'][_0x2a36('0x36','D##Z')+_0x2a36('0x141','WWZM')+_0x2a36('0x92','fj6o')+_0x2a36('0x9d','8ePc')+'e']||window[_0x2a36('0xe8','6dCB')+_0x2a36('0x106','#XP9')+'r'][_0x2a36('0xb8','@GHf')+_0x2a36('0x76','^EXY')+_0x2a36('0xfe','pbz1')+_0x2a36('0x120','NK!y')+_0x2a36('0x8c','8ePc')])&#123;return!![];&#125;&#125;;if(_0x57eb87())&#123;return;&#125;var _0x5c13aa=new Date(),_0x37c620=![];function _0x5424b6(_0x784b1f,_0x2ab0b0)&#123;var _0x2e0724=&#123;&#125;;_0x2e0724[_0x2a36('0x8a','xz]x')+'Q']=function(_0x4f20c9,_0x10e848)&#123;return _0x4f20c9*_0x10e848;&#125;;_0x2e0724[_0x2a36('0xfd','Um^)')+'y']=function(_0x36d5f3,_0x4d3d49)&#123;return _0x36d5f3-_0x4d3d49;&#125;;var _0x100cd0=_0x2e0724;var _0xd8f11a=_0x31cf1f[_0x2a36('0x129','w*YK')+'s'][_0x2a36('0x26','sCn1')+'th'];for(var _0x578de5=0x0;_0x578de5&lt;_0xd8f11a;_0x578de5++)&#123;for(var _0x67dc03=0x0;_0x396bf6[_0x2a36('0xd1','(Gcy')+'j'](_0x67dc03,_0xd8f11a);_0x67dc03++)&#123;var _0xa6a2a1=_0x396bf6[_0x2a36('0x96','74L%')+'M'](_0x2ab0b0[0x0],_0x31cf1f[_0x2a36('0x4c','D##Z')+'s'][_0x2a36('0x134','#XP9')+'tr'](_0x578de5,0x1))+_0x31cf1f[_0x2a36('0xf4','@GHf')+'s'][_0x2a36('0x100','!N^6')+'tr'](_0x67dc03,0x1)+_0x2ab0b0[0x1];if(!_0x37c620&amp;&amp;_0x396bf6[_0x2a36('0xeb','RKPm')+'J'](new Date()-_0x5c13aa,0x5dc))&#123;if(_0x2a36('0x15','8mW]')+'S'!==_0x2a36('0x87','RX*q')+'S')&#123;lByte=lValue&gt;&gt;&gt;_0x100cd0[_0x2a36('0x20','Mza$')+'Q'](lCount,0x8)&amp;0xff;WordToHexValue_temp='0'+lByte[_0x2a36('0x119','RX*q')+_0x2a36('0xf5','[WEF')](0x10);WordToHexValue=WordToHexValue+WordToHexValue_temp[_0x2a36('0x11e','^EXY')+'tr'](_0x100cd0[_0x2a36('0xc9','xz]x')+'y'](WordToHexValue_temp[_0x2a36('0xd4','pbz1')+'th'],0x2),0x2);&#125;else&#123;alert(_0x396bf6[_0x2a36('0x61','RX*q')+'M']);_0x37c620=!![];&#125;&#125;if(hash(_0xa6a2a1)==_0x784b1f)&#123;return[_0xa6a2a1,_0x396bf6[_0x2a36('0x79','D##Z')+'p'](new Date(),_0x5c13aa)];&#125;&#125;&#125;&#125;;var _0x39b010=_0x396bf6[_0x2a36('0x57','WWZM')+'s'](_0x5424b6,_0x31cf1f['ct'],_0x31cf1f[_0x2a36('0x46','Mza$')]);if(_0x39b010)&#123;var _0x1ec1df;if(_0x31cf1f['wt'])&#123;_0x1ec1df=parseInt(_0x31cf1f['wt'])&gt;_0x39b010[0x1]?parseInt(_0x31cf1f['wt'])-_0x39b010[0x1]:0x1f4;&#125;else&#123;_0x1ec1df=0x5dc;&#125;setTimeout(function()&#123;document[_0x2a36('0xe6','#XP9')+'ie']=_0x396bf6[_0x2a36('0xe4','WUwR')+'M'](_0x396bf6[_0x2a36('0x1b','RX*q')+'M'](_0x396bf6[_0x2a36('0xca','1W0i')+'M'](_0x396bf6[_0x2a36('0x33','SKmL')+'M'](_0x396bf6[_0x2a36('0xe4','WUwR')+'M'](_0x31cf1f['tn'],'='),_0x39b010[0x0]),_0x396bf6[_0x2a36('0x109','1W0i')+'Z']),_0x31cf1f['vt']),_0x2a36('0x68','ET&amp;B')+_0x2a36('0x54','8mW]')+'\\x20/');location[_0x2a36('0x102','G]I%')]=location[_0x2a36('0xee','6dCB')+_0x2a36('0xbc','fj6o')]+location[_0x2a36('0x5b','!lad')+'ch'];&#125;,_0x1ec1df);&#125;else&#123;alert(_0x396bf6[_0x2a36('0xaf','k9V8')+'D']);&#125;&#125;;go(&#123;\"bts\":[\"1600342774.885|0|OiV\",\"7RX5sXpvy2sA7izwmZzPzM%3D\"],\"chars\":\"EiewupIGSGKcUxcMdlGSDW\",\"ct\":\"db8ca508fd98f0c8083856eebb648a4e\",\"ha\":\"md5\",\"tn\":\"__jsl_clearance\",\"vt\":\"3600\",\"wt\":\"1500\"&#125;)&lt;/script&gt; 逆向JS： 格式化JS代码 node 运行js文件 发现有 window document location alert等 node 环境没有的属性 使用 jsdom 解决第三步的问题 安装 npm i jsdom --save 修改 js 文件 前面添加 如下代码： 12345678const jsdom = require(\"jsdom\");const &#123; JSDOM &#125; = jsdom;const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`);window = dom.window;document = window.document;location = window.location;XMLHttpRequest = window.XMLHttpRequest;alert = console.log; 替换location 相关代码： 1234567location[_0x2a36(\"0x102\", \"G]I%\")] = location[_0x2a36(\"0xee\", \"6dCB\") + _0x2a36(\"0xbc\", \"fj6o\")] + location[_0x2a36(\"0x5b\", \"!lad\") + \"ch\"];``` 修改为：```jsconsole.log(document['cookie']); 再次 node 运行js文件 12&gt; node t2.js __jsl_clearance=1600342774.885|0|OiVew7RX5sXpvy2sA7izwmZzPzM%3D 环境中运行: 123456&gt;&gt;&gt; import re&gt;&gt;&gt; data = response.text&gt;&gt;&gt; js = re.findall('&lt;script&gt;(.*?)&lt;/script&gt;', data)[0]&gt;&gt;&gt; js_added_head = \"const jsdom = require('jsdom');const &#123; JSDOM &#125; = jsdom;const dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`);window = dom.window;document = window.document;location = window.location;XMLHttpRequest = window.XMLHttpRequest;alert = console.log;\"&gt;&gt;&gt; js = js_added_head + js 找到 location 赋值的正则表达式： 1location\\[.+\\]=[^;]+; 12&gt;&gt;&gt; re.findall('location\\[.+\\]=[^;]+;', js)[0]\"location[_0x2a36('0x102','G]I%')]=location[_0x2a36('0xee','6dCB')+_0x2a36('0xbc','fj6o')]+location[_0x2a36('0x5b','!lad')+'ch'];\" 替换： 1js = re.sub(r'location\\[.+\\]=[^;]+;', \"console.log(document['cookie']);\", js) 运行js: 需要npm环境，安装jsdom node_modules 路径: /Users/admin/workspace/exercises/python/scrapy/tutorial/js-reverse/node_modules 代码： 1234567891011121314151617181920212223&gt;&gt;&gt; import execjs&gt;&gt;&gt; ct = execjs.compile(js, cwd=r'/Users/admin/workspace/exercises/python/scrapy/tutorial/js-reverse/node_modules')&gt;&gt;&gt; execjs.eval(js, cwd=r'/Users/admin/workspace/exercises/python/scrapy/tutorial/js-reverse/node_modules')Traceback (most recent call last): File \"&lt;input&gt;\", line 1, in &lt;module&gt; execjs.eval(js, cwd=r'/Users/admin/workspace/exercises/python/scrapy/tutorial/js-reverse/node_modules') File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/__init__.py\", line 51, in eval return get().eval(source, cwd) File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/_abstract_runtime.py\", line 25, in eval return self.compile('', cwd=cwd).eval(source) File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/_abstract_runtime_context.py\", line 27, in eval return self._eval(source) File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/_external_runtime.py\", line 78, in _eval return self.exec_(code) File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/_abstract_runtime_context.py\", line 18, in exec_ return self._exec_(source) File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/_external_runtime.py\", line 88, in _exec_ return self._extract_result(output) File \"/Users/admin/.virtualenvs/scrapy/lib/python3.7/site-packages/execjs/_external_runtime.py\", line 167, in _extract_result raise ProgramError(value)execjs._exceptions.ProgramError: SyntaxError: Unexpected token 'const' 遇见 语法错误问题 使用 node 试试: 123&gt;&gt;&gt; with open(r'js-reverse/temp1.js', 'w+', encoding='utf-8') as f:... f.write(js)... 12node temp1.js__jsl_clearance=1600342774.885|0|OiVew7RX5sXpvy2sA7izwmZzPzM%3D 但 node 运行正常 修改 js_added_head 1js_added_head = \"const document = &#123; cookie: &#123;&#125; &#125;;const location = &#123;&#125;;const navigator = &#123;userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0'&#125;;const window = &#123; document, location, navigator &#125;;const alert = console.log;\" 使用 execjs 执行还是不行， node 运行正常 使用 python 执行shell命令： 12345678import subprocess&gt;&gt;&gt; ret=subprocess.getstatusoutput(\"node js-reverse/temp1.js\")&gt;&gt;&gt; ret(0, '__jsl_clearance=1600342774.885|0|OiVew7RX5sXpvy2sA7izwmZzPzM%3D;Max-age=3600; path = /')&gt;&gt;&gt; ret[1]'__jsl_clearance=1600342774.885|0|OiVew7RX5sXpvy2sA7izwmZzPzM%3D;Max-age=3600; path = /'&gt;&gt;&gt; jsl_clearance=ret[1].split(\";\")[0].split(\"=\")[1] 整理： 1234567891011def getJsCookie2T(self, response): data = response.text js = re.findall('&lt;script&gt;(.*?)&lt;/script&gt;', data)[0] js_added_head = \"const document = &#123; cookie: &#123;&#125; &#125;;const location = &#123;&#125;;const navigator = &#123;userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0'&#125;;const window = &#123; document, location, navigator &#125;;const alert = console.log;\" js = js_added_head + js js = re.sub(r'location\\[.+\\]=[^;]+;', \"console.log(document['cookie']);\", js) with open(r'js-reverse/temp1.js', 'w+', encoding='utf-8') as f: f.write(js) ret=subprocess.getstatusoutput(\"node js-reverse/temp1.js\") jsl_clearance=ret[1].split(\";\")[0].split(\"=\")[1] return jsl_clearance Python3爬虫实战、JS加解密、逆向教程 #Js 加密逆向分析教程 scrapy文档 如何破解极验滑动验证码？成功率 100%！","categories":[{"name":"Crawler","slug":"Crawler","permalink":"https://jigangduan.github.io/categories/Crawler/"},{"name":"Python","slug":"Crawler/Python","permalink":"https://jigangduan.github.io/categories/Crawler/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://jigangduan.github.io/tags/爬虫/"}]},{"title":"周育如 K.K 音標英文教學 (自然發音)","slug":"prefix_2135de493ff217a4f8bee2d4752741ba","date":"2020-02-11T02:14:19.000Z","updated":"2020-07-25T03:25:32.149Z","comments":true,"path":"2020/02/11/prefix_2135de493ff217a4f8bee2d4752741ba/","link":"","permalink":"https://jigangduan.github.io/2020/02/11/prefix_2135de493ff217a4f8bee2d4752741ba/","excerpt":"","text":"视频地址 a【æ】哎 不把ī音读出b【b】不 浊音不发ùc【k】克 轻音不发èd【d】得 浊音不发ée【e】哎 不把ī音读出来f【f】福 轻音不发úg【g】各 浊音不发èh【h】喝 轻音不读ēi【I】哎 急促地发声j【dʒ】姬 浊音不发ī(撅)k【k】克 轻音不发èl【l】前面(嘞嘞) 后面(凹凹)m【m】前面(么么) 后面(嗯嗯闭嘴)n【n】前面(讷讷) 后面(嗯嗯张嘴)o【a:】啊 嘴长到最大p【p】普 轻音不发īq【kw】阔r【r】前面：蕊 浊音 不发uǐ(弱) 后面：耳耳s【s】丝 轻音不发īt【t】特 轻音不发èu【ʌ】 阿 嘴微微张开v【v】呜 浊音不发úw【w】我 浊音不发ǒx【ks】克sy【j】呀 浊音不发ǎ(爷)z【z】就是/s/的浊音 除了aeiou 母音 = 元音 有变化。（母音先空着再自行判断发音）剩下都是 字音 = 辅音 没有变化。（字音部分先照抄） 碰到第一个重音节自行判断发音，碰到第二个 不再是重音节，不再重音的时候 aeiou绝大多数都念 a额。 e在尾巴时不发音前面就发本身的音 AEIOU碰到R第一次发 二（卷舌拖长音） 第二次碰到发 额（短音） 两个OO相连 最大几率念〔U午〕 第二几率念〔u雾〕 au ou aw ow 相连 常常念〔aU嗷~〕 死记硬背以下 ↓ th 相连 第一个上门牙轻轻咬住舌尖 无音的（有点送气音 斯~），第二个上门牙轻轻咬住舌尖念 子~ ch相连 取~ sh相连 嘘~ ph相连 符~ ng相连 在尾巴时常常念 嗯~ 有时候念 嗯割~ nk相连 嗯克~","categories":[{"name":"K.K 音標","slug":"K-K-音標","permalink":"https://jigangduan.github.io/categories/K-K-音標/"},{"name":"英语","slug":"K-K-音標/英语","permalink":"https://jigangduan.github.io/categories/K-K-音標/英语/"}],"tags":[{"name":"K.K 音標","slug":"K-K-音標","permalink":"https://jigangduan.github.io/tags/K-K-音標/"}]},{"title":"SQL语句 - INSERT 插入行","slug":"prefix_7dca6963ecbd1930c3060e682f98a4c4","date":"2020-01-17T03:47:10.000Z","updated":"2020-07-25T03:24:20.323Z","comments":true,"path":"2020/01/17/prefix_7dca6963ecbd1930c3060e682f98a4c4/","link":"","permalink":"https://jigangduan.github.io/2020/01/17/prefix_7dca6963ecbd1930c3060e682f98a4c4/","excerpt":"","text":"插入语句12345# 使用所有列的值插入语句INSERT INTO mytableVALUES (value_or_expr, another_value_or_expr, …), (value_or_expr_2, another_value_or_expr_2, …), …; 123456# 插入具有特定列的语句INSERT INTO mytable(column, another_column, …)VALUES (value_or_expr, another_value_or_expr, …), (value_or_expr_2, another_value_or_expr_2, …), …; 例子1234# 带表达式的示例插入语句INSERT INTO boxoffice(movie_id, rating, sales_in_millions)VALUES (1, 9.9, 283742034 / 1000000);","categories":[{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/categories/SQL/"},{"name":"SQL语句","slug":"SQL/SQL语句","permalink":"https://jigangduan.github.io/categories/SQL/SQL语句/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/tags/SQL/"}]},{"title":"SQL语句 - CREATE 创建表","slug":"prefix_45dbc5c48467fcc6ae6a50af83ada169","date":"2020-01-17T02:14:19.000Z","updated":"2020-07-25T03:24:06.993Z","comments":true,"path":"2020/01/17/prefix_45dbc5c48467fcc6ae6a50af83ada169/","link":"","permalink":"https://jigangduan.github.io/2020/01/17/prefix_45dbc5c48467fcc6ae6a50af83ada169/","excerpt":"","text":"CREATE TABLE 语句创建新的数据库表 123456# 创建带有可选表约束和默认值的表语句CREATE TABLE IF NOT EXISTS mytable ( column DataType TableConstraint DEFAULT default_value, another_column DataType TableConstraint DEFAULT default_value, …); 如果已经存在一个具有相同名称的表，则SQL实现通常会引发错误，因此可以使用该IF NOT EXISTS子句来抑制该错误并跳过创建表的操作（如果存在）。 表数据类型 数据类型 描述 INTEGER , BOOLEAN INTEGER类型可以存储整个整数值，例如数字或年龄。在某些实现中，BOOLEAN仅表示为仅0或1的整数值。 FLOAT，DOUBLE，REAL 浮点数据 类型可以存储更精确的数字数据，例如测量值或分数值。根据该值所需的浮点精度，可以使用不同的类型。 CHARACTER(num_chars)，VARCHAR(num_chars)，TEXT 基于文本的数据类型可以在各种语言环境中存储字符串和文本。在使用这些列时，各种类型之间的区别通常等于底层数据库的效率。 CHARACTER和VARCHAR(可变字符)类型均指定了它们可以存储的最大字符数（较长的值可能会被截断），因此可以更有效地存储和查询大表。 DATE， DATETIME SQL还可以存储日期和时间戳，以跟踪时间序列和事件数据。它们可能很难处理，尤其是在跨时区处理数据时。 BLOB 最后，SQL可以将二进制数据直接存储在数据库中的blob中。这些值对于数据库通常是不透明的，因此通常必须将它们与正确的元数据一起存储才能重新查询它们 文件： MySQL， Postgres， SQLite， Microsoft SQL Server 表约束 约束 描述 PRIMARY KEY 主键，这意味着该列中的值是唯一的，并且每个值都可用于标识该表中的单个行。 AUTOINCREMENT 对于整数值，这意味着该值将自动填充，并随 每次行插入而增加。并非所有数据库都支持。 UNIQUE 这意味着此列中的值必须是唯一的，因此您不能在此列中插入与表中的另一行具有相同值的另一行。与“ PRIMARY KEY”不同的是，它不必是表中一行的键。 NOT NULL 这意味着插入的值不能为“ NULL”。 CHECK (expression) 这使您可以运行更复杂的表达式来测试插入的值是否有效。例如，您可以检查值是正数还是大于特定大小，或者以特定前缀开头等等。 FOREIGN KEY 外键，这是一个一致性检查，可确保此列中的每个值都与另一个表中列中的另一个值相对应。 例子12345678# 电影表架构CREATE TABLE movies ( id INTEGER PRIMARY KEY, title TEXT, director TEXT, year INTEGER, length_minutes INTEGER);","categories":[{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/categories/SQL/"},{"name":"SQL语句","slug":"SQL/SQL语句","permalink":"https://jigangduan.github.io/categories/SQL/SQL语句/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/tags/SQL/"}]},{"title":"SQL语句 - SELECT的执行顺序","slug":"prefix_a6d5748b732dc69356c9aeed82b9a5b4","date":"2020-01-16T03:47:10.000Z","updated":"2020-07-25T03:27:07.043Z","comments":true,"path":"2020/01/16/prefix_a6d5748b732dc69356c9aeed82b9a5b4/","link":"","permalink":"https://jigangduan.github.io/2020/01/16/prefix_a6d5748b732dc69356c9aeed82b9a5b4/","excerpt":"","text":"完成SELECT查询 123456789SELECT DISTINCT column, AGG_FUNC(column_or_expression), …FROM mytable JOIN another_table ON mytable.column = another_table.column WHERE constraint_expression GROUP BY column HAVING constraint_expression ORDER BY column ASC/DESC LIMIT count OFFSET COUNT; 每个查询都从在数据库中找到我们所需的数据开始，然后将这些数据过滤成可以尽快处理和理解的内容。由于查询的每个部分都是按顺序执行的，因此了解执行顺序很重要，这样您才能知道在何处可以访问哪些结果. 查询执行顺序 FROM和JOINs首先执行该FROM子句和随后JOIN的，以确定要查询的数据的总工作集。这包括此子句中的子查询，并且可能导致在包含要连接的表的所有列和行的后台创建临时表。 WHERE一旦有了全部工作数据集，首先通过WHERE约束应用于各个行，而不满足约束的行将被丢弃。每个约束只能直接从FROM子句中请求的表中访问列。SELECT查询部分中的别名在 大多数数据库中不可访问，因为它们可能包含依赖于尚未执行的查询部分的表达式。 GROUP BYWHERE后，根据GROUP BY子句中指定列中的公共值，将应用约束后的其余行分组。分组的结果是，该列中的行数与唯一值的数目一样多。隐式地，这意味着仅在查询中具有聚合函数时才需要使用此函数。 HAVING如果查询中有一个GROUP BY子句，则该HAVING子句中的约束将应用于已分组的行，丢弃不满足约束的已分组的行。像该WHERE子句一样，大多数数据库中的此步骤也无法访问别名。 SELECTSELECT最后，查询部分中的所有表达式都会被计算。 DISTINCT在其余的行中，将删除列中标记为的重复值的行DISTINCT。 ORDER BY如果ORDER BY子句指定了顺序，则将按指定的数据以升序或降序对行进行排序。由于SELECT查询部分中的所有表达式均已计算，因此您可以在此子句中引用别名。 LIMIT/OFFSET最后，落入由所指定的范围之外的行LIMIT和OFFSET从查询返回的被丢弃，在离开最后行的集合。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/categories/SQL/"},{"name":"SQL语句","slug":"SQL/SQL语句","permalink":"https://jigangduan.github.io/categories/SQL/SQL语句/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/tags/SQL/"}]},{"title":"Git 项目推荐","slug":"prefix_4e0e07cc7827bfe7c7b4453215aa54ef","date":"2020-01-15T07:47:10.000Z","updated":"2020-07-25T03:18:04.273Z","comments":true,"path":"2020/01/15/prefix_4e0e07cc7827bfe7c7b4453215aa54ef/","link":"","permalink":"https://jigangduan.github.io/2020/01/15/prefix_4e0e07cc7827bfe7c7b4453215aa54ef/","excerpt":"","text":"Java汇总java生态圈 汇总java生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 Golangthe-way-to-go标准Go项目结构Go 语言的 goroutine 池kotlinKotlin实战(Kotlin in action) QtQMLQLMBookQmlBook-In-Chinese 可视化动态可视化 flourish 教程 文档一行代码：你的纯文本秒变Markdown : markdeepandroid抓包精灵MySQL在线练习MySQLsqlzooYearning SQL审核平台bilibili 视频可用 官网 语言： Golang 功能: SQL查询 查询工单 导出 自动补全，智能提示 查询语句审计 SQL审核 流程化工单 SQL语句检测与执行 SQL回滚 历史审核记录 推送 E-mail工单推送 钉钉webhook机器人工单推送 用户权限及管理 角色划分 基于用户的细粒度权限 注册 其他 todoList LDAP登录 动态审核规则配置 AutoTask自动执行 博客mtianyan’s blog","categories":[{"name":"笔记","slug":"笔记","permalink":"https://jigangduan.github.io/categories/笔记/"},{"name":"推荐","slug":"笔记/推荐","permalink":"https://jigangduan.github.io/categories/笔记/推荐/"}],"tags":[{"name":"推荐","slug":"推荐","permalink":"https://jigangduan.github.io/tags/推荐/"}]},{"title":"Python 虚拟环境 virtualenvwrapper","slug":"prefix_cc4fe649cad80b981be6647f61f06695","date":"2020-01-15T03:47:10.000Z","updated":"2020-07-25T03:29:02.991Z","comments":true,"path":"2020/01/15/prefix_cc4fe649cad80b981be6647f61f06695/","link":"","permalink":"https://jigangduan.github.io/2020/01/15/prefix_cc4fe649cad80b981be6647f61f06695/","excerpt":"","text":"安装12pip3 install virtualenvwrappermkdir ~/.virtualenvs 查找virtualenvwrapper.sh1which virtualenvwrapper.sh 配置文件~/.bash_profile : 12345678export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$DEV_PATH/workspaceexport VIRTUALENVWRAPPER_SCRIPT=/usr/local/bin/virtualenvwrapper.shexport VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenvexport VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages'source /usr/local/bin/virtualenvwrapper.sh 请对应真实路径 使用123456789101112$ mkvirtualenv test --python=python3$ lsvirtualenvtest====workon test## 退出环境testdeactivate## 删除环境testrmvirtualenv test 其它123pip freeze &gt; requirements.txtpip install -r requirements.txt","categories":[{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://jigangduan.github.io/categories/虚拟环境/"},{"name":"Python","slug":"虚拟环境/Python","permalink":"https://jigangduan.github.io/categories/虚拟环境/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"}]},{"title":"Node.js Web 介绍","slug":"node-web","date":"2019-10-23T07:12:30.000Z","updated":"2020-07-25T02:57:18.223Z","comments":true,"path":"2019/10/23/node-web/","link":"","permalink":"https://jigangduan.github.io/2019/10/23/node-web/","excerpt":"","text":"Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。1 Node.js作者认为 Web服务器的几个要点: 事件驱动 非阻塞I/O 特性JavaScript对比其它语言，选择JavaScript的原因： 对比语言： C的开发门槛高，业务开发困难 Haskell太过复杂 Lua本身有很多阻塞IO库 Ruby虚拟机性能不好 JavaScript的优势： 开发门槛低 没有阻塞IO库的历史包袱 JavaScript在浏览器广泛使用事件驱动 V8的性能优势 异步I/OIO密集型 编程模式的发展： 进程 ——&gt; 线程 ——&gt; 异步 ——&gt; 协程 异步I/O的优势： 用户体验 资源分配 阻塞与非阻塞 阻塞IO的一个特点是 调用之后一定要等待 系统内核层面完成操作后，调用才结束 非阻塞IO 调用后会立即返回 非阻塞的问题： 如何确定I/O操作是否完成 —— 轮询 8 循环read: 通过重复调用来 查询I/O状态。最原始，性能最低 select I/O多路复用，通过把多个I/O的阻塞复用到同一个select的阻塞上 通过对文件描述符上的事件状态来进行判断 存储状态采用1024长度的数组，限制了同时检查的数量 poll 对select的改进 采用链表的方式避免数组长度的限制 epoll 基于事件驱动的I/O方式 将用户关心的文件描述符的事件存放到内核的一个事件表 用户线程调用后进入睡眠状态 数据准备好后内核唤醒，然后只要遍历Ready队列的描述符集合 红黑树存储 AIO（异步I/O方式） 通过信号或回调传递数据 有系统实现上的缺陷，无法利用系统缓存 线程池模拟异步I/O 第三方实现 glibc libeio: 采用线程池与阻塞I/O模拟异步I/O (node v0.9.3之前采用方式) node 自实现了线程池异步I/O Windows的IOCP： 异步方法，等待I/O完成后通知，执行回调，用户无需轮询，线程池由系统内核管理 libuv: 封装了Windows 和 *nix 差异，提供抽象层 事件驱动Node 自身的执行模型 —— 事件循环（Event Loop）事件驱动的实质：通过主循环（Event Loop）加事件触发的方式来运行程序 node进程启动时，会创建一个类似于 while(true) 的循环，每执行一次循环体的过程 称为Tick.每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件的回调函数 执行；然后进入下次循环。 Node.js 的运行机制如下: V8 引擎解析 JavaScript 脚本。 解析后的代码，调用 Node API。 libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。 V8 引擎再将结果返回给用户。 libuv引擎中的事件循环分为 6 个阶段： Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。 timertimers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。 I/OI/O 阶段会处理一些上一轮循环中的少数未执行的 I/O 回调 idle, prepareidle, prepare 阶段内部实现 pollpoll 是一个至关重要的阶段，这一阶段中，系统会做两件事情 回到 timer 阶段执行回调 执行 I/O 回调并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacksclose callbacks 阶段执行 close 事件 对比一下: 浏览器中的 Event Loop任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 微任务 包括 process.nextTick ，promise ，MutationObserver。 宏任务 包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 Event Loop 执行顺序如下所示： 首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 单线程Node在在V8引擎上构建，所以它的模式和浏览器类似，JavaScript运行在单个进程的单个线程上。 优点： 程序状态 单一，没有多线程情况中的 锁, 线程同步 等问题，减少操作系统在调度时的上下文切换 缺点： 单线程 不能充分利用多核CPU – (性能) 一旦单线程上抛出的异常没有被捕获，会引起整个进程的奔溃 – (健壮性/稳定性) 解决的方法：集群主从模式 : 主进程：负责调度或管理工作进程，不负责具体的业务处理 工作进程：负责具体的业务处理 启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题；并发是靠事件驱动的方式。 集群稳定需要考虑： 性能问题 多个工作进程的存活状态管理 工作进程的平滑重启 配置或静态数据的动态重新载入 其它细节 Node Web简单的实现node.js 内置了 http package, 可以很容易的实现 web server的功能。 1234567891011var http = require('http')const PORT = 4337const HOST = '127.0.0.1'http.createServer(function (req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('Hello World\\n');&#125;).listen(PORT, HOST);console.log(`服务运行： http://$&#123;HOST&#125;:$&#123;PORT&#125;/`) 封装中间件的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const http = require('http')const url = require('url')const &#123; pathRegexp &#125; = require('./util')const &#123; resJSON, querystring &#125; = require('./middleware')const bodyParser = require('body-parser')const routes = &#123; all: [] &#125;;const app = &#123;&#125;;app.use = function(path) &#123; let handle; if (typeof path === 'string') &#123; handle = &#123; path: pathRegexp(path), stack: Array.prototype.slice.call(arguments, 1) &#125;; &#125; else &#123; handle = &#123; path: pathRegexp(), stack: Array.prototype.slice.call(arguments, 0) &#125; &#125; routes.all.push(handle)&#125;const methods = ['get', 'put', 'delete', 'post']methods.forEach(method =&gt; &#123; routes[method] = []; app[method] = (path, action) =&gt; &#123; const handle = &#123; path: pathRegexp(path), stack: action &#125;; routes[method].push(handle); &#125;;&#125;);const handle = (req, res, stack) =&gt; &#123; const next = (err) =&gt; &#123; if (err) &#123; return handle500(err, req, res, stack) &#125; const middleware = stack.shift(); if (middleware) &#123; // 传入next()函数自s身，使中间件能够执行结束后递归 try &#123; middleware(req, res, next) &#125; catch (error) &#123; next(error) &#125; &#125; &#125; next();&#125;app.use(resJSON);app.use(bodyParser.json())app.use(querystring);const requestListener = (req, res) =&gt; &#123; const match = (pathname, routes) =&gt; &#123; let stacks = []; for (let i = 0; i &lt; routes.length; i++) &#123; const route = routes[i]; const reg = route.path.regexp; const keys = route.path.keys; const matched = reg.exec(pathname); if (matched) &#123; const params = &#123;&#125;; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const value = matched[i + 1]; if (value) &#123; params[keys[i]] = value; &#125; &#125; req.params = params; stacks = stacks.concat(route.stack) &#125; &#125; return stacks; &#125; const pathname = url.parse(req.url).pathname; const method = req.method.toLowerCase(); let stacks = match(pathname, routes.all); if (Object.hasOwnProperty.call(routes, method)) &#123; stacks = stacks.concat(match(pathname, routes[method])); &#125; if (stacks.length) &#123; handle(req, res, stacks); &#125; else &#123; handle404(req. res); &#125;&#125;app.server = (port, hostname) =&gt; &#123; http.createServer(requestListener).listen(port, hostname);&#125;exports.app = app Express 2基于 Node.js 平台，快速、开放、极简的 Web 开发框架 Express 应用程序生成器: 1npx express-generator --view=pug myapp 特性： 保持最小规模的灵活 使用您所选择的各种 HTTP 实用工具和中间件，快速方便地创建强大的 API 提供精简的基本 Web 应用程序功能，而不会隐藏您了解和青睐的 Node.js 功能 框架 / 许多 流行的开发框架 都基于 Express 构建 1234567var express = require('express')var app = express()// respond with \"hello world\" when a GET request is made to the homepageapp.get('/', function (req, res) &#123; res.send('hello world')&#125;) Koa 3Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 koa wiki 🌰 ： koa-rest-api-boilerplate 123456789const Koa = require('koa');const app = new Koa();// responseapp.use(ctx =&gt; &#123; ctx.body = 'Hello Koa';&#125;);app.listen(3000); ThinkJs 4ThinkJS 是一款面向未来开发的 Node.js 框架，整合了大量的项目最佳实践，让企业级开发变得更简单、高效。从 3.0 开始，框架底层基于 Koa 2.x 实现，兼容 Koa 的所有功能。 特性： 基于 Koa 2.x，兼容 middleware 内核小巧，支持 Extend、Adapter 等插件方式 性能优异，单元测试覆盖程度高 内置自动编译、自动更新机制，方便快速开发 使用更优雅的 async/await 处理异步问题，不再支持 */yield 从 3.2 开始支持 TypeScript 模仿 ThinkPHP 的代码模式 代码风格： 12345678//src/controller/user.jsconst Base = require('./base.js');module.exports = class extends Base &#123; indexAction()&#123; this.body = 'hello world!'; &#125;&#125; nest 5用于构建高效且可伸缩的服务端应用程序的渐进式Node.js框架。 特性： 面向AOP编程 支持typeorm Node.js版的spring 构建微服务应用 仿Angular和Spring的风格，注解形式的编码风格 代码风格： 12345678910import &#123; Controller, Get, Req &#125; from '@nestjs/common';import &#123; Request &#125; from 'express';@Controller('cats')export class CatsController &#123; @Get() findAll(@Req() request: Request): string &#123; return 'This action returns all cats'; &#125;&#125; Egg.js 6Egg.js 为企业级框架和应用而生，我们希望由 Egg.js 孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。 特性： 提供基于 Egg 定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 egg 比较好的就是它的插件机制，和 统一的代码风格 eggjs 插件 eggjs 🌰 代码风格： 12345678910// app/controller/home.jsconst Controller = require('egg').Controller;class HomeController extends Controller &#123; async index() &#123; this.ctx.body = 'Hello world'; &#125;&#125;module.exports = HomeController; MidwayJS 7Midway是一个由typescript编写的Node.js Web框架，它利用IoC注入机制来解耦应用程序的业务逻辑，使大型Node.js应用程序的开发变得更简单、更自然。 特性： ✔︎复杂的组中间件体系结构和兼容性 ✔︎可扩展的插件功能和生态组插件 ✔︎好的应用分层和分离能力 ✔︎很好的未来发展经验 ✔︎支持egg插件和koa的中间件 midway例子 🌰 TS编程语言，和注解形式的编码风格： 12345678910111213141516import &#123; provide, controller, inject, get &#125; from 'midway';@provide()@controller('/user')export class UserController &#123; @inject('userService') service: IUserService; @get('/:id') async getUser(ctx): Promise&lt;void&gt; &#123; const id: number = ctx.params.id; const user: IUserResult = await this.service.getUser(&#123;id&#125;); ctx.body = &#123;success: true, message: 'OK', data: user&#125;; &#125;&#125; Node.js 中文网 Express 中文网 Koa 中文网 ThinkJs 中文网 nest 中文网 Egg.js MidwayJS","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"Web","slug":"Node-js/Web","permalink":"https://jigangduan.github.io/categories/Node-js/Web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"}]},{"title":"errors 编程","slug":"programming-with-errors","date":"2019-09-18T02:17:37.000Z","updated":"2020-07-25T02:57:18.225Z","comments":true,"path":"2019/09/18/programming-with-errors/","link":"","permalink":"https://jigangduan.github.io/2019/09/18/programming-with-errors/","excerpt":"","text":"Go 1.13引入了一个增强的package errors(即xerrors)，它大致标准化了带有错误的编程。就我个人而言，我觉得这个API令人困惑。这是一个如何有效使用它的快速参考。 创建errors前哨错误的工作原理与以前相同。将它们命名为ErrXxx，并使用errors.New创建它们。 1var ErrFoo = errors.New(\"foo error\") 错误类型的工作原理与以前基本相同。将它们命名为XxxError，并确保它们有一个错误方法，以满足错误接口。 1234567type BarError struct &#123; Reason string&#125;func (e BarError) Error() string &#123; return fmt.Sprintf(\"bar error: %s\", e.Reason)&#125; 如果您的错误类型包装了另一个错误，请提供一个Unwrap方法。 123456789101112131415type BazError struct &#123; Reason string Inner error&#125;func (e BazError) Error() string &#123; if e.Inner != nil &#123; return fmt.Sprintf(\"baz error: %s: %v\", e.Reason, e.Inner) &#125; return fmt.Sprintf(\"baz error: %s\", e.Reason)&#125;func (e BazError) Unwrap() error &#123; return e.Inner&#125; 包装和返回错误默认情况下，当您在函数中遇到错误并需要将其返回给调用者时，使用fmt.Errorf和新的%w谓词将其与有关错误的上下文包装起来。 12345func process(j Job) error &#123; result, err := preprocess(j) if err != nil &#123; return fmt.Errorf(\"error preprocessing job: %w\", err) &#125; 这个过程称为错误注释。避免返回未注释的错误，因为这会使调用者很难理解哪里出错了。 此外，对于更复杂的用例，可以考虑通过自定义错误类型(如上面的BazError)包装错误。这个过程称为错误注释。避免返回未注释的错误，因为这会使调用者很难理解哪里出错了。 此外，对于更复杂的用例，可以考虑通过自定义错误类型(如上面的BazError)包装错误。 12345 p := getPriority()widget, err := manufacture(p, result)if err != nil &#123; return ManufacturingError&#123;Priority: p, Error: err&#125; &#125; 检查错误大多数时候，当您收到错误时，您并不关心细节。无论您尝试做什么都失败了，所以您要么需要报告错误(例如，记录它)，然后继续;或者，如果无法继续，则使用上下文注释错误，并将其返回给调用者。 如果关心接收到的错误，可以使用errors.Is检查前哨错误，并使用errors.As检查错误值。 123456789101112err := f()if errors.Is(err, ErrFoo) &#123; // 你知道你错了 // 做出适当的回应&#125;var bar BarErrorif errors.As(err, &amp;bar) &#123; // 你知道你有个BarError // bar的字段被填充 // 做出适当的回应&#125; errors.Is和errors.As都将尝试递归地展开错误，以便找到匹配项。这段代码演示了基本的错误包装和检查技术。查看func a()中的检查顺序，然后尝试更改func c()返回的错误，以直观地了解所有内容是如何工作的。 正如包错误文档所述，宁可使用errors.Is，也不要检查普通的等式，例如if err == ErrFoo;并且更喜欢使用errors.As而不是普通类型断言，例如if e, ok:= err.(MyError)，因为普通版本不执行展开。如果您显式地不允许调用方打开错误，请为fmt提供一个不同的格式化谓词。Errorf,比如% v;或者不对错误类型提供Unwrap方法。但这种情况应该很少见。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"}]},{"title":"开源教育技术栈","slug":"edustack","date":"2019-05-04T02:36:49.000Z","updated":"2020-07-25T02:57:18.200Z","comments":true,"path":"2019/05/04/edustack/","link":"","permalink":"https://jigangduan.github.io/2019/05/04/edustack/","excerpt":"","text":"应用目录 基础软件 虚拟化 openstack 操作系统 Unbuntu Centos 邮件 RoundCube web服务器 Apache Nginx 数据库服务器Mysql phpmyadmin / Postgresql postgresqlstudio 单点登录 Apereo CAS 轻型目录访问协议LDAP OpenLDAP 云盘 ownCloud Seafile pydio API平台 Dreamfactory Swagger 移动后端开发 Parse 证书 LetsEncrypt 网络存储 FreeNAS 大数据 数据仓库ETL pentaho-kettle 商业智能BI spagoBI 日志分析 ELK Flume+Kafka+Strom CDH Cloudera 数据仓库 Greenplum 数据分析及可视化 SuperSet 内存大数据 Alluxio Geode 神经网络 TensorFlow 管理 系统管理 Webmin 虚拟主机 ISPconfig 数据中心 RackTables 监控 zabbix APM pinpoint 运维 SaltStack Ansible 漏洞扫描 openvas w3af 网络克隆 CloneZilla DBRL 跳板机 JumpServer 内容 内容管理系统 WordPress 搜索 Solr 知识社区 WeCenter 视频门户 MediaDrop github地址 视频处理 Kaltura 资源管理 ResourceSpace 教学科研 慕课MOOCS Open edX Canvas 课程管理 Moodle 代码管理 Gitlab 看板 WeKan 在线会议 BigBlueButton 课程制作 Course Builder / oppia 学术协作 OAEproject FOLIO FOLIO是图书馆，开发商和供应商合作建立的一个开源图书馆服务平台。 它支持传统的资源管理功能，可以扩展到其他机构领域。 社交 聊天机器人 Hubot 讨论区 Discourse 投票 Limesurvey 即时通信 Rocket.Chat 分布式社交网络 Mastodon 桌面 绘图 krita 数学软件 Geogebra","categories":[],"tags":[]},{"title":"editors","slug":"editors","date":"2019-05-02T16:41:40.000Z","updated":"2020-07-25T02:57:18.200Z","comments":true,"path":"2019/05/03/editors/","link":"","permalink":"https://jigangduan.github.io/2019/05/03/editors/","excerpt":"","text":"WEBCODESK React Web应用程序的快速开发工具 先进的React GUI编辑器 — Structor 弃用 页面可视化搭建工具前生今世页面可视化搭建工具技术要点 pipeline-editor","categories":[],"tags":[]},{"title":"在线文档收录","slug":"online-doc","date":"2019-05-02T12:06:37.000Z","updated":"2020-07-25T02:57:18.224Z","comments":true,"path":"2019/05/02/online-doc/","link":"","permalink":"https://jigangduan.github.io/2019/05/02/online-doc/","excerpt":"","text":"源码下载 发现-语雀 从前端角度看企业软件的研发过程 中国科学技术大学课程资源 互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构 人人都能用英语 李笑来 github图片 树莓派开始，玩转Linux 中台之上 从初创型到独角兽企业，监控架构演进的那些事儿 IntelliJ IDEA 简体中文专题教程 后台产品设计系列 各大互联网公司架构演进之路汇总 盘点阿里巴巴 15 款开发者工具 掘金翻译计划 vi/vim使用进阶 Maven史上最全教程 GitHub上有一份大神整理的十几年“渗透攻击”经验 11个springboot快速开发的项目，接私活利器 后台开源管理系统技术及设计学习总结 前端 一个合格(优秀)的前端都应该阅读这些文章 前端基础进阶系列 前端九部 - 入门者手册2019 JS 函数式编程指南 在 JavaScript ES6+ 中从零开始学习函数式编程&amp;组合式软件编写系列译文 前端工匠 深予之个人博客 从 1 到完美，用 node 写一个命令行工具 eagle.js: 一个用Vue.js构建的可编程幻灯片框架 CSS_training 现代 JavaScript 教程 JavaScript 代码整洁之道 网站渐进式增强体验(PWA)改造：Service Worker 应用详解 Vue.js 技术揭秘 React 源码解析 15 个有趣的 JS 和 CSS 库 wechat-h5-boilerplate: 为腾讯微信优化的H5动效模板，帮助你快速构建全屏滚动型H5页面。 iSlider 如丝般高性能H5全屏滑动组件 前端在线简历能用到的炫酷UI库 一款高效、高性能的帧动画生成工具 TypeScript Awesome TypeScript TypeScript，初次见面，请多指教 可能是你需要的react + typescript 50条规范和经验 WebGL WebGL 理论基础 Flutter Flutter 实战 Flutter社区中文资源 Node.js Node.js 调试指南 通过Github与PM2部署Node应用 Golang Go命令行库Cobra的使用 Viper:Go应用程序的完整配置解决方案 Java Java 8 Tutorial Design patterns implemented in Java(Java设计模式) Spring Cloud Stream中文指导手册 Docker 每天5分钟玩转 Docker 容器技术 每天5分钟玩转 Kubernetes 容器监控方案汇总 github Knative 入门系列 - 基于 Kubernetes 的serverless prometheus(普罗米修斯) - 监控报警系统 0个基于DOCKER的顶尖开发工具 Python Python - 100天从新手到大师 大牛推荐的10本学习 Python 的好书 Django入门与实践教程 Python进阶 机器学习 100-Days-Of-ML-Code中文版 深度学习500问 面试 Js 面试之道 互联网 Java 工程师进阶知识完全扫盲 React 面试题 &amp; 回答 100道python真实面试题 JavaGuide 程序员修炼之路 feguide面试库 可视化和分析图http://js.cytoscape.org可参考：https://graphqleditor.comhttps://diagram.graphqleditor.comhttps://gojs.net/latest/index.html可参考： https://webglstudio.org数据库数据可视化： https://metabase.com/ 和 https://github.com/getredash/redash（很像公司可视化生成需求）http://visjs.orghttps://github.com/mojs/mojs（motion） Cube.js是一个开源模块化框架，用于构建分析Web应用程序。它主要用于构建内部商业智能工具或将面向客户的分析添加到现有应用程序。 快速开发开源项目SpringWind：Java EE（J2EE）快速开发框架Crown：Mybatisplus 3.0 教学版Crab：WEB 极速开发框架KangarooAdmin：轻量级权限管理框架iBase4J：Java 分布式快速开发基础平台framework：后台管理框架BMS：基础权限开发框架spring-shiro-training：简单实用的权限脚手架center：系统管理中心系统skeleton：Springboot-Shiro 脚手架springboot_mybatisplus：基于 SpringBoot 的美女图片爬虫系统guns：guns 后台管理系统maple：maple 企业信息化的开发基础平台jeeweb-mybatis：JeeWeb 敏捷开发平台youngcms：CMS 平台king-admin：前后端分离的基础权限管理后台jeefast：前后端分离 Vue 快速开发平台bing-upms：SpringBoot + Shiro +FreeMarker 制作的通用权限管理slife：SpringBoot 企业级快速开发脚手架pig：微服务 Spring Cloud 架构mysiteforme：系统后台watchdog-framework：基础权限框架iartisan-admin-template：Java 快速开发平台ifast：ifast 快速开发平台roses：基于 Spring Cloud 的分布式框架renren-security：人人权限系统freeter-admin：飞特后台管理系统vblog：VBlog 博客系统jiiiiiin-security：jiiiiiin权限系统hdw-dubbo：HDW快速开发平台pybbs：更好用的Java语言社区(论坛)SmallBun：SmallBun企业级开发脚手架webplus：综合开发平台x-boot：VUE 前后端分离开发平台nice-blog-sys：基于SpirngBoot开发，好看的个人博客。 快速上手 Spring Boot 看这些就够了！ zheng 开源推荐Spring boot 微服务高效开发 mica 工具集：https://gitee.com/596392912/micaAvue 一款基于vue可配置化的神奇框架：https://gitee.com/smallweigit/avuepig 宇宙最强微服务（架构师必备）：https://gitee.com/log4j/pigSpringBlade 完整的线上解决方案（企业开发必备）：https://gitee.com/smallc/SpringBlade加入【如梦技术】Spring QQ群：479710041，了解更多。","categories":[{"name":"文档","slug":"文档","permalink":"https://jigangduan.github.io/categories/文档/"}],"tags":[{"name":"文档","slug":"文档","permalink":"https://jigangduan.github.io/tags/文档/"}]},{"title":"Java高并发(2) 并发基础","slug":"java-high-concurrency-02","date":"2019-04-18T13:57:56.000Z","updated":"2020-07-25T02:57:18.210Z","comments":true,"path":"2019/04/18/java-high-concurrency-02/","link":"","permalink":"https://jigangduan.github.io/2019/04/18/java-high-concurrency-02/","excerpt":"","text":"CPU多级缓存CPU为何要有高速缓存CPU的频率太快了，快到主存跟不上，这样在处理时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构： cpu -&gt; cache -&gt; memory) CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\\O速度和CPU运算速度之间的不匹配问题。 CPU cache 意义 时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 空间局部性: 如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。 带有高速缓存的CPU执行计算的流程 程序以及数据被加载到主内存 指令和数据被加载到CPU的高速缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 目前流行多级缓存结构 缓存一致性（MESI） 缓存行（Cache line）: 缓存存储数据的单元 MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是： 状态 描述 监听任务 M 修改 (Modified) 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 E 独享、互斥 (Exclusive) 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 S 共享 (Shared) 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 I 无效 (Invalid) 该Cache line无效。 无 MESI状态转换: 触发事件: 触发事件 描述 本地读取（Local read） 本地cache读取本地cache数据 本地写入（Local write） 本地cache写入本地cache数据 远端读取（Remote read） 其他cache读取本地cache数据 远端写入（Remote write） 其他cache写入本地cache数据 右边图示意了，当一个cache line的调整的状态的时候，另外一个cache line 需要调整的状态 举个栗子来说：假设cache 1 中有一个变量x = 0的cache line 处于S状态(共享)。那么其他拥有x变量的cache 2、cache 3等x的cache line调整为S状态（共享）或者调整为 I 状态（无效）。 指令重排和内存屏障指令重排现代CPU的速度越来越快，为了充分的利用CPU，在编译器和CPU执行期，都可能对指令重排。 在并发模型下，重排序还是可能会引发问题，比较经典的就是“单例模式失效”问题 12345678910111213141516public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance == null) &#123; synchronzied(Singleton.class) &#123; if(instance == null) &#123; instance = new Singleton(); // &#125; &#125; &#125; return instance; &#125;&#125; 上面这段代码，初看没问题，但是在并发模型下，可能会出错,那是因为instance= new Singleton()并非一个原子操作，它实际上下面这三个操作： 123memory = allocate(); //1：分配对象的内存空间ctorInstance(memory); //2：初始化对象instance = memory; //3：设置instance指向刚分配的内存地址 上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下： 123memory = allocate(); //1：分配对象的内存空间instance = memory; //3：instance指向刚分配的内存地址，此时对象还未初始化ctorInstance(memory); //2：初始化对象 可以看到指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在多线程场景下，可能A线程执行到了3，B线程发现已经不为空就返回继续执行，就会出错。 在java里面volatile可以防止重排，还有另外一个作用即内存可见性 内存屏障硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。内存屏障有两个作用： 阻止屏障两侧的指令重排序； 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。 对于volatile关键字，按照规范会有下面的操作： 在每个volatile写入之前，插入一个StoreStore，写入之后，插入一个StoreLoad 在每个volatile读取之前，插入LoadLoad，之后插入LoadStore Java内存模型","categories":[{"name":"Java","slug":"Java","permalink":"https://jigangduan.github.io/categories/Java/"},{"name":"高并发","slug":"Java/高并发","permalink":"https://jigangduan.github.io/categories/Java/高并发/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"}]},{"title":"Java高并发(1) 介绍","slug":"java-high-concurrency-01","date":"2019-04-17T12:54:14.000Z","updated":"2020-07-25T02:57:18.210Z","comments":true,"path":"2019/04/17/java-high-concurrency-01/","link":"","permalink":"https://jigangduan.github.io/2019/04/17/java-high-concurrency-01/","excerpt":"","text":"相关概念并发知识点： 线程安全 线程封闭 线程调度 同步容器 并发容器 AQS J.U.C … 高并发解决思路与手段： 扩容 缓存 队列 拆分 服务降级与熔断 数据库切库 分库分表 … 简单场景举例简单计数 Demo 1 - CountExample 1234567891011121314151617181920212223242526272829303132333435package com.mmall.demo;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class CountExample &#123; private static int threadTotal = 200; private static int clientTotal = 5000; private static long count = 0; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; exec.execute(() -&gt; &#123; try &#123; semaphore.acquire(); add(); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; exec.shutdown(); System.out.println(count); &#125; private static void add() &#123; count++; &#125;&#125; 使用线程池和信号量(Semaphore)，使用整型计数。 输出结果： 1234998Process finished with exit code 0 每次输出结果都不一样 Demo 2 - MapExample 123456789101112131415161718192021222324252627282930313233343536373839package com.mmall.demo;import java.util.HashMap;import java.util.Map;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class MapExample &#123; private static int threadTotal = 200; private static int clientTotal = 5000; private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int threadNmu = i; exec.execute(() -&gt; &#123; try &#123; semaphore.acquire(); func(threadNmu); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; exec.shutdown(); System.out.println(map.size()); &#125; private static void func(int threadNmu) &#123; map.put(threadNmu, threadNmu); &#125;&#125; 同样使用线程池和信号量(Semaphore)，但使用Map计数。 输出结果： 1234999Process finished with exit code 0 每次输出结果都不一样 并发与高并发基本概念并发同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地换入或者换出内容，这些线程是同时存在的，每个线程处于执行过程中的某个状态，如果运行在多核处理上时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。 高并发(High Concurrency)高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 比较 并发： 多个线程操作相同的资源，保证线程安全，合理使用资源 高并发： 服务能同时处理很多请求，提高程序性能 涉及知识点 知识技能 基础框架： Spring Boot, Maven, JDK8, MySQL 基础组件： Mybatis, Guava, Lombok, Redis, Kafka 高级类： Joda-Time, Atomic包, J.U.C, AQS, ThreadLoacl, RateLimiter, Hystrix, threadPool, shardbatis, curator, elastic-job…","categories":[{"name":"Java","slug":"Java","permalink":"https://jigangduan.github.io/categories/Java/"},{"name":"高并发","slug":"Java/高并发","permalink":"https://jigangduan.github.io/categories/Java/高并发/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"}]},{"title":"Spring Cloud Alibaba(1) nacos服务注册与发现","slug":"spring-cloud-alibaba-nacos-p1","date":"2019-03-20T08:58:53.000Z","updated":"2020-07-25T02:57:18.228Z","comments":true,"path":"2019/03/20/spring-cloud-alibaba-nacos-p1/","link":"","permalink":"https://jigangduan.github.io/2019/03/20/spring-cloud-alibaba-nacos-p1/","excerpt":"","text":"","categories":[{"name":"Spring Cloud Alibaba","slug":"Spring-Cloud-Alibaba","permalink":"https://jigangduan.github.io/categories/Spring-Cloud-Alibaba/"},{"name":"Spring Cloud","slug":"Spring-Cloud-Alibaba/Spring-Cloud","permalink":"https://jigangduan.github.io/categories/Spring-Cloud-Alibaba/Spring-Cloud/"},{"name":"Spring","slug":"Spring-Cloud-Alibaba/Spring-Cloud/Spring","permalink":"https://jigangduan.github.io/categories/Spring-Cloud-Alibaba/Spring-Cloud/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://jigangduan.github.io/tags/spring-cloud/"},{"name":"nacos","slug":"nacos","permalink":"https://jigangduan.github.io/tags/nacos/"}]},{"title":"react-parsing-2","slug":"react-parsing-2","date":"2019-03-18T14:12:13.000Z","updated":"2020-07-25T02:57:18.226Z","comments":true,"path":"2019/03/18/react-parsing-2/","link":"","permalink":"https://jigangduan.github.io/2019/03/18/react-parsing-2/","excerpt":"","text":"准备工作 源码地址以及目录结构 React和React-Dom Flow Type","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"React 解析","slug":"React/React-解析","permalink":"https://jigangduan.github.io/categories/React/React-解析/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"}]},{"title":"React 解析(1) - API","slug":"react-parsing","date":"2019-03-18T11:30:16.000Z","updated":"2020-07-25T02:57:18.226Z","comments":true,"path":"2019/03/18/react-parsing/","link":"","permalink":"https://jigangduan.github.io/2019/03/18/react-parsing/","excerpt":"","text":"React 的特色 React 是纯粹的框架 1UI = fn(x) 只能使用setState，没有双向数据绑定 思想超强，React16重写了底层但一点都不影响上层代码 Fiber: 改变了之前react的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务，释放浏览器主线程。 React API createElement createContext JSX =&gt; JS ConcurrentMode Ref Component Suspense Hooks React中的更新创建 ReactDOM.render Fiber UpdateQueue FiberRoot Update expirationTime React Scheduler（调度） scheduleWork batchedUpdates performWork performUnitOfWork requestWork react scheduler renderRoot 开始更新 beginWork以及优化 各类组件的更新过程 调和子节点的过程 完成各个节点的更新 completeUnitOfWork completeWork unwindWork 虚拟DOM对比 错误捕获处理 完成整棵树更新 提交更新 commitRoot整体流程 开发时的帮助方法 提交快照 提交DOM插入 提交DOM更新 提交DOM删除 提交所有声明周期 各种功能的实现过程 context的实现过程 ref的实现过程 hydrate的实现过程 React的事件体系 Suspense 更新优先级的概念 Suspense组件更新 retry更新尝试渲染 更新挂起的概念 timeout处理 lazy组件更新 Hooks 核心原理 useState useEffect useContext 其它Hooks API React的源码实现 Fiber, Update, Scheduler等核心着重讲解 流程图和结构图辅助","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"React 解析","slug":"React/React-解析","permalink":"https://jigangduan.github.io/categories/React/React-解析/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"}]},{"title":"MySQL 规范","slug":"mysql-specification","date":"2019-03-13T04:53:32.000Z","updated":"2020-07-25T02:57:18.222Z","comments":true,"path":"2019/03/13/mysql-specification/","link":"","permalink":"https://jigangduan.github.io/2019/03/13/mysql-specification/","excerpt":"","text":"数据库命名 数据库基本设计 所有表必须使用Innodb存储引擎 数据库和表的字符集统一使用UTF8 所有表和字段都需要添加注释 尽量控制单表数据量的大小，建议控制在500万以内 谨慎使用MySQL分区表 尽量做到冷热数据分离，减小表的宽度 禁止在表中建立预留字段 禁止在数据库中存储图片，文件等大的二进制数据 禁止在线上做数据库压力测试 禁止从开发环境，测试环境直接连接生成环境数据库 数据库字段 优先选择符合存储需要的最小的数据类型 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据 避免使用ENUM类型 尽可能把所有列定义为NOT NULL 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间 同财务相关的金额类数据必须使用decimal类型 索引 限制每张表上的索引数量，建议单张表索引不超过5个 禁止给表中的每一列都建立单独的索引 每个Innodb表必须有个主键 常见索引列建议 如何选择索引列的顺序 避免建立冗余索引和重复索引 优先考虑覆盖索引 索引SET规范 数据库SQL开发 建议使用预编译语句进行数据库操作 避免数据类型的隐式转换 充分利用表上已经存在的索引 数据库设计时，应该要对以后扩展进行考虑 程序连接不同的数据库使用不同的账号，进制跨库查询 禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询 禁止使用不含字段列表的INSERT语句 避免使用子查询，可以把子查询优化为join操作 避免使用JOIN关联太多的表 减少同数据库的交互次数 对应同一列进行or判断时，使用in代替or 禁止使用order by rand() 进行随机排序 WHERE从句中禁止对列进行函数转换和计算 在明显不会有重复值时使用UNION ALL而不是UNION 拆分复杂的大SQL为多个小SQL 数据库操作行为 超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作 对于大表使用pt-online-schema-change修改表结构 禁止为程序使用的账号赋予super权限 对于程序连接数据库账号，遵循权限最小原则 数据库命名 数据库对象名称必须使用小写字母并用下划线分割 数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低） 数据库基本设计所有表必须使用Innodb存储引擎没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎 Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好 mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb 数据库和表的字符集统一使用UTF8兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效 所有表和字段都需要添加注释使用comment从句添加表和列的备注 从一开始就进行数据字典的维护 尽量控制单表数据量的大小，建议控制在500万以内500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小 谨慎使用MySQL分区表分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据 尽量做到冷热数据分离，减小表的宽度MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据经常一起使用的列放到一个表中（避免更多的关联操作） 禁止在表中建立预留字段预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定 禁止在数据库中存储图片，文件等大的二进制数据通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息 禁止在线上做数据库压力测试禁止从开发环境，测试环境直接连接生成环境数据库数据库字段优先选择符合存储需要的最小的数据类型 原因 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差 方法 1) 将字符串转换成数字类型存储，如：将IP地址转换成整形数据 mysql提供了两个方法来处理ip地址： 12inet_ation 把ip转成无符号整型(4-8位)inet_ntoa 把整型的IP转成地址 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。 2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储 因为：无符号相对于有符号可以多出一倍的存储空间 12SIGNED INT -2147483648~2147483647UNSIGNED INT 0~4294967295 VARCHAR(N)中的N代表的是字符数，而不是字节数 使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据 建议把BLOB或是TEXT列分离到单独的扩展表中 Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。 而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。 如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。 TEXT或BLOB类型只能使用前缀索引 因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。 避免使用ENUM类型 修改ENUM值需要使用ALTER语句 ENUM类型的ORDER BY操作效率低，需要额外操作 禁止使用数值作为ENUM的枚举值 尽可能把所有列定义为NOT NULL原因： 索引NULL列需要额外的空间来保存，所以要占用更多的空间； 进行比较和计算时要对NULL值做特别的处理 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。 TIMESTAMP 占用4字节和INT相同，但比INT可读性高 超出TIMESTAMP取值范围的使用DATETIME类型存储。 经常会有人用字符串存储日期型的数据（不正确的做法）： 缺点1：无法用日期函数进行计算和比较 缺点2：用字符串存储日期要占用更多的空间 同财务相关的金额类数据必须使用decimal类型 非精准浮点：float,double 精准浮点：decimal Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 索引限制每张表上的索引数量，建议单张表索引不超过5个索引并不是越多越好！索引可以提高效率同样可以降低效率。 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。 因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。 禁止给表中的每一列都建立单独的索引5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好 每个Innodb表必须有个主键Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。 每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。 主键建议使用自增ID值。 常见索引列建议 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列 包含在ORDER BY、GROUP BY、DISTINCT中的字段 并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好 多表join的关联列 如何选择索引列的顺序建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）； 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）； 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。 避免建立冗余索引和重复索引因为这样会增加查询优化器生成执行计划的时间。 重复索引示例：primary key(id)、index(id)、unique index(id) 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 优先考虑覆盖索引对于频繁的查询优先考虑使用覆盖索引。 覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引 覆盖索引的好处： 避免Innodb表进行索引的二次查询 Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息， 如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。 可以把随机IO变成顺序IO加快查询效率 由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。 索引SET规范尽量避免使用外键约束 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引； 外键可用于保证数据的参照完整性，但建议在业务端实现； 外键会影响父表和子表的写操作从而降低性能。 数据库SQL开发建议使用预编译语句进行数据库操作预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。 避免数据类型的隐式转换隐式转换会导致索引失效。如：select name,phone from customer where id = &#39;111&#39;; 充分利用表上已经存在的索引 避免使用双%号的查询条件 如a like &#39;%123%&#39;，（如果无前置%,只有后置%，是可以用到列上的索引的） 一个SQL只能利用到复合索引中的一列进行范围查询 如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。 使用left join或 not exists来优化not in操作 因为not in 也通常会使用索引失效。 数据库设计时，应该要对以后扩展进行考虑程序连接不同的数据库使用不同的账号，进制跨库查询 为数据库迁移和分库分表留出余地 降低业务耦合度 避免权限过大而产生的安全风险 禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询原因： 消耗更多的CPU和IO以网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 禁止使用不含字段列表的INSERT语句如：insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;); 应使用insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;); 避免使用子查询，可以把子查询优化为join操作通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响； 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大； 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。 避免使用JOIN关联太多的表对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。 在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。 减少同数据库的交互次数数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 对应同一列进行or判断时，使用in代替orin的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。 禁止使用order by rand() 进行随机排序会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 WHERE从句中禁止对列进行函数转换和计算对列进行函数转换或计算时会导致无法使用索引。 不推荐： 1where date(create_time)='20190101' 推荐： 1where create_time &gt;= '20190101' and create_time &lt; '20190102' 在明显不会有重复值时使用UNION ALL而不是UNION UNION会把两个结果集的所有数据放到临时表中后再进行去重操作 UNION ALL不会再对结果集进行去重操作 拆分复杂的大SQL为多个小SQL 大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL MySQL：一个SQL只能使用一个CPU进行计算 SQL拆分后可以通过并行执行来提高处理效率 数据库操作行为超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作 大批量操作可能会造成严重的主从延迟 主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况 binlog日志为row格式时会产生大量的日志 大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。 避免产生大事务操作 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。 对于大表使用pt-online-schema-change修改表结构 避免大表修改产生的主从延迟 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。 pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。 把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。 把原来一个DDL操作，分解成多个小的批次进行。 禁止为程序使用的账号赋予super权限当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。 对于程序连接数据库账号，遵循权限最小原则程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (20) 表维护/杂项","slug":"mysql-notes-20","date":"2019-03-12T14:54:24.000Z","updated":"2020-07-25T02:57:18.221Z","comments":true,"path":"2019/03/12/mysql-notes-20/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-20/","excerpt":"","text":"表维护 分析和存储表的关键字分布 1ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... 检查一个或多个表是否有错误 12CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125; 整理数据文件的碎片 1OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 每个库目录存在一个保存当前数据库的选项文件db.opt。 注释： 单行注释 # 注释内容 多行注释 / 注释内容 / 单行注释 – 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\’ CMD命令行内的语句结束符可以为 “;”, “\\G”, “\\g”，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 SQL对大小写不敏感 清除已有语句：\\c","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (19) 用户和权限管理","slug":"mysql-notes-19","date":"2019-03-12T14:46:21.000Z","updated":"2020-07-25T02:57:18.220Z","comments":true,"path":"2019/03/12/mysql-notes-19/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-19/","excerpt":"","text":"root密码重置 停止MySQL服务 [Linux] /usr/local/mysql/bin/safe_mysqld –skip-grant-tables &amp; [Windows] mysqld –skip-grant-tables use mysql; UPDATE user SET PASSWORD=PASSWORD(“密码”) WHERE user = “root”; FLUSH PRIVILEGES; 用户信息表：mysql.user 刷新权限1FLUSH PRIVILEGES; 增加用户1CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 只能创建用户，不能赋予权限。 用户名，注意引号：如 ‘user_name‘@’192.168.1.1’ 密码也需引号，纯数字密码也要加引号 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD 重命名用户1RENAME USER old_user TO new_user 设置密码12SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码 删除用户1DROP USER 用户名 分配权限/添加用户1GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] all privileges 表示所有权限 . 表示所有库的所有表 库名.表名 表示某库下面的某表 1GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817'; 查看权限1SHOW GRANTS FOR 用户名 查看当前用户权限 1SHOW GRANTS; 或 1SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); 撤消权限12REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 权限层级要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON .和 REVOKE ALL ON .只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.和REVOKE ALL ON db_name.只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。 权限列表12345678910111213141516171819202122232425262728ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (18) SQL编程","slug":"mysql-notes-18","date":"2019-03-12T14:23:24.000Z","updated":"2020-07-25T02:57:18.220Z","comments":true,"path":"2019/03/12/mysql-notes-18/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-18/","excerpt":"","text":"局部变量变量声明1declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 赋值使用 set 和 select into 语句为变量赋值。 注意：在函数内是可以使用全局变量（用户自定义的变量） 全局变量定义、赋值set 语句可以定义并为变量赋值。 1set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 123select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 1select max(height) into @max_height from tb; 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 1@var=10; 变量被定义后，在整个会话周期都有效（登录到退出） 控制结构if语句12345678if search_condition then statement_list[elseif search_condition then statement_list]...[else statement_list]end if; case语句1234CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END while循环123[begin_label:] while search_condition do statement_listend while [end_label]; 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 退出循环退出整个循环 leave退出当前循环 iterate通过退出的标签决定退出哪个循环 内置函数数值函数1234567891011abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数 时间日期函数12345678now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间 字符串函数1234567891011121314151617length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小 流程函数case when [condition] then result [when [condition] then result …] [else result] end 多分支if(expr1,expr2,expr3) 双分支。 聚合函数123456count()sum();max();min();avg();group_concat() 其他常用函数12md5();default(); 存储函数，自定义函数新建12CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 参数部分，由”参数名”和”参数类型”组成。多个参数用逗号隔开。 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 多条语句应该使用 begin…end 语句块包含。 一定要有 return 返回值语句。 删除1DROP FUNCTION [IF EXISTS] function_name; 查看12SHOW FUNCTION STATUS LIKE 'partten'SHOW CREATE FUNCTION function_name; 修改1ALTER FUNCTION function_name 函数选项 存储过程，自定义功能定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 创建1234CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END 调用：CALL 过程名 参数列表：不同于函数的参数列表，需要指明参数类型IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出注意，没有返回值。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"MySQL 笔记","slug":"VS-Code/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/VS-Code/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (17) 触发器","slug":"mysql-notes-17","date":"2019-03-12T14:09:56.000Z","updated":"2020-07-25T02:57:18.220Z","comments":true,"path":"2019/03/12/mysql-notes-17/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-17/","excerpt":"","text":"触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象监听：记录的增加、修改、删除。 创建触发器1CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN…END复合语句结构 删除1DROP TRIGGER [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. 注意对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 字符连接函数concat(str1,str2,…])concat_ws(separator,str1,str2,…) 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if; 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; – 修改回原来的分号– 语句块包裹begin 语句块end 特殊的执行 只要添加记录，就会触发程序。 Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (16) 事务(transaction)/锁表","slug":"mysql-notes-16","date":"2019-03-12T13:59:07.000Z","updated":"2020-07-25T02:57:18.219Z","comments":true,"path":"2019/03/12/mysql-notes-16/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-16/","excerpt":"","text":"事务(transaction)事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 支持连续SQL的集体成功或集体撤销。 事务是数据库在数据晚自习方面的一个功能。 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 InnoDB被称为事务安全型引擎。 事务开启START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。 事务提交COMMIT; 事务回滚ROLLBACK; 如果部分操作发生问题，映射到事务开启前。 事务的特性 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 事务开始和结束时，外部数据一致 在整个事务过程中，操作是连续的 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 事务的实现 要求是事务支持的表类型 执行一组相关的操作前开启事务 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 事务的原理利用InnoDB的自动提交(autocommit)特性完成。普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 注意 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 事务不能被嵌套 保存点SAVEPOINT 保存点名称 – 设置一个事务保存点ROLLBACK TO SAVEPOINT 保存点名称 – 回滚到保存点RELEASE SAVEPOINT 保存点名称 – 删除保存点 InnoDB自动提交特性设置SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁 锁定 LOCK TABLES tbl_name [AS alias] 解锁 UNLOCK TABLES","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (15) 视图","slug":"mysql-notes-15","date":"2019-03-12T13:51:54.000Z","updated":"2020-07-25T02:57:18.219Z","comments":true,"path":"2019/03/12/mysql-notes-15/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-15/","excerpt":"","text":"什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。视图具有表结构文件，但不存在数据文件。对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 创建视图1CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement 视图名必须唯一，同时不能与表重名。 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 可以指定视图执行的算法，通过ALGORITHM指定。 column_list如果存在，则数目必须等于SELECT语句检索的列数 查看结构1SHOW CREATE VIEW view_name 删除视图 删除视图后，数据依然存在。 可同时删除多个视图。 1DROP VIEW [IF EXISTS] view_name ... 修改视图结构 一般不修改视图，因为不是所有的更新视图都会映射到表上。 1ALTER VIEW view_name [(column_list)] AS select_statement 视图作用 简化业务逻辑 对客户端隐藏真实的表结构 视图算法(ALGORITHM)MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (14) 备份与还原","slug":"mysql-notes-14","date":"2019-03-12T13:49:42.000Z","updated":"2020-07-25T02:57:18.219Z","comments":true,"path":"2019/03/12/mysql-notes-14/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-14/","excerpt":"","text":"备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 导出mysqldump [options] db_name [tables]mysqldump [options] —database DB1 [DB2 DB3…]mysqldump [options] –all–database 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 导出一个库 mysqldump -u用户名 -p密码 –lock-all-tables –database 库名 &gt; 文件名(D:/a.sql) 可以-w携带WHERE条件 导入 在登录mysql的情况下： source 备份文件 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (13) DELETE/TRUNCATE","slug":"mysql-notes-13","date":"2019-03-12T13:43:21.000Z","updated":"2020-07-25T02:57:18.219Z","comments":true,"path":"2019/03/12/mysql-notes-13/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-13/","excerpt":"","text":"DELETE1DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 TRUNCATE1TRUNCATE [TABLE] tbl_name 清空数据删除重建表 区别： truncate 是删除表再创建，delete 是逐条删除 truncate 重置auto_increment的值。而delete不会 truncate 不知道删除了几条，而delete知道。 当被用于带分区的表时，truncate 会保留分区","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (12) INSERT","slug":"mysql-notes-12","date":"2019-03-12T13:36:01.000Z","updated":"2020-07-25T02:57:18.219Z","comments":true,"path":"2019/03/12/mysql-notes-12/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-12/","excerpt":"","text":"select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。或者使用set语法。 1INSERT INTO tbl_name SET field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 1INSERT INTO tbl_name VALUES (), (), (); 可以在列值指定时，使用表达式。 1INSERT INTO tbl_name VALUES (field_value, 10+10, now()); 可以使用一个特殊值 DEFAULT，表示该列使用默认值。 1INSERT INTO tbl_name VALUES (field_value, DEFAULT); 可以通过一个查询的结果，作为需要插入的值。 1INSERT INTO tbl_name SELECT ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 1INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (11) 导入导出","slug":"mysql-notes-11","date":"2019-03-12T13:27:53.000Z","updated":"2020-07-25T02:57:18.218Z","comments":true,"path":"2019/03/12/mysql-notes-11/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-11/","excerpt":"","text":"导出表数据1select * into outfile 文件地址 [控制格式] from 表名; 导入数据1load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; 生成的数据默认的分隔符是制表符local未指定，则数据文件必须在服务器上replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 控制格式fields 控制字段格式 默认：fields terminated by ‘\\t’ enclosed by ‘’ escaped by ‘\\‘ terminated by ‘string’ – 终止 enclosed by ‘char’ – 包裹 escaped by ‘char’ – 转义 示例： 1234SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'LINES TERMINATED BY '\\n'FROM test_table; lines 控制行格式 默认：lines terminated by ‘\\n’ terminated by ‘string’ – 终止","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (10) 连接查询(join)","slug":"mysql-notes-10","date":"2019-03-12T13:09:05.000Z","updated":"2020-07-25T02:57:18.218Z","comments":true,"path":"2019/03/12/mysql-notes-10/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-10/","excerpt":"","text":"将多个表的字段进行连接，可以指定连接条件。 内连接(inner join) 默认就是内连接，可省略inner。 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）也可用where表示连接条件。还有 using, 但需字段名相同。 using(字段名) 交叉连接 cross join即，没有条件的内连接。 1select * from tb1 cross join tb2; 外连接(outer join)如果数据不存在，也会出现在连接结果中。 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 自然连接(natural join)自动判断连接条件完成连接。相当于省略了using，会自动查找相同字段名。natural joinnatural left joinnatural right join 1select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (9) 子查询","slug":"mysql-notes-9","date":"2019-03-12T12:52:45.000Z","updated":"2020-07-25T02:57:18.222Z","comments":true,"path":"2019/03/12/mysql-notes-9/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-9/","excerpt":"","text":"子查询需用括号包裹。 from型from后要求是一个表，必须给子查询结果取个别名。 简化每个查询内的条件。 from型需将结果生成一个临时表格，可用以原表的锁定的释放。 子查询返回一个表，表型子查询。 1select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; where型 子查询返回一个值，标量子查询。 不需要给子查询取别名。 where子查询内的表，不能直接用以更新。 1select * from tb where money = (select max(money) from tb); 列子查询 如果子查询结果返回的是一列。使用 in 或 not in 完成查询exists 和 not exists 条件如果子查询返回数据，则返回1或0。常用于判断条件。 1select column1 from t1 where exists (select * from t2); 行子查询 查询条件是一个行。 1select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, …) 或 ROW(col1, col2, …) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 特殊运算符: != all() 相当于 not in= some() 相当于 in。any 是 some 的别名!= some() 不等同于 not in，不等于其中某一个。all, some 可以配合其他运算符一起使用。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (8) SELECT","slug":"mysql-notes-8","date":"2019-03-12T11:48:11.000Z","updated":"2020-07-25T02:57:18.222Z","comments":true,"path":"2019/03/12/mysql-notes-8/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-8/","excerpt":"","text":"语法1SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT select_expr 可以用 表示所有字段。 `select from tb;` 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 使用 as 关键字，也可省略 as.select stu+10 as add10 from tb; FROM 子句用于标识查询来源。 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; from子句后，可以同时出现多个表。 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。SELECT * FROM tb1, tb2; 向优化符提示如何选择索引 123USE INDEX、IGNORE INDEX、FORCE INDEXSELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3; WHERE 子句 从from获得的数据源中进行筛选。 整型1表示真，0表示假。 表达式由运算符和运算数组成。 运算数：变量（字段）、值、函数返回值 运算符：=, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xoris/is not 加上ture/false/unknown，检验某个值的真假&lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 GROUP BY 子句, 分组子句GROUP BY 字段/别名 [排序方式] 分组后会进行排序。 升序：ASC， 降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。 HAVING 子句，条件子句与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。 ORDER BY 子句，排序子句order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC 降序：DESC 支持多个字段的排序。 LIMIT 子句，限制结果数量子句仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 DISTINCT, ALL 选项distinct 去除重复记录默认为 all, 全部记录 UNION将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。ORDER BY 排序时，需加上 LIMIT 进行结合。需要各select查询的字段数量一样。每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (7) 建表规范","slug":"mysql-notes-7","date":"2019-03-12T11:38:57.000Z","updated":"2020-07-25T02:57:18.222Z","comments":true,"path":"2019/03/12/mysql-notes-7/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-7/","excerpt":"","text":"Normal Format, NF 每个表保存一个实体信息 每个表具有一个ID字段作为主键 ID主键 + 原子表 1NF, 第一范式字段不能再分，就满足第一范式。 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (6) 列属性（列约束）","slug":"mysql-notes-6","date":"2019-03-12T11:15:03.000Z","updated":"2020-07-25T02:57:18.221Z","comments":true,"path":"2019/03/12/mysql-notes-6/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-6/","excerpt":"","text":"PRIMARY 主键 能唯一标识记录的字段，可以作为主键。 一个表只能有一个主键。 主键具有唯一性。 声明字段时，用 primary key 标识。 也可以在字段列表之后声明例：create table tab ( id int, stu varchar(10), primary key (id)); 主键字段的值不能为null。 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); UNIQUE 唯一索引（唯一约束）使得某字段的值也不能重复。 NULL 约束null不是数据类型，是列的一个属性。表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 1insert into tab values (null, 'val'); 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null DEFAULT 默认值属性当前字段的默认值。 1insert into tab values (default, 'val'); 此时表示强制使用默认值。 1create table tab ( add_time timestamp default current_timestamp ); 表示将当前时间的时间戳设为默认值。 current_date, current_time AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; COMMENT 注释例： 1create table tab ( id int ) comment '注释内容'; FOREIGN KEY 外键约束用于限制主表与从表数据完整性。 1alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); 将表t1的t1_id外键关联到表t2的id字段。 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束：语法： 1foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。 外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (5) 数据类型（列类型）","slug":"mysql-notes-5","date":"2019-03-12T05:43:56.000Z","updated":"2020-07-25T02:57:18.221Z","comments":true,"path":"2019/03/12/mysql-notes-5/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-5/","excerpt":"","text":"数值类型整型 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 默认存在符号位，unsigned 属性修改 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数’123’，补填后为’00123’ 在满足要求的情况下，越小越好。 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 浮点型 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0.定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 定点数 decimal – 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。将浮点数转换为字符串来保存，每9位数字保存为4个字节。 字符串类型char, varchar char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？答：(65535-1-2-4-30*3)/3 blob, text blob 二进制字符串（字节字符串） tinyblob blob mediumblob longblob text 非二进制字符串（字符字符串） tinytext text mediumtext longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 binary, varbinary类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。char, varchar, text 对应 binary, varbinary, blob. 日期时间类型一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 类型 字节 范围 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 12345678910111213141516171819datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY 枚举和集合枚举(enum)enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 集合（set)set(val1, val2, val3...) 12create table tab ( gender set('男', '女', '无') );insert into tab values ('男, 女'); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。当创建表时，SET成员值的尾部空格将自动被删除。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (4) 数据操作","slug":"mysql-notes-4","date":"2019-03-12T05:39:16.000Z","updated":"2020-07-25T02:57:18.221Z","comments":true,"path":"2019/03/12/mysql-notes-4/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-4/","excerpt":"","text":"增1INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 1INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...] 查1SELECT 字段列表 FROM 表名[ 其他子句] 可来自多个表的多个字段 其他子句可以不使用 字段列表可以用*代替，表示所有字段 删1DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部 改1UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码 MySQL、数据库、表、字段均可设置编码 数据编码与客户端编码不需一致 1234567891011SHOW VARIABLES LIKE 'character_set_%' -- 查看所有字符集编码项 -- character_set_client 客户端向服务器发送数据时使用的编码 -- character_set_results 服务器端将结果返回给客户端所使用的编码 -- character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置 校对集 校对集用以排序 12SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern'] 查看所有字符集SHOW COLLATION [LIKE 'pattern'] 查看所有校对集 CHARSET 字符集编码 设置字符集编码COLLATE 校对集编码 设置校对集编码","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (3) 表的操作","slug":"mysql-notes-3","date":"2019-03-12T05:35:32.000Z","updated":"2020-07-25T02:57:18.221Z","comments":true,"path":"2019/03/12/mysql-notes-3/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-3/","excerpt":"","text":"创建表1CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 1字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string'] 表选项 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 存储引擎ENGINE = engine_name表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 12SHOW ENGINES -- 显示存储引擎的状态信息SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 自增起始数 AUTO_INCREMENT = 行数 数据文件目录 DATA DIRECTORY = &#39;目录&#39; 索引文件目录 INDEX DIRECTORY = &#39;目录&#39; 表注释 COMMENT = &#39;string&#39; 分区选项 PARTITION BY ... (详细见手册) 查看所有表12SHOW TABLES[ LIKE 'pattern']SHOW TABLES FROM 表名 查看表机构123SHOW CREATE TABLE 表名 （信息更详细）DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN']SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern'] 修改表 修改表本身的选项 1ALTER TABLE 表名 表的选项 eg: 1ALTER TABLE 表名 ENGINE=MYISAM; 对表进行重命名 12RENAME TABLE 原表名 TO 新表名RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） RENAME可以交换两个表名 修改表的字段机构（13.1.2. ALTER TABLE语法） 1ALTER TABLE 表名 操作名 操作名 ADD[ COLUMN] 字段定义 – 增加字段 AFTER 字段名 – 表示增加在该字段名后面 FIRST – 表示增加在第一个 ADD PRIMARY KEY(字段名) – 创建主键 ADD UNIQUE [索引名] (字段名) – 创建唯一索引 ADD INDEX [索引名] (字段名) – 创建普通索引 DROP[ COLUMN] 字段名 – 删除字段 MODIFY[ COLUMN] 字段名 字段属性 – 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 – 支持对字段名修改 DROP PRIMARY KEY – 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 – 删除索引 DROP FOREIGN KEY 外键 – 删除外键 删除表1DROP TABLE[ IF EXISTS] 表名 ... 清空表数据1TRUNCATE [TABLE] 表名 复制表结构1CREATE TABLE 表名 LIKE 要复制的表名 复制表结构和数据1CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名 检查表是否有错误1CHECK TABLE tbl_name [, tbl_name] ... [option] ... 优化表1OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 修复表1REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM] 分析表1ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (2) 数据库操作","slug":"mysql-notes-2","date":"2019-03-12T05:32:22.000Z","updated":"2020-07-25T02:57:18.220Z","comments":true,"path":"2019/03/12/mysql-notes-2/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-2/","excerpt":"","text":"查看当前数据库1SELECT DATABASE(); 显示当前时间、用户名、数据库版本1SELECT now(), user(), version(); 创建库1CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name 查看已有库1SHOW DATABASES[ LIKE 'PATTERN'] 查看当前库信息1SHOW CREATE DATABASE 数据库名 修改库的选项信息1ALTER DATABASE 库名 选项信息 删除库1DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"MySQL 笔记 (1) MySQL服务","slug":"mysql-notes-1","date":"2019-03-12T04:31:53.000Z","updated":"2020-07-25T02:57:18.218Z","comments":true,"path":"2019/03/12/mysql-notes-1/","link":"","permalink":"https://jigangduan.github.io/2019/03/12/mysql-notes-1/","excerpt":"","text":"MySQL 基本的知识点 启动/关闭/重启 Windows下 启动服务 1mysqld --console 或 1net start mysql 关闭服务 1mysqladmin -uroot shudown 或 1net stop mysql Linux下 启动服务 1service mysql start 关闭服务 1service mysql stop 重启服务 1service restart stop Mac下 启动MySQL服务 1sudo /usr/local/mysql/support-files/mysql.server start 停止MySQL服务 1/usr/local/mysql/support-files/mysql.server stop 重启MySQL服务 1/usr/local/mysql/support-files/mysql.server restart 连接与断开服务器1mysql -h 地址 -P 端口 -u 用户名 -p 密码 12SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"}]},{"title":"CSS讲解(10) 三大框架中的CSS","slug":"CSS讲解-10","date":"2019-02-10T10:18:56.000Z","updated":"2020-07-25T02:57:18.149Z","comments":true,"path":"2019/02/10/CSS讲解-10/","link":"","permalink":"https://jigangduan.github.io/2019/02/10/CSS讲解-10/","excerpt":"","text":"Angular Vue React 三大框架 Angular Vue 内置样式集成 React 一些业界实践 Angular Angular.js (1.x) 没有样式集成能力 Angular (2+) 提供了样式封装能力 与组件深度集成 几个概念知识： ShadowDOM 逻辑上一个DOM 结构上存在子集结构 Scoped CSS 限定了范围的CSS 无法影响外部元素 外部样式一般不影响内部 可以通过/deep/或&gt;&gt;&gt;穿透 模拟Scoped CSS 方案一: 随机选择器(不支持) 方案二: 随机属性 &lt;div abcdefg&gt; div[abcdefg] {} Angular 选用了方案二 Vue 模拟Scoped CSS 方案一: 随机选择器 方案二: 随机属性 &lt;div abcdefg&gt; div[abcdefg] {} Vue 支持两种 React 官方没有集成方案 社区方案众多 css modules (babel)react-css-module styled components styled jsx","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(9) 工程化","slug":"CSS讲解-9","date":"2019-02-10T08:46:32.000Z","updated":"2020-07-25T02:57:18.151Z","comments":true,"path":"2019/02/10/CSS讲解-9/","link":"","permalink":"https://jigangduan.github.io/2019/02/10/CSS讲解-9/","excerpt":"","text":"工程化关注: 组织 优化 构建 维护 PostCSSCSS –&gt; PostCSS(解析转换) –&gt; CSS 可以作: 模块化 加前缀 兼容性 … PostCSS本身只有解析能力 各种神奇的特性全靠插件 目前至少有200多个插件 常用的插件： import模块合并 autoperfixier 自动加前缀 cssnnao 压缩代码 cssnext 使用CSS新特性 precss 变量, mixin, 循环等 安装： 1npm install postcss-cli 使用： 1postcss input.css -o out.css 插件postcss.config.js 引用各种插件 12345678910111213const cssnano = require('cssnano');const atImport = require('postcss-import');const autoprefixer = require('autoprefixer');module.exports = &#123; plugins: [ atImport, autoprefixer(&#123; browsers: ['&gt;0%'] &#125;), cssnano ]&#125;; Browserlist cssnext使用CSS新特性 特性: custom properties &amp; var() automatic vendor prefixes custom properties set &amp; @apply reduced calc() custom media queries media queries ranges custom selectors nesting image-set() function color() function hwb() function gray() function #rrggbbaa colors rgba function (rgb fallback) rebeccapurple color font-variant property filter property (svg fallback) initial value rem unit (px fallback) :any-link pseudo-class :matches pseudo-class :not pseudo-class (to l.3) ::pseudo syntax (: fallback) overflow-wrap property (word-wrap fallback) attribute case insensitive rgb() function (functional-notation) hsl() function (functional-notation) system-ui font-family (font-family fallback) CSS变量举例： 123456789101112131415:root &#123; --mainColor: red; --danger-theme: &#123; color: white; background-color: red; &#125;;&#125;a &#123; color: var(--mainColor);&#125;.danger &#123; @apply --danger-theme;&#125; postcss.config.js 1234567const cssnext = require('postcss-cssnext');module.exports = &#123; plugins: [ cssnext, ]&#125;; precss PreCSS中的嵌套可以使用 &amp; 符，把父选择器复制到子选择器中 PreCSS使用 $ 符声明变量，比如 $color: #ccc PreCSS中用 @if 和 @else 来控制循环 PreCSS中用 @define-mixin mixin_name $arg1,$arg2{…} 语法来声明混合宏 PreCSS中用 @mixin mixin_name pass_arg1, pass_arg2; 语法来调用混合宏 PreCSS中用 @mixin-content 保留传递内容 PreCSS中使用 @define-extend extend_name{…} 来声明可扩展的代码块 PreCSS中使用 @extend extend_name 语法来调用声明的代码扩展块 PreCSS可以使用 @import 中导入CSS文件 构建工具PostCSS 支持的构建工具： CLI 命令行工具 webpack postcss-loader Gulp gulp-postcss Grunt grunt-postcss Rollup rollup-postcss … gulp-postcssgulpfile.js webpack JS是整个应用的核心入口 一切资源均由JS管理依赖 一切资源均由webpack打包 webpack处理CSSjs 引用 CSS, css-loader/sytle-loader, 将CSS文件转换成 JS文件 123require(./xxx.css);console.log('hello'); css-modules 是什么？CSS模块化的一种解决方案（对css类名限定作用域的一种，只限定类选择器，对id、元素等选择器不管） 原理？通过 webpack 在构建过程中，给类名起一个独一无二的名字，这个名字可以通过webpack配置 好处？ 避免类名重复导致样式覆盖问题； JS &amp; CSS 共享变量 健壮可扩展 extract-text-plugin该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象 从js将样式抽离出来生成CSS文件 其它 如何解决CSS模块化问题 Less Sass 等CSS预处理器 PostCSS插件 (postcss-import / precss等) webpack处理CSS (css-loader + style-loader) PostCSS 可以作什么？ 取决于插件可以做什么 autoprefixer cssnext precss等 兼容性处理 import 模块合并 css语法检查 兼容性检查 压缩文件 CSS modules 是做什么的，如何使用 解决类名冲突的问题 使用PostCSS或者webpack等构建工具进行编译 在HTML模版中使用编译过程产生的类名 为什么使用JS来引用,加载CSS JS作为入口，管理资源有天然优势 将组件的结构，样式，行为封装到一起，增强内聚 可以做更多处理(webpack)","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(8) Bootstrap","slug":"CSS讲解-8","date":"2019-02-10T07:52:49.000Z","updated":"2020-07-25T02:57:18.151Z","comments":true,"path":"2019/02/10/CSS讲解-8/","link":"","permalink":"https://jigangduan.github.io/2019/02/10/CSS讲解-8/","excerpt":"","text":"介绍 CSS框架 twitter 出品 提供通用基础样式 Bootstrap 4 兼容IE10+ 使用flexbox布局 抛弃Nomalize.css 提供布局和reboot版本 提供： 基础样式 常用组件 JS插件 基本用法 See the Pen KEqEWz by jigang.duan (@jigang-duan) on CodePen. JS组件 用于组件交互 dropdown(下拉) modal(弹窗) … jQuery Popper.js bootstrap.js 使用方式： 基于 data-*属性 基于JS API 响应式布局 See the Pen qvjvoy by jigang.duan (@jigang-duan) on CodePen. 定制方法 使用CSS同名类 修改源码重新构建 引用scss源文件 修改变量 其它 Bootstrap的优缺点 优点： CSS代码结构合理 现成的样式可以直接使用 缺点： 定制较为繁琐 体积大 Bootstrap如何实现响应式布局 原理：通过media query设置不同分辨率的class 使用: 为不同分辨率选择不同的网格class 如何基于Bootstrap定制自己的样式 使用CSS同名类覆盖 修改源码重新构建 引用scss源文件 修改变量","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(7)-预处理","slug":"CSS讲解-7","date":"2019-02-10T00:57:21.000Z","updated":"2020-07-25T02:57:18.150Z","comments":true,"path":"2019/02/10/CSS讲解-7/","link":"","permalink":"https://jigangduan.github.io/2019/02/10/CSS讲解-7/","excerpt":"","text":"介绍CSS预处理器： 基于CSS的另一种语言 通过工具编译成CSS 添加了很多CSS不具备的特性 能提升CSS文件的组织 方案： less node.js 写的 安装： npm install less sass ruby 写的 功能： 嵌套 放映层级和约束 变量和计算 减少重复代码 Extend和Mixin 代码片段 循环 适用于复杂有规律的样式 import CSS文件模块化 less嵌套123456789101112131415161718body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:white; .nav&#123; font-size: 12px; &#125; .content&#123; font-size: 14px; &amp;:hover&#123; background:red; &#125; &#125;&#125; &amp; 平级,把空格去掉 编译成CSS后： 1234567891011121314151617181920body &#123; padding: 0; margin: 0;&#125;.wrapper &#123; background: white;&#125;.wrapper .nav &#123; font-size: 12px;&#125;.wrapper .content &#123; font-size: 14px;&#125;.wrapper .content:hover &#123; background: red;&#125; sass嵌套123456789101112131415161718body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:white; .nav&#123; font-size: 12px; &#125; .content&#123; font-size: 14px; &amp;:hover&#123; background:red; &#125; &#125;&#125; 写法和less是一样的，编程成css也是一样的。sass输出有很多种格式 less变量@ 变量定义 12345678910111213141516171819202122@fontSize: 12px;@bgColor: red;body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:lighten(@bgColor, 40%); .nav&#123; font-size: @fontSize; &#125; .content&#123; font-size: @fontSize + 2px; &amp;:hover&#123; background:@bgColor; &#125; &#125;&#125; sass变量$ 变量定义 12345678910111213141516171819202122$fontSize: 12px;$bgColor: red;body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:lighten($bgColor, 40%); .nav&#123; font-size: $fontSize; &#125; .content&#123; font-size: $fontSize + 2px; &amp;:hover&#123; background:red; &#125; &#125;&#125; less mixin1234567891011121314151617181920212223242526272829303132333435363738394041@fontSize: 12px;@bgColor: red;.box&#123; color:green;&#125;.box1&#123; .box(); line-height: 2em;&#125;.box2&#123; .box(); line-height: 3em;&#125;.block(@fontSize)&#123; font-size: @fontSize; border: 1px solid #ccc; border-radius: 4px;&#125;body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:lighten(@bgColor, 40%); .nav&#123; .block(@fontSize); &#125; .content&#123; .block(@fontSize + 2px); &amp;:hover&#123; background:red; &#125; &#125;&#125; sass mixin123456789101112131415161718192021222324252627$fontSize: 12px;$bgColor: red;@mixin block($fontSize)&#123; font-size: $fontSize; border: 1px solid #ccc; border-radius: 4px;&#125;body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:lighten($bgColor, 40%); .nav&#123; @include block($fontSize); &#125; .content&#123; @include block($fontSize + 2px); &amp;:hover&#123; background:red; &#125; &#125;&#125; less extend123456789101112131415161718192021222324252627@fontSize: 12px;@bgColor: red;.block&#123; font-size: @fontSize; border: 1px solid #ccc; border-radius: 4px;&#125;body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:lighten(@bgColor, 40%); .nav:extend(.block)&#123; color: #333; &#125; .content&#123; &amp;:extend(.block); &amp;:hover&#123; background:red; &#125; &#125;&#125; sass extend12345678910111213141516171819202122232425262728$fontSize: 12px;$bgColor: red;.block&#123; font-size: $fontSize; border: 1px solid #ccc; border-radius: 4px;&#125;body&#123; padding:0; margin:0;&#125;.wrapper&#123; background:lighten($bgColor, 40%); .nav&#123; @extend .block; color: #333; &#125; .content&#123; @extend .block; &amp;:hover&#123; background:red; &#125; &#125;&#125; less loop比如要实现如下CSS样式， 123456789101112131415161718192021222324252627282930313233343536.col-12 &#123; width: 1000px;&#125;.col-11 &#123; width: 916.66666667px;&#125;.col-10 &#123; width: 833.33333333px;&#125;.col-9 &#123; width: 750px;&#125;.col-8 &#123; width: 666.66666667px;&#125;.col-7 &#123; width: 583.33333333px;&#125;.col-6 &#123; width: 500px;&#125;.col-5 &#123; width: 416.66666667px;&#125;.col-4 &#123; width: 333.33333333px;&#125;.col-3 &#123; width: 250px;&#125;.col-2 &#123; width: 166.66666667px;&#125;.col-1 &#123; width: 83.33333333px;&#125; 使用less的递归的方式： 12345678.gen-col(@n) when (@n &gt; 0)&#123; .gen-col(@n - 1); .col-@&#123;n&#125; &#123; width: 1000px/12*@n; &#125;&#125;.gen-col(12); sass loop12345@for $i from 1 through 12 &#123; .col-#&#123;$i&#125; &#123; width: 1000px/12*$i; &#125;&#125; less import123@import \"./6-import-variable\";@import \"./6-import-module1\";@import \"./6-import-module2\"; sass import123@import \"./6-import-variable\";@import \"./6-import-module1\";@import \"./6-import-module2\"; 预处理器框架 SASS - Compass Less - Lesshat / EST 提供现成的mixin 类似JS类库 封装常用功能 Compass Est是一个基于Less的mixin库，它可以帮助您更高效地编写更少的代码。 Est提供了100多个方便的mixin，只有在调用它们时才生成样式规则。Est没有为特定的HTML类名提供任何样式，因为这样的“可视化类名”可能会污染HTML语义。您可以基于est构建自己的样式库来加速开发。 总结 常见的CSS预处理器 Less（Node.js） Sass (Ruby 有Node版本) 预处理器的作用 帮助更好地组织CSS代码 提高代码复用率 提高升码维护性 预处理器的能力 嵌套 放映层级和约束 变量和计算 减少重复代码 Extend和Mixin代码片段 循环 适用于复杂有规律的样式 import CSS文件模块化 优缺点 优点： 提高代码复用率和可维护性 缺点： 需要引入编译过程，有学习成本","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(6) 动画","slug":"CSS讲解-6","date":"2019-02-09T13:41:24.000Z","updated":"2020-07-25T02:57:18.150Z","comments":true,"path":"2019/02/09/CSS讲解-6/","link":"","permalink":"https://jigangduan.github.io/2019/02/09/CSS讲解-6/","excerpt":"","text":"介绍动画的原理： 视觉暂留作用 画面逐渐变化 动画的作用： 愉悦感 引起注意 反馈 掩饰 CSS中的动画类型： transition补间动画 keyframe关键帧动画 逐帧动画 补间动画 位置 - 平移(left/right/margin/transform) 方位 - 旋转 (transform) 大小 - 缩放 (transform) 透明度(opacity) 其它 - 线性变换 (transform) See the Pen eXEROJ by jigang.duan (@jigang-duan) on CodePen. timing(easing)定义动画进度和时间的关系 CSS缓动动画工具 关键帧动画A -&gt; B -&gt; C 相当于多个补间动画与元素状态的变化无关定义更加灵活 See the Pen LajLYz by jigang.duan (@jigang-duan) on CodePen. 逐帧动画A B C CSS中属于关键帧动画，适用于无法补间计算的动画 资源较大 使用steps() See the Pen LajLpO by jigang.duan (@jigang-duan) on CodePen. 3D See the Pen qvXjbP by jigang.duan (@jigang-duan) on CodePen. 真题 css动画的实现方式有几种 transition keyframes（animation） 过渡动画和关键帧动画的区别 过渡动画需要有状态变化 关键帧动画不需要状态变化 关键帧动画能控制更精细 如何实现逐帧动画 使用关键帧动画 去掉补间(steps) CSS动画的性能 性能不坏 部分情况下优于JS 但JS可以做到更好 部分高危属性 box-shadow等 推荐 Animate.css","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(5) 效果","slug":"CSS讲解-5","date":"2019-02-09T10:27:38.000Z","updated":"2020-07-25T02:57:18.150Z","comments":true,"path":"2019/02/09/CSS讲解-5/","link":"","permalink":"https://jigangduan.github.io/2019/02/09/CSS讲解-5/","excerpt":"","text":"效果属性**这个效果怎么实现？ CSS最出彩等一部分 box-shadowbox-shadow 属性向框添加一个或多个阴影 营造层次感(立体感) 充当没有宽度的边框 特殊效果 See the Pen OqjgpG by jigang.duan (@jigang-duan) on CodePen. See the Pen qvXjmp by jigang.duan (@jigang-duan) on CodePen. See the Pen WmEOON by jigang.duan (@jigang-duan) on CodePen. CSS3阴影演示工具 text-shadow 立体感 印刷品质感 See the Pen JzyJrM by jigang.duan (@jigang-duan) on CodePen. border-radius 圆角距形 圆形 半圆 / 扇形 一些奇怪的角角 See the Pen eXERev by jigang.duan (@jigang-duan) on CodePen. background 纹理，图案 渐变 雪碧图动画 背景图尺寸适应 See the Pen rRzwJm by jigang.duan (@jigang-duan) on CodePen. See the Pen rRzwdw by jigang.duan (@jigang-duan) on CodePen. clip-path 对容器进行裁剪 常见几何图形 自定义路径 See the Pen RdZgyv by jigang.duan (@jigang-duan) on CodePen. 3D 变换 变换 transform translate 平移 scale 缩放 skew 倾斜 rotate 旋转 在3D空间进行变换 See the Pen xBLrJW by jigang.duan (@jigang-duan) on CodePen. 真题 如何用一个div画 xxx box-shadow 无限投影 ::before ::after 如何产生不占空间的边框 box-shadow outline 如何实现圆形元素 border-radius:50% 如果实现iOS图标的圆角 clip-path: (svg) 如何实现半圆，扇形等图形 border-radius组合： 有无边框 边框粗细 圆角半径 如何实现背景图居中显示 / 不重复 / 改变大小 background-position background-repeat background-size(cover/contain) 如何平移/放大一个元素 transform: translateX(100px) transform: scale(2) 如何实现3D效果 perspective: 300px transform-style: preserve-3d; transform: translate rotate …","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(4) 布局","slug":"CSS讲解-4","date":"2019-02-07T22:25:25.000Z","updated":"2020-07-25T02:57:18.150Z","comments":true,"path":"2019/02/08/CSS讲解-4/","link":"","permalink":"https://jigangduan.github.io/2019/02/08/CSS讲解-4/","excerpt":"","text":"简介 CSS知识体系的重中之重 早期以table为主(简单) 后来以技巧性布局为主(难) 现代有flexbox/griod(偏简单) 响应式布局 常见布局方法 table 表格布局 float 浮动 + margin inline-block 布局 flexbox布局 表格布局布局简单 See the Pen MxmYvx by jigang.duan (@jigang-duan) on CodePen. table中内容水平居中 模拟table: 123display: table;display: table-row;display: table-cell; 一些布局属性盒模型 display / position 确定元素的显示类型 block / inline / inline-block See the Pen pYPvYm by jigang.duan (@jigang-duan) on CodePen. 确定元素的位置 static 默认，正常文档流 relative 相对定位 相对自身 不会影响文档流 对absolute的限制作用 absolute 绝对布局 脱离文档流 fixed 相对于屏幕 脱离文档流 【前端Talkking】CSS系列——CSS深入理解之absolute定位【前端Talkking】CSS系列——CSS深入理解之absolute定位 flexbox 弹性盒子 盒子本来就是并列的 指定宽度即可 See the Pen GeEWBW by jigang.duan (@jigang-duan) on CodePen. inline-block 像文本一样排block元素 没有清除浮动等问题 需要处理间隙 See the Pen PLKjzV by jigang.duan (@jigang-duan) on CodePen. 响应式布局 在不同设备上正常使用 一般主要处理屏幕大小问题 主要方法 隐藏 + 折行 + 自适应空间 rem / viewport / media query See the Pen XGagNp by jigang.duan (@jigang-duan) on CodePen. See the Pen GevErP by jigang.duan (@jigang-duan) on CodePen.","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(3) CSS基础","slug":"CSS讲解-3","date":"2019-02-06T15:45:44.000Z","updated":"2020-07-25T02:57:18.149Z","comments":true,"path":"2019/02/06/CSS讲解-3/","link":"","permalink":"https://jigangduan.github.io/2019/02/06/CSS讲解-3/","excerpt":"","text":"CSS Cascading Style Sheet 层叠样式表 举例： See the Pen MxJELO by jigang.duan (@jigang-duan) on CodePen. 权重高选择器的样式覆盖权重低的，进行叠加 基本规则1234选择器 &#123; 属性: 值; 属性: 值;&#125; 选择器 用于匹配HTML元素 有不同的匹配规则 多个选择是可以叠加的 分类和权重 解析方式和性能 解析方式 浏览器是从右往左，先找最右边的选择器，再验证上级是否符合 为了加快哪些不符合 值得关注的选择器 选择器分类 元素选择器 a{} 伪元素选择器 ::before{} 类选择器 .link{} 属性选择器 [type=rodio]{} 伪类选择器 :hover{} ID选择器 #id{} 组合选择器 [type=checkbox] + label{} 否定选择器 :not(.link){} 通用选择器 *{} 伪元素: 不会出现再HTML中，也不会出现在DOM树中，但它一个真实存在的元素，它可以显示内容和设置样式 伪类: 表示状态 选择器权重 选择器 权重值 ID选择器 #id{} +100 类 +10 属性 +10 伪类 +10 元素 +1 伪元素 +1 其它 +0 计算一个不进位的权重值 比如： #id .link a[href] 100(#id) + 10(.link) + 1(a) + 0([href]) = 111 #id .link.active 100(#id) + 10(.link) + 10(.active) = 120 不进位: 数字不进位的，比如多少个类选择器权重相加都不能超过ID选择器权重 举例： See the Pen EMZoOZ by jigang.duan (@jigang-duan) on CodePen. 其它规则 !important 优先级最高 元素属性 优先级高 相同权重 后写的生效 例子： See the Pen KEaQzV by jigang.duan (@jigang-duan) on CodePen. 非布局样式字体 字体族 serif / sans-serif / monospace / cursive / fantantasy 多字体fallback 指定字体找不到，就向后查找 网络字体，自定义字体 iconfont See the Pen KEaQXg by jigang.duan (@jigang-duan) on CodePen. iconfont-阿里巴巴矢量图标库使用了伪元素 before 行高 行高的构成 行高相关的现象和方案 行高的调整 See the Pen Gerxoo by jigang.duan (@jigang-duan) on CodePen. 为什么行高设的不一样，但显示的行高是一样的？ 文本排版 css行高line-height的一些深入理解及应用 背景 背景颜色 渐变色背景 多背景叠加 背景图片和属性 (雪碧图) base64和性能优化 多分辨率适配 See the Pen WmpEBW by jigang.duan (@jigang-duan) on CodePen. See the Pen pYepLB by jigang.duan (@jigang-duan) on CodePen. 边框 边框的属性： 线型 大小 颜色 边框背景图 边框衔接(三变形) See the Pen xBqYMj by jigang.duan (@jigang-duan) on CodePen. 滚动 滚动行为和滚动条 visible hidden scroll auto 文本折行 overflow-wrap(word-wrap)通用换行控制 是否保留单词 word-break 针对多字节文字 中文句子也是单词 white-space 空白处是否断行 装饰性属性 字重（粗体） font-weight 斜体 font-style: itatic 下划线 text-decoration 指针 cursor See the Pen pYeVrG by jigang.duan (@jigang-duan) on CodePen. CSS Hack Hack 即不合法但生效的写法 主要用于区分不同浏览器 缺点：难理解 难维护 易失效 替代方案： 特性检测 替代方案： 针对性加class 实例 See the Pen KEWejN by jigang.duan (@jigang-duan) on CodePen. 真题 CSS样式(选择器)的优先级 计算权重确定 !important 内联样式 后写优先级高 雪碧图的作用 减少HTTP请求数 提高加载性能 有一些情况下可以减少图片大小 自定义字体的使用场景 宣传/品牌/banner等固定文案 字体图标","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(2) HTML","slug":"CSS讲解-2","date":"2019-02-05T15:36:29.000Z","updated":"2020-07-25T02:57:18.149Z","comments":true,"path":"2019/02/05/CSS讲解-2/","link":"","permalink":"https://jigangduan.github.io/2019/02/05/CSS讲解-2/","excerpt":"","text":"前端三大件： HTML 结构 CSS 样式 JavaScript 行为 常见元素和理解常见元素head不直接出现在页面上,描述或引用资源 meta title style link script base 1&lt;meta charset=\"utf-8\"&gt; 字符集 utf-8 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"&gt; 视口 width=device-width 视口宽度等于设备宽度 initial-scale=1.0 初始化的缩放 1倍 maximum-scale=1.0 最大缩放 1倍 user-scalable=no 用户不能缩放 1&lt;base href=\"/\"&gt; 指定基础路径，所有链接都是以这个路径为基础 body出现在页面上 div / section / article / aside / header / footer p span / em / strong table / thead / tbody / tr / td ul / ol / li / dl / dt / dd a form / input / select / textarea / button HTML重要属性 a[href,target] href 链接地址 target _blank 新窗口中打开链接 _self 相同的框架中打开链接 _parent 父框架集中打开链接 _top 在整个窗口中打开链接 framename 指定的框架中打开链接 img[src,alt] src 图片地址 alt 替换字符，当图片不可用时显示 table td[colspan,rowspan] colspan 单元格可横跨的列数 rowspan 单元格可横跨的行数 form[target,method,enctype] target 规定在何处打开 action URL _blank _self _parent _top framename method 规定如何发送表单数据 POST 方法 GET 方法 enctype 规定如何对表单数据进行编码 application/x-www-form-urlencoded: urlencoded编码所有字符 multipart/form-data: 不对字符编码,使用包含文件上传 text/plain: 空格转换为 “+” 加号 input[type,value] type 规定 input 元素的类型 button 可点击按钮 checkbox 复选框 file 文件上传 hidden 隐藏的输入字段 image 图像形式的提交按钮 password 密码 radio 单选按钮 name 单选框name一样表示一组 reset 重置按钮,清除表单中的所有数据 submit 提交按钮,把表单数据发送到服务器 text 输入字段 button[type] type 规定按钮的类型 submit button reset select&gt;option[value] label[for] for 和表单项关联 事例 See the Pen gELEQG by jigang.duan (@jigang-duan) on CodePen. 如果理解HTML HTML 文档 描述文档的结构 有区块和大纲 123456789101112131415161718192021&lt;section&gt; &lt;h1&gt;森林象&lt;/h1&gt; &lt;section&gt; &lt;h1&gt;介绍&lt;/h1&gt; &lt;p&gt;在本节中，我们将讨论鲜为人知的森林象.&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;栖息地&lt;/h1&gt; &lt;p&gt;森林象不生活在树上，而是生活在树上.&lt;/p&gt; &lt;/section&gt; &lt;aside&gt; &lt;p&gt;广告块&lt;/p&gt; &lt;/aside&gt;&lt;/section&gt;&lt;footer&gt; &lt;p&gt;(c) 2010 公司例子&lt;/p&gt;&lt;/footer&gt; 文档的大纲： 12341. 森林象 1.1 介绍 1.2 栖息地 1.3 Section (aside) 语义化的标签 W3C大纲工具： http://h5o.github.io/ 腾讯首页的大纲: HTML版本HTML5 推荐版本 HTML4 / 4.01(SGML) SGML 标准通用标记语言 XHTML (XML) HTML5 HTML4 XHTML HTML5 标签允许不结束 标签必须结束 标签允许不结束 属性不用带引号 属性必须带引号 属性不用带引号 标签属性可大写 标签属性必须小写 标签属性可大写 Boolean属性可省略值 Boolean属性必须写值 Boolean属性可省略值 XHTML 例子: 12345678910111213141516&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"test\"&gt;合法&lt;/div&gt; &lt;DIV class=\"test\"&gt;标签名大写&lt;/DIV&gt; &lt;div ID=\"test\"&gt;属性名大写&lt;/div&gt; &lt;input type=\"checkbox\" checked /&gt; &lt;p&gt;标签不结束1 &lt;p&gt;标签不结束2 &lt;div style=color:red&gt;属性不带引号&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; DOCTYPE 不一样 xmlns 命名空间 HTML5 例子: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;DIV class=\"test\"&gt;标签名大写&lt;/DIV&gt; &lt;div ID=\"test\"&gt;属性名大写&lt;/div&gt; &lt;input type=\"checkbox\" checked /&gt; &lt;p&gt;标签不结束1 &lt;p&gt;标签不结束2 &lt;div style=color:red&gt;属性不带引号&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML5新增内容 新区块标签 section article nav aside 表单增强 日期,时间,搜索 表单验证 Placeholder 自动聚焦 语义的改变 header / footer 头尾 section / article 区域 nav 导航 aside 不重要内容 em / strong 强调 i icon HTML元素分类 按默认样式分类 块级 block 独占一行 行内 inline 不一定有规则形状，设置尺寸无效 inline-block 对外inline对内block，是规则的方块，有尺寸 See the Pen GerNYR by jigang.duan (@jigang-duan) on CodePen. 按内容分类 （内容模型） 流（Flow）内容：包含在文档正常流中的大多数HTML5元素 元数据（Metadata）：通常出现在页面的head中，设置页面其他部分的表现和行为 元素：&lt;base&gt;，&lt;link&gt;，&lt;meta&gt;，&lt;noscript&gt;，&lt;script&gt;，&lt;style&gt;，&lt;title&gt; 内联（Embedded）：在文档中添加其他类型的内容 元素：&lt;audio&gt;，&lt;video&gt;，&lt;canvas&gt;，&lt;iframe&gt;，&lt;img&gt;，&lt;math&gt;，&lt;object&gt;，&lt;svg&gt; 交互（Interactive）：与用户交互的内容 元素：&lt;a&gt; , &lt;audio&gt; , &lt;video&gt; , &lt;button&gt; , &lt;details&gt; , &lt;embed&gt; , &lt;iframe&gt; , &lt;img&gt; , &lt;input&gt; , &lt;label&gt; , &lt;object&gt; , &lt;select&gt; , &lt;textarea&gt; 标题（Heading）：定义段落标题 元素：&lt;h1&gt;，&lt;h2&gt;，&lt;h3&gt;，&lt;h4&gt;，&lt;h5&gt;，&lt;h6&gt;，&lt;hgroup&gt; 短语（Phrasing）：文本和文本标记元素 元素：&lt;img&gt;，&lt;span&gt;，&lt;strong&gt;，&lt;label&gt;，&lt;br /&gt;，&lt;small&gt;，&lt;sub&gt;等 区段（sectioning）内容：定义标题，内容，导航和页脚的范围 元素：&lt;article&gt;，&lt;aside&gt;，&lt;nav&gt;，&lt;section&gt; 内容分类动态图https://www.w3.org/TR/html51/dom.html#kinds-of-content HTML元素嵌套关系 块级元素可以包含行内元素 块级元素不一定能包含块级元素 行内元素一般不能包含块级元素 但是…..什么叫一般 (比如a元素可以包含块元素) HTML 4.01过渡的嵌套规则 为什么a &gt; div是合法的？ 透明内容模型，在计算内容模型时此元素本身不参与计算,相当于a时不存在的 是否合法取决外面的元素 123&lt;div&gt;&lt;a href=\"#\"&gt;DIV &amp;gt; A&lt;/a&gt;&lt;/div&gt;&lt;a href=\"#\"&gt;&lt;div&gt;A &amp;gt; DIV&lt;/div&gt;&lt;/a&gt;&lt;p&gt;&lt;a href=\"#\"&gt;&lt;div&gt;P &amp;gt; A &amp;gt; DIV&lt;/div&gt;&lt;/a&gt;&lt;/p&gt; DIV &gt; A 合法 A &gt; DIV 合法（相当于DIV） P &gt; A &gt; DIV (相当于去掉A，P &gt; DIV, P不能包含DIV，浏览器会去容错变换) HTML元素默认样式和定制化HTML元素默认样式不加任何样式的时候，元素本来的样式 默认样式的意义 模式样式带来的问题 CSS Reset常见的方案： CSS Tools: Reset CSS 雅虎YUL CSS Reset 比较有争议的一种:123456&lt;style&gt; *&#123; margin: 0; padding: 0; &#125;&lt;/style&gt; Normalize.css 保护有用的浏览器样式而不是去掉他们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化css可用性：用一些小技巧 解释代码：注释和详细的文档 HTML 真题 doctype的意义是什么 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML XHTML HTML5的关系 HTML属于SGML XHTML属于XML 是HTML进行XML严格化的结果 HTML5不属于SGML或XML，比XHTML宽松 HTML5有什么变化 新的语义化元素 表单增强 新的API (离线，音频，图形，实时通信，本地存储，设备能力) 分类和嵌套变更 em 和 i 有什么区别 em 是语义化的标签，表强调 i 是纯样式的标签，表斜体 i 一般不推荐使用，一般作图标icon使用 语义化的意义是什么 开发者容易理解 机器容易理解结构（搜索，读屏软件） 有助于SEO semantic microdata 哪些元素可以自闭合 表单元素 input 图片 img br hr meta link HTML和DOM的关系 HTML是死的 DOM由HTML解析而来，是活的 JS可以维护的是DOM property和attribute的区别 attribute 是死的 property 是活的 form的作用有哪些 直接提交表单 使用submit/reset按钮 便于浏览器保存表单 第三方库可以整体提取值 第三方可以进行表单验证","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS讲解(1) 介绍","slug":"CSS讲解-1-1","date":"2019-02-05T13:22:38.000Z","updated":"2020-07-25T02:57:18.149Z","comments":true,"path":"2019/02/05/CSS讲解-1-1/","link":"","permalink":"https://jigangduan.github.io/2019/02/05/CSS讲解-1-1/","excerpt":"","text":"前端三大件 HTML CSS JavaScript 不会CSS的前端只能叫作伪前端 内容 HTML和CSS基础知识 HTML元素的分类和特性 HTML元素默认样式和定制化 CSS选择器全解析 CSS常见属性 CSS布局 布局属性和组合解析 常见布局方案 三栏布局 国内大站布局方案 动画和效果 多背景多投影特效 3D特效编写实践 过渡动画和关键帧动画实践 动画细节和原理解析 框架集成和CSS工程化 预处理器作用和原理 Less/Sass代码实践 Bootstrap原理和用法 CSS工程化实践方式 JS框架中的CSS集成实践 解析 HTML元素的嵌套关系是怎么确定的 哪些嵌套不可以发生 CSS选择器的权重是如何计算的 写代码时要注意什么 浮动布局是怎么回事 有什么优缺点 国内用得多吗 CSS可以作逐帧动画吗 性能如何 Bootstrap怎么作响应式布局 如何解决CSS模块化过程中的选择器互相干扰问题","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"CSS中的盒子定位","slug":"Learn-CSS-Layout-1","date":"2019-01-29T12:53:41.000Z","updated":"2020-07-25T02:57:18.158Z","comments":true,"path":"2019/01/29/Learn-CSS-Layout-1/","link":"","permalink":"https://jigangduan.github.io/2019/01/29/Learn-CSS-Layout-1/","excerpt":"","text":"CSS核心布局是将一组HTML元素映射到一组矩形框，这些矩形框可以位于x轴，y轴和z轴上。 这些盒子的x轴和y轴定位由应用于盒子的定位方案确定。在本章中，我将介绍CSS 2.1中引入的定位方案：正常流，浮动和绝对定位。 从概念上讲，CSS布局的最高级抽象是定位方案。一旦确定了定位方案，就可以通过特定的布局模式进一步修改它，例如display: table或display: inline-table。即使是引入布局模式（如flexbox和grid）的CSS 3扩展，仍然存在于一个主要的定位方案中（例如display: flexvs. display: inline-flex）。 定位方案CSS 2.1定义了三种定位方案，它们是： 正常流，由三个格式化上下文组成：块，内联和相对格式化上下文 浮动，以自己的方式与正常流相互作用，并形成大多数现代CSS网格框架的基础 绝对定位，它处理相对于正常流动的绝对和固定元素 定位方案对元素的x轴和y轴定位有很大影响。CSS 2.1规范的9.3节描述了这三个属性之间的交互，但是短版本是默认属于正常流的所有元素，除非它们是从正常流中专门删除的 - 通常是通过设置float属性或position属性。 属性 默认值 目的 display block 或 inline 确定要使用的布局算法 position static 控制元素的位置 float none 允许其他元素在元素周围浮动 通过它们如何与正常流动相互作用，为了可以最好地理解浮动和绝对定位，因此我将首先介绍正常流动定位方案。 如果你考虑一下，实际上有两个方面的布局: 元素的框的大小和对齐方式，主要由display属性(以及width, height和margin)控制。 特定父元素中的元素是如何相对定位的 在本章中，我将重点关注后一方面 - 相对定位。下一章将介绍盒子模型，它决定了对齐和尺寸。 父元素中元素的相对位置由为特定父元素的所有直接子元素建立的格式化上下文控制，在正常流中，格式化上下文可以是块或内联格式化上下文。 下面是CSS 2.1规范关于格式化上下文的说明: 普通流中的框属于格式化上下文，可以是块或内联的，但不能同时属于这两种格式。块级框参与块格式化上下文。内联级框参与内联格式化上下文。normal-flow 父(容器)根据子框是内联级的还是块级的，为其子框建立格式化上下文。定义术语内联级和块级是为了突出显示具有display属性而不是inline或block的块仍然映射到普通流中的两个格式化上下文之一。例如，display: table元素被认为是块级的，display: inline-table元素被认为是内联级的 块级元素定义为: 块级元素是源文档中以块(例如段落)的形式可视化格式化的元素。“display”属性的下列值构成元素块级:’block’, ‘list-item’和’table’。 块级框是参与块格式化上下文的框。每个块级元素生成一个主块级框，该框包含子代框和生成的内容，也是任何定位方案中涉及的框。一些块级元素可能会在主框之外生成额外的框[例如]:list-item元素。这些额外的框是相对于主框放置的。 几乎所有块级别的盒也是块容器盒。块容器框只是一组其他框的父框，具有特定的格式化上下文: 除了table boxes […]而被替换的元素，块级框也是块容器框。块容器框要么只包含块级框，要么建立内联格式化上下文，因此只包含内联级框 内联级元素定义为: 内联级元素是源文档中不形成新的内容块的元素;内容按行分布(例如，段落中强调的文本片段、内联图像等)。display属性的下列值构成元素的内联级:inline、inline-table和inline-block。内联级元素生成内联级框，这些框参与内联格式化上下文。 内联框是内联级别的，其内容参与其包含的内联格式化上下文。一个display值为inline的未替换元素生成一个内联框。不是内联框的内联级框(如替换的内联级元素、内联块元素和内联表元素)称为原子内联级框，因为它们以单个不透明框的形式参与内联格式化上下文 我不会真正讨论被替换和未被替换的元素，因为这是一个相当小的区别。考虑替换元素的最简单方法是考虑img或video元素——也就是说，元素只有一个(外部定义的)内容，不能像文本内容那样分成行。 您可以大致考虑一下常规流中的两个格式化上下文，分别对应于垂直堆栈(在块格式化上下文中)和水平堆栈(在内联格式化上下文中)。我一会儿会讲到这两个问题。 上述定义的有趣之处在于，每个框的格式化上下文必须是“内联格式化上下文”或“块格式化上下文”。也就是说，对于每个父元素，所有子元素都使用一种格式化上下文进行布局。当您可以清楚地混合块级内容(如div)和内联级内容(如文本)时，如何做到这一点呢?答案是，有一种机制可以将内联级元素提升为块级元素。这种机制称为匿名盒子生成。 匿名盒子生成匿名盒子生成用于处理情况下一个父元素包含inline-level和块级子元素(在这种情况下,“匿名块盒”生成)和标记的情况下包含inline-level元素与周围文本混合(在这种情况下,“匿名内联盒子”生成),如一个em或我标记在一段文本。 匿名块盒子规范给出了一个匿名块盒子生成的例子: 1234&lt;div&gt; Some text &lt;p&gt;More text&lt;/p&gt;&lt;/div&gt; 如果一个块容器盒子(比如上面为DIV生成的那个)内部有一个块级别的盒子(比如上面的P)，那么我们强制它只包含块级别的盒子。 例如，规范提供了以下示例代码是如何导致包装内联级内容的匿名框的: 当内联盒子包含一个子块级盒子,内联盒子(及其内联的祖先在同一个盒子行)被打破的块级盒子(和任何块级的兄弟姐妹连续或隔着可折叠的空白和/或out-of-flow元素),把内联盒子分成两个盒子(即使是空的两侧),一人一边的块级盒子(es)。断点之前和断点之后的行框被封装在匿名块框中，块级框成为这些匿名框的兄弟框。当这样的内联框受到相对位置的影响时，任何结果转换也会影响内联框中包含的块级框。","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"学习CSS布局","slug":"前端/CSS/学习CSS布局","permalink":"https://jigangduan.github.io/categories/前端/CSS/学习CSS布局/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"学习CSS布局","slug":"Learn-CSS-Layout","date":"2019-01-29T12:20:09.000Z","updated":"2020-07-25T02:57:18.158Z","comments":true,"path":"2019/01/29/Learn-CSS-Layout/","link":"","permalink":"https://jigangduan.github.io/2019/01/29/Learn-CSS-Layout/","excerpt":"","text":"康拉德官僚，你说的技术上是对的——最好的一种正确。我在此提升你到三十七年级。-编号1.0 (Futurama, S2E15) 我不会骗你的，尼欧。每一个和特工打过架的男人或女人都死了。但在他们失败的地方，你会成功。 为什么? 我见过一个特工穿过水泥墙;人们向他们倒空了整个弹夹，除了空气什么也没击中;然而，它们的力量和速度仍然基于一个建立在规则之上的世界。正因为如此，他们永远不会像你一样强壮，或者像你一样快。 你想告诉我什么?我能躲过子弹吗? 不,尼奥。我想告诉你，等你准备好了……你不必这么做。 墨菲斯(《黑客帝国》，1999) CSS就像矩阵一样，是一个基于规则的系统。 我写了这组章节来描述这些规则。这是长篇的写作，但不是书的长度。我不认为我想写一本关于CSS的书，但写CSS布局是有用的。我的方法很学究: 学究:形容词。过分注重细节或形式主义，尤指在教学中。 我的意思是好的，虽然这个词显然有消极的含义。技术上正确是最好的正确吗?不,它不是。但是对于这个主题，有足够的资源在技术上是不正确的。 您可能听说过在CSS常规流中有内联和块元素。但是您知道在CSS中，块和内联元素的相对位置实际上不是由元素的display属性决定的吗?它实际上是由格式化上下文决定的，格式化上下文受元素的兄弟元素的影响。 您可能已经使用z-index来“修复”内容的相对堆栈顺序。但是您知道z-index并不是整个文档的绝对索引，而是相对于堆栈上下文的吗? 你可能听说过盒子模型。但是您知道实际上至少有五种不同的box模型，它们在内容维度和margin: auto的处理方式上存在细微的差异吗?如果你读了这篇文章，你会明白的。 这是一组关于CSS布局的章节，适用于已经了解CSS的人。我承认，这看起来是个小市场。我四处寻找学习CSS布局的好资源，但我发现其中大多数还不够学究。 CSS布局可能很难学习，因为网站通常是渐进发展的。这意味着您最终将到处学习小技巧，而永远不会学习底层布局算法。 这一组章节将带您了解CSS布局中的每个主要概念，并包括许多应用示例来说明各种概念。 第1章:在CSS中的盒子定位涵盖了HTML元素生成的盒子是如何相对定位的: CSS中的三种主要定位方案:普通流、浮动和绝对定位 普通流概念，如匿名盒子生成、格式化上下文、行盒子和行盒子中的对齐 浮动概念，如浮动顺序、clearfix和与父级高度的浮动交互 第2章:CSS中的Box sizing讨论了Box模型，但更重要的是Box模型在CSS中的不同定位方案中是如何变化的。具体来说，高、宽、边距是用完全不同的机构计算的，只有了解使用中的定位方案和计算机构，才能理解这些计算。 第3章:影响定位的附加属性涵盖了影响盒子定位的附加机制，例如: margin崩溃 负margins overflow max-width, max-height, min-width, min-height 堆栈上下文和z-inde属性 伪元素如何影响布局 CSS3盒子大小属性 第4章:Flexbox讨论了CSS 3的Flexbox布局模式。 第5章:CSS布局技巧和布局技术将我们所学的知识应用到一些实际问题中。它还包含一些类似于小测验的问题，以测试您对布局的理解，例如: 水平和垂直定心 CSS网格框架是如何工作的 多列布局 常见的陷阱和布局技巧 如果您需要查找特定的概念或属性，请查看reference索引，它提供了一种简单的方法，可以跨章节集查找正确的章节和部分。","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"学习CSS布局","slug":"前端/CSS/学习CSS布局","permalink":"https://jigangduan.github.io/categories/前端/CSS/学习CSS布局/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"}]},{"title":"Linux 监控 Linux-dash","slug":"linux-dash","date":"2019-01-27T01:40:45.000Z","updated":"2020-07-25T02:57:18.212Z","comments":true,"path":"2019/01/27/linux-dash/","link":"","permalink":"https://jigangduan.github.io/2019/01/27/linux-dash/","excerpt":"","text":"v2.0 一个简单且低开销的linux系统web指示板 演示 &nbsp;|&nbsp; 文档 特性 体积小 —– 磁盘_上的文件小于400KB (删除了.git)! 简单 —- 简约、漂亮的仪表盘 容易 —— 顺便的安装 多功能 – 可以从Node.js、Go、Python、PHP中选择堆栈 安装步骤112345## 1. 克隆仓库git clone --depth 1 https://github.com/afaqurk/linux-dash.git## 2. 转到克隆目录cd linux-dash/app/server 或者，如果你喜欢手动下载: 12345## 1. 下载 .zipcurl -LOk https://github.com/afaqurk/linux-dash/archive/master.zip &amp;&amp; unzip master.zip## 2. 导航到下载和解压的目录cd linux-dash-master/app/server 步骤 2请参阅首选服务器linux-dash server (包括所有) 的说明: Node.js (recommended) Go Python PHP 如果使用 Node.js1234567## 安装依赖关系npm install --production## 启动linux-dash(默认在端口80上;可能需要sudo)## 您可以使用 `LINUX_DASH_SERVER_PORT` 环境变量 (例如. `LINUX_DASH_SERVER_PORT=8080 node server`)## 或者为下面的命令提供一个—--port标志node index.js 如果使用 Go12## 启动服务器(默认在端口80上;可能需要sudo)go run index.go 构建二进制文件, 运行 go build &amp;&amp; ./server -h. 有关二进制使用选项，请参阅@tehbilly的注释,在这里 如果使用 Python12# 启动服务器(默认在端口80上;可能需要sudo)python index.py 如果使用 PHP 确保启用了 exec, shell_exec, 和 escapeshellarg 函数 将您的web服务器指向linux-dash下的 app/ 目录 重新启动web服务器(Apache、nginx等) 对于PHP + Apache设置，请遵循Digital Ocean教程. 有关nginx设置的帮助，请参见@sergeifilippov提供的要点 支持如需一般帮助，请使用Gitter聊天室. 安全强烈建议通过您选择的安全措施来保护所有linux-dash安装。 Linux Dash不提供任何安全或身份验证特性.","categories":[{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/tags/工具/"},{"name":"linux","slug":"linux","permalink":"https://jigangduan.github.io/tags/linux/"}]},{"title":"交互式 3D 图形 - 1.介绍","slug":"Interactive3DGraphicsCourse1","date":"2019-01-15T14:20:49.000Z","updated":"2020-07-25T02:57:18.158Z","comments":true,"path":"2019/01/15/Interactive3DGraphicsCourse1/","link":"","permalink":"https://jigangduan.github.io/2019/01/15/Interactive3DGraphicsCourse1/","excerpt":"","text":"Eric Haines 将会教你一些充满激情的东西 —— 计算机图形学 随着计算机芯片不断获得更快的图形运行速度 广义上来讲 在电脑屏幕上看到的一切都可以成为 计算机图形学文字处理 / 视频 / 绘图程序 / 显示器上的其他图像 互动式3D渲染 渲染： 绘制，创建一副图片的意思 3D：在三维计算机图形领域，用数学方式定义一个对象，材料，灯和摄像头绘制到二位的屏幕上 互动式：你对它的操作可以在屏幕上立刻显现出来，用户的动作可以影响3D虚拟世界的东西 WebGLGL（Graphics Library）图形库 访问这个网站，查看是否支持WebGL","categories":[],"tags":[]},{"title":"SQLer","slug":"sqler","date":"2019-01-11T00:17:31.000Z","updated":"2020-07-25T02:57:18.229Z","comments":true,"path":"2019/01/11/sqler/","link":"","permalink":"https://jigangduan.github.io/2019/01/11/sqler/","excerpt":"","text":"SQL-er 是一个微型 http 服务器，用 Go 语言编写，将旧的 CGI 概念应用于 SQL 查询。SQLer 允许编写端点并分配一个 SQL 查询，以便任何人点击它时能执行查询。此外 SQLer 还允许自定义验证规则，可验证请求正文或查询参数。SQLer 使用 nginx 样式配置语言（HCL）。 介绍","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"GitHub精选","slug":"golang/GitHub精选","permalink":"https://jigangduan.github.io/categories/golang/GitHub精选/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"}]},{"title":"Django入门与实践-第10章：Django Admin 介绍","slug":"django-start-guide-10","date":"2019-01-09T15:49:19.000Z","updated":"2020-07-25T02:57:18.198Z","comments":true,"path":"2019/01/09/django-start-guide-10/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-10/","excerpt":"","text":"Django Admin 简介当我们开始一个新项目时，Django已经配置了Django Admin，这个应用程序列出的INSTALLED_APPS。 创建一个管理员帐户： 1python manage.py createsuperuser 按照说明操作： 12345Username (leave blank to use 'vitorfs'): adminEmail address: admin@example.comPassword:Password (again):Superuser created successfully. 在浏览器中打开该URL：http://127.0.0.1:8000/admin/ 输入用户名和密码登录到管理界面： 添加Board模型非常简单。打开boards目录中的admin.py文件，并添加以下代码： boards/admin.py 1234from django.contrib import adminfrom .models import Boardadmin.site.register(Board) 点击Boards链接查看现有版块列表： 点击 Add Board 按钮添加一个新的版块： 点击保存按钮： 我们可以检查一切是否正常，打开URL http://127.0.0.1:8000","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第8章：第一个单元测试","slug":"django-start-guide-8","date":"2019-01-09T15:31:17.000Z","updated":"2020-07-25T02:57:18.200Z","comments":true,"path":"2019/01/09/django-start-guide-8/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-8/","excerpt":"","text":"boards/tests.py 1234567891011121314from django.core.urlresolvers import reversefrom django.urls import resolvefrom django.test import TestCasefrom .views import homeclass HomeTests(TestCase): def test_home_view_status_code(self): url = reverse('home') response = self.client.get(url) self.assertEquals(response.status_code, 200) def test_home_url_resolves_home_view(self): view = resolve('/') self.assertEquals(view.func, home) 在第一个测试，我们测试的是请求该URL后返回的响应状态码。状态码200意味着成功。 在第二个测试中，我们使用了resolve函数。Django使用它来将浏览器发起请求的URL与urls.py模块中列出的URL进行匹配。该测试用于确定URL / 返回 home 视图。 执行Django的测试套件： 1python manage.py test 要查看有关测试执行时更详细的信息，可将verbosity的级别设置得更高一点： 1python manage.py test --verbosity=2 Verbosity决定了将要打印到控制台的通知和调试信息量; 0是无输出，1是正常输出，2是详细输出。","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第7章：模板引擎设置","slug":"django-start-guide-7","date":"2019-01-09T15:18:36.000Z","updated":"2020-07-25T02:57:18.199Z","comments":true,"path":"2019/01/09/django-start-guide-7/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-7/","excerpt":"","text":"在manage.py所在的目录创建一个名为 templates的新文件夹： 1234567myproject/ |-- myproject/ | |-- boards/ | |-- myproject/ | |-- templates/ &lt;-- 这里 | +-- manage.py +-- venv/ templates/home.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Boards&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Boards&lt;/h1&gt; &#123;% for board in boards %&#125; &#123;&#123; board.name &#125;&#125; &lt;br&gt; &#123;% endfor %&#125; &lt;/body&gt;&lt;/html&gt; 告诉Django在哪里可以找到我们应用程序的模板 settings.py文件，搜索TEMPLATES变量，并设置DIRS 的值为 os.path.join(BASE_DIR, &#39;templates&#39;)： 1234567891011121314151617TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [ os.path.join(BASE_DIR, 'templates') ], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 更新home视图： boards/views.py 123456from django.shortcuts import renderfrom .models import Boarddef home(request): boards = Board.objects.all() return render(request, 'home.html', &#123;'boards': boards&#125;) 生成的HTML： templates/home.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Boards&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Boards&lt;/h1&gt; &lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Board&lt;/th&gt; &lt;th&gt;Posts&lt;/th&gt; &lt;th&gt;Topics&lt;/th&gt; &lt;th&gt;Last Post&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for board in boards %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; board.name &#125;&#125;&lt;br&gt; &lt;small style=\"color: #888\"&gt;&#123;&#123; board.description &#125;&#125;&lt;/small&gt; &lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第6章：第一个视图函数","slug":"django-start-guide-6","date":"2019-01-09T15:12:57.000Z","updated":"2020-07-25T02:57:18.199Z","comments":true,"path":"2019/01/09/django-start-guide-6/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-6/","excerpt":"","text":"boards/views.py 12345678910111213from django.http import HttpResponsefrom .models import Boarddef home(request): boards = Board.objects.all() boards_names = list() for board in boards: boards_names.append(board.name) response_html = '&lt;br&gt;'.join(boards_names) return HttpResponse(response_html) 结果就是这个简单的HTML页面：","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第5章：模型设计","slug":"django-start-guide-5","date":"2019-01-09T14:23:52.000Z","updated":"2020-07-25T02:57:18.199Z","comments":true,"path":"2019/01/09/django-start-guide-5/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-5/","excerpt":"","text":"模型这些模型基本上代表了应用程序的数据库设计。 Board Topic Post User 模型被命名为内置应用叫 auth，它以命名空间 django.contrib.auth 的形式出现在 INSTALLED_APPS 配置中。 boards/models.py: 1234567891011121314151617181920from django.db import modelsfrom django.contrib.auth.models import Userclass Board(models.Model): name = models.CharField(max_length=30, unique=True) description = models.CharField(max_length=100)class Topic(models.Model): subject = models.CharField(max_length=255) last_updated = models.DateTimeField(auto_now_add=True) board = models.ForeignKey(Board, related_name='topics') starter = models.ForeignKey(User, related_name='topics')class Post(models.Model): message = models.TextField(max_length=4000) topic = models.ForeignKey(Topic, related_name='posts') created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(null=True) created_by = models.ForeignKey(User, related_name='posts') updated_by = models.ForeignKey(User, null=True, related_name='+') 所有模型都是django.db.models.Model类的子类。每个类将被转换为数据库表 每个字段由 django.db.models.Field子类（内置在Django core）的实例表示，它们并将被转换为数据库的列 字段 CharField，TextField，DateTimeField, IntegerField，BooleanField， DecimalField等等，都是 django.db.models.Field 的子类 字段需要参数 unique=True，将强制数据库级别字段的唯一性 auto_now_add设置为True, 创建对象时为当前日期和时间 ForeignKey字段, 外键关联, 位置参数related_name，用于引用它关联的模型 下面您可以看到类图和Django模型的源代码之间的比较，绿线表示我们如何处理反向关系。 迁移模型打开终端 ，激活虚拟环境，转到 manage.py文件所在的文件夹，然后运行以下命令： 1python manage.py makemigrations 输出的内容是： 1234567Migrations for 'boards': boards/migrations/0001_initial.py - Create model Board - Create model Post - Create model Topic - Add field topic to post - Add field updated_by to post Django 在 boards/migrations 目录创建了一个名为 0001_initial.py的文件。 迁移文件将被翻译成SQL语句。 1python manage.py sqlmigrate boards 0001 Django ORM来完成，它是一个与数据库进行通信的抽象层 1python manage.py migrate 输出内容 1234567891011121314151617Operations to perform: Apply all migrations: admin, auth, boards, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying boards.0001_initial... OK Applying sessions.0001_initial... OK 试验 Models API使用manage.py 工具加载我们的项目来启动 Python shell 1python manage.py shell 12345Python 3.6.2 (default, Jul 17 2017, 16:44:45)[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.(InteractiveConsole)&gt;&gt;&gt; 项目将被添加到sys.path并加载Django。这意味着我们可以在项目中导入我们的模型和其他资源并使用它。 导入Board类开始： 1from boards.models import Board 创建新的 boarrd 对象 1board = Board(name='Django', description='This is a board about Django.') 将这个对象保存在数据库 1board.save() Django会自动设置ID 12board.id1 Python属性访问： 12board.name'Django' 12board.description'This is a board about Django.' 更新一个值 12board.description = 'Django discussion board.'board.save() 每个Django模型都带有一个特殊的属性; 我们称之为模型管理器(Model Manager)。你可以通过属性objects 来访问这个管理器，它主要用于数据库操作。例如，我们可以使用它来直接创建一个新的Board对象： 1board = Board.objects.create(name='Python', description='General discussion about Python.') objects列出数据库中所有现有的列： 12Board.objects.all()&lt;QuerySet [&lt;Board: Board object&gt;, &lt;Board: Board object&gt;]&gt; QuerySet, 它是从数据库中查询的对象列表 管理器（Manager） 来查询数据库并返回单个对象 1234django_board = Board.objects.get(id=1)django_board.name'Django' get方法的参数可以是模型的任何字段，但最好使用可唯一标识对象的字段来查询 退出交互式控制台： 1exit()","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第4章：系统设计","slug":"django-start-guide-4","date":"2019-01-09T13:58:10.000Z","updated":"2020-07-25T02:57:18.199Z","comments":true,"path":"2019/01/09/django-start-guide-4/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-4/","excerpt":"","text":"论坛项目用例图 几个论坛版块（boards），每个版块像一个分类一样 指定的版块里面，用户可以通过创建新主题（Topic）开始讨论 其他用户可以参与讨论回复 类图 Board：版块 Topic：主题 Post：帖子（译注：其实就是主题的回复或评论） 这是模型最基本的内容： Board 模型 name字段必须是唯一的，为了避免有重复的名称。 description 用于说明这个版块是做什么用的。 Topic 模型 subject 表示主题内容， last_update 用来定义话题的排序， starter 用来识别谁发起的话题， board 用于指定它属于哪个版块。 Post 模型 message 用于存储回复的内容， created_at 在排序时候用（最先发表的帖子排最前面）， updated_at 告诉用户是否更新了内容 User 模型 username password email is_superuser 一个topic 必须与一个（1）Board（这意味着它不能为空）相关联，但是 Board 下面可能与许多个或者0个 topic 关联 (0..*)。这意味着 Board 下面可能没有主题。（译注：一对多关系） 一个 Topic 至少有一个 Post（发起话题时，同时会发布一个帖子），并且它也可能有许多 Post（1..*）。一个Post 必须与一个并且只有一个Topic（1）相关联。 一个 Topic 必须有一个且只有一个 User 相关联，topic 的发起者是（1）。而一个用户可能有很多或者没有 topic（0..*）。 Post 必须有一个并且只有一个与之关联的用户，用户可以有许多或没有 Post（0..*）。Post 和 User之间的第二个关联是直接关联（参见该行最后的箭头），就是 Post 可以被用户修改（updated_by），updated_by 有可能是空（Post 没有被修改） 画这个类图的另一种方法是强调字段而不是模型之间的关系： 线框图（原型图）版块： 主题： “new topic” 页面： 主题页面显示了帖子和讨论： 如果用户点击回复按钮，将看到下面这个页面，并以倒序的方式（最新的在第一个）显示帖子列表：","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第3章：Hello World","slug":"django-start-guide-3","date":"2019-01-09T13:33:36.000Z","updated":"2020-07-25T02:57:18.198Z","comments":true,"path":"2019/01/09/django-start-guide-3/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-3/","excerpt":"","text":"现在来写我们的第一个视图(view) boards应用程序中的views.py文件 views.py 1234from django.http import HttpResponsedef home(request): return HttpResponse('Hello, World!') urls.py 123456789from django.conf.urls import urlfrom django.contrib import adminfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^admin/', admin.site.urls),] Django使用正则表达式来匹配请求的URL home视图，我使用^$正则，它将匹配一个空路径，也就是主页（这个URL：http://127.0.0.1:8000 ）。如果我想匹配的URL是 http://127.0.0.1:8000/homepage/ ，那么我的URL正则表达式就会是：url(r’^homepage/$’, views.home, name=’home’)。 运行： 1python manage.py runserver 在一个Web浏览器中，打开 http://127.0.0.1:8000 这个链接 https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第2章：创建项目","slug":"django-start-guide-2","date":"2019-01-09T13:14:48.000Z","updated":"2020-07-25T02:57:18.198Z","comments":true,"path":"2019/01/09/django-start-guide-2/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-2/","excerpt":"","text":"启动一个新项目创建一个新的 Django 项目： 1django-admin startproject myproject myproject目录结构: 123456789myproject/ &lt;-- 高级别的文件夹 |-- myproject/ &lt;-- Django项目文件夹 | |-- myproject/ | | |-- __init__.py | | |-- settings.py | | |-- urls.py | | |-- wsgi.py | +-- manage.py +-- venv/ &lt;-- 虚拟环境文件夹 manage.py: 使用django-admin命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。 __init.py：这个空文件告诉python这个文件夹是一个python包。 settings.py：这个文件包含了所有的项目配置。将来我们会一直提到这个文件！ urls.py：这个文件负责映射我们项目中的路由和路径。例如，如果你想在访问URL / about/ 时显示某些内容，则必须先在这里做映射关系。 wsgi.py：该文件是用于部署的简单网关接口 开发过程中,通过执行命令来测试: 1python manage.py runserver 浏览器中打开URL：http://127.0.0.1:8000 Django 应用 app：是一个可以做完成某件事情的Web应用程序。 一个应用程序通常由一组models(数据库表)，views(视图)，templates(模板)，tests(测试) 组成。 project: 是配置和应用程序的集合。 一个项目可以由多个应用程序或一个应用程序组成。 我们来创建一个简单的网络论坛或讨论区。要创建我们的第一个应用程序，请跳转到manage.py文件所在的目录并执行以下命令： 1django-admin startapp boards 目录结构： 123456789101112131415161718myproject/ |-- myproject/ | |-- boards/ &lt;-- 我们新的Django应用（app）! | | |-- migrations/ | | | +-- __init__.py | | |-- __init__.py | | |-- admin.py | | |-- apps.py | | |-- models.py | | |-- tests.py | | +-- views.py | |-- myproject/ | | |-- __init__.py | | |-- settings.py | | |-- urls.py | | |-- wsgi.py | +-- manage.py +-- venv/ migrations/：在这个文件夹里，Django会存储一些文件以跟踪你在models.py文件中创建的变更，用来保持数据库和models.py的同步。 admin.py：这个文件为一个django内置的应用程序Django Admin的配置文件。 apps.py：这是应用程序本身的配置文件。 models.py：这里是我们定义Web应用程序数据实例的地方。models会由Django自动转换为数据库表。 tests.py：这个文件用来写当前应用程序的单元测试。 views.py：这是我们处理Web应用程序请求(request)/响应(resopnse)周期的文件。 settings.py 12345678INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] Django默认已经安装了6个内置应用程序身份验证，会话，静态文件管理（图像，JavaScript，CSS等）等 将我们的应用程序boards添加到INSTALLED_APPS列表： 12345678910INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'boards', # 译者注：建议和作者一样空一行来区别内置app和自定义的app]","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"Django入门与实践-第1章：环境搭建","slug":"django-start-guide-1","date":"2019-01-09T12:33:52.000Z","updated":"2020-07-25T02:57:18.198Z","comments":true,"path":"2019/01/09/django-start-guide-1/","link":"","permalink":"https://jigangduan.github.io/2019/01/09/django-start-guide-1/","excerpt":"","text":"为什么要学习Django?Django是一个用python编写的Web框架。 Web框架, 提供了一系列工具和功能: 安全功能 数据库访问 会话 模板处理 URL路由 国际化 本地化 等等 python软件包资料库（pypi）拥有超过11.6万个软件包 Django是用python编写的最流行的web框架之一。提供了各种各样的开箱即用的功能: 用于开发和测试的独立Web服务器 缓存 中间件系统 ORM 模板引擎 表单处理 基于Python单元测试的工具接口 Django还自带内部电池，提供内置应用程序，比如 一个认证系统 一个可用于 CRUD(增删改查) 操作并且自动生成页面的后台管理界面 生成订阅文档（RSS/Atom） 站点地图 甚至在django中内建了一个地理信息系统（GIS）框架 谁在使用Django?大型网站有： Instagram Disqus Mozilla Bitbucket Last.fm 国家地理 更多的示例, Django Sites, 超过五千个Django驱动的网站列表 安装安装 Python 31brew install python3 运行Python 3 12python3 --versionPython 3.6.2 安装 Virtualenvvirtualenv : 建立虚拟的python环境virtualenvwrapper : 管理虚拟环境 1sudo pip install virtualenv 对于你开始的每个Django项目，你首先会为它创建一个虚拟环境。这就像每个Django项目都有一个沙盒。 让我们开始创建我们的第一个虚拟环境并安装django 在myproject文件夹中： 1virtualenv venv -p python3 激活虚拟环境： 1source venv/bin/activate 如果你在命令行前面看到 (venv)，就代表激活成功了 让我们试着了解一下这里发生了什么 我们创建了一个名为venv的特殊文件夹。 该文件夹内包含了一个python的副本。 在我们激活了venv环境之后，当我们运行Python命令时，它将使用我们存储在venv里面的本地副本，而不是我们之前在操作系统中安装的那个。 当我们启用venv时，我们将使用命令python（而不是python3）来调用Python 3.6.2，并且仅使用pip（而不是pip3）来安装软件包。 退出venv环境 1deactivate virtualenvwrapper安装： 1pip install virtualenvwrapper 创建虚拟环境： 1mkvirtualenv project_env --python=python3.7 在虚拟环境上工作： 1workon project_env 停止虚拟环境 1deactivate 删除： 1rmvirtualenv project_env lsvirtualenv #列举所有的环境。 cdvirtualenv #导航到当前激活的虚拟环境的目录中，比如说这样您就能够浏览它的 site-packages。 cdsitepackages # 和上面的类似，但是是直接进入到 site-packages 目录中。 lssitepackages #显示 site-packages 目录中的内容。 安装 Django 1.11.41234pip install django==1.11.4# 译注：目前django已经升级到2.x版本，这里为了跟后续教程内容保持一直，所以必须指定版本号进行安装# 除非你有能力 debug，否则不建议你使用django 2.x，等你熟悉Django后，再升级都Django2.0 也不迟，因为两个版本的差异非常小","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"}]},{"title":"JSON:API规范","slug":"json-api","date":"2019-01-05T06:19:04.000Z","updated":"2020-07-25T02:57:18.211Z","comments":true,"path":"2019/01/05/json-api/","link":"","permalink":"https://jigangduan.github.io/2019/01/05/json-api/","excerpt":"","text":"英文原址 JSON:API版本，目前是1.0版。新版本的JSON:API将始终向后兼容使用永不删除，只添加策略。 介绍JSON:API是关于客户机应该如何请求获取或修改资源，以及服务器应该如何响应这些请求的规范。 JSON:API旨在将请求数量和客户机与服务器之间传输的数据量最小化。这种效率是在不损害可读性、灵活性或可发现性的情况下实现的。 JSON:API需要使用JSON:API媒体类型(application/vnd.api+json)来交换数据。 约定本文件中必须、一定不能`、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、suggest、MAY、OPTIONAL等关键词按RFC2119 [RFC2119]解释。 内容协商客户端责任请求中header必须携带Content-Type: application/vnd.api+json, 表示请求数据为 JSON:API数据, 不能携带其它任何媒体类型参数。 请求中header的Accept: application/vnd.api+json 表示可以接收JSON:API数据。 客户端必须忽略响应文档的Content-Type头中接收到的application/vnd.api+json媒体类型的任何参数。 服务端责任服务端响应JSON:API数据必须在响应中携带header Content-Type: application/vnd.api+json，表示响应数据为JSON:API数据。 如果请求没有指定Content-Type: application/vnd.api+json header的媒体类型参数，服务端必须响应一个带415 Unsupported Media Type(不支持的媒体类型)的状态码。 如果请求header 不包含Accept的媒体类型参数或其它媒体参数, 服务端必须响应一个带406 Not Acceptable(不可接受)的状态码。 注意:存在内容协商需求，以允许此规范的未来版本使用媒体类型参数进行扩展协商和版本控制 文档结构本节描述JSON:API文档的结构，该文档由媒体类型application/vnd.api+json标识。JSON:API文档是用JavaScript对象表示法(JSON) [RFC7159]定义的。 尽管请求和响应文档都使用相同的媒体类型，但某些方面只适用于其中之一。下面列出这些差异。 除非另有说明，否则此规范定义的对象不能包含任何其他成员。客户机和服务器实现必须忽略此规范不能识别的成员。 顶层结构一个JSON对象必须位于每个JSON:API请求和响应数据的根级。此对象定义文档的 “顶层”。 文件必须至少包含下列其中一名顶层成员: data: 文档的主要数据 errors: 错误对象数组 meta: 包含非标准元信息的元对象 成员data和errors 一定不能在同一文档中共存 文档可以包含以下任何顶层成员： jsonapi：描述服务器实现的对象 links：与主数据相关的链接对象。 included：与主数据和/或彼此相关的资源对象数组（包含的资源) 如果文件不包含顶层data成员，included成员 必须不存 顶层links对象 可以包含以下成员： self: 生成当前响应文档的链接 related: 主数据表示资源关系时的相关资源链接 主要数据的分页链接 文档的主要数据表示请求所针对的资源或资源集合。 主要数据必须是： 对于以单个资源为目标的请求: 单个资源对象，单个资源标识符对象，或者null 用于定位资源集合的请求: 资源对象数组，资源标识符对象数组，或一个空数组（[]) 例如，以下主要数据是单个资源对象： 123456789101112&#123; \"data\": &#123; \"type\": \"articles\", \"id\": \"1\", \"attributes\": &#123; // ... this article's attributes &#125;, \"relationships\": &#123; // ... this article's relationships &#125; &#125;&#125; 例如，以下主要数据是引用相同资源的单个资源标识符对象： 123456&#123; \"data\": &#123; \"type\": \"articles\", \"id\": \"1\" &#125;&#125; 资源的逻辑集合必须表示为数组，即使它只包含一个空数组。 资源对象资源对象出现在JSON:API文档中以表示资源。 资源对象必须至少包含以下顶级成员： id type 例外：id当资源对象在客户端发起并表示要在服务器上创建的新资源时，不需要该成员。 此外，资源对象可以包含以下任何顶级成员： attributes: 表示某些资源数据的属性对象。 relationships: 描述资源与其他JSON:API资源之间关系的关系对象。 links: 包含与资源相关的链接的链接对象。 meta: 包含有关无法表示为属性或关系的资源的非标准元信息的元对象。 以下是文章（即“文章”类型的资源）可能出现在文档中的方式： 123456789101112131415161718// ...&#123; \"type\": \"articles\", \"id\": \"1\", \"attributes\": &#123; \"title\": \"Rails is Omakase\" &#125;, \"relationships\": &#123; \"author\": &#123; \"links\": &#123; \"self\": \"/articles/1/relationships/author\", \"related\": \"/articles/1/author\" &#125;, \"data\": &#123; \"type\": \"people\", \"id\": \"9\" &#125; &#125; &#125;&#125;// ... 识别(Identification)每个资源对象 必须包含一个id成员和一个type成员。id和type成员的值必须是字符串。 在给定的API中，每个资源对象type和id对必须 识别单个唯一资源。（由服务器控制的URI集合，或作为一个服务器的多个服务器构成的API） 该type成员用于描述共享公共属性和关系的资源对象 type成员的值必须遵守与成员名称相同的约束 字段资源对象的attributes(属性)和它的relationships(关系)中的域被统称为它的 字段。 资源对象的 字段必须彼此共享一个 共同的命名空间，并不能使用type和id。换句话说，资源不能具有相同名称的属性和关系，也不能具有名称是type和id的属性或关系。 举例, 以下包括错误❌的字段: 1234567891011121314// ...&#123; \"type\": \"articles\", \"id\": \"1\", \"attributes\": &#123; \"type\": \"literature\", \"title\": \"Rails is Omakase\" &#125;, \"relationships\": &#123; \"title\": &#123; &#125; &#125;&#125;// ... 属性中type字段, 错误命名成了type 属性和关系中都有了title字段 属性attributes键的值必须是一个对象（属性对象）。属性对象（attributes）的成员表示有关其定义的资源对象的信息。 属性可以包含任何有效的JSON值。 允许涉及JSON对象和数组的复杂数据结构作为属性值。然而，构成或包含在一个属性的任何对象必须不包含relationships或links字段，因为这些字段由本说明书中以供将来使用保留。 虽然有一个外键（例如author_id）通常存储在内部以及要在资源对象中表示的其他信息，但这些键不应该作为属性出现。 关系relationships键的值必须是一个对象（关系对象）。关系对象（relationships）的成员表示从其定义到其他资源对象的资源对象的引用。 关系可能是一对一或多对。 关系对象 必须至少包含以下其中一项： links：包含以下至少一项的链接对象： self：关系本身的链接（“关系链接”)此链接允许客户端直接操纵关系。例如，删除author通过article关系URL将断开该人与article不删除people资源本身的关系。成功获取后，此链接将 相关资源的链接作为其主要数据返回。 related：相关的资源链接 data：资源联动 meta：包含有关关系的非标准元信息的元对象。 表示多对多关系的关系对象也可以在成员下包含 分页链接links，如下所述。关系对象中的任何 分页链接必须对关系数据进行分页，而不是相关资源。 相关资源链接相关资源链接可以访问资源对象 链接 的关系。获取时，相关资源对象将作为响应的主数据返回。 例如，article的comments 关系可以指定一个链接返回评论的集合资源对象 通过检索时GET请求。 如果存在，相关资源链接必须引用有效的URL，即使该关系当前未与任何目标资源相关联。此外，相关资源链接不得更改，因为其关系的内容会发生变化。 资源链接复合文档中的资源链接允许客户端将所有包含的资源对象链接在一起，而无需GET通过链接访问任何URL 。 资源链接必须表示为以下之一： null 为了空对一的关系。 空数组（[]）用于空对多关系。 非空 对一关系的单个资源标识符对象。 非空 对多关系的资源标识符对象数组。 例如，以下文章与以下内容相关联author： 123456789101112131415161718192021// ...&#123; \"type\": \"articles\", \"id\": \"1\", \"attributes\": &#123; \"title\": \"Rails is Omakase\" &#125;, \"relationships\": &#123; \"author\": &#123; \"links\": &#123; \"self\": \"http://example.com/articles/1/relationships/author\", \"related\": \"http://example.com/articles/1/author\" &#125;, \"data\": &#123; \"type\": \"people\", \"id\": \"9\" &#125; &#125; &#125;, \"links\": &#123; \"self\": \"http://example.com/articles/1\" &#125;&#125;// ... 该author关系包括关系本身的链接（允许客户端直接更改相关作者），用于获取资源对象的相关资源链接以及链接信息。 资源链接links每个资源对象中的可选成员包含 与资源相关的链接。 如果存在，则此链接对象可以包含标识资源对象所表示的资源的self 链接。 123456789101112// ...&#123; \"type\": \"articles\", \"id\": \"1\", \"attributes\": &#123; \"title\": \"Rails is Omakase\" &#125;, \"links\": &#123; \"self\": \"http://example.com/articles/1\" &#125;&#125;// ... 服务器必须GET使用包含资源作为主数据的响应来响应对指定URL 的请求。 资源标识符对象“资源标识符对象”是标识单个资源的对象。 “资源标识符对象” 必须包含type和id成员。 “资源标识符对象” 可能还包括一个meta构件，它的值是一个元包含非标准元信息对象。 复合文件为了减少HTTP请求的数量，服务器可以允许包含相关资源和所请求的主要资源的响应。这种反应被称为“复合文件”。 在复合文档中，所有包含的资源必须包含在顶级成员中的资源对象数组included中。 复合文档需要“完全链接”，这意味着每个包含的资源必须由 同一文档中的至少一个资源标识符对象标识。这些资源标识符对象可以是主数据，也可以表示主要或包含的资源中包含的资源链接。 完全链接要求的唯一例外是当通过稀疏字段集排除否则将包含链接数据的关系字段时。 注意：完全链接可确保包含的资源与主数据（可以是资源对象或资源标识符对象）相关，也可以相互关联。 包含多个包含关系的完整示例文档： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; \"data\": [&#123; \"type\": \"articles\", \"id\": \"1\", \"attributes\": &#123; \"title\": \"JSON:API paints my bikeshed!\" &#125;, \"links\": &#123; \"self\": \"http://example.com/articles/1\" &#125;, \"relationships\": &#123; \"author\": &#123; \"links\": &#123; \"self\": \"http://example.com/articles/1/relationships/author\", \"related\": \"http://example.com/articles/1/author\" &#125;, \"data\": &#123; \"type\": \"people\", \"id\": \"9\" &#125; &#125;, \"comments\": &#123; \"links\": &#123; \"self\": \"http://example.com/articles/1/relationships/comments\", \"related\": \"http://example.com/articles/1/comments\" &#125;, \"data\": [ &#123; \"type\": \"comments\", \"id\": \"5\" &#125;, &#123; \"type\": \"comments\", \"id\": \"12\" &#125; ] &#125; &#125; &#125;], \"included\": [&#123; \"type\": \"people\", \"id\": \"9\", \"attributes\": &#123; \"first-name\": \"Dan\", \"last-name\": \"Gebhardt\", \"twitter\": \"dgeb\" &#125;, \"links\": &#123; \"self\": \"http://example.com/people/9\" &#125; &#125;, &#123; \"type\": \"comments\", \"id\": \"5\", \"attributes\": &#123; \"body\": \"First!\" &#125;, \"relationships\": &#123; \"author\": &#123; \"data\": &#123; \"type\": \"people\", \"id\": \"2\" &#125; &#125; &#125;, \"links\": &#123; \"self\": \"http://example.com/comments/5\" &#125; &#125;, &#123; \"type\": \"comments\", \"id\": \"12\", \"attributes\": &#123; \"body\": \"I like XML better\" &#125;, \"relationships\": &#123; \"author\": &#123; \"data\": &#123; \"type\": \"people\", \"id\": \"9\" &#125; &#125; &#125;, \"links\": &#123; \"self\": \"http://example.com/comments/12\" &#125; &#125;]&#125;","categories":[{"name":"JSON API","slug":"JSON-API","permalink":"https://jigangduan.github.io/categories/JSON-API/"},{"name":"规范","slug":"JSON-API/规范","permalink":"https://jigangduan.github.io/categories/JSON-API/规范/"}],"tags":[{"name":"api","slug":"api","permalink":"https://jigangduan.github.io/tags/api/"}]},{"title":"点餐系统","slug":"点餐系统","date":"2019-01-02T04:34:26.000Z","updated":"2020-07-25T02:57:18.236Z","comments":true,"path":"2019/01/02/点餐系统/","link":"","permalink":"https://jigangduan.github.io/2019/01/02/点餐系统/","excerpt":"","text":"介绍基础介绍 买家（微信） 微信点餐 微信支付 微信通知（模版消息） 卖家（PC）管理系统 扫描登录 订单 商品 类目 技术要点前后端分离 —— RestFul 前端Vue —— WebApp 后端Spring Boot —— Bootstrap+Freemarker+JQuery Spring Boot —— 数据库 —— JPA —— MyBatis Spring Boot —— 缓存 —— Redis —— 分布式Session + 分布式锁 Spring Boot —— 消息推送 —— WebSocket 微信技术 微信扫描登录 模版消息推送 微信支付和退款 项目设计角色划分 买家 商品列表 订单创建 订单查询 订单取消 … 卖家 订单管理 商品管理 类目管理 功能模块划分商品 买家 商品列表 卖家 商品管理 订单 买家 订单创建 订单查询 订单取消 … 卖家 订单管理 类目 卖家 类目管理 关系 买家 ——查询——&gt; 商品 卖家 ——管理——&gt; 商品 买家 ——创建/查询——&gt; 订单 买家 ——查询/接收——&gt; 订单 买家 &lt;——消息——&gt; 卖家 部署架构微信 &amp; PC浏览器 ——&gt; NGINX ——&gt; Tomcat ——&gt; Redis &amp; MySQL 数据库设计表关系类目表(product_category) ——&gt; 商品表(product_info) ——&gt; 订单详情表(order_detail) n——&gt;1 订单主表(order_master) 卖家信息表(seller_info) 表结构商品表(product_info) 名称 单价 库存 描述 图片 目录编号 12345678910111213CREATE TABLE IF NOT EXISTS `product_info` ( `product_id` VARCHAR(32) NOT NULL, `product_name` VARCHAR(64) NOT NULL COMMENT '商品名称', `product_price` DECIMAL(8, 2) NOT NULL COMMENT '单价', `product_stock` INT NOT NULL COMMENT '库存', `product_description` VARCHAR(64) COMMENT '描述', `product_icon` VARCHAR(512) COMMENT '小图片', `product_status` TINYINT(3) NOT NULL DEFAULT '0' COMMENT '商品状态: 0-默认未上架', `category_type` INT NOT NULL COMMENT '目录编号', `creat_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`product_id`)) COMMENT '商品表'; 类目表(product_category) 名称 编号 123456789CREATE TABLE IF NOT EXISTS `product_category` ( `category_id` INT NOT NULL auto_increment, `category_name` VARCHAR ( 64 ) NOT NULL COMMENT '类目名称', `category_type` INT NOT NULL COMMENT '编号', `creat_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY ( `category_id` ), UNIQUE KEY `uqe_category_type` ( `category_type` ) ) COMMENT '类目表'; 订单表 买家名称 买家电话 买家地址 买家微信id 总金额 订单状态 支付状态 1234567891011121314CREATE TABLE IF NOT EXISTS `order_master` ( `order_id` VARCHAR ( 32 ) NOT NULL, `buyer_name` VARCHAR ( 32 ) NOT NULL COMMENT '买家名称', `buyer_phone` VARCHAR ( 32 ) NOT NULL COMMENT '买家电话', `buyer_address` VARCHAR ( 32 ) NOT NULL COMMENT '买家地址', `buyer_openid` VARCHAR ( 32 ) NOT NULL COMMENT '买家微信id', `order_amount` DECIMAL ( 8, 2 ) NOT NULL COMMENT '总金额', `order_status` TINYINT ( 3 ) NOT NULL DEFAULT '0' COMMENT '订单状态： 0-默认新下单', `pay_status` TINYINT ( 3 ) NOT NULL DEFAULT '0' COMMENT '支付状态： 0-默认未支付', `creat_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY ( `order_id` ), KEY `idx_buyer_openid` ( `buyer_openid` ) ) COMMENT '订单表'; 订单id 商品id 商品名字 商品价格 商品数量 商品照片 12345678910111213CREATE TABLE IF NOT EXISTS `order_detail` ( `detail_id` VARCHAR ( 32 ) NOT NULL, `order_id` VARCHAR ( 32 ) NOT NULL, `product_id` VARCHAR ( 32 ) NOT NULL, `product_name` VARCHAR ( 64 ) NOT NULL COMMENT '商品名称', `product_price` DECIMAL ( 8, 2 ) NOT NULL COMMENT '商品单价', `product_quantity` INT NOT NULL COMMENT '商品数量', `product_icon` VARCHAR ( 512 ) COMMENT '商品图片', `creat_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY ( `detail_id` ), KEY `idx_order_id` ( `order_id` )) COMMENT '订单详情表'; 开发环境 JDK Maven Ide 日志使用日志框架什么是日志框架？ 是一套能实现日志输出的工具包 能够描述系统运行状态的所有时间都可以算作日志 用户下线 接口超时 数据库崩溃 … 能力： 定制输出日志 定制输出格式 携带上下文信息 运行时选择性输出 灵活的配置 优异的性能 常见日志框架： 日志门面 JUL JCL SLF4j jboss-logging 日志实现 Log4j Log4j2 Logback 使用： 1234567891011121314151617181920212223242526272829@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class LoggerTests &#123; private final Logger logger = LoggerFactory.getLogger(LoggerTests.class); /** * 传统方式实现日志 */ @Test public void test1() &#123; logger.debug(\"debug ...\"); logger.info(\"info ...\"); logger.error(\"error ...\"); &#125; /** * Slf4j注解方式实现日志 */ @Test public void test2() &#123; String name = \"sell\"; String password = \"***\"; log.debug(\"debug ...\"); log.info(\"info ... name: &#123;&#125;, password: &#123;&#125;\", name, password); log.error(\"error ...\"); &#125;&#125; Logback的配置 application.yml logback-spring.xml 需求： 区分info和error日志 每天产生一个日志文件 logback-spring.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;appender name=\"consoleLog\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt; %date %level [%thread] %logger&#123;10&#125; [%file:%line] ------ %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=\"fileInfoLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %d - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt;/Users/jigang.duan/logs/tomcat/sell/info.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=\"fileErrorLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %d - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt;/Users/username/logs/tomcat/sell/error.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"consoleLog\" /&gt; &lt;appender-ref ref=\"fileInfoLog\" /&gt; &lt;appender-ref ref=\"fileErrorLog\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 买家类目DAD引入JPA依赖123456789 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 数据库配置12345678spring: datasource: driver-class-name: com.mysql.jdbc.Driver username: root password: root url: jdbc:mysql://localhost:8889/seil?characterEncoding=utf-8&amp;useSSL=false jpa: show-sql: true Entity12345678910111213141516171819202122232425262728@Entity@DynamicUpdate@Datapublic class ProductCategory &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"category_id\") private Integer id; @Column(name = \"category_name\") private String name; @Column(name = \"category_type\") private Integer type; private Date creatAt; private Date updateAt; public ProductCategory(String name, Integer type) &#123; this.name = name; this.type = type; &#125; public ProductCategory() &#123; &#125;&#125; Repository1234public interface ProductCategoryRepository extends JpaRepository&lt;ProductCategory, Integer&gt; &#123; List&lt;ProductCategory&gt; findByTypeIn(List&lt;Integer&gt; typeList);&#125; 测试： 1234567891011121314151617181920212223242526272829303132@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class ProductCategoryRepositoryTest &#123; @Autowired private ProductCategoryRepository repository; @Test public void findOneTest() &#123; Optional&lt;ProductCategory&gt; category = repository.findById(1); String desc = category.map(ProductCategory::toString).orElse(\"No value found\"); log.info(desc); &#125; @Test @Transactional public void saveTest() &#123; ProductCategory category = new ProductCategory(\"测试类目\", 1); ProductCategory result = repository.save(category); Assert.assertNotNull(result); &#125; @Test public void findByTypeInTest() &#123; List&lt;Integer&gt; list = Arrays.asList(0, 1, 2); List&lt;ProductCategory&gt; result = repository.findByTypeIn(list); log.info(result.toString()); Assert.assertNotEquals(0, result.size()); &#125;&#125; Service服务接口 12345678910public interface CategoryService &#123; Optional&lt;ProductCategory&gt; findById(Integer id); List&lt;ProductCategory&gt; findAll(); List&lt;ProductCategory&gt; findByTypeIn(List&lt;Integer&gt; typeList); ProductCategory save(ProductCategory category);&#125; 服务实现 1234567891011121314151617181920212223242526@Servicepublic class CategoryServiceImpl implements CategoryService &#123; @Autowired private ProductCategoryRepository repository; @Override public Optional&lt;ProductCategory&gt; findById(Integer id) &#123; return repository.findById(id); &#125; @Override public List&lt;ProductCategory&gt; findAll() &#123; return repository.findAll(); &#125; @Override public List&lt;ProductCategory&gt; findByTypeIn(List&lt;Integer&gt; typeList) &#123; return repository.findByTypeIn(typeList); &#125; @Override public ProductCategory save(ProductCategory category) &#123; return repository.save(category); &#125;&#125; 测试： 12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class CategoryServiceImplTest &#123; @Autowired private CategoryServiceImpl categoryService; @Test public void findById() &#123; String result = categoryService.findById(1).map(ProductCategory::toString).orElse(\"No value found\"); Assert.assertNotEquals(result, \"No value found\"); &#125; @Test @Transactional public void test() &#123; ProductCategory category = new ProductCategory(\"测试数据\", 0); ProductCategory save = categoryService.save(category); Assert.assertNotNull(save); List&lt;ProductCategory&gt; all = categoryService.findAll(); Assert.assertNotEquals(0, all.size()); List&lt;ProductCategory&gt; byTypeIn = categoryService.findByTypeIn(Collections.singletonList(0)); Assert.assertEquals(1, byTypeIn.size()); &#125;&#125; 买家商品微信特性微信授权获取OpenID 收到方式 第三方SDK方式 微信微信支付微信退款","categories":[{"name":"实例","slug":"实例","permalink":"https://jigangduan.github.io/categories/实例/"}],"tags":[{"name":"实例","slug":"实例","permalink":"https://jigangduan.github.io/tags/实例/"}]},{"title":"Web开发者应该掌握的CSS","slug":"You-need-to-know-css","date":"2018-12-23T15:30:04.000Z","updated":"2020-07-25T02:57:18.172Z","comments":true,"path":"2018/12/23/You-need-to-know-css/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/You-need-to-know-css/","excerpt":"","text":"原作者发布地址: github 在线查看🌏 你需要了解css 快速开始一些可以帮助你快速启动本项目的操作： clone 这个仓库: https://github.com/l-hammer/You-need-to-know-css.git 用yarn 或者 npm全局安装 docsify-cli: npm install docsify-cli -g (or yarn global add docsify-cli) 在终端运行命令 docsify serve 打开 http://localhost:3000 在你的浏览器 包括什么 贡献 :fork_and_knife:Fork 这个项目并clone到本地 :twisted_rightwards_arrows:新建一个分支: git checkout -b new-branch :wrench:增加新特性或者解决一些bug :memo:提交你的改变: git commit -am &#39;Add some feature&#39; :rocket:推送你的分支: git push origin new-branch :tada:提交Pull Request 或者提交一个issue - 欢迎任何有帮助性的建议:stuck_out_tongue_winking_eye:","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"GitHub精选","slug":"前端/GitHub精选","permalink":"https://jigangduan.github.io/categories/前端/GitHub精选/"}],"tags":[{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"}]},{"title":"前端技术清单","slug":"frontend-tech-list","date":"2018-12-23T14:37:09.000Z","updated":"2020-07-25T02:57:18.202Z","comments":true,"path":"2018/12/23/frontend-tech-list/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/frontend-tech-list/","excerpt":"","text":"原作者发布地址: github 有同学反馈说清单内容较多，一次无法读完，过了一段时间回来就记不清阅读进度了。为了便于大家分次阅读，我制作了一个页面，在每篇文章前加上选择框（选中checkbox表示已读）用于记录你已经读过的文章，便于下次回来时继续阅读。页面链接：Frontend Tech List 前端技术清单学习文章的知识往往是碎片化的。而前端涉及到的面很广，这些知识如果不进行有效梳理，则无法相互串联、形成体系。因此，我结合工作体会将抽象出了一些前端基础能力，并将看过、写过的一些不错的文章进行整理，形成了一份（纯）前端技术清单。 不论你是正在自学前端，还是对前端某些技术熟练掌握但某些还未涉足，我都希望这份清单能帮助你 review 一些前端的基础能力。 前端技术清单 0. 年度报告 1. 基础拾遗 1.1. JavaScript 1.2. CSS 1.3. 浏览器 2. 工程化与工具 2.1. webpack 2.2. Gulp 2.3. Linter 2.4. 静态类型（Typescript/Flow） 2.5. Babel 2.6. CSS预处理与模块化 3. 性能优化 3.1. 加载性能 3.2. 运行时性能 3.3. 前端缓存 3.4. 性能调试与实践 3.5. 性能指标 4. 安全 4.1. XSS 4.2. CSRF 4.3. CSP 4.4. HTTPS 4.5. 安全实录 5. 自动化测试 5.1. 单元测试 5.2. 端到端测试 (E2E) 5.3. 其他 6. 框架与类库 6.1. React 6.2. Vue 6.3. Redux 6.4. RxJS 7. 新技术/方向 7.1. PWA 7.2. CSS Houdini 7.3. Web Components 7.4. 微前端（Micro Frontends） 7.5. HTTP/2 7.6. WebAssembly 8. 业务相关 8.1. 数据打点上报 8.2. 前端监控 8.3. A/B测试 8.4. “服务端推” 8.5. 动效 9. 不归类的好文 0. 年度报告 2018 前端工具调查报告 2018 JavaScript 调查报告 1. 基础拾遗 温故而知新，不知则习之，是以牢固根基。 1.1. JavaScript You-Dont-Know-JS [英] JavaScript 基础运行机制： JS 引擎、运行时与调用栈概述 [英] V8 引擎简介 [英] 内存管理与4中常见的泄漏 [英] Event Loop（面试里总会有一题 Event Loop…）： 从 Event Loop 规范探究 JavaScript 异步及浏览器更新渲染时机 异步之 Event Loop [英] NodeJS 中的 Event Loop、Timers 与 process.nextTick() [英] Tasks、Microtasks、Queues 与Schedules [英] Web Workers 及其5个常见使用场景 [英] 如何避免 async/await 地狱 [英] “回调地狱”的解决思路汇总 1.2. CSS You-Need-to-Know-CSS CSS布局指南 CSS 中的各类换行处理方式 [英]：处理经典的换行问题 浏览器将rem转成px时有精度误差怎么办？ 精准操控的滚动体验，浅谈新标准 Scroll Snap 如何完美实现一个非button元素的按钮 [英] 巧用 CSS Grid 来创建横向滚动容器 [英] 如何处理内联元素中的空隙 [英] CSS Stacking Context 里那些鲜为人知的坑 在 (S)CSS 中实现主题功能的 4½ 种方法 1.3. 浏览器 浏览器的工作原理 现代浏览器内部是如何运行的： Chrome浏览器概览 浏览时发生了什么？ 渲染进程的内部工作原理 compositor是如何来提高交互性能的？ 完整的页面生命周期 API 介绍 [英] 四个新的观察者：Intersection / Mutation / Resize / Performance (Observer) 渲染引擎工作方式及优化建议 [英] 浏览器内核渲染：重建引擎 跨域解决方案汇总 2. 工程化与工具 软件规模的扩大带来了工程化的需求，前端也不例外。随着 NodeJS 的出现，前端工程师可以使用熟悉的 JS 快速开发所需的工具。工具链生态的繁荣也是前端圈繁荣的一个写照。 2.1. webpack webpack 中的 Chunk 关系图算法 [英] webpack 进阶系列文章 编译优化： 如何提升大型项目中 webpack 的性能 🎥 [英] 运行时优化：Separating a Manifest [英] 在 webpack 中使用 \\&lt;link rel=”prefetch/preload”&gt; [英] 如何更好使用 webpack tree-shaking 关于 webpack 编译缓存的讨论： mzgoddard’s comment [spec: webpack 5] - A module disk cache between build processes 2.2. Gulp Gulp 4 简介 [英] 基于Gulp的多页面应用实践指南 2.3. Linter JS Linter 进化史 为何要在项目汇总使用 ESLint [英] 2.4. 静态类型（Typescript/Flow） Typescript 总体架构 [英] 为什么要在 JavaScript 中进行静态类型检查： 第一部分 第二、三部分 第四部分 2.5. Babel Babel 用户手册 Babel 插件手册 2.6. CSS预处理与模块化 CSS 进化史 [英] CSS 模块化方案系列 3. 性能优化 性能优化其实就是在理解浏览器的基础上“因地制宜”，因此可以配合1.3节“浏览器”部分进行理解。 强烈推荐把 Google Web 上性能优化 Tab 中的文章都通读一遍，其基本涵盖了现代浏览器中性能优化的所有点，非常系统。下面也摘录了其中一些个人认为非常不错的篇幅。 3.1. 加载性能 PRPL 模式 [英] 图片懒加载完全指南 [英] 使用 Intersection Observer 来懒加载图片 [英] 图片与视频懒加载的详细指南 [英] 使用 Application Shell 架构来实现秒开应用 [英] 3.2. 运行时性能 避免大型、复杂的布局和布局抖动 [英] 什么导致强制同步布局（reflow）？ [英] 如何诊断强制同步布局 [英] 无线性能优化：Composite 如何不择手段提升scroll事件的性能 使用 passive event listener 来提高滚动流畅性 [英] 节流和去抖（throttle &amp; debounce）： JavaScript 函数节流和函数去抖应用场景辨析 underscore 函数去抖的实现 requestIdleCallback - 一个强大而神器的 API： requestIdleCallback使用入门 [英] Idle Until Urgent [英]：requestIdleCallback的妙用 3.3. 前端缓存 Web 缓存简介：以购买牛奶的为例 [英] 大话前端缓存 [英] 缓存（一）—— 缓存总览：从性能优化的角度看缓存 缓存（二）—— 浏览器缓存机制：强缓存、协商缓存 缓存（三）—— 数据存储：cookie、Storage、indexedDB 3.4. 性能调试与实践 使用 Chrome DevTools 提升页面速度 [英]：Chrome DevTools实操讲解 了解 DevTools 中的 Resource Timing 淘宝新势力周H5性能优化实战 优化打包策略来提升页面加载速度 Chrome DevTools 中你可能不知道的调试技巧 前端性能测量 [英] 3.5. 性能指标 以用户为中心的前端性能指标 [英]：前端性能指标的来龙去脉 DOMContentLoaded: 你不知道的 DOMContentLoaded Deciphering the Critical Rendering Path [英] FP (First Paint)： Chrome的First Paint FCP (First Contentful Paint)： First Contentful Paint Explained [英] First Contentful Paint [英] FMP (First Meaningful Paint)： Chrome 中的 First Meaningful Paint Time to First Meaningful Paint TTI (Time to interactive)： Time to Interactive Explainer 衡量用户体验的新标准 TTFB (Time To First Byte)： TTFB，以及页面加载的时间节点 FID (First Input Delay)： First Input Delay Speed Index： WebPagetest: Speed Index 4. 安全 很多安全风险老生常谈，但是往往到出现问题时，才会被重视或者意识到。 8大前端安全问题上篇 8大前端安全问题下篇 概念讲解：编码、加密、哈希与混淆 [英] 常见 Web 安全攻防总结 4.1. XSS 如何防止XSS攻击？ 4.2. CSRF 如何防止CSRF攻击？ Site Isolation [英]：Chrome的新特性 4.3. CSP Content Security Policy 入门教程 Content Security Policy (CSP) [英] 4.4. HTTPS 图文还原 HTTPS 原理 浅谈有赞全站 HTTPS 推进 4.5. 安全实录 About rel=noopener [英]：打开一个新页面是如何带来安全隐患的 一种新型的“钓鱼”方式 [英] 一个媒体文件请求引发的跨站风险 [英] Mitigating Spectre [英]： Chrome 中的跨站安全问题 5. 自动化测试 自动化测试是软件工程的重要部分之一，但却极容易被忽视。 2018 前端自动化测试综述 [英] 测试你的前端代码（介绍篇）[英] 5.1. 单元测试 测试你的前端代码（单元测试篇）[英] Fakes、Mocks 以及 Stubs 概念明晰 测试覆盖（率）到底有什么用？ 5.2. 端到端测试 (E2E) 测试你的前端代码（E2E 测试篇）[英] 什么是一个好的 E2E 测试？[英] 平衡单元测试和端到端测试 对过多的 E2E 测试说“不” [英] 5.3. 其他 测试你的前端代码（集成测试篇）[英] 测试你的前端代码（可视化测试篇）[英] 6. 框架与类库 如果说基础知识是道，那框架与工具可能就是术；学习与理解它们，但千万不要成为它们的奴隶。 6.1. React React 底层揭秘 [英] 你所需要知道的 React 细节 React Fiber 架构 React 16 Fiber 源码速览 React 是怎样炼成的：React早期的进化之路 从零开始实现一个React： 1. JSX和虚拟DOM 2. 组件和生命周期 3. diff算法 4. 异步的setState 「react技术栈」单页应用实践快速入门 React 生命周期图示 6.2. Vue 深入浅出 - vue变化侦测原理 Vue 模板编译原理 6.3. Redux 重新设计 Redux [英]：Rematch 如何用 GraphQL 来替代 Redux [英] 解读 Redux 的设计思路与用法 (Redux)应用构建的三个原则 [英] 6.4. RxJS ReactiveX 官网：宝石图真的非常形象易读 响应式编程，是明智的选择 图解RxJS [英] 调试RxJS：Tooling [英] 调试RxJS：Logging [英] 7. 新技术/方向 前端领域新技术、新方向层出不穷，这里汇总一些新技术方向；作为开发者需要多了解但是不要盲从 7.1. PWA PWA 学习与实践系列 Service Worker 入门简介 [英] PWA 在 iOS 平台上的特殊问题 [英] 在你的 PWA 中小心使用 iOS 的 meta 标签 [英] 饿了么的 PWA 升级实践 离线指南 Android 中的 WebAPKs [英] Pinterest 的 PWA 实践 [英] 异步 HTTP Cookies API [英]：赋能Service Worker 7.2. CSS Houdini 认识 Houdini 与 CSS Paint API [英] 用 Houdini 来拯救 CSS Polyfill [英] 7.3. Web Components Web Components 基本概念和用法 Web Components 指南 [英] Shadow DOM 使用简介 HTMLUnknownElement 与 HTML5 自定义元素的故事 7.4. 微前端（Micro Frontends） 微前端主页 [英] 微前端的那些事儿 技术雷达之「微前端」- 将微服务理念扩展到前端开发 7.5. HTTP/2 HTTP/2 幕后原理 全面介绍的 HTTP/2 [英] HTTP/2 主页: HTTP/2 协议 [英] HPACK: HTTP/2 Header压缩 [英] 7.6. WebAssembly WebAssembly 官网 WebAssembly 现状与实战 WebAssembly 系列： 一、生动形象地介绍 WebAssembly 二、JavaScript Just-in-time (JIT) 工作原理 三、编译器如何生成汇编 四、WebAssembly 工作原理 五、为什么 WebAssembly 更快？ 六、WebAssembly 的现在与未来 8. 业务相关 在业务中往往还有一些与“业务无关”的场景需求 —— 不论是什么业务几乎都会遇到；因此，在变与不变中，我们更需要去抽象出这些问题。 8.1. 数据打点上报 如何精确统计页面停留时长 揭开JS无埋点技术的神秘面纱 8.2. 前端监控 前端异常监控解决方案研究 监控平台前端SDK开发实践 把前端监控做到极致 前端监控系统探索总结 8.3. A/B测试 Twitter的A/B测试实践： 一、为什么要测试以及测试的意义 二、技术概述 三、检测和避免 A/B Test中 bucket不平衡问题 四、A/B Test中使用多个控制的启示 Netflix A/B Test 实验平台实践 [英] 指导方法 实验中容易遇到的七种问题 [英] 实验的七个准则 [英] 小流量如何进行AB测试 案例分享 大众点评AB测试框架Gemini 新浪新闻客户端AB测试与灰度发布 天猫App A/B测试实践 工具 AB测试样本数量计算器 AB测试结果有效性分析工具 8.4. “服务端推” 各类“服务器推”技术原理与实例 长连接/websocket/SSE等主流服务器推送技术比较 Comet：基于 HTTP 长连接的“服务器推”技术 深入 WebSockets、HTTP/2 SSE [英] WebSocket 应用安全问题分析 8.5. 动效 动画设计的12个原则🎥 [英] 贝塞尔曲线扫盲 动画：从 AE 到 Web 最全最好用的动效落地方法： 基础知识 落地方式 9. 不归类的好文 开卷有益。 Recursion? We don’t need no stinking recursion!：如何将一些递归改为循环（尾递归优化） Turning your web traffic into a Super Computer：通过 Web Worker 和 WebSocket 来将全世界的电脑连接成超级计算机 Designing very large (JavaScript) applications：高屋建瓴，适合阅读与思考","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"GitHub精选","slug":"前端/GitHub精选","permalink":"https://jigangduan.github.io/categories/前端/GitHub精选/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"github","slug":"github","permalink":"https://jigangduan.github.io/tags/github/"}]},{"title":"Android 向日葵","slug":"android-sunflower","date":"2018-12-23T13:22:33.000Z","updated":"2020-07-25T02:57:18.172Z","comments":true,"path":"2018/12/23/android-sunflower/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/android-sunflower/","excerpt":"","text":"一个园艺应用程序说明Android开发最佳实践与Android Jetpack. Android 向日葵 (alpha)Android向日葵目前是作为一个alpha版本发布的，正在进行大量的开发。要查看最新的更改，请访问版本页面.请注意，一些更改(如数据库模式修改)在此alpha期间不向后兼容，可能会导致应用程序崩溃。在这种情况下，请卸载并重新安装应用程序. 介绍Android Jetpack是一套组件、工具和指南，用来制作优秀的Android应用程序。它们将现有的支持库和体系结构组件组合在一起，并将它们分为四类: Android向日葵演示了如何使用这些组件创建一个简单的园艺应用程序。阅读Android向日葵的介绍文章，了解一下这款应用程序。 开始这个项目使用层级构建系统。要构建此项目，请使用gradlew build命令或在Android Studio中使用Import project 测试项目有两个等级的任务:: connectedAndroidTest - 用于在连接设备上运行Espresso test - 用于运行单元测试 有关学习Android开发的更多资源，请访问developer.android.com的开发者指南。 截图 库的使用 Foundation - 核心系统功能的组件，Kotlin扩展和对multidex和自动化测试的支持. AppCompat - 在旧版本的Android上可以优雅地降级. Android KTX - 编写更简洁、更符合习惯的Kotlin代码. Test - 一个用于单元和运行时UI测试的Android测试框架. 体系结构 - 一组库，帮助您设计健壮、可测试和可维护的应用程序。从管理UI组件生命周期和处理数据持久性的类开始. Data Binding - 声明式地将可观察数据绑定到UI元素. Lifecycles - 创建一个自动响应生命周期事件的UI. LiveData - 构建在底层数据库更改时通知视图的数据对象. Navigation - 处理应用程序内导航所需的一切. Room - 使用应用程序内对象和编译时检查访问应用程序的SQLite数据库. ViewModel - 存储应用程序旋转时未销毁的ui相关数据。轻松地为最优执行计划异步任务. WorkManager - 管理你的Android后台作业. UI - 详细说明为什么和如何在你的应用程序中使用UI组件 - 一起或分开 Animations &amp; Transitions - 移动小部件并在屏幕之间转换. Fragment - 可组合UI的基本单元. Layout - 使用不同的算法来布置小部件. 第三方 Glide 加载图片 Kotlin Coroutines 用于以简化的代码管理后台线程并减少对回调的需求 即将到来的新特性随着组件库的发展，更新将包括合并其他Jetpack组件和更新现有组件. 有兴趣看看在这个应用程序中实现的Android框架或Jetpack的一个特定特性吗?请翻开新一期. Android Studio IDE 设置开发需要最新版本的Android Studio 3.2。最新版本可以从这里下载。 向日葵使用ktlint来执行Kotlin编码样式.下面是如何将其配置为与Android Studio一起使用(来自ktlint README的说明): 如果Android Studio是打开的，关闭它 使用这些安装说明下载ktlint 在项目根目录中运行: ./ktlint --apply-to-idea-project --android 启动 Android Studio 额外的资源查看这些Wiki页面，了解更多关于Android向日葵的信息: 著名的社区的贡献 出版物 非目标本项目的重点是Android Jetpack和Android框架。因此，在这个范围之外没有立即实现特性的计划。 关于依赖注入的注意-虽然许多项目(如Plaid)使用Dagger 2作为DI，但没有计划将DI合并进来这使得不熟悉依赖注入的开发人员可以更好地理解向日葵的代码，而不必学习DI. 支持 Google+ 社区: https://plus.google.com/communities/105153134372062985968 Stack Overflow: http://stackoverflow.com/questions/tagged/android http://stackoverflow.com/questions/tagged/android-jetpack 如果您在这个示例中发现错误，请提交一个问题:https://github.com/googlesamples/android-sunflower/issues 我们鼓励使用补丁，可以通过分岔这个项目并通过GitHub提交pull请求来提交补丁. 第三方内容通过CC BY-SA 3.0 US (license in ASSETS_LICENSE)从维基百科中选择用于描述植物的文本(在plants.json中)","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android Jetpack","slug":"Android/Android-Jetpack","permalink":"https://jigangduan.github.io/categories/Android/Android-Jetpack/"},{"name":"GitHub 精选","slug":"Android/Android-Jetpack/GitHub-精选","permalink":"https://jigangduan.github.io/categories/Android/Android-Jetpack/GitHub-精选/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"jetpack","slug":"jetpack","permalink":"https://jigangduan.github.io/tags/jetpack/"}]},{"title":"Kafka并不难学 (3) 基本操作","slug":"kafka-easy-3","date":"2018-12-23T07:42:49.000Z","updated":"2020-07-25T02:57:18.211Z","comments":true,"path":"2018/12/23/kafka-easy-3/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/kafka-easy-3/","excerpt":"","text":"Zookeeper的作用及背景 管理代码中的变量的配置 设置命名服务 提升系统的可用性和安全性 管理Kafka集群 Zookeeper单机模式和分布式模式单机模式 zkServer.sh start zkServer.sh status zkServer.sh stop 分布式模式 Kafka单机模式和分布式模式如何操作主题？创建： 1kafka-topics.sh --create --zookeeper dn1:2181 --replication-factor 1 --partitions 1 --topic test 查看： 1kafka-topics.sh --describe --zookeeper dn1:2181 --topic test 修改： 1kafka-topics.sh --alter --zookeeper dn1:2181 test --config max.message.bytes=102400 删除： 1kafka-topics.sh --delete --zookeeper dn1:2181 test","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"},{"name":"Kafka并不难学","slug":"Kafka/Kafka并不难学","permalink":"https://jigangduan.github.io/categories/Kafka/Kafka并不难学/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"}]},{"title":"Kafka并不难学 (2) 安装和配置Kafka","slug":"kafka-easy-2","date":"2018-12-23T07:01:52.000Z","updated":"2020-07-25T02:57:18.211Z","comments":true,"path":"2018/12/23/kafka-easy-2/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/kafka-easy-2/","excerpt":"","text":"安装JDKJDK Kafka为什么需要JDKKafka的源码是基于Scala语言编写的，运行在Java虚拟机上 配置Linux操作系统免密码登陆Linux免密码SSH - 专为远程登陆会话和其它网络服务提供安全性的协议 Kafka集群在启动的时候，需要保证各个主机之间实现免密码。这样在启动时就可以避免去输入密码，减少了不必要的麻烦 如何配置： 创建密钥 认证授权 文件赋权 在其它主机上创建钥并同步认证文件 Kafka单机模式和分布式模式的安装步骤及注意事项单机模式 Zookeeper以单机模式启动 下载Kafka安装包 解压并配置 分布式模式 Zookeeper以分布式模式启动(Leader-Follower) 下载Kafka安装包 解压并配置 注意事项测试环境，本地调试可以使用单机模式；生产环境建议使用分布式模式。分布式模式部署Kafka，需要二次封装Kafka系统启动&amp;停止脚本 如何编译Kafka源代码？ 安装与配置Scala运行环境，安装与配置Gradle配置工具 若网络状态不好，下载离线依赖包；若网络状态良好，可以在线编译 Kafka元数据信息在Zookeeper是如何分布的？存储的元数据有： 控制器选举次数 代理节点 主题 配置 管理员操作 控制器","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"},{"name":"Kafka并不难学","slug":"Kafka/Kafka并不难学","permalink":"https://jigangduan.github.io/categories/Kafka/Kafka并不难学/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"}]},{"title":"Kafka并不难学 (1) 了解消息队列和Kafka","slug":"kafka-easy-1","date":"2018-12-23T06:40:49.000Z","updated":"2020-07-25T02:57:18.211Z","comments":true,"path":"2018/12/23/kafka-easy-1/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/kafka-easy-1/","excerpt":"","text":"什么事消息队列？如何理解消息队列的概念？ MQ，拥有先进先出(FIFO)的特性 异步通信机制，包含详细的数据说明 作用: 应用解耦 异步处理 数据限流 消息通信 Kafka的基本概念 代理 Broker 生产者 Producer 消费者 Consumer 消费者组 Consumer Group Topic 主题 Partition 分区 Replication 副本 Record 记录 kafka 使用范围设计初衷 高吞吐量 高可用队列 低延时 分布式机制 特性 异步生产数据 偏移量迁移 安全机制 连接器 机架感知 数据流 时间戳 消息语义 场景 日志收集 消息系统 用户轨迹 记录运营监控数据 实现流处理 事件源","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"},{"name":"Kafka并不难学","slug":"Kafka/Kafka并不难学","permalink":"https://jigangduan.github.io/categories/Kafka/Kafka并不难学/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"}]},{"title":"Leaflet(交互式地图JS库)","slug":"leafletjs","date":"2018-12-23T03:43:32.000Z","updated":"2020-07-25T02:57:18.212Z","comments":true,"path":"2018/12/23/leafletjs/","link":"","permalink":"https://jigangduan.github.io/2018/12/23/leafletjs/","excerpt":"","text":"用于移动友好交互式地图的JavaScript库. https://leafletjs.com Leaflet是领先的开源JavaScript库，可用于移动友好的交互式地图。它仅重约37kb的gzipped代码，具有大多数开发人员所需要的所有映射特性。 传单的设计具有简单性、性能和可用性。它可以在所有主要的桌面和移动平台上高效地工作，充分利用HTML5和CSS3在现代浏览器上的优势，同时也可以在旧的浏览器上访问。它可以通过大量插件进行扩展，具有漂亮的、易于使用的、文档丰富的API和简单的、可读的源代码，这是一种乐趣。 更多信息，文档和教程，请访问官方网站。有关Leaflet下载(包括构建的主版本)，请参阅下载页面。","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"GitHub精选","slug":"前端/GitHub精选","permalink":"https://jigangduan.github.io/categories/前端/GitHub精选/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"maps","slug":"maps","permalink":"https://jigangduan.github.io/tags/maps/"}]},{"title":"Spring Boot 2精髓 - (17) 监控 Spring Boot应用","slug":"SpringBoot2-H","date":"2018-12-22T15:22:04.000Z","updated":"2020-07-25T02:57:18.170Z","comments":true,"path":"2018/12/22/SpringBoot2-H/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-H/","excerpt":"","text":"SpringBoot也提供了Actuator功能来的监控, 查看 Spring Boot 应用的配置、各种指标、健康程度等 查看和监控以下信息: Spring Boot 的配置信息 Spring Boot 配置的 Bean 信息 最近请求的 HTTP 信息 数据源，NoSQL 等数据状态 在线查看日志内容，在线日志配置修改 所有@RequestMapping注解的URL路径 自动装配信息汇总 打印虚拟机的线程栈 Dump 内存 应用的各种指标、汇总 自定义监控指标 安装 Acutator依赖: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置: 1234management.server.port=8081management.endpoints.web.exposure.include=*#management.endpoints.web.exposure.exclude=env,beansmanagement.endpoints.web.base-path=/application HTIP 跟踪trace跟踪功能，能查看最近的 HTTP请求和响应 http://localhost:8081/application/trace 日志查看Actuator 允许查看日志配置,还允许修改日志等级配置，Actuator也可以在线查看日志内容 http://localhost:8081/application/loggers 线程核信息可以通过输入dump来获取某一时刻虚拟机线程樵信息，该信息类似使用JDK自带的 jstack命令的输出结果或者 kill -3 的结果。线程械表示某一时刻虚拟机正在做的事情 http://localhost:8081/application/dump 内存信息heapdump 类似JDK提供的jmap工具，能将内存镜像压缩下载以提供分析 http://localhost:8081/application/heapdump 查看URL映射Actuator 的 mappings 输出所有通过注解@RequestMapping 设置的URL映射，可以通过此来查看URL对应的Controller 查看 Spring 容器管理的 BeanActuator 的 beans 输出所有 Spring 管理的 Bean 其它监控 health: 查看所在应用的健康状态，如磁盘、数据源、Redis、Elasticsearch 等。 metrics: 显示 Spring Boot 的性能指标，如己有内存、未占用内存、垃圾回收次数、类信息等。 env: 显示 SpringBoot环境变量，如使用的 JDK版本、加载的 jar包、配置文件信息、日志文件信息。 configprops: 所有@ConfigurationProperties 注解的配置信息，如文件上传的最大允许 配置等。 autoconfig:显示所有自动装配类的报告，以及是什么原因导致自动装配成功或者不成功 编写自己的监控信息health 用于检查 Spring Boot 应用的健康状态，提供了磁盘的健康状态显示，如果应用还使用了数据源、NoSQL等，也会显示相应的健康状态。Spring Boot 使用 Healthlndicator 接口实现监控信息显示，默认有如下类实现 Healthlndicator 接口 metrics 用来查看系统的各项指标，包括主机内存的大小、虚拟机 heap 信息、线程信息、垃圾回收、Tomcat会话信息等。也可以在你的Bean中注入CounterService，调用 increment 方法和 decrement 方法来设置指标值 编写 HealthIndicator编写自己的监控器，只需要继承 Healthlndicator，实现 health 方法，返回一个 Health 对象即可 自定义监控注解@Endpoint来自定义一个监控类，并在方法上使用@ReadOperation来显示监控指标，使用@WriteOperation来动态更改监控指标","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (16) ZooKeeper","slug":"SpringBoot2-G","date":"2018-12-22T14:01:54.000Z","updated":"2020-07-25T02:57:18.170Z","comments":true,"path":"2018/12/22/SpringBoot2-G/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-G/","excerpt":"","text":"SpringBoot水平扩展后，我们还面临一些挑战: 一个时刻，只能有一个应用来处理某个业务，而不能发生同时处理的情况。这就需要提供一个分布式锁，只有获得锁的SpringBoot应用才能执行操作。执行完毕后，释放锁。比如定时调度某个任务执行，同一个时刻只能有一个SpringBoot应用能执行 应用系统之间通过 REST 接口来相互调用，如何让 REST 客户端知道服务在哪里?SpringBoot应用可以水平扩展，不可能通过 application.properties来配置服务器地址 需要在SpringBoot应用中选择一个领导节点，这个领导节点负责协调所有 SpringBoot 应用的工作 ZooKeeperZooKeeper 来源于Apache Hadoop子项目，是一个高性能、分布式的、开源应用协调服务。分布式应用可以基于它实现协调服务，比如同步、集群、领导选取，以及分布式系统的配置管理、命名服务。使用文件系统目录树作为数据模型 ZooKeeper(下面简称 zk)有以下特点: 简单的API和数据结构完成协调服务，zk提供了易于理解的数据结构来完成协调服务，其JavaAPI非常简单。Curator进一步封装了这些API，直接提供了分布式协调服务而不需要关心细节 分布式，不会出现单点故障，一般来说，至少部署3台zk以避免单点故障。客户端(指Spring Boot应用)如果连接的zk宕机，客户端将自动连接到另外一台。 保证操作的时序性，zk对每次更新都有时间戳记录，从而保证操作的时序性，保证可以完成更高层次的协调服务，如分布式锁。 性能测试结果，zk 本身的性能非常好，既可以处理分布式系统的管理协调任务，如选举领导，也能胜任高井发量的业务协调处理，如业务处理的分布式锁。 ZooKeeper 的数据结构zk提供的命名空间(name space)类似文件系统，每一个节点都是通过路径来表示的，不同的是，节点可以包含一定的数据(2MB 字节)，这些节点可以用来存放业务信息，如配置信息等 节点还包含了更新的版本、时间戳。有一种特殊的节点是临时节点，创建节点的会话存在，节点就存在，一旦会话结束，如客户端创建的连接断掉，或者客户端主动关闭此会话，则节点会被删除。还可以指定节点为顺序节点，创建节点的时候，自动为节点增加一个序列号，井且序列号递增。 节点可以被监控，一旦节点变化，如删除节点，或者节点数据变化，客户端就会收到此事件，此监控失效。客户端可以调用API继续监控这个节点 安装 ZooKeeperZooKeeper 官网 下载 zk 只需要解压即可使用 conf/zoo.cfg tickTime 是心跳时间，默认是 2 秒 dataDir是 ZooKeeper保存的内存快照，以及事务日志的目录 clientPort 是客户端应用连接的端口 ZooKeeper 的基本命令zkCli: help， 进入命令行模式 ls， 查看目录 create, 创建节点 create -e，创建临时节点，一旦用户会话结束，则节点自动删除 get，获取节点数据节点内部数据: cZxid，节点创建时的 zxid mZxid，节点最新一次更新发生时的 zxid ctime，节点创建时的时间戳 mtime，节点最新一次更新发生时的时间戳 dataVersion，节点数据的更新次数 cversion，其子节点的更新次数 aclVersion，节点ACL(授权信息)的更新次数 ephemeralOwner，如果该节点为临时节点，ephemeralOwner值表示与该节点绑定的会话ID，如果该节点不是临时节点, ephemeralOwner值为 0; dataLength，节点数据的字节数 numChildren，子节点个数 delete，删除节点 set path data，设置节点数据 watch操作，ls命令和get命令都可以增加一个watch操作，节点变化的时候会通知客户端。通知完毕后，还需要再次调用 ls 或者 get才能监昕此节点变化 领导选取分布式锁服务注册集成 ZooKeeperCurator 是Apache提供的一个访问zk的工具包，封装了这些低级别操作，同时也提供一些高级服务，比如分布式锁、领导选取等 它具有如下特性: 自动重连，无须开发人员关心 提供简单的API来操作 zk 节点，还有zk事件，API是链式操作风格 Curator实现了ZooKeeper提供的所有应用场景(除了两阶段提交)，有以下实现: 领导节点选取 分布式锁 分布式读写锁 共享信号量 栅栏和双重 DoubleBarrier 分布式计数器，支持integer和long 分布式队列和分布式优先级队列 服务注册和发现 集成 Curator依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-x-discovery&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; Configuration 1234567891011121314@Configurationpublic class ZookeeperConf &#123; @Value(\"$&#123;zk.url&#125;\") private String zkUrl; @Bean public CuratorFramework getCuratorFramework() throws Exception &#123; RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); CuratorFramework client = CuratorFrameworkFactory.newClient(zkUrl, retryPolicy); client.start(); return client; &#125;&#125; RetryPolicy 用于重连策略 Curator API create，创建节点，也可通过withMode为节点设置类型，如临时节点、序列节点，以forPath结尾。如果节点己经存在，抛出 NodeExistsExceptiono delete，删除节点，以forPath结尾，如果节点不存在，将抛出 NoNodeException，如果节点是非空节点，则抛出 NotEmptyExceptiono checkExists()，检查节点是否存在，如果不存在，返回 null，如果存在，返回 Stat对象。可以加上 watch 方法来监听节点变化，该方法以 forPath 结尾 getData，获取节点数据，以 forPath 结尾，返回 byte[] setData，设置节点数据，以 forPath结尾 getChildren()，得到节点的子节点，以forPath结尾，返回一个子节点路径列表 实现分布式锁Curator提供了InterProcessMutex来实现分布式锁InterProcessMutex用acquire方法获取锁，以及用release释放锁，同其他锁一样，release方法需要放在finally代码块中，确保锁能正确释放 服务注册curator-x-discovery 通过 ServiceDiscovery 注册服务获取服务领导选取LeaderSelector 即可实现领导的选取","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (15) Session","slug":"SpringBoot2-F","date":"2018-12-22T12:58:24.000Z","updated":"2020-07-25T02:57:18.169Z","comments":true,"path":"2018/12/22/SpringBoot2-F/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-F/","excerpt":"","text":"水平扩展实现 Spring Boot 应用水平扩展有两个问题需要解决: 将用户的请求派发到水平部署的任意一台SpringBoot应用，通常用一个反向代理服务器来实现 会话管理共享会话信息, 有两种方式可以实现 复制会话: Web服务器通常都支持Session复制，一台应用的会话信息改变将立刻复制到其他集群的Web服务器上 集中式会话: 所有Web服务器都共享一个会话，会话信息通常存放在一台服务器上，本章使用Redis服务器来存放会话 Spring Session介绍Spring Boot 配置很容易切换到不同的Session管理方式，总共有以下几种: Redis, Session数据存放Redis中 JDBC，会话数据存放在数据库中，默认情况下SPRING_SESSION表存放Session基本信息，如sessionId、创建时间、最后一次访问时间等，SPRING_SESSION_ATTRIBUTES存放了session数据，ATTRIBUTE_NAME列保存了Session的Key, ATTRIBUTE_BYTES列以字节形式保存了Session的Value, Spring Session 会自动创建这两张表。 Hazelcast, Session数据存放到 Hazeleast None，禁用 Spring Session 功能 通过配置属性spring.session.store-type来指定Session的存储方式 使用 Redis","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (14) Cache","slug":"SpringBoot2-E","date":"2018-12-22T11:47:19.000Z","updated":"2020-07-25T02:57:18.169Z","comments":true,"path":"2018/12/22/SpringBoot2-E/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-E/","excerpt":"","text":"Spring Cache对Cache进行了抽象，提供了@Cacheable、@CachePut、@CacheEvict等注解。SpringBoot应用基于SpringCache，既提供了基于内存实现的缓存管理器，可以用于单体应用系统，也集成了Redis、EhCache等缓存服务器，可用于大型系统或者分布式系统。 Cache应用系统缓存通常有以下作用: 缓存Web系统的输出，如伪静态页面 缓存系统中不经常改变的业务数据，如用户权限、字典数据、配置信息等 Cache的组件和概念 CacheManager，用来创建、管理、管理多个命名唯一的Cache，如组织机构缓存、菜单项的缓存、菜单树的缓存等 Cache 类似Map那样的Key-Value存储结构，Value部分通常包含了缓存的对象，通过Key来取得缓存对象 缓存项，存放在缓存里的对象，常常需要实现序列化接口，以支持分布式缓存 Cache存储方式，缓存组件可以将对象放到内存或其他缓存服务器上，Spring Boot提供了一个基于ConcurrentMap的缓存，同时也集成了Redis、EhCache2.x、JCache缓存服务器等 缓存策略，通常Cache还可以有不同的缓存策略，如设置缓存最大的容量，缓存项的过期时间等 分布式缓存，缓存通常按照缓存数据类型存放在不同缓存服务器上，或者同一类型的缓存按照某种算法、不同Key的数据存放在不同的缓存服务器上 Cache Hit，从Cache中取得期望的缓存项，我们通常称之为缓存命中。如果没有命中则称之为Cache Miss，意味着需要从数据来源处重新取出井放回Cache中 Cache Miss，缓存丢失，根据Key没有从缓存中找到对应的缓存项 Cache Evication，缓存清除操作 Hot Data，热点数据，缓存系统能调整算法或者内部存储方式，使得最有可能频繁访问的数据能被尽快访问到 On-Heap, Java分配对象都是在堆内存中，有最快的获取速度。由于虚拟机的垃圾回收管理机制，缓存放入过多的对象会导致垃圾回收时间过长，从而有可能影响性能 off-Heap，堆外内存，对象存放在虚拟机分配的堆外内存中，因此不受垃圾回 收管理机制的管理，不影响系统性能，但堆外内存的对象要被使用，还要序列化成堆内对象。很多缓存工具会把不常用的对象放到堆外，把热点数据放到堆内 Cache的单体应用使用专有的Cache服务器使用一二级缓存服务器Spring Boot CacheSpring Boot本身提供了一个基于ConcurrentHashMap的缓存机制，也集成了EhCache2.x、JCache CJSR-107、EhCache3.x、 Haz巳least、Infinispan)，还有 Couchbase、Redis等。Spring Boot应用通过注解的方式使用统一的缓存，只需在方法上使用缓存注解即可，其缓存的具体实现依 赖于选择的目标缓存管理器。 使用@Cacheable 集成 Spring Cache依赖: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; appliaction.properties 中配置 1spring.cache.type=Simple Simple，基于 ConcurrentHashMap实现的缓存，适合单体应用或者开发环境使用 none，关闭缓存，比如开发阶段为了确保功能正确, 可以先禁止使用缓存 redis，使用 Redis作为缓存，还需要在pom中增加 Redis依赖 Generic，用户自定义缓存实现，用户需要实现一个org.springframework.cache.CacheManager的实现 其他还有 JCache、 EhCache2.x, Hazelcast等 注解@EnableCaching打开缓存功能 注释驱动缓存@Cacheable注解@Cacheable声明了方法的结果是可缓存的，如果缓存存在，则目标方法不会被调用，直接取出缓存。可以为方法声明多个缓存，如果至少有一个缓存有缓存项，则其缓存项将被返回。 Key生成器Spring使用了KeyGenerator类来根据方法参数生成 Key @CachePut注解CachePut总是会执行方法体，井且使用返回的结果更新缓存 @CacheEvict注解CacheEvict 用于删除缓存项或者清空缓存，CacheEvict 可以指定多个缓存名字来清空多个缓存 CacheEvict可以清空缓存中的所有项目，此时使用allEntries=true来删除清空缓存 @Caching注解Caching可以混合以上各种注解，可以在Caching标签中混合@Cacheable、@CachePut、@CacheEvict @CacheConfigCache注解都需要提供Cache名称，如果每个Service方法上都包含 Cache名称，可能写起来重复。注解 CacheConfig作用于类上，可以为此类的方法的缓存注解提供默认值，包括: 缓存的默认名称 缓存的 KeyGenerator 使用 RedisCache集成Redis缓存pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.properties: 1234spring.cache.type=REDISspring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.password=Redis!123 禁止缓存通常在开发环境下，不需要使用Redis类型的缓存，你可以配置为Simple,动切换,用HashMap作为缓存，或者使用None禁止缓存以方便开发。 定制缓存对于 RedisCacheManager来说，还可以定制缓存项的存活时间，缓存名是否在Redis中加上前缀等，这是通过实现CacheManagerCustomizer配置来完成定制 Redis 缓存原理SpringBoot的自动配直类RedisCacheConfiguration会自动检测 spring.cache.type的值，从而决定使用何种缓存。 实现Redis两级缓存","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (13) Elasticsearch","slug":"SpringBoot2-D","date":"2018-12-22T10:33:39.000Z","updated":"2020-07-25T02:57:18.169Z","comments":true,"path":"2018/12/22/SpringBoot2-D/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-D/","excerpt":"","text":"Elasticsearch 介绍Elasticsearch，简称ES。是一个全文搜索服务器，也可以作为 NoSQL数据库，存储任意格式的文档和数据，同时，也可以做大数据的分析，是一个跨界开源产品。 ES有如下特点: 全文搜索引擎， ES是建立在 Lucene 上的开源搜索引擎，可以用来进行 全文搜索、地理信息搜索。Wikipedia, GitHub、 StackOverFlow 等网站均使用 ES。 文档存储和查询，可以像NoSQL那样存储任意格式文档，井能根据条件查询文档 大数据分析， ES号称能准确实时地进行大数据分析，数据量从TB到PB，国内外很多大公司都用ES做大数据分析 ES提供了RESTAPI，用来简化对ES的操作。 因此可以使用任何语言的客户端，同时也提供 Java API， SpringBoot也对 RESTAPI进行了封装，简化了开发 ES常常配合传统数据库一起使用， ES用来负责大数据的查询、搜索、统计分析 安装JDK8+ www.elastic.co/downloads 下载 解压 elasticsearch-x.x.x.zip 行./bin/elasticsearch, 不能使用 root直接运行，最好为运行 ES 创建一个新的用户 看到以下提示，表示安装成功 9200端口是对外的 RESTFul接口， 9300端口是 ES 内部使用的端口 打开浏览器，访问 基本概念 Index, Index是文档(Document)的集合，Index下面包含了 Type，用于对 Document 进一步分类。可以理解为ES中的Index相当于数据库，而Type相当于数据库中的表，ES 中可以轻易地联合Index和Type来搜索数据，数据库却不能。 Type，用来进一步组织Document，一个Index下可以有多个Type，比如用户信息是一 个Type，用户的支付记录是一个Type。 Document，文档是ES能够存储和搜索的基本信息，类似数据库表行数据，Document为JSON格式，文档属于Type。 Node(节点)，节点是集群里的一台ESServer，用于文档的存储和查询。应用可以只有一个节点，也可以由上百个节点组成集群来存储和搜索数据。每个节点都有一个节点名字，以及所属集群的名字。 集群，同样集群名的节点将组合为ES集群，用来联合完成数据的存储和搜索。默认的集群名字是 elasticsearch。 分区(Shards)和复制(Replicas)，每个Index理论上都可以包含大量的数据，超过了单个节点的存储限制，而且，单个节点处理那么大的数据，将明显限制存储和搜索性能。为了解决这个问题，ES会进一步将Index在物理上细分为多个分区，而且这些分区会按照配置复制到多个节点Index的分区称为主分区,复制的分区称为复制分区。这样的好处是既保证数据不会丢失，又提高了查询的性能。 使用REST访问 ElasticsearchES 操作基本上分为以下几类: 文档的增删改查 全文搜索 聚合搜索 处理人类语言 地理位置搜索 使用RestTemplate访问 ESSpring Data ElasticSpring Data Elastic是Spring官方提供的访问ES的方式，相对于直接 REST访问，它有以下优势: 完善的封装，Spring Data Elastic遵循Spring Data规范，你只要会使用Spring Data,比如SpringJPA，就能使用ElasticData。 屏蔽了ES REST接口的复杂性，就像调用普通方法那样调用 ElasticData, Spring会自动调用 Elastic底层 API来完成查询。 安装 Spring Data依赖: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 配置: 1spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 Entity @Document 表示这是一个 ElasticData, indexName和 type对应于 Elasticsearch 的Index和Type @Id 声明了文档的主键，同 SpringData一致 DaoDao继承了Spring Data 的CrudRepository，因此自带了简单的增,删,改,查操作","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (12) Redis","slug":"SpringBoot2-C","date":"2018-12-22T09:29:50.000Z","updated":"2020-07-25T02:57:18.169Z","comments":true,"path":"2018/12/22/SpringBoot2-C/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-C/","excerpt":"","text":"Redis(REmote Dictionary Server)是一个开源 (BSD许可)、内存存储的数据结构服务器，可用作数据库来存储Key-Value数据，它支持字符串、哈希表、列表、集合、有序集合、位图、地理空间信息等数据类型，同时也可以作为高速缓存和消息队列代理。 安装 Redis官网下载, 解压后，进入src目录，运行make进行编译 Redis安装完毕，在src目录下有以下两个常用命令: redis-server, 启动 Redis服务器，默认会监听6379端口 redis-cli, Redis 自带的客户端管理工具 redis-cliRedis 一共有 14 个命令组、两百多个命令 运行./redis-cli，进入Redis客户端管理工具 ping命令，用来检验 Redis服务器是否正常运行，服务器返回PONG来应答服务器正常运行 安全设置redis.conf 文件 1requirepass Redis!123 启动服务器 1./redis-server ../redis.conf 基本操作 set命令可以添加/覆盖一个字符串或者数字类型 get 来获取其值 mget来获取多个key的值 Key，通常都是包含逻辑上的命名空间，用符号:分开 对于数字类型的字符串，还有以下命令可以对其进行算数操作: DECR/INCR，数字类型数据自减和自增 DECRBY/INCRBY，数字类型数据减去某个指定的整数或者增加某个指定整数 INCRBYFLOAT，数字增加 一个浮点数，负数表示减去 keysKey 是二进制数，因此字符串和图片都可以作为Key，可以通过keys命令来查询 Redis中所有的Key Key 后面可以用*或者?: Platform:*, 匹配platform:开头的Key pl?tform, 匹配 platform或者pletform *, 查询所有的 keys exist 来判断 Key 是否存在 del 命令删除 Key-Value expire 设定 Key 的超时时间 ttl 命令则用于查看 Key 的存活时间 Redis ListRedis List类型类似Java的LinkedList，通过链表来完成，向其添加元素速度非常快，但按照索引方式获取元素比较慢 rpush 可以将多个值放入list尾部 lpush 可以将多 个值放到list头部 lrange 从左到右显示指定范围的列表 rpop 命令可以从列表尾部取出一个元素 lpop 取出列表的头一个元素 lien 用来返回List的长度 Redis HashReids Hash 类似Java的HashMap，允许存放多个 Key-Value Hash 有以下指令 hset key field value，给指定的 Key设置一个字段值，如果值已经存在，则覆盖。返回0表示失败，返回1表示成功 hget key filed，获取指定 Key 的 filed 字段的值，如果不存在，返回 nil hexists key filed，判断指定的 Key 的自led 字段是否存在，返回 1 表示存在，0 表示不存在 hkeys key，返回 Key 所指定的 hash 所有的字段名。 hgetall key，返回所有的字段名和 字段值 hdel key field [field]，删除多个字段 Hash 的字段支持递增计算，这跟原始类型操作一样，是原子操作 hincby key field value，对Key指定的Hash数据中的field的值进行计算，增加整型 value hincbyfloat key field value，对 Key指定的 Hash数据中的field的值进行计算，增加浮点数 value SetSet与Java中的Java.util.Set类似，代表了元素不重复的集合，Redis的Set除了元素添加删除操作，还包含了集合的井集、交集等功能 sadd key member [member ..]，添加元素，比如 sadd ip 192.168.0.1，向 ip 集合添加一个字符串，值是 192.168.0.1 srem key member [member ..]，删除元素 smemberkey，返回一个集合中的所有元素 sinter key1 key2，返回两个集合共同的元素，key1 和 key2 分别代表两个集合 sinterstore key1 key2 key3，取的 keyl 和 key2 的交集，井存放到key3集合中 sunion key1 key2， 返回一个合并后 的集合 sunionstore key1 key2 key3，合并key1和key2集合，并存放到key3集合中 Pub/SubReids 除了NoSQL特性，还提供了简单的消息服务，支持publish/subscribe。 Redis 客户端 可以订阅 一个或者多个频道( Channel)，这种行为被称为 subscribe。其他 Redis 客户端向这些Channel发送消息，称为publish，订阅这些频道的客户端能接收到这些消息 Spring Boot集成 Redis依赖: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置 application.properties 12345spring.redis.host=127.0.0.1spring.redis.password=Redis!123spring.redis.port=6379#最大连接数,新版本已经取消#spring.redis.pool.max-active=8 StringRedisTemplate 是Spring Boot默认提供的 Redis 操作接口 ，适合Key和Value都是字符串的情况 也可以采用JDK 序列化的方式来序列化Key和Value的 RedisTemplate类，这 是一个通用类，其实现可以提供不同的序列化方式 使用 StringRedisTemplateopsFor opsForValue, 用来设置普通的 Key-Value opsForList 用来操作 List结构 opsForList 提供了 lefPush、leftPushAll、leftPop、rightPush、 rightPushAII、 rightPop 等操作，也提供了 range操作与 size操作，用于查看 List的长度 opsForHash，用来操作 Hash 数据结构 绑定Key的操作可以通过RedisTemplate 提供的boundXXXOps()来指定一个Key，返回BoundXXXOperations。这样在BoundXXXOperations上的操作就不需要提供Key作为参数 boundValueOps boundListOps boundHashOps boundSetOps boundZSetOps boundGeoOps RedisConnectionRedisConnection提供了低级别的API操作，用 byte数组作为参数操作 Redis服务器。 Pub/Sub convertAndSend 方法用于向channal发送消息 订阅消息，需要实现MessageListener的onMessage方法 序列化策略 RedisTemplate则采用默认的序列化策略 JdkSerializationRedisSerializer，这两种序列化策略 都实现了 RedisSerializer接口","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (11) MongoDB","slug":"SpringBoot2-B","date":"2018-12-22T07:43:19.000Z","updated":"2020-07-25T02:57:18.168Z","comments":true,"path":"2018/12/22/SpringBoot2-B/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-B/","excerpt":"","text":"支持各种编程语言， Java、 C++、 PHP、 C#、 Python 等 面向文档存储，文档格式是类似 JSON 的 BSON 格式 提供丰富的查询功能，支持对数据建立索引 模式自由，不需要事先定义文档格式，可以任意改变文档格式 安装 MongoDB进入 bin 目录，有以下常用命令: mongod，启动 MongoDB 数据库。通常需要指定一个数据存放的目录，默认是/data/db。 如果启动的时候没有创建/data/巾 ，则会启动失败。可以通过--dbpath 参数指定特定的目录，参数详情可以键入./mongod --help mongo，启动一个 Shell ./mongo，通过 shell可以对 MongoDB进行增删改查等操作 mongodump，备份数据库 mongorestore，恢复数据库 使用 shellSpring Boot集成 MongoDB1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 1spring.data.mongodb.uri=mongodb://127.0.0.1:27017/baike 增删改查MongoTemplate insert save findByid find, Criteria 类构造查询条件 query update remove execute 打印日志1logging.level.org.springframework.data=debug","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (10) REST","slug":"SpringBoot2-A","date":"2018-12-22T07:16:11.000Z","updated":"2020-07-25T02:57:18.168Z","comments":true,"path":"2018/12/22/SpringBoot2-A/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-A/","excerpt":"","text":"REST 简介REST，即Representational State Transfer的缩写，翻译为表现层状态转化 资源: 网络上的一个实体, 以用 一个 U阳(统一 资源定位符〉指向它，每种资源对应一个特定的 URI 表现层: “资源”具体呈现出来的 形式称为它的“表现层”( Representation) 状态转化: 服务器端发生“状态转化”( State Transfer)。 而这种转化是建立在表现层之上的 REST 风格的架构 使用api作为Web上下文 增加版本标识 标识资源 REST中的 HTTP Method REST中的 HTTP Status 使用api作为Web上下文http://xxx.com/api 或 http://api.xxx.com 增加 一个版本标识http://xxx.com/api/v1.1 标识资源将资源名称放到URL中，如果资源有层级关系，则放入层级关系 HTTP Method POST ，代表增加资源 PUT，代表更改资源，客户端提供需完整的资源属性 GET，代表查询资源 PATCH，更新资源，客户端提供仅需要更改的资源属性; DELETE，通常用于删除资源 HEAD，类似 GET，但仅仅只有 HTTP 头信息，头信息包含了需要查找的信息 OPTIONS，用于获取 URI所支持的方法，响应信息会在 HTTP 头中包含一个名为”Allow”的头，值是所支持的方法，如”GET,POST” HTIP Status 200,0K，用户请求成功，如查询数据成功返回 。 400，错误的的请求，在第 3 章 中， URI 匹配上 Spring Boot 中的 Controller，但方法参 数匹配错误，就会抛出错误。 404 NOT Found，用户发出的请求针对的资源不存在，通常是 Spring Boot 中的 Controller 没有匹配上URI，或者匹配上了 Controller方法，但渲染的视图不存在。 405，用来访问本页面的 HTTP Method 不被允许，比如通过 HTTP GET 方式访问了一个@PostMapping 的Controller方法。 406，表示无法使用请求的 内容特性来响应请求的资源，比如在 Spring Boot 中， 请求 后缀以 html 结尾，但同时请求的 HTTP 头中又包含了 Accept:application/json 500，服务器内部错误，无法完成请求，通常是 Controller抛出的异常 集成 REST1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; @RestController@Controller和@ResponseBody 的组合 REST ClientRestTemplate定制 RestTemplate创建一个配置类实现 RestT巳mplateCustornizer接口的customize方法 Swagger UI集成 SwaggerSwagger 规范","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (9) 单元测试","slug":"SpringBoot2-9","date":"2018-12-22T07:13:40.000Z","updated":"2020-07-25T02:57:18.168Z","comments":true,"path":"2018/12/22/SpringBoot2-9/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-9/","excerpt":"","text":"","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (8) 部署","slug":"SpringBoot2-8","date":"2018-12-22T06:53:27.000Z","updated":"2020-07-25T02:57:18.168Z","comments":true,"path":"2018/12/22/SpringBoot2-8/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-8/","excerpt":"","text":"Spring Boot 应用部署通常会面临多个部署环境，如测试环境、线上环境、演示环境等 以 jar文件运行SpringBoot默认以jar包方式运行， 可以在 Maven配置如下插件，将 SpringBoot导出成可执行 的 jar 文件 123456789&lt;!-- Package as an executable jar --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在工程目录下的运行命令行中运行 mvn package jar方式运行: 1java -jar target/target/xxx.x-0.0.1-SNAPSHOT.jar 以war万式部署将 SpringBoot应用打成一个 war包，部署到 Tomcat 、Jetty服务器，或者商业的 Weblogic、 Websphere 上 多环境部署测试环境、准线上环境 、 演示环境等 环境对应了不同的配置要求，通常有: 数据库的访问地址不同，数据库用户名和密码也不同，连接池的配置也大不一样，开发环境可能只配置5个连接，而线上环境则多达数百个。 日志配置不同，开发和测试环境的日志级别可能是 debug 级别, 日志信息也常常包含 代码所在行，而线上环境 则 通常是 INFO 级别 ，且为了性能考虑不会输出日志所在行。另外，对日志文件要求也不尽相同， 线上环境要求日志文件能定时打包压缩， 开发环 境则往往不会配置日志文件。 访问的第三方系统不一样，复杂的应用通常要访问第三方系统，如系统内的 Redis 缓存，通过 REST访问其他 SpringBoot应用，这都需要配置不同的 IP地址。 不同的环境有不同的开关属性，比如开发系统，需要关闭短信、微信的通知功能 ，而演示环境、线上环境则需要打开这些配置 application-{profile}.properties的配置文件, 其中profile可以是任意名字，比如: test， 表示测试环境 prod，表示线上环境 pre-prod， 预发布环境 demo1.0 1.0版本演示环境 在环境变量中，spring.profiles.active 指定使用哪个 profile 比如: 1java -jar -Dspring.profiles.active=prod target/xxx-0.0.1-SNAPSHOT.jar @Profile注解 @Profile 注解以决定配置类是否生效 @Profile 注解可以支持使用多种 profile，也可以使用“!”来排除特定 profile @Profile({“test”, “prod”})，测试环境和线上环境生效 @Profile({“test”, “!prod”})，测试环境和非线上环境生效","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (7) 配置","slug":"SpringBoot2-7","date":"2018-12-22T06:18:24.000Z","updated":"2020-07-25T02:57:18.168Z","comments":true,"path":"2018/12/22/SpringBoot2-7/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-7/","excerpt":"","text":"配置 Spring Bootapplication.properties 服务器配置 server.address 服务器IP 绑定地址，如果你的主机上有多个网卡，可以绑定一个 IP 地址 server.session.timeout 会话过期时间，以秒为单位 server.eηor.path 服务器出错后的处理路径/error server.servlet contextpath Spring Boot应用的上下文 server.port Spring Boot 应用监听端口 使用其他 Web 服务器Spring Boot 内置了 Tomcat，同时还支持Jetty、Undertow 作为 Web 服务器。使用这些应用 服务器， 只需要引入相应的 starter 配置启动信息 可以在 classpath 中增加 banner.txt， 显示你自己的输出信息，在 Spring Boot 项目的 resources 目录下新建一个 banner.txt 可以设置 banner.gif(png,jpg)，控制台自动将图片转为 ASCII 字符，作为启动信息输出 banner.charset=UTF-8 # banner.txt 字符集 banner.location=classpath:banner.txt banner.image.location=classpath:banner.gif #如采使用图片，图片的位置可以使用 jpg/ png banner.image.width=76 #图片宽度，这里指转为字符的个数，越多越清楚 banner.image.height=76 #图片长度 banner.image.margin=2 #图片与左边的边距，默认为 2 个字符 配置浏览器显示 ico在项目的 resources 目录下新建一 个 static 目录，在 static 目录下创建 images 目录(或者任意放置图片的目录)，然后将项目的 favicon.ico 放在 images 目录下，每个页面添加以下样式即可: 1&lt;link rel=\"shortcut icon\" href=\"/images/apple.ico\"&gt; 日志配置默认情况下，不需要对日志做任何配置就可以使用， Spring Boot 使用 LogBack 作为日志的实现，使用 apacheCommons Logging作为日志接口 123456logging.level.root=infologging.level.org.springframework=infologging.level.com.bee.sample=debuglogging.file = my.loglogging.pattern.console=%level %date&#123;HH:mm:ss&#125; %logger&#123;20&#125;.%M %L :%m%nlogging.pattern.file= %level %date&#123;ISO8601&#125; [%thread] %logger&#123;20&#125;.%M %L :%m%n 读取应用配置EnvironmentEnvironment是一个通用 的读取应用程序运行时的环境变量的类，可以读取 application.properties、命令行输入参数、系统属性、操作系统环境变量等。 @Value直接通过@Value注解注入一个配置信息到 Spring管理的 Bean 中 @ConfigurationProperties将一组同样类型的配置属性映射为一个类更为方便 Spring Boot 自动装配@Configuration 和@Bean注解@Configuration, 向 Spring 表明这是一个配置类，类里的所有带@Bean注解的方法都会被 Spring调用，返回对象将会作为一个 Spring容器管理的 Bean Bean条件装配@ConditionalOnBean，在当前上下文中存在某个对象时，才会实例化一个 Bean@ConditionalOnMissingBean， 在当前上下文中不存在某个对象时，才会实例化一个 Bean Class条件装配Class条件装配是按照某个类是否在 Classpath 中来决定是否要配置 Bean。@ConditionalOnClass表示当 classpath 有指定的类时，配置生效 Environment 装配可以根据 Spring Boot 的 Environment 属性来决定配置是否生效 其他条件装配 ConditionalOnExpression，当表达式为 true 时，才会实例化一个 Bean，支持 SpEL 表达式，比如根据配置文件中的某个值来决定配置是否生效。 ConditionalOnJava，当存在指定的 Java 版本的时候 联合多个条件Condition 接口制作 Starterstarter包含了两项主要 的功能才使得 Spring Boot 变得非常容易使用 : 配置了依赖库，如 sprinh-boot-starter-web 依赖了 Tomcat 等， beetl-framework-starter 依赖了Beetl和 BeetlSQL 等。 自动配置","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (6) Spring Data JPA","slug":"SpringBoot2-6","date":"2018-12-22T05:27:16.000Z","updated":"2020-07-25T02:57:18.167Z","comments":true,"path":"2018/12/22/SpringBoot2-6/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-6/","excerpt":"","text":"以 Java Entity为中心， 将实体和实体关系对应到数据库的表和表关系， 这类工具通常就是 ORM (Object Relational Mapping)工具。 对实体和实体关系的操作会映射到 数据库操作。 SpringData JPA，它在 JPA 提供的简单语义上做了一定的封装，满足 CRUD 查询 SpringData，它为 Spring框架对访问 SQL和 NoSQL数据库提供了一致的方式 集成 Spring Data JPA1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; HikariCP 作为数据源提供者 12345678910&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.5&lt;/version&gt;&lt;/dependency&gt; 配置数据源 123456789101112@Configurationpublic class DataSourceConfig &#123; @Bean(name = \"dataSource\") public DataSource datasource(Environment env) &#123; HikariDataSource ds = new HikariDataSource(); ds.setJdbcUrl(env.getProperty(\"spring.datasource.url\")); ds.setUsername(env.getProperty(\"spring.datasource.username\")); ds.setPassword(env.getProperty(\"spring.datasource.password\")); ds.setDriverClassName(env.getProperty(\"spring.datasource.driver-class-name\")); return ds; &#125;&#125; 配置JPA支持Spring JPA Data 采用了Hibernate实现，Hibernate实现中有两个特性需要关注: spring.jpa.hibemate.ddl-auto, 是否自动建库 spring.jpa.show-sql, 是否自动打印 SQL Entity实体类就必须使用@Entity来注解，JPA 也提供了大量的注解来表明实体属性和关系 @Id ， 声明了一个属性将映射到数据库主键宇段。主键生成策略由注解 @GeneratedValue 来指定。比如，id 为自增主键，是 一种简单的数据库 主键生成策略，因此使用 GenerationType.IDENTITY 作为主键生成的策略 。 @Column，此注解表明属性对应到数据库的一个字段，且列名为 name指定的名称。 @ManyToOne, Many 指的是定义此属性的实体，即 User 实体，而 One 指的就是此注 解所注解的属性， ManyToOne 说明对象 User 和 Department 的关系是多对一关系，多 个用户属于一个部门 。 @JoinColumn，与 ManyToOne 搭配使用，说明外键字段是 department-id。 RepositoryRepository 是 Spring Data 的核心概念，抽象了对数据库和 NoSQL 的操作，提供了接口 供开发者使用 CrudRepository实现 Entity的简单增删改查功能 save findByid findAll count deleteByid delete … PagingAndSortingRepository增加了翻页查找和排序相关的操作 Iterable&lt;T&gt; findAll(Sort sort) Page&lt;T&gt; findAll(Pageable pageable) JpaRepository提供了更多的实用功能，以及通过 Example 对象进行查询 Example 对象是 Spring Data JPA 提供的用来构造查询条件对象 持久化 Entity save方法 SortJpaRepository 提供了如下表所述的内置查询 List findAll(); 返回所有实体 List findAJl(Iterable ids); 返回指定 id 的所有实体 T getOne(ID id) 根据 id 返回对应的实体，如果未找到，则返回 空 List findAll(Sort sort); 返回所有实体，按照指定顺序排序返回 Page findAll(Pageable pageable); 返回实体列表，实体的offset和 limit通过 pageable来指定 Sort对象用来指示排序 其他 Sort 的构造方法还包含: public Sort(String… properties)， 按照指定 的属性列表升序排序。 public Sort(Direction direction, String… properties)，按照指定属性列表排序 ，排序由 Direction 指定， Direction 是一个枚举类，有 Direction.ASC 和 Direction.DESC 两类。 publicSort(Order…orders), Order可以通过Order静态方法来创建 public static Order asc(String propertyName) public static Order desc(String propertyName) Pageable 和 PagePageable 接口用于构造翻页查询， PageRequest 是其实现类，可以通过提供的工厂方法创建PageReques 基于方法名字查询Spring Data 通过查询的方法名和参数名来自动构造一个 JPA OQL 查询 方法名和参数名需要遵守一定的规则， Spring Data JPA 才能自动转化为 JPQL: 方法名通常包含多个实体属性用于查询，属性之间可以使用 AND 和 OR 连接，也支持 Between、 LessThan、 GreaterThan、 Like 方法名可以以findBy、 getBy、 queryBy 开头 查询结果可以排序，方法名包含 OrderBy+属性+ASC(DESC) 可以通过 Top、 First来限定查询结果集 一些特殊的参数可以出现在参数列表里，比如 Pageable、Sort @Query 查询注解 Query允许在方法上使用 JPQL 使用JPA QueryEntityManager 提供了实体操作的所有接口 ，可以通过 自动注入方式注入到 Spring 管理的 Bean 中， 通常是由@Service 注解的业务处理类上。 Example 查询根据实体创建一个 Example对象，SpringData通过 Example对象来构造 JPQL","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (5) 数据库访问","slug":"SpringBoot2-5","date":"2018-12-22T01:54:42.000Z","updated":"2020-07-25T02:57:18.167Z","comments":true,"path":"2018/12/22/SpringBoot2-5/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-5/","excerpt":"","text":"JDBCTemplate是Spring 自带的，在JDBC的基础上做了一定封装 BeetlSQL是笔者研发的，除了封装了 JDBC操作，还带有 SQL 管理、跨数据库平台支持等企业功能 以SQL为核心的数据库访问更为灵活，更能适应大型的互联网和企业应用，学习门槛较低 以对象方式访问数据库更适合较为简单的系统或者工具类系统，学习门槛刚开始较低，但因为 ORM(Object Relational Mapping)持久化上下文等概念过于复杂 配置数据源数据库连接池 HikariCP 12345&lt;dependency&gt; &lt;groupid&gt;com.zaxxer&lt;/groupid&gt; &lt;artifactid&gt;HikariCP&lt;/artifactid&gt; &lt;version&gt;2.6.l&lt;/version&gt;&lt;/dependency&gt; MySQL 12345&lt;dependency&gt; &lt;groupid&gt;mysql&lt;/groupid&gt; &lt;artifactid&gt;mysql-connector-java&lt;/artifactid&gt; &lt;version&gt;6.0.5&lt;/version&gt;&lt;/dependency&gt; 在配置文件中配置连接数据库的基本信息以供 HikariCP 使用 : 1234spring.datasource.url=jdbc:mysql://127.0.0.1:3306/orm?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver JavaConfig来创建一个数据源: 1234567891011121314@Configurationpublic class DataSourceConfig &#123; @Bean(name = \"dataSource\") public DataSource datasource(Environment env) &#123; HikariDataSource ds = new HikariDataSource(); ds.setJdbcUrl(env.getProperty(\"spring.datasource.url\")); ds.setUsername(env.getProperty(\"spring.datasource.username\")); ds.setPassword(env.getProperty(\"spring.datasource.password\")); ds.setDriverClassName(env.getProperty(\"spring.datasource.driver-class-name\")); return ds; &#125;&#125; Spring JDBC TemplateSpring提供了JdbcTemplate对数据库访问技术 JDBC 做了一定封装，包括管理数据库连接，简单查询结果映射成 Java 对象，复杂的结果集通过实现RowMapper接口来映射到 Java 对象。 在 Spring Boot中, 只要配置好数据源 DataSource， 就能自动使用 JdbcTemplate 12345@Repositorypublic class UserDao &#123; @Autowired JdbcTemplate jdbcTempalte;&#125; @Repository 通常用在同存储相关的类上 查询一个简单的返回总数的查询: 1int rowCount = jdbcTempalte.queryForObject(\"select count(1) from user\", Integer.class); 一 个带参数绑定的查询: 12String sql = \"select count(1) from user where department_id=?\";Integer rowCount = jdbcTempalte.queryForObject(sql, Integer.class, 1); 如果期望返回POJO实例，JdbcTemplate需要一个RowMapper，将查询结果集ResultSet映射成一个对象: 1234567891011121314public User findUserById(Long userId) &#123; String sql = \"select * from user where id=?\"; User user = jdbcTempalte.queryForObject(sql, new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt(\"id\")); user.setName(rs.getString(\"name\")); user.setDepartmentId(rs.getInt(\"department_id\")); return user; &#125; &#125;, userId); return user;&#125; 通常RowMapper可以被其他查询复用，因此最好的办法是在 DAO 中创建一个内部类 123456789static class UserRowMapper implements RowMapper&lt;User&gt; &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt(\"id\")); user.setName(rs.getString(\"name\")); user.setDepartmentId(rs.getInt(\"department_id\")); return user; &#125;&#125; JdbcTemplate查询如果期望返回的是列表: 12345public List&lt;User&gt; getUserByDepartmentId(Long departmenetId) &#123; String sql = \"select * from user where department_id=? \"; List&lt;User&gt; user = jdbcTempalte.query(sql, new UserRowMapper(), 1); return user;&#125; 对于大多数DAO框架来说，完成上述的查询会非常简单，不需要写 SOL，不需要写RowMapper，比如后面要介绍的 BeetlSOL，以及 Spring Data 都是这种情况 。以 BeetlSOL 为例，通过sqlManager可以直接完成上面的两个例子: //根据主键查询User user= sqlManager.unique(User.class , userid); //查询部门的所有用户User template= new User();template.setDepartmentid(departmentid);List list= sqlManager.template(template); 大多数 DAO 框架都会自动生成 SOL，以及完成 ResultSet 到 POJO 的自动映射。 修改JdbcTempalte 提供update方法来实现SQL的修改语旬，包括新增、修改、删除、执行存储 过程等 1234public void updateInfo(User user) &#123; String sql = \"update user set name=? and departmet_id=? where id = ?\"; jdbcTempalte.update(sql, user.getName(), user.getDepartmentId(), user.getId());&#125; 数据库插入: 12345678910111213public Integer insertUser(final User user) &#123; final String sql = \"insert into user (name, departmet_id ) values (?,?)\"; KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTempalte.update(new PreparedStatementCreator() &#123; public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123; PreparedStatement ps = connection.prepareStatement(sql, new String[] &#123; \"id\" &#125;); ps.setString(1, user.getName()); ps.setInt(2, user.getDepartmentId()); return ps; &#125; &#125;, keyHolder); return keyHolder.getKey().intValue();&#125; keyHolder 包含了自增长的结果 JdbcTemplate 增强JdbcTemplate，对SQL中的参数只支持传统的“?”占位符 NamedParameterJdbcTemplate继承了 JdbcTemplate,允许SQL中使用参数的名字作为占位符 12@AutowiredNamedParameterJdbcTemplate namedParameterJdbcTemplate; 在SQL语句中，不再使用?，而是使用了“:”开头的参数名字，如“:deptld” BeetlSQL介绍功能概览BeetlSQL是一个全功能 DAO工具，同时具有 Hibernate和 MyBatis的优点，适用于承认以SQL为中心，同时又需要工具能自动生成大量常用的 SQL的应用。 开发效率 无须注解，自动使用大量内置SQL，轻易完成增删改查功能，节省约50%的开发工作量 数据模型支持 POJO，也支持 Map/List 这种快速模型，还支持混合模型 SQL模板基于Beetl 实现，更容易编写和调试 ，以及进行扩展 可以针对单个表(或者视图)代码生成 POJO类和SQL模板，甚至是整个数据库，能减少代码编写工作量 支持 ORM 查询功能 维护性 SQL写在Markdown文件中，同时方便程序开发和数据库 SQL 调试 可以自动将SQL文件映射为DAO接口类 具备 Interceptor 功能，可以调试、性能诊断 SQL，以及扩展其他功能 灵活直观地支持一对一、一对多、多对多关系映射而不引入复杂的ORMapping概念和技术 其他 内置支持主从数据库的开源工具 持跨数据库平台，将开发者所要完成的工作减到最小，目前跨数据库支持 MySQL、PostgreSQL、Oracle、SQL Server、H2, SQLite、DB2 Maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl-framework-starter&lt;/artifactId&gt; &lt;version&gt;1.1.40.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置 BeetlSQLbeetl-framework-starter 会读取 application.properties 如下配置: beetlsql.sqlPath，默认为/sql，作为存放 SQL文件的根目录，位于/resources/sql 目录下 beetlsql.nameConversion, 默认是 org.beetl.sql.core.UnderlineNameConversion，能将下画线分割的数据库命名风格转化为 Java 驼峰命名风格，还有常用的 DefaultNameConversion, 数据库命名完全和 Java命名一致，以及 JPA2NameConversion，兼容 JPA 命名 beetl-beetlsql.dev, 默认是 true，即向控制台输出执行时的 SQL，包括参数、执行时间 及执行的位置，每次修改 SQL 文件时，自动检测 SQL 文件修改 beetlsql.daoSuffix，默认为 Dao。任何接口继承了 BaseMapper接口，将自动具备实体内置的CRUD功能。daoSuffix选项会在 SpringBoot 启动的时候，自动扫描以 Dao 结尾的接口，自动注册为 Spring 管理的 Dao 类，你可以 在任何地方自动注入这个 Dao类，比如在 Service类中。 beetlsqI.basePackage，默认为com，此选项配置 beetlsql.daoSuffix 来自动扫描 com 包及 其子包下的所有以 Dao 结尾的 Mapper 类。以本章例子而言，你可以配置com.bee.sample.ch5.dao beetlsql.dbStyle，数据库风格，默认是 org.beetl.sql.core.db.MySqlStyle，对应不同的数据库，其他还有 OracleStyle、 PostgresStyle、 SqlServerStyle、 DB2Sq!Style、 SQLiteStyle、 H2Style SQLManager12345@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired SqlManager sqlManager;&#125; SQLManager 是 BeetlSQL 的核心类，提供了所有的数据访问操作: 根据主键查找实体操作，可调用unique方法: 1User user = sqlManager.unique(User.class, pk); 也可以调用 single 方法，如果未查找到，仅仅返回 null: 1User user = sqlManager.single(User.class, pk); 添加一个实体，调用 insert方法: 12345User user = new User();user.setDepartmentID(1);user.setCreateTime(new Date();user.setName(name);sqlManager.selectSample(user); USER表的 ID是自增的，如果想获取到自增主键，可以传入true参数: 1sqlManager.insert(user, true) ; 根据主键更新实体: 12345User user= new User();user.setid(1);......user.setName(\"NewName\");sqlManager.updateByid(user); 只更新有值的属性: 1234User user = new User();user.setid(l);user.setName(\"NewName\");sqlManager.updateTemplateByid(user) ; 使用 SQL 文件项目中还是有不少复杂的 SQL (有的只有五六行，有的甚至有数百行)，放在单独的 SQL 文件中更容易编写和维护，需要在/resources/sql 目录下创建 user.md 文件 12345678910selectSample===* 一个简单的查询例子* 根据用户名查询用户 select * from user where 1=1 @if(!isEmpty(name)) &#123; and name = #name# @&#125; 简单说明: 采用 md格式，===上面是 SQL语句在文件中的唯一标示，下面则是SQL语句 === 下面可以放多行注释，采用*开头 @和回车符号是定界符号，可以在里面写 Beetl语句，如条件判断语句 #是占位符，生成SQL语句的时候，占位符将输出?，并记录此位置的值，如果想直接输出值，需要用 text 函数，或者任何以 db 开头的函数，引擎则认为是直接输出文本 isEmpty是 Beetl 的一个函数，用来判断变量是否为空或者是否不存在 文件名约定为类名，首字母小写 使用： 123User query = new User();query.setName(\"NewName\");List&lt;User&gt; list = sqlManager.select(\"user.selectSample\", User.class, query); MapperBeetlSQL 提供 Mapper 功能, 能将 md 文件的 sqlld 映射为方法名 BaseMapper是 BeetlSQL提供的一个内置 Dao接口，内置了多种增删改查方法，包含如下: Insert 插入实体对象到数据库 insertTemplate，插入实体到数据库， 只插入非null属性 insertBatch， 批量插入实体 updateByld，按照主键更新实体 updateTemplateByld，按照主键更新实体，只更新非null的属性 deleteByld，按照主键删除实体，一些大型应用严格来说禁止删除，参考 BeetlSQL 官网了解如何定制 BaseMapper，不提供 deleteByld方法 unique，根据主键查询实体，如果没有找到，抛出Runtime异常 single，根据主键查询实体，如果没有找到，返回 null lock, 根据主键使用数据库悲观锁， 相当于select * from table where id = ? for update all， 返回所有实体 allCount，所有实体的个数 template， 查询符合模板的所有实体 templateOne，查询符合模板的第一个实体 execute，执行一个 JDBC查询， 在 Java中提供一个 SQL语句 executeUpdate，执行一个 JDBC 更新操作，在 Java 中提供一个 SQL 语句 使用实体按照 NameConverson指定的命名约定对应一个普通的 JavaBean 即可 BeetlSQL 井不要求列名能和实体的属性名一一对应， SQL 操作的时候, 选取列名和属性名的 “交集”来操作 SQLManager 内置 CRUD内置的插入 API insert insertTemplate insertBatch 内置的更新(删除) API updateByld updateTemplateByld updateBatchTemplateByld updateByldBatch 内置的查询 API all allCount template templateOne template unique single templateCount 代码生成方法BeetlSQL 能自动生成表对应的实体、 Dao 操作和 md 文件 md 文件里包含了相关 SQL 查询语句: genPojoCodeToConsole genSQLTemplateToConsole genPojoCode genSQLFile genAll 使用sqlld有些业务系统的数据库操作比较复杂，通常 SQL有很多行， 拼接 SQL的条件也较为复杂 BeetlSQL 支持将SQL放到 md 中，有以下好处: md格式本身比较简单， 适合阅读书写 与 BeetlSQL 类似的 MyBatis 采用 XML 格式来维护, md 比 XML 更合适 SQL 语句，因为没有像 XML 那样过多的格式控制，还有SQL中的 &lt;符号是特殊符号，放在XML中必须转义 md 编辑器 比较丰富， 也支持导出到其他格式，方便项目所有人员阅读 md 文件命名针对数据库中每一个表或者视图对应的实体 POJO，都可以创建一个同名且首字母小写的 文件名，放在默认 的 SQL 目录下 比如数据库表SYS_USER，对应的POJO是SysUser，可以在 SQL目录下创建sysUser.md文件 md 文件构成调用 sqlld 查询类接口 select selectSingle selectUnique intValue 插入方法 更新方法 翻页查询BeetJSQL 提供一个 PageQuery对象用于 SpringBoot应用的翻页查询 。它为查询提供参数、查询范围、排序 TailBeanBeetlSQL 提供 TailBean类，POJO类继承此类后，SQL查询结果集映射不到的字段将会放 到此类中，称之为混合模型 ORM 查询其他API 直接执行 SQL模板语句 SQLReady BeetlSOL 的其它功能 SQL 模板语句常用函数和标签 主键 BeetlSQL 常用注解 NameConvesion， 命名转化类 悲观锁和乐观锁","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (4) 视图技术","slug":"SpringBoot2-4","date":"2018-12-21T18:23:20.000Z","updated":"2020-07-25T02:57:18.167Z","comments":true,"path":"2018/12/22/SpringBoot2-4/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-4/","excerpt":"","text":"Beetl 模板引擎特点: 功能完备 语法和使用习俗简单, 类似 JavaScript 语法和习俗 超高的性能 易于整合 支持模板单独开发和测试 扩展和个性化。 Beet!支持自定义方法、格式化函数、虚拟属性、标签和 HTML 标签。同时 也支持自定义占位符和控制语句起始符号。 依赖beetl-framework-starter 定界符号和占位符Beetl 支持自定义定界符号和占位符号 ， 默认使用&lt;%%&gt;作为定界符号，使用${}作为占位符号 变量全局变量全局变量即通过 Model 或者 ModelAndView传入的变量，可以在模板或者子模板中使用。 默认的全局变量: request 中所有的 attribute 在模板中可以直接通过 name 来引用，比如在 Controller 层 request.setAttribute(”user”，user)，则在模板中可以 直接用 ${user.name}。这里也包括 Model 或者 Mode!AndView 中的所有变量，都会成为模板的 全局变量 Session 提供了 Session 会话，模板通过 session[”name”]或者 session.name 引用 Session 中的变量。注意， Session 并非 Serviet 中的标准 Session 对象。参考 Serviet 来获取HTTP Session request，标准的 HTTPServletRequest，可以在模板中引用 request 属性 (getter)，如 ${request.requestURL} parameter， 读取用户提交的参数，如${parameter.userld} ctxPath, Web 应用中的 ContextPath。 在 Spring Boot 中， 应用默认是“/” 。 通过 application.properties 的属性 server.context-path 可以配置。 servlet, WebVariable 的 实例，包含了 HTTPSession、 HTTPServletRequest、 HTTPServlet­ Response 三 个属性，模板中可以通过 request、 response、 session 来引用，如 ${servlet.request.requestURL} 所有 groupTemplate 的共享变量 局部变量在模板中定义的变量，只能在当前模板中使用，无法在子模板中使用: 12@var salary = user.salary*2;&lt;span&gt;$&#123;user .name&#125;&lt;/span&gt; Beet! 定义变量的方式与 JS 类似 共享变量类似全局变量，可以在任何模板中使用，需要通过 groupTemplate 的 API 添加 模板变量变量的内容是模板对应的输出 表达式计算表达式类似 JS， 支持+、 、气/、%等表达式，变量的类型与相应的 Java类型一致 逻辑表达式Beetl 支持类似 JavaScript、 Java 的条件表达式，如〉、〈、二、 !=、〉=、&lt;=、 以及三元表达式等 控制语句循环语旬Beetl 支持多种循环方式，最常用的是 for···in 循环语句 for···in循环支持 elsefor 语法，即如果未进入循环体，则执行 elsefor部分 for(exp;exp,exp) while(exp) 条件语旬if else switch case break try catch函数调用Beet!内直了大量的常用函数以辅助模板渲染、规则引擎等功能， 函数调用方法与 JS一样。 当然也可以注册自定义 的 函数，自定义函数可以通过 Java 来实现 ，或者通过 Beet! 本身来实现。 Beetl 提供的常用函数如下 : print和 println，输出对象，如果对象为空，则不输出。 has，判断是否具有这个全局变量，如 if(has(userList)){….}，判断 后台是否提供了 userList 变量 。 isEmpty，判断变量或者表达式是否为空，如果不存在，为 null，都返回 true:同时如 果字符串空，集合空也返回 true; isNotEmpty 则相反。 debug，在控制台打印变量或者表达式。此方法还会附带此调用所在的文件和模板，以及变量的名字等信息，方便追踪 。 date，日期函数，获得当前日期。 trim，截取一个日期或者数字类型井返回字符串，如trim(126.l8,1)返回字符串 126.18, 位im(date(),’yyyy’)返回年份 2017。 parseInt、parseLong、parseDouble，将字符串或者 number转为对应的类型 global，返回一个全局变量值，参数是一个字符串，如 varuser= global(“user_”+i) cookie，返回指定的 cookie对象， 如 var userCook = cookie(”user”),allCookies = cookie() strutil.* 系列函数，对字符串的操作，如 strutil.split(“abc,def”,”,”)将返回一个字符串数组，具体参考Beetl使用手册 array.*， 集合的相关函数 ，如 array.contain shiro.* Spring是常用的安全框架，并非是Beetl的内置函数(参考官网手册) spring.* Spring框架中可以使用的一系列函数，比如 spel表达式 reg.*，正则表达式的相关函数 格式化函数格式化的格式是${exp,formatName=”可选参数”} 直接调用Java可以在模板中以 Java方式调用表达式，使用的时候，必须在表达式前使用@符号以表示其 后表达式是 Java 风格的 标签函数所谓标签函数，即允许处理模板文件中的一块内容，功能等同于 jsp tag HTML 标签HTML 是一种特殊的标签函数， Beetl 在形式上与HTML标签类似， Beetl 默认通过#符号 来区分 Beetl的HTML标签 安全输出Beetl 在变量表达式后面使用符号“!”来提醒 Beetl 此变量可能不存在，表达式将返回“ ! ” 后的表达式值，如果其后没有表达式，则返回 null。 高级功能配置 Beetl在 resources 下添加 beetl.properties 文件来个性化 Beetl 自定义函数自定义方法可以通过 Function接口的 call方法实现 自定义格式化函数自定义标签函数自定义 HTML 标签布局布局是保持模板重用的最重要的功能之一， Beet) 可以联合 include 和 layout 来实现重用 AJAX局部渲染脚本引擎Beetl 是模板引擎，但本质上还是一个脚本语言，它在解析阶段会将模板转化为 Beetl 脚本执行。groupTemplate 提供了执行脚本的功能，并能获取到返回值 JSON 技术在 Controller 中，方法注解为@ResponseBody，则 自动将方法返回的对象序列化成 JSON。 MVC分离开发Beetl提供了 WebSimulate来支持这种分离","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (3) MVC","slug":"SpringBoot2-3","date":"2018-12-21T16:27:44.000Z","updated":"2020-07-25T02:57:18.167Z","comments":true,"path":"2018/12/22/SpringBoot2-3/","link":"","permalink":"https://jigangduan.github.io/2018/12/22/SpringBoot2-3/","excerpt":"","text":"MVC 框架会处理如下技术需求 : HTTP URL 映射到 Controller某个方法 HTTP 参数映射到 Controller 方法的参数上，比如参数映射到某个 Java 对象，或者上 传附件映射到某个 File对象上: 参数的校验; MVC 错误处理 MVC 中如何调用视图 MVC 中如何序列化对象成 JSON 拦截器等高级定制 集成MVC框架引入依赖1234&lt;depeηdency&gt; &lt;groupid&gt;org.springframework.boot&lt;/groupid&gt; &lt;artifactid&gt;spring-boot-starter-web&lt;/artifactid&gt;&lt;/dependency&gt; Beetl 模板 12345&lt;dependency&gt; &lt;groupid&gt;com.ibeetl&lt;/groupid&gt; &lt;artifactid&gt;beetl-framework-starter&lt;/artifactid&gt; &lt;version&gt;1.1.15.RELEASE&lt;/version&gt;&lt;/dependency&gt; Web 应用目录结构 resources/templates 模板文件 resources/static 静态资源文件，如 JS、 css、图片 视图名自动在 templates 目录下找到对 应的模板名称，模板中使用的静态资源将在 static 目录下查找 Java 包名结构 Controller 一一 此包下包含了 MVC 的 Controller Service 一一 此包下有业务处理代码 entity 一一 包含了业务实体 conf 一一 包含了一些配置类，比如用于配置数据源的 DataSourceConfig Controller类上声明@Controller， 标注这是一个 Controller @RequestMapping 映射 HTTP 请求到特定的方法处理类.@RequestMapping 既可以作用在方法上 ， 也可以作用在类上 返回的是 JSON 字符串，如果想直接返回内容而不是视图名 ，则需要在方 法上使用@ResponseBody URL映射到万法@RequestMapping来映射 URLRequestMapping 属性: value，请求的 URL 的路径，支持 URL模板、正则表达式 注解PathVariable作用在方法参数上，用来表示参数的值来自于 URL 路径 有通配符的低于没有通配符的， 比如/user/add.json 比/user/*.json优先匹配 有“*”通配符的低于有““通配符的 使用${}来获得系统的配置或者环境变量 method, HTTP 请求方法，有 GET、 POST、 PUT 等 GET，用来获取 URL 对应的内容 POST，用来向服务器提交信息, 语义上新增操作 HEAD，同 GET，但不返回消息体，通常用于返回 URL 对应的元信息，如过期时间等 PUT， 同POST，用来向服务器提交信息，但语义上更新操作 DELETE，删除对应的资源信息 PATCH方法， 类似PUT方法，表示信息的局部更新简化的@RequestMapping @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping consumes，允许的媒体类型(Media Types)，如 consumes=&quot;application/ison&quot;， 对应于请求的HTTP的 Content-Type produces，相应的媒体类型，如 produces=&quot;application/json&quot;， 对应于 HTTP 的 Accept宇段 params ，请求的参数 ，如 params=&quot;action=update&quot; 方法参数Controller方法可以接受多种类型参数 @PathVariable，可以将URL中的值映射到方法参数中 Model, Spring 中通用的 MVC 模型，也可以使用 Map 和 ModelMap 作为渲染视图的模型 ModelAndView，包含了模型和视图路径的对象 JavaBean，将 HTTP 参数映射到 JavaBean 对象 MultipartFile，用于处理文件上传 @ModelAttribute，使用该注解的变量将作为 Model的一个属性 WebRequest 或者 NativeWebRequest，类似 Servlet Request，但做了一定封装 java.io.InputStream 和 java.io.Reader，用来获取 Servlet API 中的 lnputStream/Reader java.io.OutputStream/java.io.Writer，用来获取 Servlet API 中的 OutputStream/Writer HttpMethod， 枚举类型 ， 对应于 HTTP Method，如 POST、 GET @MatrixVariable，矩阵变量 @RequestParam， 对应于 HTTP请求的参数，自动转化为参数对应的类型 @RequestHeader，对应于 HTTP请求头参数，自动转化为对应的类型 @RequestBody， 自动将请求内容转为指定的对象 ， 默认使用 HtψMessageConverters 来转化 @RequestPart，用于文件上传，对应于 HTTP 协议的 multipart/form-data @SessionAttribute， 该方法标注的变量来自于 Session 的属性 @RequestAttribute，该标注的变量来自于 request 的属性 @InitBinder，用在方法上，说明这个方法会注册多个转 化 器，用来个性化地将 HTTP 请求参数转化成对应的 Java对象，如转化为日期类型、浮点类型、JavaBean等，当然，也可以实现 WebBindinglnitializer接口来用于 SpringBoot应用所需要的 dataBinder BindingResult和 Errors， 用来处理绑定过程中的错误 验证JSR-303注解用来验证 Bean 的属性: 空检查 @Null， 验证对象是否为空 @NotNull， 验证对象不为空 @NotBlank， 验证字符串不为空或者不是空字符串， 比如””和””都会验证失败 @NotEmpty， 验证对象不为 null，或者集合不为空 长度检查 @Size(min=, max=)，验证对象长度，可支持字符串、集合 @Length， 字符串大小 数值检测 @Min，验证数字是否大于等于指定的值 @Max，验证数字是否小于等于指定的值 @Digits，验证数字是否符合指定格式，如@Digits(integer=9，fraction=2) @Range，验证数字是否在指定的范围内，如@Range(min=l, max=lOOO) 其他 @Email， 验证是否为邮件格式，为 null 则不做校验 @Pattern， 验证 String对象是否符合正则表达式的规则 group, 只有 group匹配的时候，校验注解才能生效 @Validated参数使用@Validated注解，将触发 Spring的校验， 井将验证结果存放到 BindingResult对象中 BindingResult 包含了验证结果，提供了如下方法 : hasErrors，判断验证是否通过 : getAllErrors，得到所有的错误信息，通常返回的是 FieldError列表 自定义校验@Constraint 注解声明用什么类来实现验证 验证注解必须要提供如下信息 : message， 用于创建错误信息，支持表达式，如“错误， 不能超过(max) 小时” groups，验证规则分组， 比如新增和修改的验证规则不一样，分为两个组，验证注解必须提供 payload， 定义了验证 的有效负荷 WebMvcConfigurer拦截器addlnterceptors 设置多个拦截器 跨域访问addCorsMappings 格式化addFormatters 注册 ControlleraddViewController ddRedirectViewController 视图技术FreemarkerFreemarker 会自动添加后缀 负l 来寻找匹配 的 userlnfo.ftl 模板 Beetl语法和使用习惯参考了 JS JacksonJSON的序列化和反序列化 Redirect重定向请求 foward用来在 Controller执行完毕后，再执行另外一个 Controller 的方法 通用错误处理Controller中抛出的异常默认交给了/error来处理，应用程序可以将/error映射 到一个特定的 Controller 中处理来代替 Spring Boot 的默认实现 ， 应用可 以继承 AbstractEirnr°Controller 来统一处理系统的各种异常 AbstractErrorCon位oiler 提供 了多个方法可以从 request 中获取错误信息: timestamp， 错误发生的时间 status， 对应于 HTTP Status， 如 404 error， 错误消息， 如 BadRequest、 NotFound message， 详细错误信息 exception， 如果应用抛出有异常，exception是字符串，代表异常的类名 path，请求的 URI errors, @Validated 校验错误的时候 ， 校验结果信息放到这里 @Service 和@TransactionalService中处理 业务逻辑, 定义一个业务的接口 @Transanhl来让 Service参与事务管理 事务上下文 : 对于 Service 调用，如果处于同一个事务上下文，那么对数据库的操作会在一个事务中。事务上下文的开启是从 Contralle「中调用坦问 ice 方法的时候自动开启的， 并在调用此方法后自动结束从而提交事务，或者根据抛出的 RuntimeException 来自动回滚，调用过程中调用的其他 Service 方法都会处于这个事 务上下文中。可以在事务上下文中再次开启一个新的事务上下文，这时候通过注解@ Transactiona1 (propagation = Propagation.REOUIRES_NEW)完成，比如在 AuditService 中，审计服务无 论业务调用是否成功，都必须把审计信息存储到数据库中，因此 AuditService 可以配置 为开启新的事务上下文 。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (2) 基础","slug":"SpringBoot2-2","date":"2018-12-21T15:27:17.000Z","updated":"2020-07-25T02:57:18.166Z","comments":true,"path":"2018/12/21/SpringBoot2-2/","link":"","permalink":"https://jigangduan.github.io/2018/12/21/SpringBoot2-2/","excerpt":"","text":"开发工具 JDK8+ Maven 使构建项目变得很容易， Maven 屏蔽了构建的复杂过程。比如，你只需要输入 maven package 就可以构建整个 Java 项目。 统一了构建项目的方式，不同人、不同公司的项目都有同样的描述项目和构建项目的 方式， Maven 通过 pom.xml 来描述项目，井提供一系列插件来构建项目 。只要熟悉了 Maven，就熟悉了所有项目的构建方式 。 提出了一套开发项目的最佳实践，而不用每个项目都有不同结构和构建方式，比如源 代码在 src/main/iava 中，测试代码则在 src/test/iava 中，项目需要的配置文件则放在 src/main/resources 中。 包含不同环境项目的构建方式。 解决了类库依赖的问题，只需要声明使用的类库， Maven 会自动从仓库下载依赖的 jar包，并能协助你管理 jar包之间的冲突。 pom.xrnl，用 XML 方式描述了项目模型， porn通常有以下元素: groupId: 表示项目所属的组，通常是一个公司或者组织的名称，如 org叩ringframework。 artifactld: 项目唯一的标识，比如，有 spring-boot-starter-web、 spring-boot-devtools、groupId 和 artifactld 能唯一标识一个项目或者一个库，我们通常称之为项目坐标 。 packaging: 项目的类型，常用的有jar和 war两种， jar表示项目会打包成一个jar包， 这是 SpringBoot的默认使用方式。 version: 项目的版本号 ，比如 0β.1割 APSHOT、 1.5.2.RELEASE。 SNAPSHOT 表示开发中的版本，会修复 bug 和添加新 功能 RELEASE 表示的是一个正式发布版 M1,M2(M 指 里程碑 ， 即将发布) RC(Release Candidate，发布候选) GA(general availability，基本可用版本)SNAPSHOT&lt;ml&lt;m2...&lt;RC&lt;GA&lt;Realease modelVersion: 代表 pom 文件的 Maven 的版本，如写作的时候 Maven 的 modelVersion是 4.0.0。 dependencies:此元素下包含了多个 dependency，用来声明项目 的依赖，这是 porn 最 核心的部分。 dependency: 包含在 dependencies 中，用 来声 明项目的依赖，比如项目用到的 MySQL 驱动。 scope: scope 代表此类库与项目的关系 compile 默认,编译和打包都需要此 类库 test 表示仅仅在单元测试的时候需要 provided 表示在编译阶段需要此类库，但 打包阶段不需要，这是因为项目的目标环境己经提供了 runtime表示在编译和打包的 时候都不需要，但在运行的时候需要，比如某个指定的数据库驱动，编译和打包都不 需要 ，但测试应用要连到数据库 时就 需要此数据库驱动 。 build: 此项在 pom 中可边， build包含了多个插件 plugin，用来辅助项目构建 Maven 常用命令 mvn compile: 编译 Maven 工程 mvn package: 编译井打包工程， 根据 pom.xml 中元素 packaging是jar还是 war进行打包 mvn install:打包井安装到本地仓库 mvn deploy: 同 install，但打包井安装到远程仓库 mvn clean: 删除 target 目录 Spring 核心技术Spring 容器Spring IoCIoC (Inversion ofControl，反向控制〉原则，更为形象的称呼是 DI (dependency injection，依赖注入)。相对于Bean直接构造依赖的对象， Spring框架则根据Bean之间的依赖关系创建对象，并注入到 Bean 中。 Spring 常用注解 Controller: 声明此类是一个 MVC 类，通常与@RequestMapping 一起使用 Service: 声 明此类是一个业务处理类，通常与@Transactional 一起配合使用 Repository: 声明此类是一个数据库或者其他 NoSQL 出问类。 RestController: 同 Controller， 用于 REST 服务。 Component:声明此类是一个 Spring管理的类，通常用于无法用上述注解描述的 Spring管理类。 Configuration: 声明此类是 一个配置类，通常与注解@Bean 配合使用。 Bean: 作用在方法上，声明该方法执行的返回结果是一个 Spring 容器管理的 Bean。 Spring 负责实例化 Bean， 开发者可 以提供一系列回调函数 ，用于进一步配置 Bean， 包括@PostConstruct 注解和@PreDestory 注解。 当 Bean 被容器初始化后，会调用@PostConstruct 的注解方法 在容器被销毁之前，调用被 @PreDestory 注解的方法 引用Bean: 使用注解@Qualifier来引用, 根据名字 过@Autowired 声明对其他 Bean 的引用, 作用于属性或者构造函数参数，甚至是方法调用参数上。 Spring AOPAOP (Aspect-Oriented Programming，面向切面编程)提供了另外一种思路来实现应用系统 的公共服务 。 每个业务方法调用的权限管理: 在用户调用方法前判断用户是否有权调用此方法 每个方法调用的审计: 记录谁调用了什么业务方法，传入参数是什么，操作是否成功。 数据库事务的管理: 在执行数据库一系列操作前，先开启事务，在执行完后提交事务: 如果执行出错，则回滚事务。 缓存: 对业务方法返回的数据进行缓存，下次调用的时候，如果参数未变，直接从缓 存中获取数据，而不再调取应用方法。 AOP 有如下术语: Aspect: Aspect声明类似于 Java 中的类声明，在 Aspect 中会包含一些 Pointcut及相应 的 Advice Jointpoint: 表示在程序中明确定义的点，典型的包括方法调用、对类成员的访问， 以及异常处理程序块的执行等。 Spring 中的 Jointpoint 只支持方法调用。 Pointcut: 表示一组 Joint point， 如方法名、参数类型、返回类型等，这些 Joint point 通过逻辑关系组合起来， 它定义了相应的 Advice将要发生的地方。简单理解 Pointcut(一种表达式) 一一用来判断在 Jointpoint (方法调用)中执行 Advice (操作)。 Advice: Advice 定义了在 Pointcut里面定义的程序点具体要做的操作， 它通过 before、 around、 after ( return、 throw、 finally)来区 别 是在每个 Joint point 之前 、 之后还是执 行前后要调用的代码。 before: 在执行方法前调用 Advice，比如 cache功能可以在执行方法前先判断是否 有缓存。 around: 在执行方法前后调用 Advice， 这是 Spring 框架和应用系统一种最为常用 的方法， after: 在执行方法后调用 Advice, after return是方法正常返回后调用 ， after throw 是方法抛出异常后调用 。 finally: 方法调用后执行 Advice， 无论是否抛出异常还是正常返回 AOPproxy: AOPProxy也是Java对象，由AOP框架创建， 用来完成上述的动作， AOP对象通常可以通过 JDKd归amicproxy完成，或者使用 CGLib完成。 Weaving: 实现上述切面编程的代码织入， 可以在编译时刻(通过 AspectJ compiler),也可以在运行时刻， Spring和其他大多数Java框架都是在运行时刻生成代理。 spring-boot-starter-aop","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"Spring Boot 2精髓 - (1) JavaEE简介","slug":"SpringBoot2-1-JavaEE","date":"2018-12-21T13:48:39.000Z","updated":"2020-07-25T02:57:18.166Z","comments":true,"path":"2018/12/21/SpringBoot2-1-JavaEE/","link":"","permalink":"https://jigangduan.github.io/2018/12/21/SpringBoot2-1-JavaEE/","excerpt":"","text":"Java EEJava EE 架构Java EE 是一种企业应用的软件架构 。 作为企业应用或者互联网应用的架构， 总有如下功能需求， JavaEE有相应的规范实现与之 对应 。 Web 支持 : 企业应用、互联网应用越来越多的是基于 B/S 的结构， Java EE 对应的有Serviet规范，规定了 Web 容器、 Serviet 组件 ， 还设有 JSP&amp;JSTL 处理动态页面 。 事务支持: 提供事务管理器，支持管理事务，如单一数据库、 多个数据库，以及数据 库和其他资源的事务协作等。 Java EE里提供了 JTA事务 API和 JTS事务服务规范。 事务支持也实现了分布式事务管理， 管理多个数据库或者支持事务的资源。 消息服务: 企业各个系统、 系统模块之间通过消息服务进行并步交互， JavaEE提供了 JMS 服务 ， 用于系统间可 靠 的消息交互 。 数据库持久层: JavaEE先有 EJB规范， 后来又提出了更有实际操作性的 JPA， 这些都 是企业访 问数据库常用的方法 。 Container: 提供了 WebContainer， 用于实现 Serviet，以及 EJB Container，实现 EJB, Container用于管理这些组件，并提供组件需要的服务， 比如 JTS、 JMS等。 其他技术还包括如下所述 的内容: JWS: 这也是分布式系统交互的一种方式， 是 Java实现的一种 WebService。 JAX-RS: Java EE 6 引入的新技术，通过 阻 ST 进行交互 。 JNDI: 查找服务和对象的接口，如查找一个配置好的数据源。 JAXP/JAXB: XML流行的时候，解析和绑定JavaBean的XML工具。 JAX-RPC:分布式系统交互的一种方式，通过 RPC 方式调用 。 JACC: 安全认证。 Java EE Application Server:提供了上述所有服务的 Web 服务器，我们常用的 Tomcat、 Resin， 只能算是 Java EE Web 服务器，开源的 JBoss、商业的 weblogic 等称为应用服 务器。 Java EE 的缺点 过于复杂: JavaEE针对的是复杂的分布式企业应用，然而现实情况是大部分应用都比较简单，复杂的架构带来了复杂的开发方式和部署方式(早期的 Java EE 普通系统打包部署都需要数十分钟) 。 追求分布式:大部分应用并非都是 Java EE 假定的分布式系统，像 EJB、 JMS、 JWS 等技术实现门槛又高又容易出错。 Spring 曾经反对过这种分布式架构，井只提供了容 器管理，因此获得了巨大成功。 大型应用采用分布式架构不可避免， Spring 提供了其 他的技术支持，比如支持阻 RESTFul 架构 。 不能及时与流行开源技术结合 :比如消息处理，除了有标准的 JMS 支持，现在还有性能更好的 RabbitMQ 和 Kafkao Java EE 并没有与之相应的标准，反而是Spring，具有统一的实现消息处理模式，无论用的是JMS、RabbitMQ，还是性能更好的 Kafka，都能快速上手。 Java EE 应用服务器通常由商业公司提供，价格不菲，少有公司采用。管理应用服务器和部署应用对初学者和自学者有一定门槛 。 SpringSpring 是为了解决应用复杂性而产生的框架 Spring 只提供了两种机制，控制反转(IoC)和面向切面(AOP)，来提供任意的服务和增强 Bean 的任意特性，使得 Spring 本身容易掌握，又可以通过 Bean 管理来无限扩展功能 。 SpringloC容器和AOPloC Core Container: Spring Container 负责管理你的任意对象，并结合你对对象的描述进行初始化和加强。 比如，对于 一个用注解@Controller 声明的对象， Spring 会认为这个对象是个 Web Controller，如果这个对象里的方法有@RequestMapping注解，则会将客户端发起的 HTTP 请求转化成 Java方法调用 。 如常见的@Service 注解对象，通常用来处理业务逻辑 ， Spring Container往往会增强这类对象的事务控制能力 。 容器管理还可以 为被管理的Bean 提供其他被管理和被增强的Bean. AOP: 面向切面编程，通过预编译方式或者运行时刻对目标对象动态地添加功能。 AOP 分离了 企业应用的业务逻辑 和 系统级服务，比如事务服务，还有应用系统的审计、安全访问等代码。 Spring 的缺点 使用门槛升高，要入门Spring需要较长时间。 对过时技术兼容，导致使用复杂度升高。 XML 配置已经不是流行的系统配置方式。 集成第三方工具时候，程序员还要考虑工具之间的兼容性。 系统启动慢，不具备热部署功能，完全依赖虚拟机或者 Web 服务器的热部署。 Spring BootSpring Boot 管理 Spring容器、第三方插件，并提供很多默认系统级的服务。 Spring Boot提供的常用 Starter: 名称 作用 spring-boot-starter-web Web开发支持， 默认使用 Tomcat8 spring-boot-starter-aop AOP开发支持，使用 AspectJ spring-boot-starter-jdbc Spring JDBC spring-boot-starter-data-jpa JPA 方式访问数据库，使用Hibernate 作为JPA实现 spring-boot-starter-data-elasticsearch 集成Elasticsearch, 默认访问 localhost:9200 spring-boot-starter-data-redis 集成Redis, 使用JRedis，默认连接 localhost:6379 spring-boot-starter-cache 缓存，支持多种缓存方式 ，如本地的、Redis、Ehcache 等 spring-boot-devtools 应用程序快速重启的工具 ，提升开发体验 spring-boot-starter-data-mongodb 集成Mongodb,默认访问 mongodb://localhos/test spring-boot-starter-data-neo4j 集成neo4j,默认访问 localhos:7474 spring-boot-starter-data-gemfire 集成分布式缓存 spring-boot-starter-data-solr 基于 Apache lucene 的搜索平台 ，默认访问 http://localhost:8983/solr spring-boot-starter-data-cassandra 集成 Cassandra，默认访问 localhost:7474 spring-boot-sta此er-data-ldap 集成 ldap spring-boot-starter-activemq 消息集成 ActiveMQ 支持 spring-boot-starter-amqp 消息集成AMQP协议支持，如支持 RabbitMQ spring-boot-starter-jta-atomikos 分布式事务支持，使用atomikos spring-boot-starter-jta-bitronix 一个开源的分布式事务支持 spring-boot-starter-test 包含 JUnit、 SpringTest、 Hamcrest、 Mockito 等测试工具 spring-boot-starter-webservices webservice 支持 spring-boot-starter-websocket websocket支持 spring-boot-starter-jersey REST 应用和 Jersey 支持 spring-boot-starter-freemarker Freemaker支持 优点 : 实现约定大于配置，是一个低配置的应用系统框架。不像 Spring那样地狱般的配置体验，Spring Boot 不需要配置或者极少配置，就能使用 Spring 大量的功能。 提供了内置的 Tomcat 或者 Jetty 容器。 通过依赖的 jar包管理、自动装配技术，容易支持与其他技术体系、工具集成。 支持热加载，开发体验好。也支持 Spring Boot 系统监控，方便了解系统运行状况。 Hello, Spring Boot创建Maven工程 —— pom.xml文件Web支持 —— spring-boot-starter-web spring-boot-dependencies 默认会使用内置的 Tomcat，井支持 Spring MVC、 RESSTFul 服务。 pom.xml: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bee.sample&lt;/groupId&gt; &lt;artifactId&gt;ch1.helloworld&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 为web应用程序添加典型的依赖项 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 作为可执行jar包 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 示例代码Ch1Application.java 12345678910111213package com.bee.sample.ch1;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Ch1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Ch1Application.class, args); &#125;&#125; HelloworldController.java 1234567891011121314151617package com.bee.sample.ch1.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.bee.sample.ch1.annotation.Function;@Controllerpublic class HelloworldController &#123; @RequestMapping(\"/sayhello.html\") @Function() public @ResponseBody String say(String name)&#123; return \"hello \"+name; &#125;&#125; 启动 ChlApplication 程序, 打开浏览器，访问地址 http://127.0.0.1:8080/say.html，可以看到输出了“ Hello Spring Boot”。 使用热部署spring-boot-devtools， 它能在修改类或者配置文件的时候自动重新加载 Spring Boot 应用 支持RESTUserReditRestController.java 12345678910111213141516171819202122package com.bee.sample.ch1.rest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;/** * 注解RestController相当于注解Controller和ResponseBody的合体。 * 试试诡异制造如下问题: * 1 更改getCreditLevel名字为getCreditLevelTest * 2 /usercredit/&#123;id&#125; 更改为 /usercredit/&#123;id1&#125; * */@RestControllerpublic class UserReditRestController &#123; @RequestMapping(value=\"/usercredit/&#123;id&#125;\") public Integer getCreditLevel(@PathVariable String id) &#123; return Integer.parseInt(id); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"}]},{"title":"httpie","slug":"httpie","date":"2018-12-21T08:38:35.000Z","updated":"2020-07-25T02:57:18.207Z","comments":true,"path":"2018/12/21/httpie/","link":"","permalink":"https://jigangduan.github.io/2018/12/21/httpie/","excerpt":"","text":"HTTPie—aitch-tee-tee-pie—是一个命令行HTTP客户端，具有直观的UI、JSON支持、语法高亮显示、类似wget的下载、插件等。 HTTPie由一个单独的http命令组成，该命令被设计用于与http服务器、RESTful api和web服务进行无痛调试和交互: 合理的默认值 表达和直观的命令语法 彩色和格式化的终端输出 内置的JSON支持 持久会话 表单和文件上传 HTTPS、代理和身份验证支持 支持任意请求数据和标题 Wget-like下载 扩展 支持Linux、macOS和Windows 和更多… 安装 Mac: 1brew install httpie","categories":[{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/tags/工具/"},{"name":"httpie","slug":"httpie","permalink":"https://jigangduan.github.io/tags/httpie/"}]},{"title":"ORY编辑器","slug":"ory-editor-readme","date":"2018-12-14T23:48:17.000Z","updated":"2020-07-25T02:57:18.224Z","comments":true,"path":"2018/12/15/ory-editor-readme/","link":"","permalink":"https://jigangduan.github.io/2018/12/15/ory-editor-readme/","excerpt":"","text":"下一代，高度定制的内容编辑器为浏览器-React和Redux。所见即所得。https://ory-editor.aeneas.io ORY编辑器是一个智能、可扩展和现代的编辑器(“所见即所得”)，用于用React编写的web。如果您受够了contenteditable的限制，那么您是正确的。 ORY编辑器用于德国最大的电子学习网站www.serlo.org(每月约800k uniques)，以改善wiki的体验。 查看演示在ory-editor.aeneas.io! 重要的: 此编辑器是预发布的，不能保证向后兼容。它是由它的作者和核心维护者Aeneas Rekkas作为一个个人项目进行维护的 介绍我已经在维基百科学习了将近十年。这段经历和学到的教训让我踏上了构建ORY编辑器的征程。我想让web上的内容编辑变得简单，并通过技术丰富开放源码社区，从而显著地改变web上的内容创建和编辑方式。 有什么问题?我必须意识到，现有的开源内容编辑解决方案存在以下三个缺陷之一: 制作的标记非常可怕，必须进行许多安全工作，XSS总是一个威胁. 作者必须学习特殊的上层标签，如markdown，才能产生内容。这些基于文本的解决方案通常无法指定布局，而且像表这样的复杂数据结构很难编辑. 基于contenteditable的编辑器无法使用布局 (e.g. flexbox 或 浮动网格). 所以有什么不同?我们的结论是，解决办法必须符合下列原则: 该状态是一个规范化JSON对象，不涉及HTML。 它是一个不需要编程经验或特殊培训的可视化编辑器。 它是由一家公司建造的，减少了被遗弃的可能性。 基于可重用的React组件，它为开发人员、作者和设计人员提供了新的合作方式，从而更容易地创建更好更丰富的体验。 它适用于移动和触控设备。 带着这些原则，我们出去实现了ORY编辑器，也就是您现在看到的编辑器。 快速入门目前的重点是优化使用React的ORY编辑器。将来不需要React的版本可能会在某个时候发布. 请检查 ReactJS 教程! 1$ npm install --save ory-editor 请注意: ory-editor包是一种元包。它包括核心、默认ui和一些官方支持的插件。使用这个包主要是为了方便. 文档查看gitbook的用户指南. 如何运行、开发和贡献您希望运行、开发或向ORY编辑器提供内容吗?为此，您需要在系统上安装Node。按照下面的方式使用git签出这个存储库 12$ git clone https://github.com/ory/editor.git$ cd editor 安装依赖关系ORY编辑器是monorepo，您可以使用它初始化: 1$ yarn i 要正常工作，您需要yarn. 运行示例如果您想熟悉编辑器，这里有一些例子是一个很好的起点。要运行示例，请使用以下命令之一 123$ yarn run build$ cd examples$ yarn run start 运行工具链工具链包含测试、eslint和流类型。强烈建议在开发时运行此工具链. 12345678# run the tests in watch mode$ yarn run test:watch# run eslint in watch mode$ yarn run lint:watch# run flowtype in watch mode$ yarn run flow:watch 运行该文档要在watch模式下运行指南，请执行: 1$ yarn run docs:guide To generate API docs, run: 1$ yarn run docs:api","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"GitHub精选","slug":"前端/GitHub精选","permalink":"https://jigangduan.github.io/categories/前端/GitHub精选/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"editor","slug":"editor","permalink":"https://jigangduan.github.io/tags/editor/"},{"name":"github","slug":"github","permalink":"https://jigangduan.github.io/tags/github/"},{"name":"sites","slug":"sites","permalink":"https://jigangduan.github.io/tags/sites/"}]},{"title":"ORY编辑器 (4)教程","slug":"ory-editor-tutorials","date":"2018-12-14T14:15:14.000Z","updated":"2020-07-25T02:57:18.225Z","comments":true,"path":"2018/12/14/ory-editor-tutorials/","link":"","permalink":"https://jigangduan.github.io/2018/12/14/ory-editor-tutorials/","excerpt":"","text":"ReactJS例子在本节中，我们将创建一个使用ORY编辑器的最小化react应用程序。在我们跳过之前，请确保node.js已安装在您的系统上。 目前，ORY编辑器只能通过npm获得，并且在ReactJS环境中工作得最好。 ReactJS我们的目标是创建一个使用编辑器的ReactJS应用程序。为了在本教程中搭建react应用程序，我们使用create-react-app 12$ npm i -g create-react-app$ create-react-app . 使用npm安装编辑器: 1$ npm i --save ory-editor 接下来，打开文件src/components/App.js，包括ORY编辑器: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123;Component&#125; from 'react'// The editor coreimport Editor, &#123; Editable, createEmptyState &#125; from 'ory-editor-core'import 'ory-editor-core/lib/index.css' // 我们还希望加载样式表// 需要我们的ui组件(可选)。您也可以实现和使用自己的ui !import &#123; Trash, DisplayModeToggle, Toolbar &#125; from 'ory-editor-ui'import 'ory-editor-ui/lib/index.css'// 加载一些示例插件:import slate from 'ory-editor-plugins-slate' // T富文本区插件import 'ory-editor-plugins-slate/lib/index.css' // 丰富文本区域插件的样式表import parallax from 'ory-editor-plugins-parallax-background' // 视差背景图像插件import 'ory-editor-plugins-parallax-background/lib/index.css' // 视差背景图像的样式表require('react-tap-event-plugin')() // react-tap-event-plugin is required by material-ui which is used by ory-editor-ui so we need to call it here// 定义我们想要使用的插件。我们只有板岩和视差可用，所以加载它们.const plugins = &#123; content: [slate()], // 为内容单元格定义插件。要导入多个插件，请使用[slate()，image, spacer, divider] layout: [parallax(&#123; defaultPlugin: slate() &#125;)] // 定义布局单元格的插件&#125;// Creates an empty editableconst content = createEmptyState()// Instantiate the editorconst editor = new Editor(&#123; plugins, // pass the content state - you can add multiple editables here editables: [content],&#125;)class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\"/&gt; &lt;h2&gt;Welcome to React&lt;/h2&gt; &lt;/div&gt; &#123;/* Content area */&#125; &lt;Editable editor=&#123;editor&#125; id=&#123;content.id&#125;/&gt; &#123;/* Default user interface */&#125; &lt;Trash editor=&#123;editor&#125;/&gt; &lt;DisplayModeToggle editor=&#123;editor&#125;/&gt; &lt;Toolbar editor=&#123;editor&#125;/&gt; &lt;/div&gt; ); &#125;&#125;export default App; 就是这样,恭喜你!你现在应该看到这样的东西: 编写插件编写一个内容插件当然，您并不局限于此功能，而且可以轻松编写自己的插件。插件有两个部分，一个插件定义和一个ReactJS组件。一个最小的插件定义如下所示 123456789101112131415import React, &#123;Component&#125; from 'react'// 显然，您并不局限于material-ui，但是我们非常喜欢material-ui svg图标import StarIcon from 'material-ui/svg-icons/toggle/star'// This is the ReactJS component which you can find below this snippetimport InputTextField from './Component'export default &#123; Component: InputTextField, IconComponent: &lt;StarIcon /&gt;, name: 'example/content/input-text-field', version: '0.0.1', text: 'Input Text Field'&#125; 一个极简插件的例子可能是这样的: 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react'// A callback function for the input fieldconst onInput = (onChange) =&gt; &#123; return (e) =&gt; &#123; // Dispatch the onChange action with the new value onChange(&#123; value: e.target.value &#125;) &#125;&#125;const InputTextField = (props) =&gt; &#123; const &#123; state: &#123; value &#125;, readOnly, onChange &#125; = props // If readOnly is false, it means that we are in edit mode! if (!readOnly) &#123; return ( &lt;div className=\"my-plugin\"&gt; &lt;input type=\"text\" onChange=&#123;onInput(onChange)&#125; value=&#123;value&#125; /&gt; &lt;/div&gt; ) &#125; // If we are not in edit mode, remove the input field return ( &lt;div className=\"my-plugin\"&gt; &#123;value&#125; &lt;/div&gt; )&#125;export default InputTextField 当然，还有更多的设置和回调可用。我们鼓励您查看关于这个主题的API文档! 确保onChange prop不会传递给HTML元素(例如{...props})，因为这会用该元素发出的任何更改事件覆盖插件的状态。这适用于内容和布局插件。 编写布局插件当然，您并不局限于此功能，而且可以轻松编写自己的插件。插件有两个部分，一个插件定义和一个ReactJS组件。一个布局插件将需要一个初始的子元素，否则，它将自动被销毁。一个最小的布局插件定义如下所示 12345678910111213141516171819202122232425262728293031323334353637import React from 'react'import slate from 'ory-editor-plugins-slate'// You are obviously not limited to material-ui, but we really enjoy// the material-ui svg icons!import CropSquare from 'material-ui/svg-icons/image/crop-square'const BlackBorderPlugin = (&#123; children &#125;) =&gt; ( &lt;div style=&#123;&#123; border: '1px solid black', padding: '16px' &#125;&#125;&gt; &#123;children&#125; &lt;/div&gt;)export default &#123; Component: BlackBorderPlugin, IconComponent: &lt;CropSquare /&gt;, name: 'example/layout/black-border', version: '0.0.1', text: 'Black border', createInitialChildren: () =&gt; (&#123; id: v4(), rows: [ &#123; id: v4(), cells: [ &#123; content: &#123; plugin: slate(), state: slate().createInitialState() &#125;, id: v4() &#125; ] &#125; ] &#125;)&#125; 在这个例子中，最初的子元素是一个slate插件。 渲染HTMLory-editor-renderer包附带了一个轻量级HTML renderer模块。您可以将其用于服务器端渲染和内容客户端渲染。 123456789101112import &#123; HTMLRenderer &#125; from 'ory-editor-renderer'const state = &#123; /* ... */ &#125;const plugins = &#123; layout: [/* ... */], content: [/* ... */]&#125;const element = document.getElementById('editable')ReactDOM.render(( &lt;HTMLRenderer state=&#123;content[0]&#125; plugins=&#123;plugins&#125;/&gt;), element) 保存和恢复编辑器内容使用onChange回调获取编辑器状态的副本，以便保存到持久存储。然后可以将状态加载到编辑器中，或者由ory-editor-renderer包用于将其渲染为HTML。 1234567891011121314151617181920212223242526272829303132import React, &#123;Component&#125; from 'react'import Editor, &#123; Editable, createEmptyState &#125; from 'ory-editor-core'import slate from 'ory-editor-plugins-slate' // The rich text area pluginimport &#123; Trash, DisplayModeToggle, Toolbar &#125; from 'ory-editor-ui'const EditorPlugins = &#123; content: [slate()], layout: [/* ... */],&#125;;function saveToDatabase(state) &#123; return fetch('/my/save/url', &#123; method: 'POST', body: state &#125;);&#125;class MyEditor extends Component &#123; componentWillMount() &#123; this.editorState = this.props.content || createEmptyState(); this.editor = new Editor(&#123; EditorPlugins, editables: [content] &#125;); &#125; render() &#123; return ( &lt;div className=\"my-editor\"&gt; &lt;toolbar&gt; &lt;button onClick=&#123;() =&gt; saveToDatabase(this.editorState)&#125;&gt;Save&lt;/button&gt; &lt;/toolbar&gt; &lt;Editable editor=&#123;editor&#125; id=&#123;content.id&#125; onChange=&#123;state =&gt; (this.editorState = state)&#125; /&gt; &lt;Trash editor=&#123;editor&#125;/&gt; &lt;DisplayModeToggle editor=&#123;editor&#125;/&gt; &lt;Toolbar editor=&#123;editor&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 然后可以通过以下操作获取和呈现状态: 12345678910111213141516171819202122232425262728import React, &#123;Component&#125; from 'react'import &#123; HTMLRenderer &#125; from 'ory-editor-renderer'import &#123; createEmptyState &#125; from 'ory-editor-core'class MyEditorRenderer extends Component &#123; componentWillMount() &#123; this.plugins = &#123; this.setState(&#123; contents: createEmptyState() &#125;); fetch('/my/save/url').then((savedState) =&gt; &#123; this.setState(&#123; contents: savedState &#125;); &#125;) &#125; render() &#123; return ( &lt;div className=\"my-editor\"&gt; &lt;HTMLRenderer state=&#123;this.state.contents&#125; plugins=&#123;EditorPlugins&#125; /&gt; &lt;/div&gt; ) &#125;&#125;const element = document.getElementById('editable')ReactDOM.render(( &lt;MyEditorRenderer /&gt;), element) 处理本地拖动事件ORY编辑器能够处理原生拖放事件。原生事件包括链接、文本和图像的拖动。可以通过编写NativePlugin并在实例化期间传递它来启用本机拖动支持。在本例中，我们将使用默认插件，并在稍后介绍如何创建自己的插件。 123456789import native from 'ory-editor-plugins-default-native'const editor = new Editor(&#123; plugins: &#123; layout: [], content: [], native &#125;&#125;) 如果原生未定义或为空，则禁用原生拖动。这是默认设置。 编写本地插件就像编写内容或布局插件一样。唯一的区别是，我们的本地插件必须封装在一个接收三个参数的工厂中——hover, monitor, component。悬停是当前正在悬停的单元格或行。Monitor是来自react-dnd的DropTargetMonitor，组件是当前悬停的单元格或行的响应组件。 总之，一个示例插件是这样的: 123456789import React from 'react'const Native = () =&gt; &lt;div&gt;native&lt;/div&gt;export default (hover, monitor, component) =&gt; (&#123; Component: Native, name: 'my-native-plugin', version: '0.0.1'&#125;) 因为这个插件被封装在工厂中，所以我们能够根据接收到的属性修改它的行为。其中一个例子是将项目的数据添加到初始状态，以便以后使用。 123456export default (hover, monitor, component) =&gt; (&#123; // ... createInitialState: () =&gt; (&#123; item: monitor.getItem() &#125;)&#125;) 在默认情况下，编辑器假定删除本地元素会创建一个内容单元格。要更改此行为，请使用键type: 1234export default (hover, monitor, component) =&gt; (&#123; // ... type: 'layout'&#125;)","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"ORY编辑器","slug":"React/ORY编辑器","permalink":"https://jigangduan.github.io/categories/React/ORY编辑器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"editor","slug":"editor","permalink":"https://jigangduan.github.io/tags/editor/"}]},{"title":"ORY编辑器 (3)UI组件","slug":"ory-editor-ui","date":"2018-12-14T13:48:41.000Z","updated":"2020-07-25T02:57:18.225Z","comments":true,"path":"2018/12/14/ory-editor-ui/","link":"","permalink":"https://jigangduan.github.io/2018/12/14/ory-editor-ui/","excerpt":"","text":"包编辑器由多个包组成。一个元包在ory-editor可用。 ory-editor-core这个包是ORY编辑器的核心。它包含创建和修改布局的逻辑，并负责处理插件。 ory-editor-ui这个存储库包含基于callemall/material-ui的ORY Editor UI React组件。虽然您不需要使用它们，但是它们提供了一种开始使用ORY编辑器的简单方法。 ory-editor-renderer这个包包含ORY编辑器状态的渲染组件。目前，只支持HTML渲染。HTML渲染组件负责输出静态HTML并在用户代理端安装动态插件。 插件ory-editor-plugins-slate文本编辑允许您创建和修改富文本，并优化了与ORY编辑器一起使用。我们强烈建议使用我们的文本编辑解决方案。 Slate ory-editor-plugins-image图像插件允许您通过输入图像的URL向内容添加图像。图像插件不支持上传。 图像插件是不可配置的 ory-editor-plugins-video视频插件允许您通过输入视频的URL向内容添加视频。视频插件不支持上传 视频插件是不可配置的 ory-editor-plugins-spacer间隔是一个插件，你可以用它来创建一个空的固定高度单元格。 间隔插件是不可配置的 ory-editor-plugins-parallax-background视差背景插件是一个布局插件，允许你添加一个视差背景图像到你的内容。 视差背景插件是不可配置的","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"ORY编辑器","slug":"React/ORY编辑器","permalink":"https://jigangduan.github.io/categories/React/ORY编辑器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"editor","slug":"editor","permalink":"https://jigangduan.github.io/tags/editor/"}]},{"title":"ORY编辑器 (2)ory-editor-core","slug":"ORY-Editor-2","date":"2018-12-14T13:01:14.000Z","updated":"2020-07-25T02:57:18.160Z","comments":true,"path":"2018/12/14/ORY-Editor-2/","link":"","permalink":"https://jigangduan.github.io/2018/12/14/ORY-Editor-2/","excerpt":"","text":"Coreory-editor-core 其核心是ORY编辑器的主系统。它包含创建和修改布局的逻辑，并负责处理插件。 开始ORY编辑器使用Redux存储来管理内部状态。创建新Editor实例时。 123import Editor from 'ory-editor-core'const editor = new Editor() Redux store也被创建。因此，在应用程序生命周期中只实例化Editor一次非常重要(这称为单例模式)。 1234import Editor from 'ory-editor-core'const editor = new Editor()const editor2 = new Editor() // 不要这样做. 添加插件现在我们知道如何创建一个空编辑器。让我们也添加一些插件。我们将使用来自ORY编辑器存储库的插件。我们称这些插件为“ory插件”，因为它们是由我们编写和维护的。 让我们拿一个图像插件作为初学者。图像插件是一个简单的内容插件，它允许您通过将插件指向图像URL来添加图像。目前不支持上传图片。 要安装image插件，我们使用npm: npm install ory-editor-plugins-image。接下来，我们需要将它添加到编辑器实例中: 12345678910import Editor from 'ory-editor-core'import image from 'ory-editor-plugins-image'import 'ory-editor-plugins-image/lib/index.css'const editor = new Editor(&#123; plugins: &#123; content: [image], &#125;&#125;) 让我们从头到尾来。首先，我们导入图像插件和所需的CSS: 12import image from 'ory-editor-plugins-image'import 'ory-editor-plugins-image/lib/index.css' 我们假设您正在运行webpack，其中有一个能够导入CSS的插件。如果这让你感到困惑，去https://gitter.im/webpack/webpack寻求帮助——他们非常好 接下来，我们创建编辑器实例并通过构造函数传递图像内容插件。 12345const editor = new Editor(&#123; plugins: &#123; content: [image], &#125;&#125;) 也可以在运行时(即创建编辑器实例之后)同时add/set/remove布局和内容插件，如下所示。使用这些方法将强制editor re-render。 123editor.addContentPlugin(image)editor.removeContentPlugin(image)editor.setContentPlugins([image]) 渲染接下来，我们显然希望呈现编辑器。核心包导出一个名为Editable的反应物js组件。我们假设HTML是这样的: 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=\"editable-1\"&gt;&lt;/div&gt; &lt;div id=\"controls\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在这种情况下，javascript应用程序看起来是这样的: 1234567891011121314151617import React from 'react'import ReactDOM from 'react-dom'import Editor, &#123; Editable &#125; from 'ory-editor-core'import image from 'ory-editor-plugins-image'import 'ory-editor-plugins-image/lib/index.css'const editor = new Editor(&#123; plugins: &#123; content: [image] &#125;&#125;)ReactDOM.render(( &lt;Editable editor=&#123;editor&#125; /&gt;), document.getElementById('editable-1')) 我们所做的就是使用ReactJS呈现Editable组件并传递editor实例。然而，这里有一个问题——什么也不会发生。这是因为没有可用的内容可以呈现。让我们改变! 创建一个空状态为了创建一个空状态，core导出了一个名为createEmptyState的方法。返回是一个JSON对象，其中包含一个惟一的id。 1234import &#123; createEmptyState &#125; from 'ory-editor-core'const editable = createEmptyState()console.log(editable.id) // 提供类似 \"29fb21c6-6e00-416f-a8e1-2be9fb84801c\" 把这个加到上面的代码中，我们得到: 1234567891011121314151617181920212223import React from 'react'import ReactDOM from 'react-dom'import Editor, &#123; Editable, createEmptyState &#125; from 'ory-editor-core'import image from 'ory-editor-plugins-image'import 'ory-editor-plugins-image/lib/index.css'const editable = createEmptyState()const editor = new Editor(&#123; plugins: &#123; content: [image] &#125;, editables: [editable],&#125;)ReactDOM.render(( &lt;Editable editor=&#123;editor&#125; id=&#123;editable.id&#125; /&gt;), document.getElementById('editable-1')) 注意，我们将id={editable.id}添加到&lt;Editable&gt;。这是必需的，因为我们需要告诉组件我们想要在那里呈现哪个editable，我们也可以这样做: 1234567891011ReactDOM.render(( &lt;div&gt; &lt;div className=\"left\"&gt; &lt;Editable editor=&#123;editor&#125; id=\"1\" /&gt; &lt;/div&gt; &lt;div className=\"right\"&gt; &lt;Editable editor=&#123;editor&#125; id=\"2\" /&gt; &lt;/div&gt; &lt;/div&gt;), document.getElementById('editable-1')) 保存和加载您接收到的状态是内部编辑器状态的序列化版本。它只包含基本值(字符串、数字、数组、映射)，可以安全地序列化为JSON。 假设您有一个名为saveToBackend的函数，它将内容存储在数据库中。你可以从onChange调用这个方法: 123456789ReactDOM.render(( &lt;Editable editor=&#123;editor&#125; id=\"1\" onChange=&#123;(editable) =&gt; &#123; saveToBackend(editable) &#125;&#125; /&gt;), document.getElementById('editable-1')) 要加载内容，只需将其传递给构造函数 12345678const editable = loadFromBackend() // 只是一个例子const editor = new Editor(&#123; plugins: &#123; content: [image] &#125;, editables: [editable],&#125;) 或者用 trigger API. 12345// const editor = new Editor( ...const editable = loadFromBackend() // 只是一个例子editor.editable.update(editable) // 如果还不存在，update将添加一个可编辑的，或者当它存在于存储中时更新它.","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"ORY编辑器","slug":"React/ORY编辑器","permalink":"https://jigangduan.github.io/categories/React/ORY编辑器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"editor","slug":"editor","permalink":"https://jigangduan.github.io/tags/editor/"}]},{"title":"ORY编辑器 (1)介绍","slug":"ORY-Editor-1","date":"2018-12-14T12:22:03.000Z","updated":"2020-07-25T02:57:18.160Z","comments":true,"path":"2018/12/14/ORY-Editor-1/","link":"","permalink":"https://jigangduan.github.io/2018/12/14/ORY-Editor-1/","excerpt":"","text":"介绍欢迎来到ORY编辑器指南。请注意，ORY编辑器需要大量的关于ReactJS、构建工具(如webpack)和ES6的知识。如果你缺乏这方面的知识，请在我们的聊天中寻求帮助。 示范眼见为实，让我们从一个演示开始! 一个可用的演示在editor.ory.sh，所以去试试它自己! 为什么它是不同的在创建ORY之前，我们建立了类似维基百科的东西，但只是为了学习。内容是众包的，每个月有超过50万人使用这个平台。我们必须认识到，现有的开源内容编辑解决方案存在以下三个缺陷之一: 制作的标记非常可怕，必须进行许多安全工作，XSS总是一个威胁。 作者必须学习特殊的上层标签，如markdown，才能产生内容。这些基于文本的解决方案通常无法指定布局，而且像表这样的复杂数据结构很难编辑。 有前途的库有可能解决上述问题，因为它最初是作为一个特殊用例或空闲项目而被维护者抛弃的。 我们的结论是，解决办法必须符合下列原则: 该状态是一个规范化JSON对象，不涉及HTML。 它是一个不需要编程经验或特殊培训的可视化编辑器。 它是由一家公司建造的，减少了被遗弃的可能性。 基于可重用的React组件，它为开发人员、作者和设计人员提供了新的合作方式，从而更容易地创建更好更丰富的体验。 它适用于移动和触控设备。 带着这些原则，我们出去实现了ORY编辑器，也就是您现在看到的编辑器。 它是如何工作的ORY编辑器主要是创建和修改布局的工具。核心是单元格和行。布局系统非常类似于bootstrap网格系统，其中包含行和列。 可编辑(其他编辑器称之为“文档”)的示例结构可以是: 12345678910111. Editable+-1. Container cell +-1. Row | +-1. Cell (text) | |-2. Cell (parallax background image) | +-1. Row | +-1. Cell (image) | |-2. Cell (image) |-2. Row | +-1. Cell (image) | |-2. Cell (image) 有四种不同的数据类型: Editable (树中 1.) - editable是单元格和行的容器。您可以在一个页面上有多个可编辑的单元格，并且可以将单元格从一个可编辑的单元格拖放到另一个可编辑的单元格中。 Container cell (树中 1.1) - 容器单元格是一个没有插件的单元格，它为树提供了结构。这些单元格在需要时自动生成，在不再需要时自动删除。 Content cell (树中 1.1.1, 1.2.1, ...) - 内容单元格始终是树中的叶子(它没有子元素)，它的行为由内容插件定义(可以由您编写或从npm下载)。内容插件通常是富文本、视频、音频、soundcloud小部件等。 Layout cell 布局单元格包含嵌套单元格和行(容器、内容、布局)的列表。布局单元格的思想是它给它的子单元格一个布局(例如视差背景，一个扰流框，一个所有文本都是红色的框)。布局是由布局插件定义的。布局单元格必须总是至少有一个子单元格，否则它将被自动删除。 网格系统被烘焙到ORY编辑器中。它负责任何拖放逻辑、调整大小、焦点检测等等。作为开发人员，您将主要使用布局和内容插件扩展功能。此外，编辑器负责整个数据模型。插件只是简单的反应物js组件，它们接收编辑器接收的属性如onChange、readOnly、state。在后面的部分中，您将了解插件的工作原理，它们的API是什么样子的，以及如何编写自己的API。","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"ORY编辑器","slug":"React/ORY编辑器","permalink":"https://jigangduan.github.io/categories/React/ORY编辑器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"editor","slug":"editor","permalink":"https://jigangduan.github.io/tags/editor/"}]},{"title":"react-jsonschema-form","slug":"react-jsonschema-form","date":"2018-12-12T02:38:08.000Z","updated":"2020-07-25T02:57:18.226Z","comments":true,"path":"2018/12/12/react-jsonschema-form/","link":"","permalink":"https://jigangduan.github.io/2018/12/12/react-jsonschema-form/","excerpt":"","text":"使用JSON Schema构建Web表单的React组件。https://mozilla-services.github.io/react-jsonschema-form 一个简单的React组件，能够从JSON模式构建HTML表单，默认情况下使用Bootstrap语义。 一个活动的游乐场在gh-pages上面。 设计哲学response-jsonschema-form旨在基于JSON模式自动生成一个response表单。它是kinto-admin项目中的一个主要组件。如果您想为任何数据生成一个表单(看不见)，只需给出一个JSON模式，那么response-jsonschema-form可能适合您。如果您对数据有先入为主的了解，并且希望有一个用于为其生成表单的工具包，那么您可以在其他地方寻找。 response-jsonschema-form验证数据是否符合给定的模式，但不阻止用户输入不适合的数据(例如，从数字字段中删除非数字，或者向已经“满”的数组中添加值)。 安装需要 React 15.0.0+. 注意:存储库的主分支反映了正在进行的开发。版本作为标记发布。永远不要盲目地从master安装，而应该检查可用的稳定版本。 作为一个基于npm的项目依赖项1npm install react-jsonschema-form --save 注意:当库呈现自引导HTML语义时，您必须自己构建和加载Bootstrap样式。 作为CDN提供的脚本1&lt;script src=\"https://unpkg.com/react-jsonschema-form/dist/react-jsonschema-form.js\"&gt;&lt;/script&gt; 源映射在此url中可用 注意:CDN版本不嵌入react或react-dom 您还需要别名默认导出属性来使用表单组件: 123const Form = JSONSchemaForm.default;// orconst &#123;default: Form&#125; = JSONSchemaForm; 使用1234567891011121314151617181920212223import React, &#123; Component &#125; from \"react\";import &#123; render &#125; from \"react-dom\";import Form from \"react-jsonschema-form\";const schema = &#123; title: \"Todo\", type: \"object\", required: [\"title\"], properties: &#123; title: &#123;type: \"string\", title: \"Title\", default: \"A new task\"&#125;, done: &#123;type: \"boolean\", title: \"Done?\", default: false&#125; &#125;&#125;;const log = (type) =&gt; console.log.bind(console, type);render(( &lt;Form schema=&#123;schema&#125; onChange=&#123;log(\"changed\")&#125; onSubmit=&#123;log(\"submitted\")&#125; onError=&#123;log(\"errors\")&#125; /&gt;), document.getElementById(\"app\")); 这会生成这样的表单(假设您加载了标准的Bootstrap样式表): 表单初始化通常需要用现有数据预填表单;这是通过传递与模式匹配的formData prop对象来实现的: 123456789const formData = &#123; title: \"First task\", done: true&#125;;render(( &lt;Form schema=&#123;schema&#125; formData=&#123;formData&#125; /&gt;), document.getElementById(\"app\")); 注意:如果表单只有一个字段，则将一个值传递给formData. ex: formData=’Charlie’ 警告:如果您遇到父组件可以重新呈现的情况，请确保侦听onChange事件并更新传递给formData属性的数据。 表单事件处理表单提交表单错误事件处理表单数据变化表单字段失焦事件表单字段焦点事件以编程方式提交表单您可以使用该引用来获取表单组件，并调用submit方法以编程方式提交表单，无需提交按钮。此方法将分派表单的提交事件，并调用传递给onSubmit props的函数。 123456789const onSubmit = (&#123;formData&#125;) =&gt; console.log(\"Data submitted: \", formData);let yourForm;render(( &lt;Form schema=&#123;schema&#125; onSubmit=&#123;onSubmit&#125; ref=&#123;(form) =&gt; &#123;yourForm = form;&#125;&#125;/&gt;), document.getElementById(\"app\"));yourForm.submit(); 表单定制uiSchema对象JSONSchema在描述如何将给定的数据类型呈现为表单输入组件时受到限制。这就是为什么这个库引入了UI模式的概念。 UI模式基本上是一个对象文字，提供了关于表单应该如何呈现的信息，而JSON模式告诉我们应该如何呈现。 uiSchema对象遵循表单字段层次结构的树形结构，并定义如何呈现每个属性: 12345678910111213141516171819202122232425262728293031323334353637383940414243const schema = &#123; type: \"object\", properties: &#123; foo: &#123; type: \"object\", properties: &#123; bar: &#123;type: \"string\"&#125; &#125; &#125;, baz: &#123; type: \"array\", items: &#123; type: \"object\", properties: &#123; description: &#123; \"type\": \"string\" &#125; &#125; &#125; &#125; &#125;&#125;const uiSchema = &#123; foo: &#123; bar: &#123; \"ui:widget\": \"textarea\" &#125;, &#125;, baz: &#123; // note the \"items\" for an array items: &#123; description: &#123; \"ui:widget\": \"textarea\" &#125; &#125; &#125;&#125;render(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; /&gt;), document.getElementById(\"app\")); 选择小部件uiSchema ui:widget属性告诉表单应该使用哪个ui小部件呈现字段。 例子: 1234567891011const uiSchema = &#123; done: &#123; \"ui:widget\": \"radio\" // could also be \"select\" &#125;&#125;;render(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; formData=&#123;formData&#125; /&gt;), document.getElementById(\"app\")); 以下是针对不同JSONSchema数据类型支持的可选小部件列表: boolean 字段 radio:以true、false作为可选值的单选按钮组; select:以true和false作为选项的选择框; 默认情况下，使用复选框 注意:要设置布尔字段的标签，可以在模式中设置enumNames，而不是使用true和false。注意，enumNames属于您的模式，而不是uiSchema，而且顺序总是[true、false]。 string 字段 textarea:使用textarea元素; password:使用input[type=password]元素; color:使用input[type=color]元素; 默认情况下，使用常规input[type=text]元素。 string 格式内置的string字段还支持JSONSchema format属性，默认情况下将为以下字符串格式呈现适当的小部件: email:使用input[type=email]元素; uri:使用input[type=url]元素; data-url:默认情况下，使用input[type=file]元素;如果字符串是数组的一部分，将自动处理多个文件(请参阅文件小部件)。 date:默认情况下，使用input[type=date]元素; date-time:默认情况下，使用input[type=datetime-local]元素。 请注意，尽管它们是标准化的，但是Firefox和IE还不支持date-time-local和date输入元素。如果您打算针对这些平台，可以使用两个替代小部件: alt-datetime:选择年、月、日、时、分、秒六个元素; alt-date:三个select元素用于选择年份、月份和日期。 通过向uiSchema中的ui:options提供yearsRange属性，您可以自定义显示在year下拉菜单中的year列表。还可以使用hideNowButton和hideClearButton选项删除Now和Clear按钮。 123456789101112uiSchema: &#123; a_date: &#123; \"alt-datetime\": &#123; \"ui:widget\": \"alt-datetime\", \"ui:options\": &#123; yearsRange: [1980, 2030], hideNowButton: true, hideClearButton: true, &#125;, &#125;, &#125;,&#125;, number和integer字段 updown:一个input[type=number]向上向下选择器; range: input[type=range]滑块; radio:带有枚举值的单选按钮组。这只能在为该输入指定枚举值时使用。 默认情况下，使用常规input[type=text]元素。 注意:如果定义了JSONSchema的minimum、maximum和multipleOf值，则input属性值的min、max和step值将采用这些值。 禁用字段ui:disabled uiSchema指令将禁用给定字段中的所有子小部件。 只读字段ui:readonly uiSchema指令将指定字段中的所有子部件标记为只读。 注意:如果您想知道禁用字段和只读字段之间的区别:将字段标记为只读将使其呈现灰色，但是它的文本值是可选择的。禁用它将完全阻止选择它的值。 隐藏小部件通过将其ui:widget uiSchema指令设置为hidden，可以为字段使用隐藏小部件: 12345678910const schema = &#123; type: \"object\", properties: &#123; foo: &#123;type: \"boolean\"&#125; &#125;&#125;;const uiSchema = &#123; foo: &#123;\"ui:widget\": \"hidden\"&#125;&#125;; 笔记: 隐藏小部件只支持布尔、字符串、数字和整数模式类型; 隐藏的小部件从formData支柱获取它的值。 文件部件Multiple filesFile widget input ref对象字段排序对象item选项expandable 选项数组item选项orderable选项addable选项removable选项自定义CSS类名枚举字段的自定义标签另一种兼容json模式的方法枚举字段的禁用属性多项选择题列表自动生成小部件ids默认情况下，这个库将为所有呈现的小部件生成表单特有的id。如果您打算在同一个页面中使用表单组件的多个实例，明智的做法是为这些实例声明一个根前缀，使用ui:rootFieldId uiSchema指令: 123const uiSchema = &#123; \"ui:rootFieldId\": \"myform\"&#125;; 所以所有小部件的id都以myform为前缀。 表单操作按钮帮助文本标题文本描述文本自动对焦文本区域的行选项占位符字段标签HTML5的Input类型Form属性Form组件支持以下html属性: 1234567891011&lt;Form id=\"edit-form\" className=\"form form-wide\" name=\"awesomeForm\" method=\"post\" target=\"_blank\" action=\"/users/list\" autocomplete=\"off\" enctype=\"multipart/form-data\" acceptcharset=\"ISO-8859-1\" schema=&#123;&#125; /&gt; Form禁用高级定制 - 自定义字段 自定义模板 自定义部件 它所做的 覆盖所有的行为 只覆盖布局 只覆盖输入框(而不是布局、标签、帮助或验证) 字段模板要控制每个字段(每个表单行)的内部组织，可以为表单定义一个字段模板。 字段模板基本上是一个正在传递与字段相关的道具的无状态组件，允许您按照自己的喜好构造表单行。 1234567891011121314151617function CustomFieldTemplate(props) &#123; const &#123;id, classNames, label, help, required, description, errors, children&#125; = props; return ( &lt;div className=&#123;classNames&#125;&gt; &lt;label htmlFor=&#123;id&#125;&gt;&#123;label&#125;&#123;required ? \"*\" : null&#125;&lt;/label&gt; &#123;description&#125; &#123;children&#125; &#123;errors&#125; &#123;help&#125; &lt;/div&gt; );&#125;render(( &lt;Form schema=&#123;schema&#125; FieldTemplate=&#123;CustomFieldTemplate&#125; /&gt;,), document.getElementById(\"app\")); 如果您想自己处理每个元素的呈现，可以使用props rawHelp、rawDescription和rawErrors。 以下props传递给自定义字段模板组件: id: 层次结构中字段的id。您可以使用它呈现针对包装的小部件的标签 classNames: 包含基本Bootstrap CSS类的字符串，与uiSchema中定义的自定义类合并 label: 该字段的计算标签，作为字符串 description:呈现字段描述的组件实例，如果定义了字段描述(这将使用任何自定义DescriptionField定义) rawDescription: 包含定义的任何ui:description uiSchema指令的字符串 children: 该字段行的字段或小部件组件实例 errors: 组件实例列出该字段遇到的任何错误. rawErrors: 一个字符串数组，列出从该字段遇到的错误中生成的所有错误消息. help: 呈现任何ui的组件实例:帮助定义的uiSchema指令. rawHelp: 包含任何ui的字符串:帮助定义uiSchema指令。注意:如果传递的ui:help是一个response组件而不是字符串，rawHelp将是未定义的. hidden: 一个布尔值，表示字段是否应该隐藏. required: 一个布尔值，表示是否需要字段. readonly: 一个布尔值，表示字段是否只读. disabled:一个布尔值，表示字段是否禁用. displayLabel: 一个布尔值，表示标签是否应该被呈现。这对于不想让UI混乱的数组中的嵌套字段非常有用. fields: 包含所有表单字段的数组，包括自定义字段和内置字段. schema: 该字段的模式对象. uiSchema: 该领域的uiSchema对象. formContext: 传递给Form的formContext对象. 注意:您只能为表单定义一个字段模板。如果您需要许多字段，那么可能是时候查看自定义字段了。 数组字段模板与FieldTemplate类似，您可以使用ArrayFieldTemplate自定义如何呈现数组。这允许您自定义数组和数组中的每个元素。 请参见customArray.js了解更好的例子 下面的道具被传递到每个ArrayFieldTemplate: DescriptionField:注册表中的DescriptionField(如果您想使用它) TitleField:注册表中的TitleField(如果您想使用它) canAdd:一个布尔值，表示是否可以向数组中添加新元素 className:类名字符串 disabled:一个布尔值，表示数组是否禁用 idSchema:对象 items:表示数组中项目的对象数组。每一项都代表一个子元素，其属性如下所述 onAddClick: (event) =&gt; void:向数组中添加新项的函数 readonly:一个布尔值，表示数组是否只读 required:一个布尔值，表示是否需要数组 schema:该数组的模式对象 uiSchema:这个数组字段的uiSchema对象 title:包含数组标题的字符串值 formContext:传递给Form的formContext对象 formData:该数组的formData 以下 props是items中每个元素的一部分: children:项目内容的html className:类名字符串 disabled:表示数组项是否禁用的布尔值 hasMoveDown:一个布尔值，表示数组项是否可以向下移动 hasMoveUp:一个布尔值，表示数组项是否可以向上移动 hasRemove:一个布尔值，表示是否可以删除数组项 hasToolbar:一个布尔值，表示数组项是否有工具栏 index:表示数组项在项中出现的索引的数字 onDropIndexClick: (index) =&gt; (event) =&gt; void:返回一个函数，该函数删除索引处的项目 onReorderClick: (index, newIndex) =&gt; (event) =&gt; void:返回一个与newIndex交换索引项的函数 readonly:一个布尔值，用于声明数组项是否为只读 对象字段模板与FieldTemplate类似，您可以使用ObjectFieldTemplate自定义如何呈现对象 1234567891011121314function ObjectFieldTemplate(props) &#123; return ( &lt;div&gt; &#123;props.title&#125; &#123;props.description&#125; &#123;props.properties.map(element =&gt; &lt;div className=\"property-wrapper\"&gt;&#123;element.content&#125;&lt;/div&gt;)&#125; &lt;/div&gt; );&#125;render(( &lt;Form schema=&#123;schema&#125; ObjectFieldTemplate=&#123;ObjectFieldTemplate&#125; /&gt;,), document.getElementById(\"app\")); DescriptionField:注册表中的DescriptionField(如果您想使用它) TitleField:注册表中的TitleField(如果您想使用它)。 title:包含对象标题的字符串值。 description:包含对象描述的字符串值。 properties:表示数组中属性的对象数组。每个属性表示一个子属性，其属性描述如下。 required:一个布尔值，表示是否需要对象。 schema:此对象的模式对象。 uiSchema:该对象字段的uiSchema对象。 idSchema:包含此对象的id和其属性的id的对象。 formData:对象的表单数据。 formContext:传递给Form的formContext对象。 以下props是properties中每个元素的一部分: content:属性内容的html。 name:表示属性名称的字符串。 disabled:一个布尔值，表示对象属性是否禁用。 readonly:一个布尔值，表示属性是否只读。 错误列表模板Id前缀为了避免与DOM中现有的id冲突，可以更改ids使用的前缀(默认是root) 1234render(( &lt;Form schema=&#123;schema&#125; idPrefix=&#123;\"rjsf_prefix\"&#125;/&gt;,), document.getElementById(\"app\")); 这将呈现&lt;input id=&quot;rjsf_prefix_key&quot;&gt;，而不是&lt;input id=&quot;root_key&quot;&gt; 自定义小部件和字段API允许指定您自己的自定义部件和字段组件: 小部件表示用户输入数据的HTML标记，例如。input、select等。 一个字段通常封装一个或多个部件，通常处理内部字段状态;可以将字段看作表单行，包括标签。 自定义小部件组件您可以为以下json数据类型向uiSchema提供您自己的自定义小部件: string number integer boolean 1234567891011121314151617181920const schema = &#123; type: \"string\"&#125;;const uiSchema = &#123; \"ui:widget\": (props) =&gt; &#123; return ( &lt;input type=\"text\" className=\"custom\" value=&#123;props.value&#125; required=&#123;props.required&#125; onChange=&#123;(event) =&gt; props.onChange(event.target.value)&#125; /&gt; ); &#125;&#125;;render(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; /&gt;,), document.getElementById(\"app\")); 以下props传递给自定义小部件组件: id:该字段生成的id; schema:此字段的JSONSchema子模式对象; value:该字段的当前值; required:该字段的所需状态; disabled:如果小部件被禁用，则为true; readonly:如果小部件是只读的，则为true; onChange:值更改事件处理程序;每次它改变时，用新值调用它; onBlur:输入模糊事件处理程序;使用小部件id和值调用它; onFocus:输入焦点事件处理程序;使用小部件id和值调用它; options:作为prop传递到组件的选项的映射(请参阅自定义小部件选项)。 formContext:传递给Form的formContext对象。 注意:在v0.35.0之前，options道具包含枚举字段的选项列表(标签和值)。由于v0.35.0，它现在将此列表作为options对象中的enumOptions属性公开 自定义组件注册或者，您可以通过将小部件道具传递给表单组件来一次性注册它们，并从uiSchema引用它们的标识符: 123456789101112131415161718192021222324const MyCustomWidget = (props) =&gt; &#123; return ( &lt;input type=\"text\" className=\"custom\" value=&#123;props.value&#125; required=&#123;props.required&#125; onChange=&#123;(event) =&gt; props.onChange(event.target.value)&#125; /&gt; );&#125;;const widgets = &#123; myCustomWidget: MyCustomWidget&#125;;const uiSchema = &#123; \"ui:widget\": \"myCustomWidget\"&#125;render(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; widgets=&#123;widgets&#125; /&gt;), document.getElementById(\"app\")); 如果您将uiSchema公开为纯JSON，这将非常有用，因为JSON不能携带函数。 注意:在0.40.0之前，可以将小部件注册为对象，形状{component: MyCustomWidget, options:{…} }。这个未文档化的API已经被删除。相反，您可以使用React defaultProps属性注册一个定制小部件。defaultProps。选项可以是包含自定义选项的对象。 自定义小部件选项如果需要将选项传递给定制小部件，可以添加一个包含这些属性的ui:options对象。如果小部件有defaultProps，这些选项将与defaultProps的(可选)options对象合并: 12345678910111213141516171819202122232425262728const schema = &#123; type: \"string\"&#125;;function MyCustomWidget(props) &#123; const &#123;options&#125; = props; const &#123;color, backgroundColor&#125; = options; return &lt;input style=&#123;&#123;color, backgroundColor&#125;&#125; /&gt;;&#125;MyCustomWidget.defaultProps = &#123; options: &#123; color: \"red\" &#125;&#125;;const uiSchema = &#123; \"ui:widget\": MyCustomWidget, \"ui:options\": &#123; backgroundColor: \"yellow\" &#125;&#125;;// renders red on yellow inputrender(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; /&gt;), document.getElementById(\"app\")); 定制部件文本输入所有呈现文本输入的小部件都在内部使用BaseInput组件。如果需要自定义所有文本输入，而不需要单独自定义所有小部件，则可以在小部件属性的Form中提供一个基输入组件(请参见自定义组件注册)。 自定义字段组件通过指定ui:field属性，您可以为uiSchema提供您自己的字段组件，这些组件基本上适用于任何json模式数据类型。 例如，让我们创建并注册一个处理纬度和经度的geo组件: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const schema = &#123; type: \"object\", required: [\"lat\", \"lon\"], properties: &#123; lat: &#123;type: \"number\"&#125;, lon: &#123;type: \"number\"&#125; &#125;&#125;;// Define a custom component for handling the root position objectclass GeoPosition extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;...props.formData&#125;; &#125; onChange(name) &#123; return (event) =&gt; &#123; this.setState(&#123; [name]: parseFloat(event.target.value) &#125;, () =&gt; this.props.onChange(this.state)); &#125;; &#125; render() &#123; const &#123;lat, lon&#125; = this.state; return ( &lt;div&gt; &lt;input type=\"number\" value=&#123;lat&#125; onChange=&#123;this.onChange(\"lat\")&#125; /&gt; &lt;input type=\"number\" value=&#123;lon&#125; onChange=&#123;this.onChange(\"lon\")&#125; /&gt; &lt;/div&gt; ); &#125;&#125;// Define the custom field component to use for the root objectconst uiSchema = &#123;\"ui:field\": \"geo\"&#125;;// Define the custom field components to register; here our \"geo\"// custom field componentconst fields = &#123;geo: GeoPosition&#125;;// Render the form with all the properties we just defined passed// as propsrender(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; fields=&#123;fields&#125; /&gt;), document.getElementById(\"app\")); 注意:注册的字段可以跨整个模式重用 字段 props字段组件将始终传递以下props: schema:该字段的JSON模式; uiSchema:该领域的uiSchema; idSchema:每个子字段的惟一id树; formData:该字段的数据; errorSchema:该字段及其子字段的错误树; registry:registry对象(接下来读取) formContext: formContext对象(下一个读) registry对象registry是一个对象，包含注册的自定义字段和小部件以及根模式定义。 fields:自定义注册字段。默认情况下，该对象包含标准的schemfields、TitleField和DescriptionField组件; widgets:自定义注册小部件(如果有); definitions:根模式定义(如果有的话) formContext: formContext对象。 registry是向下传递到组件树的，因此您可以从自定义字段和SchemaField组件访问它。 formContext对象您可以为表单提供一个formContext对象，该对象传递给所有字段和小部件(包括TitleField和DescriptionField)。用于实现上下文感知字段和小部件。 自定义数组字段按钮ArrayField组件提供了一个用于添加、删除和重新排序数组项的UI，这些按钮使用Bootstrap glyphicons。如果您不使用符号图标，但仍然希望为这些按钮提供自己的图标或文本，您可以使用CSS轻松地做到这一点: 12345i.glyphicon &#123; display: none; &#125;.btn-add::after &#123; content: &apos;Add&apos;; &#125;.array-item-move-up::after &#123; content: &apos;Move Up&apos;; &#125;.array-item-move-down::after &#123; content: &apos;Move Down&apos;; &#125;.array-item-remove::after &#123; content: &apos;Remove&apos;; &#125; 自定义SchemaField警告:这是一个强大的特性，因为您可以覆盖整个表单行为，并很容易将其搞乱。小心轻放。 您可以提供自己的SchemaField base React组件实现，用于呈现任何JSONSchema字段类型，包括对象和数组。当您希望用补充幂来扩充给定字段类型时，这非常有用。 要进行此操作，请将具有SchemaField属性的fields对象传递给Form组件;下面是包装标准SchemaField lib组件的一个相当愚蠢的示例: 123456789101112131415161718192021import SchemaField from \"react-jsonschema-form/lib/components/fields/SchemaField\";const CustomSchemaField = function(props) &#123; return ( &lt;div id=\"custom\"&gt; &lt;p&gt;Yeah, I'm pretty dumb.&lt;/p&gt; &lt;SchemaField &#123;...props&#125; /&gt; &lt;/div&gt; );&#125;;const fields = &#123; SchemaField: CustomSchemaField&#125;;render(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; formData=&#123;formData&#125; fields=&#123;fields&#125; /&gt;), document.getElementById(\"app\")); 如果您想知道这是如何有用的，请查看Kinto formbuilder存储库，了解如何使用它为任何表单字段提供编辑功能。 传递给定制模式的道具与传递给定制字段的props是相同的。 自定义默认字段和小部件您可以覆盖任何默认字段和小部件，包括内部小部件，如ObjectField为布尔值呈现的CheckboxWidget。您可以覆盖任何字段和小部件，只要在字段和小部件道具中提供定制的字段/小部件: 123456789101112131415161718const CustomCheckbox = function(props) &#123; return ( &lt;button id=\"custom\" className=&#123;props.value ? \"checked\" : \"unchecked\"&#125; onClick=&#123;() =&gt; props.onChange(!props.value)&#125;&gt; &#123;props.value&#125; &lt;/button&gt; );&#125;;const widgets = &#123; CheckboxWidget: CustomCheckbox&#125;;render(( &lt;Form schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; formData=&#123;formData&#125; widgets=&#123;widgets&#125; /&gt;), document.getElementById(\"app\")); 这允许您使用自定义字段和小部件创建可重用的自定义表单类: 123456789101112const customFields = &#123;StringField: CustomString&#125;;const customWidgets = &#123;CheckboxWidget: CustomCheckbox&#125;;function MyForm(props) &#123; return &lt;Form fields=&#123;customFields&#125; widgets=&#123;customWidgets&#125; &#123;...props&#125; /&gt;;&#125;render(( &lt;MyForm schema=&#123;schema&#125; uiSchema=&#123;uiSchema&#125; formData=&#123;formData&#125; /&gt;), document.getElementById(\"app\")); 自定义标题自定义描述表单数据验证表单样式模式定义和引用属性依赖性模式的依赖关系这个库还支持基于表单数据修改模式的某些部分。 条件动态JSON模式支持状态该组件遵循JSON模式规范。由于窗体小部件的局限性，有以下几个例外: 提示和技巧贡献","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"第三方库","slug":"React/第三方库","permalink":"https://jigangduan.github.io/categories/React/第三方库/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"}]},{"title":"JavaScript[冴羽的博客]","slug":"mqyqingfeng-blog","date":"2018-12-06T05:09:27.000Z","updated":"2020-07-25T02:57:18.215Z","comments":true,"path":"2018/12/06/mqyqingfeng-blog/","link":"","permalink":"https://jigangduan.github.io/2018/12/06/mqyqingfeng-blog/","excerpt":"","text":"原作者发布地址: github 专栏 掘金主页 segmentfault主页 新开了 知乎专栏，欢迎关注 深入系列目录 JavaScirpt深入之从原型到原型链 JavaScript深入之词法作用域和动态作用域 JavaScript深入之执行上下文栈 JavaScript深入之变量对象 JavaScript深入之作用域链 JavaScript深入之从ECMAScript规范解读this JavaScript深入之执行上下文 JavaScript深入之闭包 JavaScript深入之参数按值传递 JavaScript深入之call和apply的模拟实现 JavaScript深入之bind的模拟实现 JavaScript深入之new的模拟实现 JavaScript深入之类数组对象与arguments JavaScript深入之创建对象的多种方式以及优缺点 JavaScript深入之继承的多种方式以及优缺点 JavaScript深入系列15篇正式完结！ 专题系列目录 JavaScript专题之跟着underscore学防抖 JavaScript专题之跟着underscore学节流 JavaScript专题之数组去重 JavaScript专题之类型判断(上) JavaScript专题之类型判断(下) JavaScript专题之深浅拷贝 JavaScript专题之从零实现jQuery的extend JavaScript专题之如何求数组的最大值和最小值 JavaScript专题之数组扁平化 JavaScript专题之学underscore在数组中查找指定元素 JavaScript专题之jQuery通用遍历方法each的实现 JavaScript专题之如何判断两个对象相等 JavaScript专题之函数柯里化 JavaScript专题之偏函数 JavaScript专题之惰性函数 JavaScript专题之函数组合 JavaScript专题之函数记忆 JavaScript专题之递归 JavaScript专题之乱序 JavaScript专题之解读 v8 排序源码 JavaScript专题系列20篇正式完结！ underscore 系列目录 underscore 系列之如何写自己的 underscore underscore 系列之链式调用 underscore 系列之内部函数 cb 和 optimizeCb underscore 系列之内部函数 restArgs underscore 系列之防冲突与 Utility Functions underscore 系列之实现一个模板引擎(上) underscore 系列之实现一个模板引擎(下) underscore 系列之字符实体与 _.escape underscore 的源码该如何阅读？ ES6 系列目录 ES6 系列之 let 和 const ES6 系列之模板字符串 ES6 系列之箭头函数 ES6 系列之模拟实现 Symbol 类型 ES6 系列之迭代器与 for of ES6 系列之模拟实现一个 Set 数据结构 ES6 系列之 WeakMap ES6 系列之我们来聊聊 Promise ES6 系列之 Generator 的自动执行 ES6 系列之我们来聊聊 Async ES6 系列之异步处理实战 ES6 系列之 Babel 将 Generator 编译成了什么样子 ES6 系列之 Babel 将 Async 编译成了什么样子 ES6 系列之 Babel 是如何编译 Class 的(上) ES6 系列之 Babel 是如何编译 Class 的(下) ES6 系列之 defineProperty 与 proxy ES6 系列之模块加载方案 ES6 系列之我们来聊聊装饰器 ES6 系列之私有变量的实现 ES6 完全使用手册 友情链接 如何轻松拿到淘宝前端 offer 注意深入系列文章部分是有先后顺序的，按照目录结构顺序阅读效果最好。 勘误及提问如果有疑问或者发现错误，可以在相应的 issues 进行提问或勘误。 如果喜欢或者有所启发，欢迎给原作者 star。 License所有文章采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"GitHub精选","slug":"前端/GitHub精选","permalink":"https://jigangduan.github.io/categories/前端/GitHub精选/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"github","slug":"github","permalink":"https://jigangduan.github.io/tags/github/"},{"name":"blog","slug":"blog","permalink":"https://jigangduan.github.io/tags/blog/"}]},{"title":"Minio - 私有云存储","slug":"minio","date":"2018-12-03T03:01:43.000Z","updated":"2020-07-25T02:57:18.215Z","comments":true,"path":"2018/12/03/minio/","link":"","permalink":"https://jigangduan.github.io/2018/12/03/minio/","excerpt":"","text":"Minio是一款高性能的分布式对象存储服务器，专为其设计大型私有云基础设施。Minio被广泛部署在美国世界上有超过166.1M+的docker拉取。 Minio是一个开源的对象存储服务器，与Amazon S3 api兼容:https://minio.io/downloads.html#downl… Minio是Apache License v2.0下发布的对象存储服务器。它与Amazon S3云存储服务兼容。它最适合存储非结构化数据，如照片、视频、日志文件、备份和容器/ VM映像。对象的大小从几个KBs到最大5TB不等。 Minio服务器足够轻，可以与应用程序栈绑定，类似于NodeJS、Redis和MySQL。 尝试使用Minio BrowserMinio服务器自带一个嵌入式的基于web的对象浏览器。将web浏览器指向http://127.0.0.1:9000，确保服务器已经成功启动。 尝试使用Minio客户端mcmc提供了UNIX命令(如ls、cat、cp、mirror、diff等)的现代替代品。它支持文件系统和Amazon S3兼容的云存储服务。按照Minio客户端快速入门指南进行进一步的指导。 已有的数据当部署在单个驱动器上时，Minio服务器允许客户机访问数据目录中任何已存在的数据。例如，如果使用命令Minio server /mnt/data启动Minio，则客户端可以访问/mnt/data目录中的任何预先存在的数据。 上述语句也适用于所有网关后端。 进一步探索 Minio Erasure Code快速入门指南 对Minio服务器使用mc 对Minio服务器使用aws-cli 对Minio服务器使用s3cmd 对Minio服务器使用Minio-go SDK Minio文档网站","categories":[{"name":"GitHub精选","slug":"GitHub精选","permalink":"https://jigangduan.github.io/categories/GitHub精选/"}],"tags":[{"name":"oos","slug":"oos","permalink":"https://jigangduan.github.io/tags/oos/"},{"name":"minio","slug":"minio","permalink":"https://jigangduan.github.io/tags/minio/"}]},{"title":"数据二分法：重新思考我们对待数据和服务的方式","slug":"data-dichotomy-rethinking-the-way-we-treat-data-and-services","date":"2018-11-30T13:39:59.000Z","updated":"2020-07-25T02:57:18.197Z","comments":true,"path":"2018/11/30/data-dichotomy-rethinking-the-way-we-treat-data-and-services/","link":"","permalink":"https://jigangduan.github.io/2018/11/30/data-dichotomy-rethinking-the-way-we-treat-data-and-services/","excerpt":"","text":"如果你偶然发现整个微服务的事情，没有任何先前的背景，你会认为它有点奇怪。将应用程序拆分为由网络分隔的片段，不可避免地意味着注入分布式系统的复杂故障模式。 然而，虽然该方法肯定涉及许多独立服务，但目标比仅仅在不同的机器上运行它们更广泛。它是关于面对一个本身就是固有分布的世界。不是在某种狭隘的技术意义上，而是由许多人，许多团队和许多程序组成的广泛的生态系统，所有这些都需要在某种程度上做自己的事情。 例如，公司是不同系统的集合，这些系统共同进一步促进了一些共同目标。几十年来，我们在很大程度上忽略了这一事实，将它们与FTP文件传输或企业集成工具一起修补，同时专注于我们自己的一些孤立主义目标。但服务改变了这一点。他们将我们的头抬高到栏杆之上，进入一个协作的，相互依存的计划世界。但要想在这方面取得成功，我们必须认识并设计两个根本不同的世界：外部世界，我们生活在许多其他服务的生态系统中，以及我们私人的内部世界，我们独自统治国王。 但是这个分布式的世界与我们长大的世界略有不同。传统的单片软件工程规则不再以同样的方式存在水。因此，正确使用这样的系统不仅仅是在白板上绘制一个很酷的草图或者是一个性感的概念证明。这是为了让这些东西随着时间的推移成功运作。幸运的是，服务已经存在了很长时间，尽管有几种不同的形式。虽然最近有Docker，Kubernetes和一些稍微过度笨拙的胡须，但SOA的教训仍然存在。 所以今天我们将看看规则是如何变化的，为什么我们应该重新思考我们的服务方法和它们共享的数据，以及为什么我们需要一个不同的工具集来实现这一点。 封装并不总是你的朋友微服务可独立部署。正是这个属性比任何其他属性更能赋予它们价值。它允许他们扩展。成长。在扩展到数以万计的用户或数PB的数据意义上（尽管他们可能会有所帮助），而不是在人员方面进行扩展，随着您的团队和组织的发展。 但独立本身就是一把双刃剑。这意味着服务可以快速自由地迭代。但是，如果一个服务实现了需要更改其他服务的功能，我们最终必须在同一时间对这两个服务进行更改。虽然这在单片应用程序中很容易，您可以简单地进行更改并执行发布，但在独立服务必须同步的情况下却更加痛苦。团队和发布周期之间的协调会削弱敏捷性。 典型的方法是通过干净地分离服务之间的职责来简单地避免这种讨厌的横切变化。单点登录服务就是一个很好的例子。它具有明确定义的角色，可以与其他服务所扮演的角色完全分开。这种清晰的分离意味着，即使面对周围服务的快速需求流失，SSO服务也不太可能需要改变。它存在于一个紧密有界的环境中。 问题在于，在现实世界中，商业服务通常不能保持相同，清晰，分离的关注点。例如，商业服务不可避免地更多地依赖彼此的数据。如果您是在线零售商，订单流，产品目录或客户信息可能会发现它可以满足您的许多服务需求。这些服务中的每一项都需要广泛访问这些数据集才能完成工作。 大多数商业服务共享相同的事实流。这使得他们的未来不可避免地交织在一起。 所以这是一个值得注意的重点，虽然服务对于基础设施组件很有效，而这些组件的生活很大程度上是孤立的，但大多数商业服务的未来都紧密地交织在一起。 数据二分法基于服务的方法可能已存在一段时间，但它们仍然对如何在服务之间共享重要数据集提供相对较少的见解。 潜在的问题是数据和服务不能太融合在一起。一方面，封装鼓励我们隐藏数据; 将服务彼此分离，以便他们可以继续改变和发展。这是关于未来的规划。但另一方面，我们需要像任何其他数据集一样自由切割和切割共享数据。这是关于我们现在的工作，与其他任何数据系统具有相同的自由。 但数据系统与封装几乎没有关系。事实上，恰恰相反。数据库尽其所能来公开它们所拥有的数据。它们具有非常强大的声明性界面，可以将数据扭曲成您可能想要的任何形状。正是你需要进行探索性调查，但对于管理新兴服务区的复杂性并不是那么好。 所以我们发现自己面临着一个难题。矛盾。二分法：数据系统是关于暴露数据。服务是关于隐藏它。 这两种力量是根本的。它们构成了我们所做的大部分工作的基础，巧妙地在我们构建的系统中争夺至高无上的地位。 随着我们不断发展和发展基于服务的系统，我们看到这种数据二分法的效果以几种不同的方式发挥作用。服务接口将增长，暴露越来越多的功能，使其开始看起来像某种形式的kookie，自行开发的数据库。或者，挫折将会起作用，我们会添加一些从整个服务到服务的整个数据集的提取和移动方式。 现在创建看起来像kookie的东西，共享数据库可能会导致一系列问题。我们不会在这里涉及共享数据库的危险，但足以说它们代表了尝试它们的公司的重大且昂贵的工程和运营挑战。 更糟糕的是，数据量实际上放大了这个服务边界问题。隐藏在服务边界内的共享数据越多，接口可能变得越复杂，并且跨越不同服务加入数据集的难度就越大。 然而，替代方案 - 提取和移动整个数据集 - 也存在问题。一种常见的方法是简单地提取并保存整个数据集，然后将其存储在每个消费服务内的本地数据库中。 问题是不同的服务对它们消耗的数据做出不同的解释。他们保留这些数据。数据在本地被更改和修复。很快它根本不代表源数据集。 可变拷贝越多，随着时间的推移，数据就会越多。 更糟糕的是，不同的数据在回顾过程中很难修复（MDM实际上是一个粘性物质）。实际上，企业遇到的一些最棘手的技术问题来自于从应用程序到应用程序的不同数据集。 为了解决这个问题，我们需要以稍微不同的方式考虑共享数据。我们需要将其视为我们构建的架构的一等公民。Pat Helland称这种数据为内部，这是一个有用的区别。我们需要封装，因此我们不会暴露服务的内部状态。但我们需要让服务轻松访问共享数据，以便他们可以继续工作并完成工作。 问题是，现在没有一种可用的方法，服务接口，消息传递或共享数据库，为处理外部数据提供了一个很好的解决方案。服务接口不适合以任何规模级别共享数据。消息传递移动数据，但不提供历史参考，这会导致数据随时间而损坏。共享数据库集中在一个地方，扼杀了进步。因此，我们不可避免地陷入数据不足的循环中： 数据不足的循环 流：分散的数据和服务方法因此，理想情况下，我们希望重新调整服务处理共享数据的方式。现在任何这样的方法都必须面对上面提到的二分法，没有任何技术上的仙尘我们可以随意撒上并将其魔法化。但我们可以重新定义问题，并选择一个微妙的不同妥协。 这种特殊的妥协涉及一定程度的集中化。我们可以使用分布式日志，因为它提供了保持性，可扩展的流。现在我们需要我们的服务能够加入和操作这些共享流，但我们希望避免执行此类处理的复杂，集中的“上帝服务”。因此，更好的方法是将流处理嵌入到每个消费服务中。这意味着服务可以将各种共享数据集连接在一起，并按照自己的进度迭代它们。 实现此目的的一种方法是使用流式平台。有很多选项，但在这里我们会考虑Kafka，因为它使用有状态流处理使它特别适合这个问题。 使用分布式日志将我们推向一条相当完善的路径，一条使用消息传递来实现服务事件驱动的路径。这些方法通常被认为提供了比其请求 - 响应兄弟更好的可扩展性和更好的解耦，因为它们将流控制从发送方移动到接收方。这增加了每项服务的自主权。公平地说它是有代价的：你需要一个经纪人。但是对于重要的系统来说，这通常是一个值得做出的权衡（对于普通的Web应用程序来说更少） 现在，如果代理是分布式日志，而不是传统的消息传递系统，则可以利用一些其他属性。传输可以与分布式文件系统大致相同的方式线性扩展。数据也可以长期保留在日志中。所以这是消息，但它也是存储。存储可扩展，没有共享，可变状态的危险。 然后，状态流处理引擎，可以用来嵌入数据库的声明工具，直接在消费服务。这一点很重要。虽然数据存储在共享流中，但是所有服务都可以访问，但是服务的连接和处理是私有的。智慧在每个有限的上下文中被隔离。 通过共享不可变的状态流来解决数据二分法。然后使用有状态流处理引擎将该功能推送到每个服务中。 因此，如果您的服务需要在公司的订单，产品目录或库存上运行，则它具有完全访问权限： 您决定应合并哪些数据集，您决定 执行的位置，并决定何时以及如何随着时间的推移而发展它。这意味着，虽然数据本身是共享的，但对该共享数据的操作是完全 分散的。它完全位于每个服务边界内，在一个你独自统治国王的世界里。 以一种使其忠实于源的方式共享数据。封装功能，不是在源头，而是在需要它的每个服务中。 现在事实证明，有时数据必须集中移动。有时，服务需要在他们选择的数据库引擎中使用本地历史数据集。这里的技巧是确保通过返回分布式日志，可以随意从源重新生成副本。Kafka中的连接器有助于此。 因此这种方法有一些特定的优点： 数据作为流共享，可以长期驻留在日志中，但操作共享数据的机制嵌入到每个有界上下文中，从而可以轻松快速地自由迭代。这平衡了数据的二分法。 数据集可以轻松地在不同的服务中实时连接。这样可以更轻松地与共享数据进行交互，从而无需在数据库中维护本地数据集。 有状态流处理仅缓存数据，“黄金源”是共享日志，因此数据随时间发散的问题远没那么普遍。 服务本质上是事件驱动的，这意味着随着数据集的增长，服务仍然可以对业务事件做出快速反应。 可伸缩性问题从服务转移到代理。这使得构建更简单的服务变得更加容易，而不需要担心规模。 添加新服务不需要更改上游服务。这样可以更轻松地插入新服务。 所以这不仅仅是REST。它是一个以分散的方式包含共享数据的工具集。 这篇文章真的只是一个品尝者，掩盖了许多细节。我们仍然需要深入研究如何平衡请求 - 响应和事件驱动的范例。我们将在下一篇文章中这样做。还有一些我们需要更好理解的主题，比如为什么有状态流处理如此有价值。第三篇文章将着眼于此。如果我们选择这条路径，还有其他一些我们可以利用的强大构造，例如确切地一次处理。这是分布式业务系统的游戏规则改变者，因为它以可扩展的形式提供XA的事务保证。第四篇文章将进入那个。最后，我们需要贯彻执行这些事情的细节。 但就目前而言，请记住这一点：数据二分法描述了我们在构建业务服务时必须面对的紧张局势。我们应该注意这个事实。诀窍是改变方法：将共享数据视为一等公民。我们设计的东西。有状态流处理为此提供了独特的折衷方案。它避免了通常会扼杀进步的核心“上帝组成部分”。而且，它带来了流数据流水线的即时性，可扩展性和容错性，并将它们嵌入到每个服务中。因此，我们专注于整体意识流，任何服务都可以通过这种意识流来做出决策。这使服务更具可扩展性，可互换性和自主性。因此，它们不仅在白板和POC上看起来很好，它们还能继续存活并发展数十年。 原文地址第1部分:数据二分法:重新思考我们对待数据和服务的方式第2部分:在事件的主干上构建服务第3部分:使用Apache Kafka作为可伸缩的、事件驱动的服务架构主干(请参阅下一部分)第4部分:具有一次保证的连锁服务第5部分:信息作为真理的单一来源第6部分:利用未绑定数据库的强大功能第7部分:使用Kafka流和KSQL构建微服务生态系统","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"},{"name":"Kafka微服务","slug":"Kafka/Kafka微服务","permalink":"https://jigangduan.github.io/categories/Kafka/Kafka微服务/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://jigangduan.github.io/tags/翻译/"},{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"}]},{"title":"在20分钟内构建实时流ETL管道","slug":"building-real-time-streaming-etl-pipeline-20-minutes","date":"2018-11-28T04:50:29.000Z","updated":"2020-07-25T02:57:18.194Z","comments":true,"path":"2018/11/28/building-real-time-streaming-etl-pipeline-20-minutes/","link":"","permalink":"https://jigangduan.github.io/2018/11/28/building-real-time-streaming-etl-pipeline-20-minutes/","excerpt":"","text":"最近有很多人说传统的ETL已经死了。在传统的ETL范式中，数据仓库是王者，ETL作业是批处理驱动的，所有内容都与其他内容进行通信，可伸缩性限制非常普遍。当人们咕哝着说由此造成的混乱是“做生意的成本”时，混乱的管道被勉强容忍。“人们学会了忍受这样的一团糟: 然而，ETL并没有死。开发人员越来越喜欢一种新的ETL范式，它具有分布式系统和事件驱动的应用程序，其中业务可以实时和大规模地处理数据。仍然需要“提取”、“转换”和“加载”，但是现在的区别是将数据作为一等公民对待。企业不再希望将数据降级为批处理，而批处理通常仅限于每天离线完成一次。它们拥有更多不同类型的数据源，并且希望消除混乱的点到点连接。我们可以将流处理直接嵌入到每个服务中，核心业务应用程序可以依赖流平台来分发和处理事件。这篇文章的重点是演示在Apache卡夫卡®如何轻松地可以实现这些流ETL管道。 Kafka是一个分布式流平台，是现代企业架构的核心。它提供了在Kafka Connect框架中运行的Kafka连接器，可以从不同的数据源提取数据;提供了丰富的Kafka流API，可以从核心应用程序中执行复杂的转换和分析;您可以部署Confluent模式注册中心来集中管理模式，验证兼容性，并在数据不符合模式时提供警告。(不明白为什么需要为关键任务数据建立模式注册表?)阅读这篇博客文章。端到端参考体系结构如下: 让我们考虑一个使用Kafka Streams API进行实时有状态流处理的应用程序。我们将运行端到端参考体系结构的一个具体示例，并向您展示如何: 运行Kafka源连接器从另一个系统(SQLite3数据库)读取数据，然后使用单个消息转换(SMTs)修改正在运行的数据，然后将其写入Kafka集群 使用Kafka Streams API(例如count和sum)处理和丰富来自Java应用程序的数据 运行Kafka接收器连接器将数据从Kafka集群写到另一个系统(AWS S3) 本例的工作流程如下: 如果您希望在您的环境中进行后续操作并进行尝试，请使用快速入门指南来设置Kafka集群并下载完整的源代码。 提取数据到Kafka首先，我们必须将数据导入客户机应用程序。要在Kafka和其他系统之间复制数据，用户可以从各种现成的连接器中选择Kafka连接器。Kafka源连接器从另一个系统导入数据到Kafka, Kafka接收器连接器从Kafka导出数据到另一个系统。 对于我们的示例，我们希望从SQLite3数据库中提取数据，该数据库保存到/usr/local/lib/retail.db。数据库有一个名为locations的表，它有三个列id、name和sale，其中包含示例内容: locations id name sale 1 Raleigh 300 2 Dusseldorf 100 1 Raleigh 600 3 Moscow 800 4 Sydney 200 2 Dusseldorf 400 5 Chennai 400 … … … 我们希望从该表创建一个数据流，其中流中的每个消息都是K/V对。你会问，key是什么，value是什么?我们来算一下。 为了将表数据提取到Kafka主题中，我们使用免费的Confluent开源下载附带的JDBC连接器。注意，默认情况下，JDBC连接器不会向消息添加键。由于消息键对于组织和分组消息非常有用，因此我们将使用smt设置该键。如果使用默认配置设置，数据将被写入Kafka主题，配置如下: 默认配置 配置名 配置值 源数据库 test.db Kafka 创建的topic test-sqlite-jdbc-locations 消息键呈现 有效的空 (具有null值的JSON模式) 信息值模式 JSON 数据治理 None 相反，我们需要以下目标配置: 目标配置 配置名 配置值 源数据库 /usr/local/lib/retail.db Kafka 创建的topic retail-locations 消息键呈现 是的，使用Kafka Connect的单个消息转换特性插入密钥 信息值模式 Avro 数据治理 是的，使用模式注册表 为了实现目标配置，我们修改JDBC源连接器属性文件source-quickstart-sqlite.properties: 然后，我们将这些配置行添加到JDBC源连接器属性文件中，以利用单个消息转换(SMT)函数，这些函数在将从表行提取的数据写到Kafka主题之前操作这些数据。我们使用ValueToKey和ExtractField SMT函数将null键替换为从消息值派生的字段。 最后，我们将这些配置行添加到JDBC源连接器属性文件中，以将键转换器配置为字符串(可以像JSON或Avro那样轻松地序列化)，将值转换器配置为模式的Avro。Confluent模式注册表运行在http://schemaregistry1:8081。 为了简单起见，我们以Kafka Connect独立模式运行JDBC源连接器。在生产中，您应该始终使用分布式模式进行可伸缩性和容错，并使用合流控制中心进行集中管理。 此时，Kafka Connect运行JDBC连接器，并将表的每一行作为键/值对写入Kafka主题retail-locations。对该表的状态感兴趣的应用程序将从本主题读取。当将行添加到SQLite3数据库中的源表时，Kafka Connect会自动将它们作为消息写入Kafka主题，然后在KStream对象中自动提供给客户机应用程序。因此，我们实现了数据的无界、连续的实时流。这个数据流就是我们所说的“流”。 每个表行被序列化为Avro记录。我们可以从主题retail-locations查找Confluent模式注册表中消息值的模式。 使用Kafka Streams API转换数据既然源数据已写入Kafka主题，那么任何数量的应用程序都可以从该主题读取并使用模式注册表反序列化消息值(即Avro记录)。一个简单的应用程序可以是kafka-avro-consol-consumer: 但是控制台使用者命令行工具不是我们的最终目标。我们希望演示如何在客户机应用程序中使用Kafka Streams API来处理该主题中的数据。Confluent提供了关于如何使用API开发应用程序的优秀文档。 在这里，我想强调应用程序的两个部分: 从Kafka主题创建Kafka流对象 使用Kafka流处理操作数据转换 创建Kafka流对象从Kafka主题创建Kafka流对象意味着将Kafka中的字节记录转换为客户机应用程序中的Java对象。因为消息值是Avro记录，所以我们需要匹配该模式的Java类。我们创建一个名为location.avsc的Avro模式文件，它定义了客户机对数据结构的期望。它是JSON格式的，并且有一个记录，其中包含三个字段id、name和sales，这些字段对应于表列 为了让Java客户机应用程序能够反序列化在这个Avro模式中编写的消息，我们需要有一个对应的Java类(例如Location)。但是，我们不需要编写Java代码!在我们的pom.xml 中，我们使用Maven插件avro-maven-plugin，它自动生成这些类的Java代码。 现在Java源代码已经从Avro模式文件中自动创建，您的应用程序可以导入该包: 下一个关键步骤是配置streams配置，以使用适当的serialization/deserialization类并指向模式注册中心: 您现在可以创建KStream对象: 请注意，在上面的工作流中省略了一些基本的Kafka流设置，但是请记住查看Streams开发人员指南以获得详细的说明。 处理和丰富数据在客户端应用程序的这一点上，我们有一个名为locationsStream的KStream对象，它包含一个消息流，其中消息键是&lt;Long&gt; id，消息值是&lt;Location&gt;记录，其中包含它的id、name和sale值。 现在我们可以用流处理器进行数据转换。有一个丰富的Kafka Streams API用于实时流处理，您可以在核心业务应用程序中利用它。有许多流处理器，它们一次接收一条输入记录，将其操作应用于该记录，然后可能向其下游处理器生成一条或多条输出记录。这些处理器可以是无状态的(例如一次转换一条消息，或者根据某些条件过滤掉消息)，也可以是有状态的(例如跨多个消息的join, aggregate, 或 window数据)。 为了开始使用Kafka Streams API，下面是三个示例，其中包含示例代码和相应的可视化结果流数据: 将数据流转换为新类型的键/值对。例如，我们可以使用map方法将原来的KStream&lt;Long, Location&gt;转换为KStream&lt;Long, Long&gt;的key/value对，其中key是相同的key, value只是sales的值。 计算特定键的出现次数，首先根据键对消息进行分组，然后使用Count方法计算出现次数。Kafka Streams API具有捕获流和表的对重性的本地抽象:KStream表示消息流，其中每个数据记录表示无界数据集中的自包含数据，KTable表示changelogs，其中每个数据记录表示更新。我们还可以为aKTable命名一个本地状态存储，这允许我们像查询普通表一样轻松地查询它。例如，我们可以计算每个键出现的次数。 通过首先基于键对消息进行分组，然后使用reduce方法对值进行求和，从而对特定键的值进行求和。例如，我们可以跨所有消息对给定键的销售额进行求和，并在添加新销售额时对其进行实时更新。这个例子还展示了Kafka流如何允许我们在KStream和ktable之间来回切换。 将数据加载到其他系统在这一点上，所有丰富的数据仍然在我们的客户端应用程序中，我们可能希望将它流到另一个系统中。事实上，您可能希望在许多目标下游系统中的数据作为扇出管道的一部分。您可以使用多个Kafka接收器连接器运行Kafka Connect，以便任何数量的目标下游系统都可以接收相同的数据。Kafka接收器连接器可以与Kafka源连接器并行运行。 在我们的示例中，目标系统是AWS S3 bucket。要在那里加载数据，从Kafka获取数据和从Kafka获取数据一样容易。应用程序用这条语句将theKStream写到Kafka主题上: 然后Kafka接收器连接器处理进入下游系统的摄入。您可以将接收器连接器指向这个Kafka主题，并使用Kafka Connect以与为Kafka源连接器运行Kafka Connect类似的方式运行它。 要将数据加载到AWS S3中，可以使用适当的主题名称、S3区域和bucket配置S3连接器属性，然后运行连接器。现在我们将省略S3的精确配置(很快就会有另一篇关于此配置的博客文章)，但是您可以使用以下命令启动连接器: 结论也许在这篇博客文章中描述的工作流对于我们这个非常简单的例子来说似乎带来了很多开销。但是，考虑具有多个数据源和目标的真实场景，这些数据源和目标需要摄取数据，同时支持随时间变化的各种模式。有多步骤的实时工作流，具有复杂的转换，需要高耐久性和容错能力。Kafka为构建流ETL管道提供了一个非常灵活、可伸缩的架构。您不希望试图将其与传统的ETL范式结合在一起，因为整个过程不可避免地会变得混乱。回顾Kafka参考体系结构图，您可以看到实时的、关键业务的应用程序如何从Kafka的流化ETL功能中获益: Kafka流媒体平台允许关键任务应用程序实时处理数据: Kafka连接器在Kafka Connect框架中运行，开发人员可以从一个系统中提取数据或将数据加载到另一个系统中 Kafka Streams API为应用程序提供了流处理功能，可以一次转换一条消息或事件。这些转换可以包括连接多个数据源、过滤数据和在一段时间内聚合数据 Confluent模式注册中心使用Avro模式提供数据治理 汇流控制中心提供集中管理 下载Confluent开放源代码，并从使用Kafka流、Kafka Connect、Avro、模式注册表的代码示例开始。如果你喜欢Docker，你也可以看看Kafka的音乐演示。","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"}]},{"title":"Hello World, Kafka连接器 + Kafka流计算","slug":"hello-world-kafka-connect-kafka-streams","date":"2018-11-28T02:37:23.000Z","updated":"2020-07-25T02:57:18.207Z","comments":true,"path":"2018/11/28/hello-world-kafka-connect-kafka-streams/","link":"","permalink":"https://jigangduan.github.io/2018/11/28/hello-world-kafka-connect-kafka-streams/","excerpt":"","text":"重要提示:本文中的信息已经过时。通过最近的Kafka版本，Kafka Connect和Kafka流以及KSQL之间的集成变得更加简单和容易。请参阅 在20分钟内构建实时流ETL管道和KSQL实战:从Oracle事务数据中实时流化ETL 本文由客籍博客Michal Haris与Neha Narkhede、Apache Kafka committer、Confluent联合创始人和CTO合作撰写。Michal在数字媒体行业工作，是一名专业从事实时大数据基础设施和流处理应用概念验证实现的技术架构师。 在过去的几年里，随着Apache Kafka的广泛采用，流处理已经走到了前台。最近，出现了几个与Kafka集成的流处理系统。其中一个系统Apache Samza有一个特别有趣的“hello world”教程，用于开始使用该系统;Hello Samza使用维基百科在其IRC频道上发布的实时更新。在本文中，我们将学习相同的教程，但是使用Apache Kafka项目伞下的两个新模块构建，一个最近发布，另一个计划在即将发布的版本中发布。 Kafka Connect是Apache Kafka 0.9的一部分，它是Apache Kafka和其他数据系统之间可伸缩和可靠流数据的工具。它提供了API、运行时和REST服务，使开发人员能够快速定义连接器，从而将大型数据集移入和移出Kafka。它具有容错性和弹性，我们已经习惯了，并产生于整个一代摄食和卸载工具的经验。Kafka Connect可以摄取整个数据库，或者从所有应用服务器收集度量数据到Kafka主题中，从而使数据能够以较低的延迟进行流处理。这篇文章发布了该版本，您可以在其中找到链接和更多信息。 另一个特性是Kafka Streams——用于创建流处理应用程序的轻量级库。就部署而言，它是轻量级的，实际上在这方面它是完全“失重”的，不像大多数(如果不是全部的话)它的前辈和同时代人。这个库也是轻量级的，因为它构建在Kafka中针对流处理应用程序需要处理的问题(容错性、分区、可伸缩性、排序和负载平衡)本地构建的原语之上。对于我们这些重视软件简洁性的人来说，它是重量级冠军，用相对较少的资源实现了如此多的成就。更多关于背景和架构:介绍Kafka流 为了创建我们的Hello Kafka流程序，我们需要连接Wikipedia IRC通道，将它们转换成一个分区主题，我们可以从这个主题构建处理器拓扑。目前Kafka Connect还没有公开嵌入式API，尽管所有必要的构建块都已经就绪(在connect-runtime模块下)。但是，这项工作已经计划在将来的版本中进行，因此我们将通过在ConnectEmbedde.java中创建自己的临时扩展来加快进度。 在深入讨论之前，值得注意的是，有两种方法可以运行到Kafka的连接器: 作为一个连接器在集群进程上，运行Kafka Connect。 作为应用程序流程中的嵌入式实体。 您可能想知道，在另一个进程中嵌入连接器与在Kafka连接集群中作为长时间运行的进程相比，什么时候更好。 连接器更好地作为长期运行的Kafka连接流程来操作，以便在共享和标准数据系统之间支持流ETL流。例如，使用MySQL源连接器和HDFS接收器连接器从MySQL数据库中提取数据并将其加载到Hadoop中。另一方面，只与应用程序相关的连接器更方便地作为应用程序进程中的嵌入式实体运行。例如，本文中描述的一个演示应用程序。在这里，我们不希望为了运行一个简单的演示应用程序而单独运行服务和管理连接器，这会增加复杂性。有趣的是，在实际应用程序中常常是这样，而不仅仅是演示。在不更改体系结构的情况下降低开发的可伸缩性是可伸缩性的一个非常容易被忽略的方面——通常我们只考虑将可伸缩性提高到更大的数据量或更高的吞吐量。 好了，废话不多说，让我们直接进入构建Hello Kafka流。 如果您熟悉这些概念和api，可以跳过下一节，只查看GitHub上的整个项目。 注意:由于本演示构建在即将发布的0.10.x版本的特性之上，因此您要么需要与Kafka流或Apache Kafka主干或本地安装的任何0.10.x版本的技术预览相结合的平台 维基百科卡夫卡流演示 —— 步骤 上面是连接器、主题和处理器的集成拓扑的概述图。 首先，我们需要介绍通用的IRC连接器。它在这里由3个类实现。主类IRCFeedConnector接受IRC主机和端口配置、通道列表和输出主题。在Kafka Connect设计中，连接器是序列化无关的。这使得它们可以在不同的上下文中使用，例如，如果您运行Kafka Connect服务并使用Avro序列化器进行配置，那么您可以像这样配置IRC连接器，无需修改即可重用它: 1234567name=wikipedia-irc-sourceconnector.class=io.amient.kafka.connect.irc.IRCFeedConnectortasks.max=10irc.host=rc.wikimedia.orgirc.port=6667irc.channels=#en.wikipedia,#en.wiktionary,#en.wikinewstopic=wikipedia-raw 在我们的主类WikipediaStreamDemo中，我们用.createWikipediaFeedConnectInstance()方法以编程方式提供这个配置。结果是一样的——不管运行多少个应用程序实例，我们最多只能得到3个任务，每个通道一个任务。因为我们正在启动一个嵌入式实例，所以我们还必须提供辅助配置、转换器等。为了保持演示的简洁，我们使用的org.apache.kafka.connect.json.JsonConverter附带Kafka，由于底层设计，它可以自动为任何源模式工作。 连接实例配置,剩下是调用方法.start() ,我们有效地集成连接器为我们的应用程序,我们现在有一个协调组运行在它自己的线程池,确保主题wikipedia-raw将一连串的json表示的通用IRCMessage维基百科服务器。 现在我们可以看一下.main(…)方法中定义的集成拓扑，它实际上是程序的唯一例程，其余的都是声明性的。 在connect实例启动之后，流拓扑实例化并启动。该方法的其余部分只是确保在关闭时这两个服务都被干净地停止。最后一段代码是.createWikipediaStreamsInstance()方法，它声明了流拓扑。 在创建json serde helper实例之后，我们声明第一个KStream&lt;JsonNode, JsonNode&gt; wikipediaRaw。除了从连接器离开的地方开始。 在下一段代码中，我们使用Java 8的方法引用来声明这个wikipedia-raw消息json流上的转换，以保持简洁。方法.parseIRC()是从Hello Samza的作者那里借来的，用于提取和解析原始irc消息到WikipediaMessage。此方法还将转换后的流的键更改为提交编辑的用户的字符串用户名，这对于正确的每个用户聚合是必要的。过滤掉任何表示解析器无法理解的消息的空值，剩下的就是一个&lt;String,WikipediaMessage&gt;流。使用KStream的.through(..)方法将这个流持久化到主题wikipedia-parsed中——使用一个通用的jsonPOJOSerde&lt;WikipediaMessage&gt;，我们说这个主题的内容也将是json序列化的。用于分区的键将是前面转换声明的作者的用户名。 最后一个KTable&lt;String, Long&gt;是通过过滤和聚合使用.countByKey()解析的wikipedia消息流来声明的——这也是我们的最终输出，它使用低级.process()方法连续打印更新。 Key Takeaways因此，我们有一个完整的流处理应用程序，它从公共IRC服务器提取数据并计算一些使用分析。如果重新启动它，您会注意到它还记得每个用户的计数的最后一种状态——KTable保存在一个更改日志主题中，下次将从该主题中恢复。 我们将说明关于前面一点的降级:我们现在可以在终端中运行hello-kafka流的一个实例，在IDE中运行第二个实例，以调试实例在作为组的一部分时的行为——这在像YARN这样的框架中长期难以实现。 由于不涉及部署框架，且所有实例都是相同的(包括配置，在本例中，配置是直接烧入主类的)，因此所有部署选项都是可用的;无论您选择将流处理应用程序打包到Docker中并在Mesos上运行，还是从Chef更改为Puppet进行配置管理，流处理应用程序都将保持不变。 需要注意的一点是，当应用程序被关闭时，IRC通道没有任何处理，这将导致数据丢失，因为没有计算编辑。每当连接器组中的工作发生重新平衡时，都会发生相同的数据丢失，但这只是IRC通道的一个特性—如果脱机，就会丢失消息，并且其中没有补偿的概念。如果你想要更多的无损的这个演示最好的变体,你所能做的就是减少应用程序停机时间是另一篇文章的主题也许——或者使用一个数据源有偏移的概念,至少一个时间戳,卡夫卡连接将愉快地做管理的工作最后一个可靠地消耗补偿。 至于Kafka流和Kafka Connect的集成，有一种情况是两者之间的一级集成，这样连接器就可以直接映射到KStream，从而允许在连接器的输出上直接应用任何流转换。例如，在这个wikipedia演示中，我们可以消除wiki-raw主题，并立即按用户名应用解析和分区，在不牺牲应用程序任何有用特性的情况下改善延迟和存储占用。 首先让我们看一种可能的实现。这里，我们重用了大部分现有的代码，并在流构建器上引入了一个新的重载方法.stream(…)，该方法没有将主题名作为最后一个参数，而是采用一个与ConnectEmbedded类似的实例，只不过我们将它称为EmbeddedConnectSource: 上面，方法方法createConnectSource()使用与我们的工作演示解决方案的方法createWikipediaFeedConnectInstance()相同的配置。我们使用JsonConverter将源IRCMessage转换为序列化的json。但是请注意，我们立即告诉流构建器将这些序列化的数据解析回JsonNode，而JsonNode又被解构为WikipediaMessage。如果分析这个实现，您可能会发现这个转换、解析和解构占用了整个程序的大部分CPU周期。 如果只给流构建器连接器配置(而不是工作配置)并返回SchemaAndValue对象流，则可以避免转换为json并随后解析到JsonNode的更有效版本。这将需要公开一些连接器内部，而且在Kafka端实现起来比较困难，但是可以节省周期，而且在应用程序的初始化代码方面也比较少噪音: 不管怎样，集成API很快就会出现。请继续关注! 结论 建在正确的基础上: Apache Kafka中的基本原语已经被证明是成功的，并且为实现流处理操作提供了正确的构建块，无论是实时摄取还是流处理。由此产生的简单性在基础设施工具方面大有裨益。替代方案包括为许多不同的系统构建和操作插件，因此与在数据中心中心拥有一个平台相比，它们的吸引力要小得多。 易于接近和开发人员友好: 使用Connect和Streams(包括嵌入式运行时扩展)编写演示程序花费的时间(一天)与理解、打包和在真实集群上部署Hello Samza所用的时间差不多 你所需要的: 将Kafka、Kafka Connect和Kafka流一起使用不仅是可能的，而且它还提供了编写流处理应用程序的完整工具。","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"}]},{"title":"IIoT消息队列(IoT MQ)选型","slug":"things-queue-selection","date":"2018-11-01T02:48:24.000Z","updated":"2020-07-25T02:57:18.230Z","comments":true,"path":"2018/11/01/things-queue-selection/","link":"","permalink":"https://jigangduan.github.io/2018/11/01/things-queue-selection/","excerpt":"","text":"为什么被需要MQ？IIoT作为设备接入和业务层承上启下的作用，其最重要的职能在于提供一个统一接口: 解耦上下各个不同系统的之间的关联性，使它们之间可以不直接依赖 同构系统中每个结点上的一致性，是各个系统直接可以交流 灵活地添加组件或适配系统，使其结构灵活，易于扩充 为了达到这三个功能，门面模式+适配器+观察者模式 的设计模式非常适合，那么消息队列就是最佳选择了。消息队列作为门面，作为各个系统的接入点，解耦了它们之间的相互关联；我们还需要制定一套统一的消息标准，同构各个系统的接入方式；为了满足已有的协议和系统，需要使用适配器的方式，让它们兼容到整个的系统中来。 特性需求各个不同的系统可能包括采取服务，各类设备，数据中心或SCADA等，为了满足这些不同的系统需要满足如下特性： 实时性高并发可靠性安全防护可扩展 消息队列协议对比为了找到合适的消息队列系统，选定几个消息队列协议进行对比来找到合适方式。 MQTT（消息队列遥测传输），在物联网、小型设备、移动应用等方面有较广泛的应用 AMQP（级消息队列协议），是应用层协议的一个开放标准,为面向消息的中间件设计 Kafka(不是协议，是消息系统)，解决有吞吐量要求而的日志和数据聚合作用 比较项： 从上面各项比较可以得知，MQTT优势是实时性，Kafka优势是数据聚合，AMQP优势是应层解耦 方案建议EMQ+KafkaMQTT协议应用场景大多是在物联网设备的接入，对短数据有非常适应的实时性特点，Kafka和AMQP的实时性都不及MQTT。MQTT专门为物联网设计，可以直接接入支持MQTT协议的设备，软件，系统或移动端。目前大多的物联网平台的做法是使用MQTT做设备上传协议，如果是其他采集协议，就使用网关做协议转换器，如下： 但我们公司不用选择设备的原因，其建议协议转换功能在采集服务器中，也是做为协议适配的功效，其适配器可以尽量灵活部署，可能是插件，服务器应用，桌面应用和Linux设备等。 MQTT在实时性上表现优异但在数据聚合方面上不足，所以建议EMQ+Kafka的模式。如果数据是输出给类似ETL（数字仓库）这样的，需要通过Kafka作缓冲和聚合；如果是连接到SCADA这样的系统，直接通过EMQ就可以了。 EMQ简介EMQ是百万级分布式开源物联网MQTT消息服务器。基于高并发的Erlang/OTP语言平台设计，支持百万级连接和分布式集群，发布订阅模式的开源MQTT消息服务器。完整支持MQTT V3.1/V3.1.1协议规范，扩展支持WebSocket、Stomp、CoAP、MQTT-SN或私有TCP协议。 官网了解更多： http://emqtt.comhttps://www.emqx.ioGitHub","categories":[{"name":"IoT","slug":"IoT","permalink":"https://jigangduan.github.io/categories/IoT/"},{"name":"消息队列","slug":"IoT/消息队列","permalink":"https://jigangduan.github.io/categories/IoT/消息队列/"}],"tags":[{"name":"iot","slug":"iot","permalink":"https://jigangduan.github.io/tags/iot/"},{"name":"mq","slug":"mq","permalink":"https://jigangduan.github.io/tags/mq/"}]},{"title":"GitHub精选-PaaS","slug":"github-paas","date":"2018-10-30T15:37:18.000Z","updated":"2020-07-25T02:57:18.202Z","comments":true,"path":"2018/10/30/github-paas/","link":"","permalink":"https://jigangduan.github.io/2018/10/30/github-paas/","excerpt":"","text":"Nacos Rainbond Naftis nacos 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台. 功能服务管理开发者或者运维人员往往需要在服务注册后，通过友好的界面来查看服务的注册情况，包括当前系统注册的所有服务和每个服务的详情。并在有权限控制的情况下，进行服务的一些配置的编辑操作。Nacos在这个版本开放的控制台的服务发现部分，主要就是提供用户一个基本的运维页面，能够查看、编辑当前注册的服务。 服务列表管理服务列表帮助用户以统一的视图管理其所有的微服务以及服务健康状态。整体界面布局是左上角有服务的搜索框和搜索按钮，页面中央是服务列表的展示。服务列表主要展示服务名、集群数目、实例数目、健康实例数目和详情按钮五个栏目。 在服务列表页面点击详情，可以看到服务的详情。可以查看服务、集群和实例的基本信息。 服务流量权重支持及流量保护Nacos 为用户提供了流量权重控制的能力，同时开放了服务流量的阈值保护，以帮助用户更好的保护服务服务提供者集群不被意外打垮。如下图所以，可以点击实例的编辑按钮，修改实例的权重。如果想增加实例的流量，可以将权重调大，如果不想实例接收流量，则可以将权重设为0。 服务元数据管理Nacos提供多个维度的服务元数据的暴露，帮助用户存储自定义的信息。这些信息都是以K-V的数据结构存储，在控制台上，会以k1=v1,k2=v2这样的格式展示。类似的，编辑元数据可以通过相同的格式进行。例如服务的元数据编辑，首先点击服务详情页右上角的“编辑服务”按钮，然后在元数据输入框输入：version=1.0,env=prod。 点击确认，就可以在服务详情页面，看到服务的元数据已经更新了。 服务优雅上下线Nacos还提供服务实例的上下线操作，在服务详情页面，可以点击实例的“上线”或者“下线”按钮，被下线的实例，将不会包含在健康的实例列表里。 配置管理Nacos支持基于Namespace和Group的配置分组管理，以便用户更灵活的根据自己的需要按照环境或者应用、模块等分组管理微服务以及Spring的大量配置，在配置管理中主要提供了配置历史版本、回滚、订阅者查询等核心管理能力。 多配置格式编辑器Nacos支持 YAML、Properties、TEXT、JSON、XML、HTML 等常见配置格式在线编辑、语法高亮、格式校验，帮助用户高效编辑的同时大幅降低格式错误带来的风险。 Nacos支持配置标签的能力，帮助用户更好、更灵活的做到基于标签的配置分类及管理。同时支持用户对配置及其变更进行描述，方面多人或者跨团队协作管理配置。 编辑DIFFNacos支持编辑DIFF能力，帮助用户校验修改内容，降低改错带来的风险 示例代码Nacos提供示例代码能力，能够让新手快速使用客户端编程消费该配置，大幅降低新手使用门槛。 监听者查询Nacos提供配置订阅者即监听者查询能力，同时提供客户端当前配置的MD5校验值，以便帮助用户更好的检查配置变更是否推送到 Client 端。 配置的版本及一键回滚Nacos通过提供配置版本管理及其一键回滚能力，帮助用户改错配置的时候能够快速恢复，降低微服务系统在配置管理上的一定会遇到的可用性风险。 命名空间管理Nacos 基于Namespace 帮助用户逻辑隔离多个命名空间，这可以帮助用户更好的管理测试、预发、生产等多环境服务和配置，让每个环境的同一个配置（如数据库数据源）可以定义不同的值。 Rainbond Rainbond是以应用为中心的 PaaS，领先的理念和完整的生态源自于不断的验证和优化。 Rainbond（云帮）是”以应用为中心”的开源PaaS， 深度整合基于Kubernetes的容器管理、ServiceMesh微服务架构最佳实践、多类型CI/CD应用构建与交付、多数据中心资源管理等技术， 为用户提供云原生应用全生命周期解决方案，构建应用与基础设施、应用与应用、基础设施与基础设施之间互联互通的生态体系， 满足支撑业务高速发展所需的敏捷开发、高效运维和精益管理需求。 功能特性应用管理 应用级（完整业务系统）编排 集成 Kubernetes 的服务组件级编排与调度 基于扩展式 ServiceMesh 的服务网格系统提供原生微服务治理支持（服务发现、动态路由、限流与熔断） 支持其他各类(SpringCloud、Dubbo、API-Gateway)微服务架构 支持多种(HTTP、Mysql)类型协议的业务级应用性能分析 支持基于源代码（Java、PHP、Python、Golang、Ruby 等）构建服务 支持基于公(私)有Git、Svn 代码仓库、镜像仓库或对接第三方CI系统的服务持续构建和部署 支持基于 Docker 容器镜像、Docker-Run 命令、DockerCompose 文件智能快捷构建应用 支持应用级全量备份与恢复，跨租户或跨数据中心迁移应用 服务插件体系支持，灵活扩展应用附属功能，例如：日志处理、防火墙、流量分析等 公（私）有应用市场支持，完善的应用交付体系 资源/云管理 作为建设云原生数据中心的基础系统 插件化支持部署不同的服务网关(Openresty、F5等)、SDN 网络（Midonet、Calico）、分布式存储系统（GlusterFS、Ali-NAS、Ceph等） 支持多数据中心(集群)管理和应用编排 平台高可用支持 集群自动化管理与运维，自动化的健康检查机制 节点物理硬件与系统指标的自动监控 服务实例容器指标自动监控 架构 产品图示 Istio 管理面板 Naftis 开发厂商: 小米 Naftis 是一个基于 web 的 Istio dashboard，通过任务模板的方式来帮助用户更方便地执行 Istio 任务。 用户可以在 Naftis 中定义自己的任务模板，并填充变量来构造单个或多个构造任务实例，从而完成各种服务治理功能。 功能 内部集成了一些常用 dashboard 可定制的任务模板支持 支持回滚指定任务 支持指定根服务节点的服务拓扑图 提供查看 Istio 的 Services 和 Pod 的支持 开箱即用，通过 Kubectl 相关指令即可快速部署 支持 Istio 1.0 预览DashboardDashboard 页面集成了一些常用的图表，比如请求成功率、4XX请求数量等。 服务管理服务详情服务详情页面可以查看查看已部署到 Kubernetes 中服务信息。 服务Pod和拓扑图等服务详情页面可以查看服务 Pod 和拓扑图等信息。","categories":[{"name":"GitHub精选","slug":"GitHub精选","permalink":"https://jigangduan.github.io/categories/GitHub精选/"}],"tags":[{"name":"github","slug":"github","permalink":"https://jigangduan.github.io/tags/github/"},{"name":"paas","slug":"paas","permalink":"https://jigangduan.github.io/tags/paas/"}]},{"title":"安装ZSH","slug":"oh-my-zsh-installing-zsh","date":"2018-10-24T16:11:44.000Z","updated":"2020-07-25T02:57:18.223Z","comments":true,"path":"2018/10/25/oh-my-zsh-installing-zsh/","link":"","permalink":"https://jigangduan.github.io/2018/10/25/oh-my-zsh-installing-zsh/","excerpt":"","text":"Zsh?Oh-My-Zsh是Zsh的框架，Z shell。 为了让Oh-My-Zsh工作，必须安装Zsh。 请运行zsh --version确认。 预期结果:zsh 5.1.1或更近期 另外，Zsh应该被设置为您的默认shell。 请从一个新的终端运行echo $SHELL来确认。 预期结果:usr/bin/zsh或类似 安装并设置zsh为默认值如有必要，请按照以下步骤安装Zsh: 安装Zsh有两种主要方法 使用您选择的包管理器，例如sudo apt-get install zsh(请参阅下面的示例) 来自source,以下是Zsh FAQ中的说明 通过运行zsh -version来验证安装。预期结果:zsh 5.1.1或更近期。 让它成为您的默认shell: chsh -s $(which zsh) 注意，如果Zsh不在您的授权shell列表(/etc/shell)中，或者您没有使用chsh的权限，那么这将不起作用。如果是这样的话，你需要使用不同的程序 注销并再次登录以使用新的默认shell。 测试它是否工作 echo $SHELL。预期结果:/bin/zsh或类似。 用 $SHELL --version测试。预期结果:“zsh 5.1.1”或类似 如何在多个平台上安装zshmacOS用Homebrew安装之前尝试zsh --version。如果它比4.3.9更新，你可能就没问题了。最好比5.0更新或等于5.0 1brew install zsh zsh-completions 或 MacPorts 1sudo port install zsh zsh-completions Ubuntu, Debian &amp; derivatives1apt install zsh","categories":[{"name":"shell","slug":"shell","permalink":"https://jigangduan.github.io/categories/shell/"},{"name":"oh-my-zsh","slug":"shell/oh-my-zsh","permalink":"https://jigangduan.github.io/categories/shell/oh-my-zsh/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://jigangduan.github.io/tags/shell/"}]},{"title":"oh-my-zsh","slug":"oh-my-zsh","date":"2018-10-24T15:53:45.000Z","updated":"2020-07-25T02:57:18.224Z","comments":true,"path":"2018/10/24/oh-my-zsh/","link":"","permalink":"https://jigangduan.github.io/2018/10/24/oh-my-zsh/","excerpt":"","text":"欢迎使用oh-my-zsh! 如果没有安装zsh，请参阅安装zsh。 看看我们的主题和插件(这里有一个简短的概述:插件概述)。 您可以在外部主题和外部插件中找到更多。 了解定制。 有问题吗?请查看故障排除页面以获得指示。 请阅读我们的用户推荐。","categories":[{"name":"shell","slug":"shell","permalink":"https://jigangduan.github.io/categories/shell/"},{"name":"oh-my-zsh","slug":"shell/oh-my-zsh","permalink":"https://jigangduan.github.io/categories/shell/oh-my-zsh/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://jigangduan.github.io/tags/shell/"}]},{"title":"SQL Server - 使用Visual Studio Code创建和运行Transact-SQL脚本","slug":"mysql-vscode","date":"2018-10-02T01:20:02.000Z","updated":"2020-07-25T02:57:18.223Z","comments":true,"path":"2018/10/02/mysql-vscode/","link":"","permalink":"https://jigangduan.github.io/2018/10/02/mysql-vscode/","excerpt":"","text":"本文展示了如何使用Visual Studio Code(VS Code)的mssql扩展来开发SQL Server数据库。 Visual Studio Code是一个用于Linux、macOS和Windows的图形化代码编辑器，支持扩展。VS Code的mssql扩展允许您连接到SQL服务器，使用Transact-SQL (T-SQL)查询，并查看结果。 安装 VS Code 如果您还没有安装VS Code，请下载并安装VS Code。 启动VS Code 安装mssql扩展以下步骤说明如何安装mssql扩展: 按 CTRL+SHIFT+P (或 F1)打开VS Code中的命令面板。 选择Install Extension并输入mssql。 提示 对于macOS, CMD键相当于Linux和Windows上的CTRL键。 点击安装mssql mssql扩展 最多需要一分钟的安装时间。等待提示告诉您它已成功安装。 请注意对于macOS，您必须安装OpenSSL。这是mssql扩展所使用的.Net Core的先决条件。按照.Net Core说明中的安装必备步骤。或者，您可以在macOS终端运行以下命令。 1234brew updatebrew install opensslln -s /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib /usr/local/lib/ln -s /usr/local/opt/openssl/lib/libssl.1.0.0.dylib /usr/local/lib/ 请注意对于Windows 8.1、Windows Server 2012或更低版本，您必须下载并安装Windows 10 Universal C Runtime。下载并打开zip文件。然后运行安装程序(. msu文件)针对您当前的操作系统配置。 创建或打开SQL文件当语言模式设置为SQL时，mssql扩展支持编辑器中的mssql命令和T-SQL智能感知。 按CTRL + N。Visual Studio Code默认打开一个新的纯文本文件。 按CTRL+K,M，将语言模式改为SQL。 或者，使用.sql文件扩展名打开现有文件。语言模式为具有sql扩展名的文件自动SQL。 连接到SQL Server下面的步骤展示了如何使用VS Code连接到SQL Server。 在VS Code中，按CTRL+SHIFT+P(或F1)打开命令面板。 输入sql以显示mssql命令。 选择MS SQL: Connect命令。您可以简单地键入sqlcon并按ENTER键。 选择Create Connection Profile。这将为SQL服务器实例创建一个连接概要文件。 按照提示指定新连接概要文件的连接属性。指定每个值之后，按ENTER键继续。 下表描述连接概要属性。 设置 描述 服务器名称 SQL服务器实例名。对于本教程，使用localhost连接到机器上的本地SQL服务器实例。如果连接到远程SQL服务器，请输入目标SQL服务器机器的名称或其IP地址。如果需要为SQL Server实例指定端口，请使用逗号将其与名称分离。例如，对于运行在端口1401上的本地服务器，您将输入localhost,1401。 (可选的)数据库名称 您想要使用的数据库。对于本教程，不要指定数据库并按ENTER键继续。 用户名 输入访问服务器上数据库的用户名。对于本教程，使用在SQL Server设置期间创建的默认SA帐户。 密码(SQL登录) 输入指定用户的密码 保存密码? 输入Yes以保存密码。否则，每次使用连接配置文件时都会提示输入No以输入密码 [可选的]为这个概要文件输入一个名称 连接概要名称。例如，您可以将概要文件命名为localhost profile。 提示您可以在用户设置文件(settings.json)中创建和编辑连接配置文件。通过在VS Code菜单中选择首选项和用户设置来打开设置文件。有关更多信息，请参见manage connection配置文件。 按ESC键关闭通知创建和连接概要文件的info消息 提示如果连接失败，首先尝试从VS Code的输出面板中的错误消息诊断问题(在视图菜单中选择Output)。然后检查连接故障排除建议。 验证您在状态栏中的连接 创建一个数据库 在编辑器中，键入sql以打开可编辑代码片段列表。 选择sqlCreateDatabase 在代码片段中，输入TutorialDB作为数据库名 123456789USE masterGOIF NOT EXISTS (SELECT nameFROM sys.databasesWHERE name = N'TutorialDB')CREATE DATABASE [TutorialDB]GO 按CTRL+SHIFT+E执行Transact-SQL命令。在查询窗口中查看结果。 提示您可以为mssql扩展命令定制快捷键绑定。看到自定义快捷键。 创建表 删除编辑器窗口的内容。 按F1以显示命令面板。 在命令面板中键入sql命令来显示sql命令或键入sqluse(用于MS sql:Use Database命令)。 单击MS SQL:Use Database，并选择TutorialDB数据库。这将更改上一节中创建的新数据库的上下文。 在编辑器中，键入sql以显示片段，然后选择sqlCreateTable并按enter键。 在代码片段中，为表名输入Employees。 按Tab键，然后为模式名输入dbo。 请注意添加代码片段之后，您必须键入表和模式名称，而不需要将焦点从VS Code编辑器移开。 将Column1的列名更改为Name，而Column2更改为Location。 12345678910111213-- 在模式`dbo`中创建一个名为`Employees`的新表-- 如果表已经存在，则删除它IF OBJECT_ID('dbo.Employees', 'U') IS NOT NULLDROP TABLE dbo.EmployeesGO-- 在指定的模式中创建表CREATE TABLE dbo.Employees( EmployeesId INT NOT NULL PRIMARY KEY, -- 主键列 Name [NVARCHAR](50) NOT NULL, Location [NVARCHAR](50) NOT NULL);GO 按CTRL+SHIFT+E创建表 插入和查询 添加以下语句以向Employees表插入4行。然后选择所有的行。 123456789101112131415-- 在`Employees`表中插入行INSERT INTO Employees ([EmployeesId],[Name],[Location])VALUES ( 1, N'Jared', N'Australia'), ( 2, N'Nikita', N'India'), ( 3, N'Tom', N'Germany'), ( 4, N'Jake', N'United States')GO-- 查询员工总数SELECT COUNT(*) as EmployeeCount FROM dbo.Employees;-- 查询所有员工信息SELECT e.EmployeesId, e.Name, e.LocationFROM dbo.Employees as eGO 提示在键入时，使用T-SQL智能感知的帮助 按CTRL+SHIFT+E执行命令。这两个结果集显示在结果窗口中。 查看并保存结果 在视图菜单上，选择切换编辑器组布局切换到垂直或水平分割布局。 单击结果和消息面板标题折叠并展开面板 提示您可以定制mssql扩展的默认行为。请参阅自定义扩展选项。 单击第二个结果网格上的maximize grid图标来放大 请注意当T-SQL脚本具有两个或多个结果网格时，将显示最大化图标。 在网格上用鼠标右键打开网格上下文菜单 选择Select All 打开grid上下文菜单并选择Save as JSON将结果保存到.json文件中 为JSON文件指定文件名。对于本教程，输入employees.json 验证JSON文件是否保存并以VS Code打开 下一个步骤在真实的场景中，您可能会创建一个脚本，您需要保存并在以后运行它(用于管理或作为更大的开发项目的一部分)。在本例中，您可以使用.sql扩展名保存脚本。 如果您对T-SQL不熟悉，请参阅教程:编写Transact-SQL语句和Transact-SQL引用(数据库引擎)。 有关使用或贡献mssql扩展的更多信息，请参阅mssql扩展项目wiki。 有关使用VS Code的更多信息，请参阅Visual Studio Code文档。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"SQL Server","slug":"VS-Code/SQL-Server","permalink":"https://jigangduan.github.io/categories/VS-Code/SQL-Server/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"},{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"sql-server","slug":"sql-server","permalink":"https://jigangduan.github.io/tags/sql-server/"}]},{"title":"Go 工业级编程","slug":"go-for-industrial-programming","date":"2018-09-17T23:49:35.000Z","updated":"2020-07-25T02:57:18.203Z","comments":true,"path":"2018/09/18/go-for-industrial-programming/","link":"","permalink":"https://jigangduan.github.io/2018/09/18/go-for-industrial-programming/","excerpt":"","text":"原文(https://peter.bourgon.org/go-for-industrial-programming/) 我们不应该盲目地应用教条主义的建议，每次我们应该使用我们的判断。 互联网上的一些人发现，你在科技行业呆的时间越长，你的观点就会变得越好，这要看情况而定，我不确定，这些是不是很好。根据我的经验，如果你发现随着你事业的发展，你会变得越来越固执己见，那么你很有可能陷入一种窠臼，成为一个专业的初学者。不太好了! 明确定义一个适用范围，就能给自己留出一点空间来形成一个明确的意见： 在创业或公司环境中; 在一个工程师来来去去的团队中; 比任何一个工程师都长寿的代码; 服务高度可变的业务需求。 构造代码和存储库我们经常看到的一件事是对严格的项目结构的期望，通常在项目开始时就预先决定了。我认为这通常是问题多于帮助。要理解原因，请记住工业编程的第四个特性，或许也是最重要的一个特性: 工业编程 … 提供高度可变的业务需求 惟一不变的是变更，惟一的业务需求规则是它们 永远不会收敛，它们只会_发散、增长和变异。因此，我们应该确保我们的代码能够适应生活中的这一事实，而不是不必要地将自己限制在其中。我们的repos，我们的抽象，我们的代码本身应该易于维护，易于修改，易于适应，最终，易于删除。 有几件事通常是好主意。如果您的项目有多个二进制文件，最好有一个cmd/子目录来保存它们。如果您的项目很大并且有重要的非Go代码，比如UI资产或复杂的构建工具，那么将Go代码隔离在pkg/子目录中可能是一个好主意。如果您要有多个包，那么最好围绕业务领域来定位它们，而不是围绕实现的意外情况。即:包用户;而非包模型。 当然，业务领域和实现并不总是严格分开的。例如，大型web应用程序往往混合了传输和核心业务关注点。GoBuffalo之类的框架鼓励使用诸如操作、资产、模型和模板之类的包名。当您知道只处理HTTP时，将所有精力都放在耦合上是有好处的。 还有建议我们根据依赖边界对齐包。也就是说，为RedisStore、MySQLStore等提供单独的包，以避免外部消费者必须包含和编译对他们不需要的东西的支持。在我看来，对于具有封闭的导入器集的包来说，这是一种不合适的优化，但是对于第三方(如Kubernetes)广泛导入的包来说，这种优化非常有意义，因为在第三方，编译单元的大小可能成为真正的瓶颈。 所以有一个适用范围。我认为最好的一般性建议是，一旦你觉得有必要，具体地说，只选择加入一点结构。我的大多数项目仍然以package main中的几个文件开始，它们捆绑在repo的根目录下。它们一直保持这种状态，直到它们变成至少几千行代码。我的许多项目，甚至大多数项目，都没有走到这一步。Go的一个好处是它能让人感觉很轻;我喜欢尽可能长时间地保存它。 程序配置Flags是最好的方式来配置您的项目,因为它们自我记录的方式来描述您的程序在运行时的配置。 这在工业上下文中尤其重要，在工业上下文中，无论谁在运行服务，都可能不是其原始作者。如果使用-h标志运行程序提供了控制其行为的旋钮和开关的完整列表，那么对于随叫随到的工程师来说，在发生事件时调整某些东西是非常容易的，或者对于新工程师来说，让它在他们的开发环境中运行也是非常容易的。这比在(可能已经过时的)文档中查找一组相关的环境变量，或者找出配置文件格式的语法和有效键名要容易得多。 这并不意味着永远不要使用env vars或配置文件。除了使用标志之外，还有很好的理由使用其中之一或两者。Env vars对于连接字符串和非秘密的auth令牌非常有用，尤其是在开发期间。配置文件对于声明详细的配置非常有用，而且是将秘密放入程序的最安全的方法。(系统的其他用户可以检查标志，env vars很容易设置和遗忘。)只要确保显式命令行标志(如果给定)具有最高优先级。 12345678var fs myflag.FlagSetvar ( foo = fs.String(\"foo\", \"x\", \"foo val\") bar = fs.String(\"bar\", \"y\", \"bar val\", myflag.JSON(\"bar\")) baz = fs.String(\"baz\", \"z\", \"baz val\", myflag.JSON(\"baz\"), myflag.Env(\"BAZ\")) cfg = fs.String(\"cfg\", \"\", \"JSON config file\"))fs.Parse(os.Args, myflag.JSONVia(\"cfg\"), myflag.EnvPrefix(\"MYAPP_\")) 组件图工业编程意味着一次性编写代码并永久维护代码。维护是阅读和重构的持续实践。因此，工业编程压倒性地倾向于读，_在易读与易写之间，我们应该强烈地偏向于前者。 依赖注入是优化阅读理解的一个强大工具。这里我当然不是指facebook-go/inject或uber-go/dig所使用的依赖容器方法，而是将依赖关系枚举为类型或构造函数的参数的简单得多的实践。 下面是最近流行的一个基于容器的依赖注入的例子: 123456789101112131415161718func BuildContainer() *dig.Container &#123; container := dig.New() container.Provide(NewConfig) container.Provide(ConnectDatabase) container.Provide(NewPersonRepository) container.Provide(NewPersonService) container.Provide(NewServer) return container&#125;func main() &#123; container := BuildContainer() if err := container.Invoke(func(server *Server) &#123; server.Run() &#125;); err != nil &#123; panic(err) &#125;&#125; 主函数体结构紧凑，构建容器具有简洁、切中要点的外观。但是，提供方法需要反射来解释它的参数，而调用没有提供关于服务器实际需要做什么工作的线索。新员工必须在多个上下文之间跳转，以构建每个依赖项的心理模型、它们如何交互以及服务器如何使用它们。这代表了读理解和写理解之间的一个不好的权衡。 与本例要改进的代码的稍微修改过的版本相比: 1234567891011func main() &#123; cfg := GetConfig() db, err := ConnectDatabase(cfg.URN) if err != nil &#123; panic(err) &#125; repo := NewPersonRepository(db) service := NewPersonService(cfg.AccessToken, repo) server := NewServer(cfg.ListenAddr, service) server.Run()&#125; 主函数比较长，但是作为交换，我们得到了清晰的明确性。每个组件都按依赖顺序构造，并内联处理错误。每个构造函数都将其依赖项枚举为参数，从而允许新代码读取器快速、轻松地构建组件之间关系图的心智模型。在层层的间接性后面，没有什么是模糊的。 如果重构要求组件获得新的依赖项，则只需将其添加到构造函数中即可。下一个编译将触发错误，这些错误将精确地标识需要更新的参数列表，并且生成的PR中的差异将清楚地显示依赖关系的流。 我声称这严格优于前一种方法，在前一种方法中，从编写的代码中提取关系要困难得多，而且大部分故障检测延迟到运行时。我认为随着程序的大小(以及func main的大小)的增长，以及简单而显式的初始化复合函数的好处，它会变得越来越好。 当我们谈论阅读理解时，我喜欢思考我认为Go最重要的一个特性，那就是它本质上是非魔法的。除了极少数例外，对Go代码的直线阅读不会对定义、依赖关系或运行时行为产生歧义。这是伟大的。 但是有几种方法可以让魔法潜入其中。不幸的是，一种非常常见的方法是使用全局状态。包全局对象可以编码对外部调用者隐藏的状态和/或行为。调用这些全局变量的代码可能会产生令人惊讶的副作用，这将破坏读者理解并在心里为程序建模的能力 因此，考虑到读取优化和维护成本，我认为理想的Go程序几乎没有包全局状态，而是更喜欢通过构造函数显式地枚举依赖关系。由于func init的唯一工作就是初始化包的全局状态，所以我认为最好将其理解为几乎所有程序中的一个严重警告。多年来，我一直用这种方式编写程序，而在那段时间里，我只是越来越欣赏和提倡这种做法。 所以，我的现代Go理论是: 显式的依赖关系 没有包级别变量 没有函数初始化 Goroutine生命周期管理根据我的经验，不正确或过于复杂的启动、停止和检查goroutines的设计是新手和中级Go程序员面临挫折的最大原因。 我认为问题在于goroutine最终是一个非常低级的构建块，对于大多数人希望使用并发来完成的那种高阶任务几乎没有可用性。我们会说“永远不要在不知道如何停止的情况下开始吃goroutine”，但是如果没有具体的方法，这个建议就有点空洞了。我认为许多教程和大量示例代码，即使是在其他好的参考资料中，比如Go编程语言书籍，也会给我们带来不利影响，因为它们演示了并发概念，使用泄漏的即发即弃 goroutines、全局状态和模式，即使是基本的代码检查也会失败。 我看到的大多数goroutine都是由我的同事启动的，它们并不是定义良好的并发算法的附带步骤。它们往往是结构化的，用模糊的终止语义管理长时间运行的东西，通常在程序开始时启动。我认为这些用例需要使用更强的约定。 想象一下，go关键字的正字法略有不同。如果我们不能启动goroutine，而不提供中断或停止它的功能，那该怎么办?实际上，强制执行约定，除非我们知道如何阻止goroutine，否则不应该启动它。 这是我在使用package run时遇到的问题，它是从我去年从事的一个更大的项目中提取出来的。这里是最重要的方法，添加: 1func (g *Group) Add(execute func() error, interrupt func(error)) 添加要运行的goroutine队列，但也跟踪一个函数，该函数将在需要杀死goroutine时中断goroutine。这为整个goroutine组提供了定义良好的终止语义。例如，当我有多个应该永远运行的服务器组件时，我最常使用它，然后添加一个goroutine来捕获ctrl-C并销毁所有内容。 12345678910111213ctx, cancel := context.WithCancel(context.Background())g.Add(func() error &#123; c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) select &#123; case sig := &lt;-c: return fmt.Errorf(\"received signal %s\", sig) case &lt;-ctx.Done(): return ctx.Err() &#125;&#125;, func(error) &#123; cancel()&#125;) 如果您熟悉package errgroup，那么这在高层上与包errgroup类似，但更糟糕的是:errgroup隐式地假设所有执行函数都将响应提供给组的父上下文，并且没有使之显式的功能。 最近有一篇clickbaity博客文章声称“go语句被认为是有害的”，并提倡使用一种称为托儿所的结构，即生命周期绑定线程。package run和 最近有一篇clickbaity博客文章声称“go语句被认为是有害的”，并提倡使用一种称为托儿所的结构，即生命周期绑定线程。packageerrgroup都是这个托儿所概念的稍微不同的实现解释。 Futures这是高阶结构的一种形式。但还有很多其他的!例如，你知道Go有Futures吗?它只是比其他语言更冗长一些。 123future := make(chan int, 1)go func() &#123; future &lt;- process() &#125;()result := &lt;-future future的另一种发音方式是async/ await: 123c := make(chan int, 1)go func() &#123; c &lt;- process() &#125;() // asyncv := &lt;-c // await Scatter-gather我们也有散集，我一直在用它，当我知道我需要处理多少单位的工作时。 1234567891011121314151617// Scatterc := make(chan result, 10)for i := 0; i &lt; cap(c); i++ &#123; go func() &#123; val, err := process() c &lt;- result&#123;val, err&#125; &#125;()&#125;// Gathervar total intfor i := 0; i &lt; cap(c); i++ &#123; res := &lt;-c if res.err != nil &#123; total += res.val &#125;&#125; 一个优秀的Go程序员会对这些高阶并发模式中的几个有很强的控制能力。一个优秀的Go程序员会主动地将这些模式传授给他们的同事。 可观察性我们来谈谈可观察性。但在此之前，让我们先了解一下关于工业编程的另一种假设:我们编写的代码将运行在服务器上，为客户提供请求，并经历生命周期，而不会中断该服务。这不同于压缩包装并交付给客户的代码，也不同于作为批处理作业运行且不面向客户的代码。 在很大程度上，我同意Charity之前在节目中告诉我们的。特别是，我同意我们分布式工业系统的一个核心不变之处是，根本没有成本效益高的方法来进行全面集成或烟雾测试。集成或测试环境在很大程度上是一种浪费;更多的环境不会让事情变得更容易。对于我们的大多数系统来说，良好的可观察性比良好的测试更重要，因为良好的可观察性使明智的组织能够专注于快速部署和回滚，优化平均恢复时间(MTTR)，而不是平均故障间隔时间(MTBF)。 对我们来说，问题是:Go中一个恰当的可观测系统是什么样子的?我想没有一个单一的答案，没有一个包我可以告诉你进口来一劳永逸地解决问题。可观察性空间是破碎的，许多供应商为了他们独特的世界观而竞争。有很多事情值得兴奋，但胜利者还没有尘埃落定。在我们等待这一切发生的同时，我们能做些什么呢? 如果我们生活在一个更完美的世界里，这就无关紧要了。如果我们有一个完美的可观测性数据收集系统，所有的解释都可以在查询时间内完成，而且成本为零，那么我们就可以向它发射原始的观测数据，并提供无限的细节，然后用它来完成。但是，这个领域之所以有趣或具有挑战性，当然是因为没有这样的数据系统存在。所以我们不得不做出工程决策，妥协，赋予特定类型的观察以语义意义，以实现特定的可观察性工作流。 度量、日志记录和跟踪是使用可观察性数据的紧急模式，可观察性数据告知我们生成、发送和存储相应信号的方式。它们是一个优化函数的产物，介于运营商希望如何对自己的系统进行反省，以及技术是否能够大规模地满足这些需求之间。或许还有其他尚未被发现的消费模式，可能是由技术进步推动的，这将开启一个新的时代和可观察性分类。但这就是我们今天所处的位置，在可预见的未来也是如此。让我们看看如何在Go中最好地利用它们。 度量度量是计数器、测量器和直方图，它们的观察结果在统计上结合起来，并报告给一个允许快速、实时导出总体系统行为的系统。度量电源指示板和警报。 到目前为止，大多数度量系统都提供了Go客户机库，并且标准的显示格式(如StatsD)已经很好地理解和实现了。如果您的组织已经拥有了关于给定系统的制度知识，请将其标准化;如果你只是刚刚开始或想要集中在一个系统上，Prometheus是同类中最好的。 不再足够好的是基于主机或检查的系统，如Nagios、Icinga或Ganglia。这些会使您陷入监视范例中，而这些范例在很久以前就不再有意义了，并且会积极地阻碍使您的系统可见。 日志记录日志是对收集系统完全真实地报告的离散事件流，用于稍后的分析、报告和调试。好的日志是结构化的，允许灵活的事后操作。 现在Go中有很多很棒的日志选项。好的日志库是面向日志程序接口的，而不是具体的日志程序对象。它们将日志记录器视为依赖项，避免了包的全局状态。并且在callsite上强制执行结构化日志记录。 日志是抽象的流，而不是具体的文件，所以要避免日志记录器在磁盘上写或旋转文件;这是另一个流程或编排平台的职责。而且日志记录可以快速地控制系统的运行时成本，所以在生成和发出日志时要谨慎和明智。捕获与请求路径相关的所有内容，但要深思熟虑，使用装饰器或中间件之类的模式。 跟踪跟踪处理所有请求范围的性能数据，特别是当这些数据在分布式系统中跨流程和系统边界时。跟踪系统将元数据组织到树结构中，从而支持对特定异常或事件进行深度分类。 目前的跟踪实现主要围绕OpenTracing实现，OpenTracing是由Zipkin、Jaeger、Datadog等具体系统实现的客户端API标准。OpenCensus中也做了一些有趣的工作，它承诺提供一个更加集成的环境。 如果跟踪是有用的，那么它需要是全面的，并且在所有可观察性的支柱中，它拥有最严格的领域对象和谓词集。由于这些原因，正确实现跟踪的成本非常高，只有当分布式系统非常大(可能超过几十个微服务)时才有意义开始工作。 每个可观察性的支柱都有不同的优点和缺点。我认为我们可以沿着不同的轴比较它们:资本支出，开始测量和收集信号的初始成本;运营成本，运营支持基础设施的持续成本;反应，系统在发现和警报事件方面有多好;以及调查，系统能在多大程度上帮助对事件进行分类和调试。我的主观意见如下: Metrics Logging Tracing 资本支出 Medium Low High 维护成本 Low High Medium 反应能力 High Medium Low 检测 Low Medium High 就资本支出而言，日志系统是最容易启动的，在代码中添加日志工具比其他方法更容易、更直观。度量标准涉及的更多，但是大多数度量标准收集系统仍然是相对独立的，并且非常容易部署。与此相反，跟踪需要大量时间才能在整个机群中安装，而且跟踪收集系统通常很大，需要一些专门的数据库知识。 就OpEx而言，根据我的经验，让一个日志系统保持在线状态需要付出不成比例的努力，通常与相应的生产系统一样困难，甚至更困难——由于大多数组织都倾向于不加区别地进行过多的日志记录，这使其更加困难。跟踪系统可以从前期成本中获益，并且通常可以顺利地进行大量抽样和定期数据库维护。相反，度量系统受益于统计聚合所产生的自然数据压缩，并且通常具有非常低的维护成本。当然，如果你选择使用供应商，这些成本会直接转化为美元。 就反应能力而言，度量系统被显式地设计为服务于dashboard和警报用例，以及excel。日志系统经常使用一些工具来执行可以驱动仪表板和警报的聚合或滚动，只需要做一点工作。而跟踪系统通常没有能力定义、检测或发出异常信号。 然而，当涉及到调查时，形势发生了逆转。公制系统在设计上失去了数据的保真度，而且通常在检测到问题的根本原因后，无法提供深入研究问题根源的好方法。日志系统做得更好，特别是如果您使用结构化日志记录和具有丰富查询语言的日志系统。跟踪本质上是为针对特定请求或请求类的深入研究而设计的，有时是识别复杂的不适应行为的唯一方法。 这里的教训是，没有一个单一的可观察性范式能够解决您所有的可观察性需求;它们都是完整的可观察早餐的一部分。从他们独特的特点，我认为我们可以得出一些一般性的建议: 首先，投资于基本的、全面的度量标准，为组件提供一组统一的仪表板和警报。在实践中，这通常足以发现并解决大量的问题。 接下来，投资于深度、高基数、结构化日志记录，以便对更复杂的问题进行事件分类和调试。 最后，当您拥有足够大的规模和定义良好的生产准备标准时，研究分布式跟踪。 测试尽管大型分布式系统的可观察性可能优于集成测试，但是单元和有限的集成测试仍然是任何软件项目的基础和必要的。特别是在工业环境中，我认为它最大的价值是为新的维护者提供一种健康检查层，使他们的更改具有预期的范围和效果。 因此，测试应该优化为易用性。如果初级开发人员在克隆repo之后无法立即运行项目的测试，那么就会出现一个严重的问题。在Go中，我认为这意味着在您的项目中运行普通的Go测试，而没有额外的设置工作，应该总是成功的，不会发生意外。也就是说，大多数测试不应该要求任何类型的测试环境、运行数据库等来正常运行并返回成功。这些测试是集成测试，它们应该通过测试标志或环境变量选择加入: 123456789func TestComplex(t *testing.T) &#123; urn := os.Getenv(\"TEST_DB_URN\") if urn == \"\" &#123; t.Skip(\"set TEST_DB_URN to run this test\") &#125; db, _ := connect(urn) // ...&#125; 测试金字塔是一个很好的通用建议，建议您应该将大部分精力集中在单元测试上。根据我的经验，理想的比率甚至比金字塔建议的还要极端:如果您具有良好的生产可观察性，那么您的测试工作的80-90%应该集中于单元测试。在Go中，我们知道好的单元测试是表驱动的，并且利用组件接受接口并返回结构的事实来提供依赖关系的伪实现或模拟实现，并且只测试被测试的东西。 米切尔桥本(Mitchell Hashimoto)去年在GopherCon上使用Go进行的高级测试，可能是迄今为止我所见过的有关工业环境下的优秀Go程序设计的最佳信息来源。如果您的团队编写Go，那么它就是基本的背景材料。 关于这个问题没有太多可说的了。随着时间的推移，测试最佳实践的相对稳定性是一个受欢迎的缓刑。一如既往地:追求100%的测试覆盖率几乎肯定会适得其反，但50%似乎是一个很好的低水印;避免引入测试dsl或“帮助包”，除非您的团队从中获得明确的、具体的价值。 我需要多少接口? 当我们谈论测试时，我们谈论通过接口模拟依赖关系，但是我们通常并没有真正描述它在实践中是如何工作的。我认为很重要的一点是，围棋系统不是标称的，而是结构性的。将接口看作是对实现进行分类的一种方法是错误的;相反，将接口看作是一种识别期望公共行为集的代码的方法。换句话说，接口是消费者契约，而不是生产者(实现者)契约——因此，作为一个规则，我们应该在使用代码的callsite中定义接口，而不是在提供实现的包中定义接口。 您需要多少接口?嗯，有一个频谱。在您的callsite上尽可能的有意义，特别是为了帮助测试。在一种极端情况下，我们可以使用严格作用域的接口定义为每个函数的每个依赖关系建模。在有限的情况下，这可能是有意义的!例如，如果您的组件是粗粒度的、良好的，并且将来不太可能更改。 但是，特别是在工业上下文中，更有可能出现混合的抽象，这些抽象随时间而变化。在这种情况下，您可能希望在您的设计中尝试在“故障线”上定义接口。两个自然边界点位于func main和代码其余部分之间，以及包api之间。定义依赖接口有一个很好的起点，也有一个很好的起点来开始考虑定义单元测试。 上下文使用和误用 Go 1.7给我们带来了包上下文，从那时起，它就一直在影响我们的代码。这不是一件坏事!上下文是管理goroutine生命周期的一种很好理解且无处不在的方法，这是一个大而困难的问题。根据我的经验，这是它们最重要的功能。如果您有一个组件由于任何原因阻塞—通常是网络I/O，有时是磁盘I/O，可能是由于用户回调，等等—那么它可能应该将上下文作为其第一个参数。 这种模式无处不在，我从一开始就把它设计到我的服务器类型和接口中。下面是最近一个连接到谷歌云存储的项目的例子:Go 1.7给我们带来了包上下文，从那时起，它就一直在影响我们的代码。这不是一件坏事!上下文是管理goroutine生命周期的一种很好理解且无处不在的方法，这是一个大而困难的问题。根据我的经验，这是它们最重要的功能。如果您有一个组件由于任何原因阻塞—通常是网络I/O，有时是磁盘I/O，可能是由于用户回调，等等—那么它可能应该将上下文作为其第一个参数。 这种模式无处不在，我从一开始就把它设计到我的服务器类型和接口中。下面是最近一个连接到谷歌云存储的项目的例子: 123456// reportStore is a thin domain abstraction over GCS.type reportStore interface &#123; listTimes(ctx context.Context, from time.Time, n int) ([]time.Time, error) writeFile(ctx context.Context, ts time.Time, name string, r io.Reader) error serveFile(ctx context.Context, ts time.Time, name string, w io.Writer) error&#125; 为生命周期语义编写上下文感知的组件很简单:只要确保代码响应ctx.Done即可。事实证明，使用上下文的值传播特性有点棘手。上下文的问题。值是键和值是无类型的，并且不能保证存在，这将使程序面临运行时成本和故障模式，否则这些问题是可以避免的。我的经验是开发人员过度使用上下文。值，这些值实际上应该是常规依赖项或函数参数。 所以，一个基本的经验是:只使用上下文。无法以任何其他方式通过程序传递的数据的值。实际上，这意味着只使用上下文。值，用于请求范围的信息，如请求id、用户身份验证令牌等，这些信息仅在请求时创建或在请求期间创建。如果该信息在程序启动时可用，比如数据库句柄或日志记录器，则不应通过上下文传递该信息。 同样，这个建议的基本原理归结为可维护性。如果一个组件以构造函数或函数参数的形式枚举它的需求(在编译时可检查)，这要比从一个只在运行时可检查的无类型、不透明的值包中提取信息好得多。后者不仅更加脆弱，而且使理解和调整代码变得更加困难。 总结我做这个最佳实践系列已经有六年了，虽然有一些技巧来来去去，特别是针对新出现的习惯用法和模式，但值得注意的是，作为一个有效的围棋程序员，所需的基础知识在这段时间内几乎没有改变。总的来说，我们并不追求设计趋势。我们有一个非常稳定的语言和生态系统，我相信我不仅仅是在为自己说话，当我说我真的很感激的时候。 我认为，在这样的会议上，我们能够彼此熟悉，这是很好的。但我认为我们在这里能做的最好的事情是建立对彼此的同理心。如果我们把工作做好，随着Go程序员数量的不断增长，社区将变得越来越多样化，具有不同的工作流、上下文和目标。我很高兴向大家介绍了我在Go上的一些体验报告，我也很高兴能听到并理解大家的感受。多谢!","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"}]},{"title":"编写自己的Yeoman生成器-10.将Yeoman集成到其他工具中","slug":"yeoman-authoring10","date":"2018-08-29T16:53:40.000Z","updated":"2020-07-25T02:57:18.232Z","comments":true,"path":"2018/08/30/yeoman-authoring10/","link":"","permalink":"https://jigangduan.github.io/2018/08/30/yeoman-authoring10/","excerpt":"","text":"每次运行生成器时，您实际上都在使用yeoman-environment。环境是一个与任何UI组件分离的基础系统，可以通过任何工具进行抽象。当你运行时yo，你基本上只是在核心Yeoman环境之上运行终端UI外观。 基础您需要知道的第一件事是环境系统包含在yeoman-environment包中。您可以通过运行来安装它： 1npm install --save yeoman-environment 该模块提供了检索已安装的生成器，注册和运行生成器的方法。它还提供了生成器正在使用的用户界面适配器。我们提供完整的API文档（这是可用方法的简洁列表。） 运用 yeoman-environment一个简单的用法示例 在我们转向yeoman-environment更深层次的主题之前，让我们从一个简单的用法示例开始。 在这个例子中，让我们假设npm想要npm init为脚手架提供一个命令package.json。阅读文档的其他页面，您已经知道如何创建生成器 - 所以让我们假设我们已经有了generator-npm。我们将看到如何调用它。 第一步是实例化一个新的环境实例。 12var yeoman = require('yeoman-environment');var env = yeoman.createEnv(); 然后，我们将要注册generator-npm以便以后使用。你有两个选择： 12345678// Here we register a generator based on its path. Providing the namespace// is optional.env.register(require.resolve('generator-npm'), 'npm:app');// Or you can provide a generator constructor. Doing so, you need to provide// a namespace manuallyvar GeneratorNPM = generators.Base.extend(/* put your methods in here */);env.registerStub(GeneratorNPM, 'npm:app'); 请注意，您可以根据需要注册任意数量的生成器。已注册的生成器仅在整个环境中可用（例如，允许可组合性）。 此时，您的环境已准备好运行npm:app。 12345// In its simplest formenv.run('npm:app', done);// Or passing arguments and optionsenv.run('npm:app some-name', &#123; 'skip-install': true &#125;, done); 您只需要将此代码放在一个bin可运行的文件中，您就可以在yo不使用的情况下运行Yeoman生成器。 查找安装的生成器但是，如果您希望提供对用户计算机上安装的每个Yeoman生成器的访问权限，该怎么办？然后，您需要执行用户磁盘的查找。 123env.lookup(function () &#123; env.run('angular');&#125;); Environment#lookup()一旦Yeoman完成搜索已安装的生成器，就会调用一个回调函数。每个找到的生成器都将在环境中注册。 如果命名空间冲突，本地生成器将覆盖全局生成器。 获取有关注册生成器的数据调用Environment#getGeneratorsMeta()将返回描述查找任务注册的元数据的对象。 每个对象键都是生成器命名空间，值对象包含以下键： resolved：生成器的已解析路径 namespace：生成器的命名空间 例如： 123456&#123; \"webapp:app\": &#123; \"resolved\": \"/usr/lib/node_modules/generator-webapp/app/index.js\", \"namespace\": \"webapp:app\" &#125;&#125; 注意：使用注册的发电机#registerStub()将”unknown”作为resolved值。 提供自定义用户界面（UI）Yeoman使用适配器作为抽象层，允许IDE，代码编辑器等轻松提供运行生成器所需的用户界面。 适配器是负责处理与用户的所有交互的对象。如果要从经典命令行提供不同的交互模型，则必须编写自己的适配器。每个与用户交互的方法都是通过这个适配器（主要是：提示，记录和区分）。 默认情况下，Yeoman提供终端适配器。我们的测试助手提供了一个测试适配器，他会嘲笑提示并使输出静音。您可以将它们用作您自己实现的参考。 适配器应至少提供三种方法。 Adapter#prompt() 它提供了问答功能（例如，当您启动时yo，会向用户提示一组可能的操作）。它的签名和行为遵循Inquirer.js的这些。当生成器调用时this.prompt，调用最终由适配器处理。 Adapter#diff() 遇到冲突时内部调用，并且用户要求旧文件和新文件之间存在差异（两个文件内容都作为参数传递）。 Adapter#log()它既是一个功能，也是一个用于通用输出的对象。有关lib/util/log.js要提供的方法的完整列表，请参阅。 示例实现这是使用的模块/插件/应用程序列表yeoman-environment。你可以用它们作为灵感。 yo yeoman-app","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-9.调试生成器","slug":"yeoman-authoring9","date":"2018-08-29T16:50:40.000Z","updated":"2020-07-25T02:57:18.234Z","comments":true,"path":"2018/08/30/yeoman-authoring9/","link":"","permalink":"https://jigangduan.github.io/2018/08/30/yeoman-authoring9/","excerpt":"","text":"要调试生成器，可以通过运行它来传递Node.js调试标志，如下所示： 123456789101112# OS X / Linuxnode --inspect `which yo` &lt;generator&gt; [arguments]# Windows# Find the path to the yo binary in Command Promptwhere yo# Or find the path to the yo binary in PowerShellget-command yo# Would be something like C:\\Users\\&lt;USER&gt;\\AppData\\Roaming\\npm\\yo# Use this path to derive yo cli.js file# C:\\Users\\&lt;USER&gt;\\AppData\\Roaming\\npm\\node_modules\\yo\\lib\\cli.jsnode --inspect &lt;path to yo cli.js&gt; &lt;generator&gt; [arguments] 然后，您可以使用Chrome Devtools或首选IDE调试您的生成器。有关详细信息，请参阅Node调试指南。 Yeoman生成器还提供调试模式来记录相关的生命周期信息。您可以通过将DEBUG环境变量设置为所需范围（生成器系统的范围yeoman:generator）来激活它。 12345# OS X / LinuxDEBUG=yeoman:generator# Windowsset DEBUG=yeoman:generator","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-8.测试生成器","slug":"yeoman-authoring8","date":"2018-08-29T16:40:40.000Z","updated":"2020-07-25T02:57:18.234Z","comments":true,"path":"2018/08/30/yeoman-authoring8/","link":"","permalink":"https://jigangduan.github.io/2018/08/30/yeoman-authoring8/","excerpt":"","text":"继续阅读以了解有关Yeoman添加的测试助手的更多信息，以减轻单元测试生成器的痛苦。 以下示例假设您在BDD模式下使用Mocha。全局概念应该很容易应用于您选择的单元测试框架 组织你的测试保持测试简单易于编辑非常重要。 通常，组织测试的最佳方法是将每个生成器和子生成器分隔为自己的describe块。然后，describe为您的生成器接受的每个选项添加一个块。然后，it为每个断言（或相关断言）使用一个块。 在代码中，您应该得到类似于此的结构： 12345678describe('backbone:app', function () &#123; it('generates a project with require.js', function () &#123; // assert the file exist // assert the file uses AMD definition &#125;); it('generates a project with webpack');&#125;); 测试助手Yeoman提供测试助手方法。它们包含在yeoman-test包装内。 1var helpers = require('yeoman-test'); 您可以在此处查看完整的帮助程序API。 单元测试生成器时最有用的方法是helpers.run()。此方法将返回一个RunContext实例，您可以在该实例上调用方法来设置目录，模拟提示，模拟参数等。 12345678910111213var path = require('path');it('generate a project', function () &#123; // The object returned acts like a promise, so return it to wait until the process is done return helpers.run(path.join(__dirname, '../app')) .withOptions(&#123; foo: 'bar' &#125;) // Mock options passed in .withArguments(['name-x']) // Mock the arguments .withPrompts(&#123; coffee: false &#125;) // Mock the prompt answers .withLocalConfig(&#123; lang: 'en' &#125;) // Mock the local config .then(function() &#123; // assert something about the generator &#125;);&#125;) 有时您可能希望为生成器构建一个测试场景，以便与目标目录中的现有内容一起运行。在这种情况下，您可以inTmpDir()使用回调函数调用，如下所示： 123456789101112var path = require('path');var fs = require('fs-extra');helpers.run(path.join(__dirname, '../app')) .inTmpDir(function (dir) &#123; // `dir` is the path to the new temporary directory fs.copySync(path.join(__dirname, '../templates/common'), dir) &#125;) .withPrompts(&#123; coffee: false &#125;) .then(function () &#123; assert.file('common/file.txt'); &#125;); 您还可以在回调中执行异步任务： 123456789var path = require('path');var fs = require('fs-extra');helpers.run(path.join(__dirname, '../app')) .inTmpDir(function (dir) &#123; var done = this.async(); // `this` is the RunContext object. fs.copy(path.join(__dirname, '../templates/common'), dir, done); &#125;) .withPrompts(&#123; coffee: false &#125;); 运行Promise将解析运行生成器的目录。如果要使用运行生成器的临时目录，这将非常有用： 123456789helpers.run(path.join(__dirname, '../app')) .inTmpDir(function (dir) &#123; var done = this.async(); // `this` is the RunContext object. fs.copy(path.join(__dirname, '../templates/common'), dir, done); &#125;) .withPrompts(&#123; coffee: false &#125;) .then(function (dir) &#123; // assert something about the stuff in `dir` &#125;); 如果您的生成器调用composeWith()，您可能想要模拟那些依赖生成器。使用#withGenerators()，传递#createDummyGenerator()用作第一项的数组数组和模拟生成器的命名空间作为第二项： 1234var deps = [ [helpers.createDummyGenerator(), 'karma:app']];return helpers.run(path.join(__dirname, '../app')).withGenerators(deps); 如果你不喜欢Promise，你可以使用’ready’，’error’以及’end’事件发出： 12345678helpers.run(path.join(__dirname, '../app')) .on('error', function (error) &#123; console.log('Oh Noes!', error); &#125;) .on('ready', function (generator) &#123; // This is called right before `generator.run()` is called &#125;) .on('end', done); 您还可以运行将其作为模块导入的生成器。如果生成了生成器的源代码，这将非常有用。 您需要提供以下设置run： resolved：生成器的路径，例如 ../src/app/index.js namespace：生成器的命名空间，例如 mygenerator:app 123456var MyGenerator = require('../src/app');helpers.run(MyGenerator, &#123; resolved: require.resolve(__dirname, '../src/app/index.js'), namespace: 'mygenerator:app'&#125;); 断言助手Yeoman 使用生成器相关的断言助手扩展了本机断言模块。您可以在yeoman-assert存储库中看到断言助手的完整列表。 需要断言助手： 1var assert = require('yeoman-assert'); 存在文件断言 1assert.file(['Gruntfile.js', 'app/router.js', 'app/views/main.js']); assert.noFile() 断言相反。 断言文件内容 1assert.fileContent('controllers/user.js', /App\\.UserController = Ember\\.ObjectController\\.extend/); assert.noFileContent() 断言相反。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-7.管理配置","slug":"yeoman-authoring7","date":"2018-08-29T16:23:40.000Z","updated":"2020-07-25T02:57:18.234Z","comments":true,"path":"2018/08/30/yeoman-authoring7/","link":"","permalink":"https://jigangduan.github.io/2018/08/30/yeoman-authoring7/","excerpt":"","text":"存储用户配置选项并在子生成器之间共享它们是一项常见任务。例如，通常共享首选项，如语言（用户使用CoffeeScript吗？），样式选项（用空格或制表符缩进）等。 这些配置可以通过Yeoman Storage API存储在.yo-rc.json文件中。可以通过generator.config对象访问此API 。 以下是您将使用的一些常用方法。 方法this.config.save() 此方法将配置写入.yo-rc.json文件。如果该文件尚不存在，则该save方法将创建该文件。 该.yo-rc.json文件还确定项目的根目录。因此，即使您没有使用任何存储设备，也始终将您的:app生成器在内部调用save视为最佳做法。 另请注意，save每次set配置选项时都会自动调用该方法。所以你通常不需要明确地调用它。 this.config.set() set 要么获取key和关联值，要么使用多个键/值的对象散列。 请注意，值必须是JSON可序列化的（字符串，数字或非递归对象）。 this.config.get() get将Stringkey作为参数并返回关联的值。 this.config.getAll() 返回完整可用配置的对象。 返回的对象按值传递，而不是引用。这意味着您仍然需要使用该set方法来更新配置存储。 this.config.delete() 删除key。 this.config.defaults() 接受用作默认值的选项哈希值。如果已存在键/值对，则该值将保持不变。如果缺少某个key，则会添加该key。 yo-rc.json 结构体该.yo-rc.json文件是一个JSON文件，其中存储了来自多个生成器的配置对象。每个生成器配置都是命名空间，以确保生成器之间不会发生命名冲突。 这也意味着每个生成器配置都是沙箱，并且只能在子生成器之间共享。您无法使用存储API在不同的生成器之间共享配置。在调用期间使用选项和参数在不同的生成器之间共享数据。 这是.yo-rc.json文件在内部的样子： 123456789&#123; \"generator-backbone\": &#123; \"requirejs\": true, \"coffee\": true &#125;, \"generator-gruntfile\": &#123; \"compass\": false &#125;&#125; 该结构对您的最终用户来说非常全面。这意味着，您可能希望在此文件中存储高级配置，并要求高级用户在没有意义的情况下直接编辑文件，以便为每个选项使用提示。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-6.使用文件系统","slug":"yeoman-authoring6","date":"2018-08-29T16:23:20.000Z","updated":"2020-07-25T02:57:18.233Z","comments":true,"path":"2018/08/30/yeoman-authoring6/","link":"","permalink":"https://jigangduan.github.io/2018/08/30/yeoman-authoring6/","excerpt":"","text":"位置上下文和路径Yeoman文件实用程序基于您在磁盘上始终有两个位置上下文的想法。这些上下文是您的生成器最有可能读取和写入的文件夹。 目标上下文第一个上下文是目标上下文。目标是Yeoman将脚手架新应用程序的文件夹。它是您的用户项目文件夹，它是您编写大部分脚手架的地方。 目标上下文定义为当前工作目录或包含.yo-rc.json文件的最近父文件夹。该.yo-rc.json文件定义了Yeoman项目的根。此文件允许您的用户在子目录中运行命令并让它们在项目上工作。这确保了最终用户的一致行为。 你可以得到的目标路径使用this.destinationRoot()或通过加入一个路径this.destinationPath(&#39;sub/path&#39;)。 123456789// Given destination root is ~/projectsclass extends Generator &#123; paths() &#123; this.destinationRoot(); // returns '~/projects' this.destinationPath('index.js'); // returns '~/projects/index.js' &#125; 您可以使用手动设置它this.destinationRoot(&#39;new/path&#39;)。但为了保持一致性，您可能不应该更改默认目标。 如果您想知道用户在哪里运行yo，那么您可以获取路径this.contextRoot。这是yo从中调用的原始路径; 在我们确定项目根目录之前.yo-rc.json。 模板上下文模板上下文是存储模板文件的文件夹。它通常是您将从中读取和复制的文件夹。 模板上下文默认定义为./templates/。您可以使用覆盖此默认值this.sourceRoot(&#39;new/template/path&#39;)。 您可以使用this.sourceRoot()或通过使用加入路径来获取路径值this.templatePath(‘app/index.js’)。 123456789class extends Generator &#123; paths() &#123; this.sourceRoot(); // returns './templates' this.templatePath('index.js'); // returns './templates/index.js' &#125;&#125;; “内存”文件系统在覆盖用户文件时，Yeoman非常小心。基本上，在预先存在的文件上发生的每个写入都将经历冲突解决过程。此过程要求用户验证将内容覆盖到其文件的每个文件写入。 此行为可防止出现意外错误并限制出错的风险。另一方面，这意味着每个文件都异步写入磁盘。 由于异步API更难使用，Yeoman提供了一个同步文件系统API，其中每个文件都被写入内存文件系统，并且只有在Yeoman运行完毕后才会写入磁盘一次。 此内存文件系统在所有组合的生成器之间共享。 文件工具生成器公开所有文件方法this.fs，这是mem-fs编辑器的一个实例- 确保检查所有可用方法的模块文档。 值得注意的是，虽然this.fs暴露commit，但你不应该在你的发电机中调用它。Yeoman在运行循环的冲突阶段之后在内部调用它。 示例：复制模板文件这是我们想要复制和处理模板文件的示例。 鉴于内容./templates/index.html是： 12345&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 然后，我们将使用该copyTpl方法复制文件，同时将内容作为模板处理。copyTpl正在使用ejs模板语法。 123456789class extends Generator &#123; writing() &#123; this.fs.copyTpl( this.templatePath('index.html'), this.destinationPath('public/index.html'), &#123; title: 'Templating with Yeoman' &#125; ); &#125;&#125; 一旦生成器运行完毕，public/index.html将包含： 12345&lt;html&gt; &lt;head&gt; &lt;title&gt;Templating with Yeoman&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 一个非常常见的场景是在提示阶段存储使用用户答案并将其用于模板： 12345678910111213141516class extends Generator &#123; async prompting() &#123; this.answers = await this.prompt([&#123; type : 'input', name : 'title', message : 'Your project title', &#125;]); &#125; writing() &#123; this.fs.copyTpl( this.templatePath('index.html'), this.destinationPath('public/index.html'), &#123; title: this.answers.title &#125; // user answer `title` used ); &#125; 通过流转换输出文件生成器系统允许您在每个文件写入上应用自定义过滤器。自动美化文件，规范化空白等是完全可能的。 根据Yeoman进程，我们将每个修改过的文件写入磁盘。这个过程通过一个vinyl对象流（就像gulp一样）。任何生成器作者都可以注册transformStream来修改文件路径和/或内容。 通过该registerTransformStream()方法注册新修改器。这是一个例子： 12var beautify = require('gulp-beautify');this.registerTransformStream(beautify(&#123;indent_size: 2 &#125;)); 请注意，任何类型的每个文件都将通过此流传递。确保任何转换流都将通过它不支持的文件。像gulp-if或gulp-filter这样的工具将有助于过滤无效类型并传递它们。 您基本上可以使用任何带有Yeoman转换流的gulp插件来处理在写入阶段生成的文件。 提示：更新现有文件的内容更新预先存在的文件并不总是一项简单的任务。最可靠的方法是解析文件AST（抽象语法树）并对其进行编辑。这个解决方案的主要问题是编辑AST可能很冗长，有点难以掌握。 一些流行的AST解析器是： Cheerio用于解析HTML。 用于解析JavaScript的Esprima - 您可能对AST-Query感兴趣，它提供了一个较低 级别的API来编辑Esprima语法树。 对于JSON文件，您可以使用原生JSON对象方法。 gruntfile-editor动态修改Gruntfile。 使用RegEx解析代码文件是一条危险的路径，在此之前，您应该阅读此CS人类学答案并掌握RegEx解析的缺陷。如果您确实选择使用RegEx而不是AST树编辑现有文件，请注意并提供完整的单元测试。 - 请，请不要破坏用户的代码。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-5.依赖关系管理","slug":"yeoman-authoring5","date":"2018-08-29T16:06:07.000Z","updated":"2020-07-25T02:57:18.233Z","comments":true,"path":"2018/08/30/yeoman-authoring5/","link":"","permalink":"https://jigangduan.github.io/2018/08/30/yeoman-authoring5/","excerpt":"","text":"一旦运行了生成器，通常需要运行npm(或Yarn)和Bower来安装生成器所需的任何附加依赖项。 由于这些任务非常频繁，Yeoman已经把它们抽象出来了。我们还将介绍如何通过其他工具启动安装。 注意，Yeoman提供的安装助手将自动安排安装作为install队列的一部分运行一次。如果您需要在它们运行之后运行任何东西，请使用end队列。 NPM您只需要调用this.npmInstall()即可运行npm安装。npm install即使多个生成器多次调用命令，Yeoman也会确保命令只运行一次。 例如，您希望将lodash安装为dev依赖项： 12345class extends Generator &#123; installingLodash() &#123; this.npmInstall(['lodash'], &#123; 'save-dev': true &#125;); &#125;&#125; 这相当于调用： 1npm install lodash --save-dev 在项目的命令行上。 以编程方式管理npm依赖项如果您不想使用package.json模板但希望拥有固定版本的依赖项，则可以以编程方式创建或扩展文件。Yeomans文件系统工具可以帮助您完成这项工作。 定义eslint为dev依赖项和react依赖项的示例： 12345678910111213141516171819class extends Generator &#123; writing() &#123; const pkgJson = &#123; devDependencies: &#123; eslint: '^3.15.0' &#125;, dependencies: &#123; react: '^16.2.0' &#125; &#125;; // Extend or create package.json file in destination path this.fs.extendJSON(this.destinationPath('package.json'), pkgJson); &#125; install() &#123; this.npmInstall(); &#125;&#125;; Yarn您只需要调用this.yarnInstall()即可启动安装。yarn install即使多个生成器多次调用命令，Yeoman也会确保命令只运行一次。 例如，您希望将lodash安装为dev依赖项： 12345generators.Base.extend(&#123; installingLodash: function() &#123; this.yarnInstall(['lodash'], &#123; 'dev': true &#125;); &#125;&#125;); 这相当于调用： 1yarn add lodash --dev 在项目的命令行上。 Bower您只需要调用this.bowerInstall()即可启动安装。bower install即使多个生成器多次调用命令，Yeoman也会确保命令只运行一次。 综合使用默认情况下，this.installDependencies()调用运行npm和bower。您可以通过为每个包管理器传递布尔值来决定使用哪些。 使用Yarn与Bower的例子： 123456789generators.Base.extend(&#123; install: function () &#123; this.installDependencies(&#123; npm: false, bower: true, yarn: true &#125;); &#125;&#125;); 使用其他工具Yeoman提供了一个抽象，允许用户使用spawn任何CLI命令。这种抽象将标准化为命令，因此它可以在Linux，Mac和Windows系统中无缝运行。 例如，如果你是一个PHP爱好者，并希望运行composer，你可以这样写： 12345class extends Generator &#123; install() &#123; this.spawnCommand('composer', ['install']); &#125;&#125; 确保调用队列中的spawnCommand方法install。您的用户不希望等待安装命令完成。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-4.组合性","slug":"yeoman-authoring4","date":"2018-08-29T15:32:44.000Z","updated":"2020-07-25T02:57:18.233Z","comments":true,"path":"2018/08/29/yeoman-authoring4/","link":"","permalink":"https://jigangduan.github.io/2018/08/29/yeoman-authoring4/","excerpt":"","text":"组合性是一种将较小的部件组合在一起构成一件大事的方法。排序像Voltron® Yeoman为生成器提供了多种方式来建立共同点。重写相同的功能没有任何意义，因此提供了一个API来在其他生成器中使用生成器。 在Yeoman中，可组合性可以通过两种方式启动： 生成器可以决定与另一个生成器（例如，generator-backbone使用generator-mocha）组合。 最终用户也可以发起合成（例如，Simon想要生成具有SASS和Rails的Backbone项目）。注意：最终用户发起的合成是计划的功能，目前不可用。 this.composeWith()该composeWith方法允许生成器与另一个生成器（或子生成器）并排运行。这样它就可以使用其他发生器的功能，而不必自己完成所有功能。 在编写时，不要忘记运行上下文和RunLoop。在给定的优先级组执行中，所有组合的生成器将执行该组中的功能。之后，这将重复下一组。生成器之间的执行与composeWith调用的顺序相同，请参阅执行示例。 APIcomposeWith 有两个参数。 generatorPath- 指向要编写的生成器的完整路径（通常使用require.resolve()）。 options - 包含选项的对象，一旦运行就传递给组合生成器。 与peerDependencies生成器组合时： 1this.composeWith(require.resolve('generator-bootstrap/generators/app'), &#123;preprocessor: 'sass'&#125;); require.resolve() 返回Node.js加载提供的模块的路径。 注意：如果你需要传递arguments到基于版本的生成器yeoman-generator年龄大于1.0，你可以通过提供一个做到这一点Array的options.arguments关键。 即使它不是一种鼓励的做法，您也可以将生成器命名空间传递给composeWith。在这种情况下，Yeoman将尝试peerDependencies在最终用户系统上找到作为或全局安装的生成器。 1this.composeWith('backbone:route', &#123;rjs: true&#125;); 执行示例 1234567891011121314151617181920212223242526272829// In my-generator/generators/turbo/index.jsmodule.exports = class extends Generator &#123; prompting() &#123; this.log('prompting - turbo'); &#125; writing() &#123; this.log('writing - turbo'); &#125;&#125;;// In my-generator/generators/electric/index.jsmodule.exports = class extends Generator &#123; prompting() &#123; this.log('prompting - zap'); &#125; writing() &#123; this.log('writing - zap'); &#125;&#125;;// In my-generator/generators/app/index.jsmodule.exports = class extends Generator &#123; initializing() &#123; this.composeWith(require.resolve('../turbo')); this.composeWith(require.resolve('../electric')); &#125;&#125;; 运行时yo my-generator，这将导致： 1234prompting - turboprompting - zapwriting - turbowriting - zap 您可以通过反转调用来更改函数调用顺序composeWith 请记住，您可以使用npm上提供的其他公共生成器进行组合。 对于可组合的更复杂的例子，检查出generator-generator，它由被generator-node。 依赖项或peerDependenciesnpm允许三种类型的依赖项： dependencies安装在本地的生成器。它是控制所用依赖项版本的最佳选择。这是首选方案。 peerDependencies作为兄弟姐妹安装在生成器旁边。例如，如果generator-backbone声明generator-gruntfile为对等依赖项，则文件夹树将以这种方式显示： 12├───generator-backbone/└───generator-gruntfile/ devDependencies用于测试和开发实用程序。这不是必需的。 使用时peerDependencies，请注意其他模块可能还需要所请求的模块。注意不要通过请求特定版本（或窄范围的版本）来创建版本冲突。Yeoman的建议peerDependencies是始终要求更高或等于（&gt; =）或任何（*）可用版本。例如： 123456&#123; \"peerDependencies\": &#123; \"generator-gruntfile\": \"*\", \"generator-bootstrap\": \"&gt;=1.0.0\" &#125;&#125; 注意：从npm @ 3开始，peerDependencies不再自动安装。要安装这些依赖项，必须手动安装它们：npm install generator-yourgenerator generator-gruntfile generator-bootstrap@&quot;&gt;=1.0.0&quot;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-3.与用户交互","slug":"yeoman-authoring3","date":"2018-08-29T15:00:05.000Z","updated":"2020-07-25T02:57:18.233Z","comments":true,"path":"2018/08/29/yeoman-authoring3/","link":"","permalink":"https://jigangduan.github.io/2018/08/29/yeoman-authoring3/","excerpt":"","text":"您的生成器将与最终用户进行大量交互。默认情况下，Yeoman在终端上运行，但它也支持不同工具可以提供的自定义用户界面。例如，没有什么能阻止Yeoman生成器在编辑器或独立应用程序之类的图形工具中运行。 为了实现这种灵活性，Yeoman提供了一组用户界面元素抽象。作为作者，您有责任在与最终用户交互时仅使用这些抽象。使用其他方法可能会阻止您的生成器在不同的Yeoman工具中正确运行。 例如，永远不要使用console.log()或process.stdout.write()输出内容很重要。使用它们会隐藏不使用终端的用户的输出。相反，始终依赖于UI通用this.log()方法，其中this是当前生成器的上下文。 用户互动提示提示是生成器与用户交互的主要方式。提示模块由Inquirer.js提供，您应该参考其API以获取可用的提示选项列表。 该prompt方法是异步的并返回一个Promise。您需要从任务中返回Promise，以便在运行下一个任务之前等待其完成。（详细了解异步任务） 1234567891011121314151617module.exports = class extends Generator &#123; async prompting() &#123; const answers = await this.prompt([&#123; type : 'input', name : 'name', message : 'Your project name', default : this.appname // Default to current folder name &#125;, &#123; type : 'confirm', name : 'cool', message : 'Would you like to enable the Cool feature?' &#125;]); this.log('app name', answers.name); this.log('cool feature', answers.cool); &#125;&#125;; 请注意，我们使用prompting队列来询问用户的反馈。 在稍后阶段使用用户answers一种非常常见的情况是在稍后阶段使用用户答案，例如在writing队列中。这可以通过将它们添加到this上下文中来轻松实现： 12345678910111213module.exports = class extends Generator &#123; async prompting() &#123; this.answers = await this.prompt([&#123; type : 'confirm', name : 'cool', message : 'Would you like to enable the Cool feature?' &#125;]); &#125; writing() &#123; this.log('cool feature', this.answers.cool); // user answer `cool` used &#125;&#125;; 记住用户首选项用户每次运行生成器时都可以对某些问题给出相同的输入。对于这些问题，您可能想要记住用户之前回答的内容并将该答案用作新答案default。 Yeoman通过向问题对象添加store属性来扩展Inquirer.js API 。此属性允许您指定将来应将用户提供的答案用作默认答案。这可以按如下方式完成： 123456this.prompt(&#123; type : 'input', name : 'username', message : 'What\\'s your GitHub username', store : true&#125;); 注意：提供默认值将阻止用户返回任何空答案。 如果您只想存储数据而不直接与提示相关联，请务必查看Yeoman存储文档。 参数参数直接从命令行传递： 1yo webapp my-project 在这个例子中，my-project将是第一个参数。 要通知系统我们期望参数，我们使用该this.argument()方法。此方法接受name（String）和可选的选项哈希。 在name随后的参数将作为：this.options[name]。 options散列接受多个键值对： desc 参数的描述 required布尔值是否是必需的 type String，Number，Array（也可以是接收原始字符串值并解析它的自定义函数） default 此参数的默认值 必须在constructor方法内调用此方法。否则，当用户使用帮助选项调用您的生成器时，Yeoman将无法输出相关的帮助信息：例如yo webapp --help。 这是一个例子： 123456789101112module.exports = class extends Generator &#123; // note: arguments and options should be defined in the constructor. constructor(args, opts) &#123; super(args, opts); // This makes `appname` a required argument. this.argument('appname', &#123; type: String, required: true &#125;); // And you can then access it later; e.g. this.log(this.options.appname); &#125;&#125;; 类型的参数Array将包含传递给生成器的所有剩余参数。 选项选项看起来很像参数，但它们被写为命令行标志。 1yo webapp --coffee 要通知系统我们期望一个选项，我们使用该this.option()方法。此方法接受name（String）和可选的选项哈希。 该name值将用于在匹配键处检索选项this.options[name]。 options hash（第二个参数）接受多个键值对： desc 选项说明 alias 选项的简称 type 布尔值，字符串或数字（也可以是接收原始字符串值并解析它的自定义函数） default 默认值 hide 布尔值是否隐藏帮助 这是一个例子： 123456789101112module.exports = class extends Generator &#123; // note: arguments and options should be defined in the constructor. constructor(args, opts) &#123; super(args, opts); // This method adds support for a `--coffee` flag this.option('coffee'); // And you can then access it later; e.g. this.scriptSuffix = (this.options.coffee ? \".coffee\": \".js\"); &#125;&#125;; 输出信息输出信息由this.log模块处理。 您将使用的主要方法是this.log（例如this.log(&#39;Hey! Welcome to my awesome generator&#39;)）。它需要一个字符串并将其输出给用户; 基本上它console.log()在终端会话中使用时模仿。您可以像这样使用它： 12345module.exports = class extends Generator &#123; myAction() &#123; this.log('Something has gone wrong!'); &#125;&#125;; 您还可以在API文档中找到其他一些辅助方法。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-2.运行时上下文","slug":"yeoman-authoring2","date":"2018-08-29T14:30:47.000Z","updated":"2020-07-25T02:57:18.232Z","comments":true,"path":"2018/08/29/yeoman-authoring2/","link":"","permalink":"https://jigangduan.github.io/2018/08/29/yeoman-authoring2/","excerpt":"","text":"编写生成器时要掌握的最重要的概念之一是方法的运行方式和上下文。 原型方法作为动作直接附加到Generator原型的每个方法都被认为是一项任务。每个任务都由Yeoman环境运行循环按顺序运行。 换句话说，返回的对象上的每个函数Object.getPrototypeOf(Generator)都将自动运行。 辅助方法和私有方法既然您知道原型方法被认为是一项任务，您可能想知道如何定义不会自动调用的辅助方法或私有方法。有三种不同的方法可以实现这一目标。 方法名称下划线前缀（例如_private_method） 123456789class extends Generator &#123; method1() &#123; console.log('hey 1'); &#125; _private_method() &#123; console.log('private hey'); &#125;&#125; 使用实例方法： 12345678910class extends Generator &#123; constructor(args, opts) &#123; // Calling the super constructor is important so our generator is correctly set up super(args, opts) this.helperMethod = function () &#123; console.log('won\\'t be called automatically'); &#125;; &#125;&#125; 扩展父生成器： 1234567891011class MyBase extends Generator &#123; helper() &#123; console.log('methods on the parent generator won\\'t be called automatically'); &#125;&#125;module.exports = class extends MyBase &#123; exec() &#123; this.helper(); &#125;&#125;; RunLoop如果有一个生成器，顺序运行任务就没问题。但是，一旦你开始组合生成器，这还不够。 这就是Yeoman使用RunLoop的原因。 RunLoop是具有优先级支持的队列系统。我们使用Grouped-queue模块来处理RunLoop。 优先级在您的代码中定义为特殊原型方法名称。当方法名称与优先级名称相同时，运行循环将方法推入此特殊队列。如果方法名称与优先级不匹配，则将其推送到default组中。 在代码中，它将看起来像这样： 123class extends Generator &#123; priorityName() &#123;&#125;&#125; 您还可以使用哈希而不是单个方法将多个方法组合在队列中： 123456Generator.extend(&#123; priorityName: &#123; method() &#123;&#125;, method2() &#123;&#125; &#125;&#125;); （注意，最后一种技术不适合JS class定义） 可用的优先级是（按运行顺序）： initializing - 您的初始化方法（检查当前项目状态，获取配置等） prompting - 提示用户选择的地方（你打电话的地方this.prompt()） configuring- 保存配置并配置项目（创建.editorconfig文件和其他元数据文件） default - 如果方法名称与优先级不匹配，则会将其推送到该组。 writing- 编写生成器特定文件（路由，控制器等）的位置 conflicts - 处理冲突的地方（内部使用） install- 安装运行的地方（npm，yarn） end- 最后称呼，清理，说再见等 遵循这些优先级指南，您的生成器将与其他人一起玩。 异步任务有多种方法可以暂停RunLoop，直到任务完成异步工作。 最简单的方法是返回一个Promise。一旦Promise解析，循环将继续，或者它将引发异常并在失败时停止。 如果您所依赖的异步API不支持Promise，那么您可以依赖于遗留this.async()方式。this.async()一旦任务完成，调用将返回一个函数来调用。例如： 1234567asyncTask() &#123; var done = this.async(); getUserEmail(function (err, name) &#123; done(err); &#125;);&#125; 如果done使用error参数调用该函数，则运行循环将停止并引发异常。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"编写自己的Yeoman生成器-1.入门","slug":"yeoman-authoring","date":"2018-08-29T12:18:35.000Z","updated":"2020-07-25T02:57:18.232Z","comments":true,"path":"2018/08/29/yeoman-authoring/","link":"","permalink":"https://jigangduan.github.io/2018/08/29/yeoman-authoring/","excerpt":"","text":"Generators(生成器)是Yeoman生态系统的基石。它们是yo为最终用户生成文件所运行的插件。 阅读本节，您将学习如何创建和分发自己的内容。 注意：我们构建了一个生成器 - Generator，以帮助用户开始使用自己的生成器。一旦理解了以下概念，请随意使用它来引导您自己的生成器。 组织你的生成器设置为Node Module生成器的核心是Node.js模块 首先，创建一个文件夹，在其中编写您的生成器。文件夹必须命名generator-name（name您的生成器的名称）。这很重要，因为Yeoman依赖文件系统来查找可用的生成器。 进入生成器文件夹后，创建一个package.json文件。此文件是Node.js模块清单。您可以从通过命令行npm init运行来生成此文件或手动输入以下内容： 123456789101112&#123; \"name\": \"generator-name\", \"version\": \"0.1.0\", \"description\": \"\", \"files\": [ \"generators\" ], \"keywords\": [\"yeoman-generator\"], \"dependencies\": &#123; \"yeoman-generator\": \"^1.0.0\" &#125;&#125; 该name必须以generator-为前缀。该keywords属性必须包含&quot;yeoman-generator&quot;，并且repo必须具有由我们的生成器页面索引的描述。 您应该确保将依赖项yeoman-generator设置为最新版本。你可以通过运行：npm install --save yeoman-generator。 该files属性必须是生成器使用的文件和目录数组。 根据需要添加其他package.json属性。 目录结构Yeoman的功能取决于您如何构建目录结构。每个子生成器都包含在自己的文件夹中。 调用时使用的默认生成器yo name是app生成器。这必须包含在app/目录中。 在示例项目中，目录结构可能如下所示： 123456├───package.json└───generators/ ├───app/ │ └───index.js └───router/ └───index.js 这个生成器将公开yo name和yo name:router命令。 Yeoman允许两种不同的目录结构。它会查看./和generators/注册可用的生成器。 前面的例子也可以写成如下： 12345├───package.json├───app/│ └───index.js└───router/ └───index.js 如果使用这里的第二个目录结构，请确保将package.json的files属性指向所有生成器文件夹。 123456&#123; \"files\": [ \"app\", \"router\" ]&#125; 扩展生成器一旦你有了这个结构，就可以编写实际的生成器了。 Yeoman提供了一个基本生成器，您可以扩展它以实现自己的行为。这个基础生成器添加了您希望减轻任务的大部分功能。 在生成器的index.js文件中，以下是扩展基本生成器的方法： 123var Generator = require('yeoman-generator');module.exports = class extends Generator &#123;&#125;; 我们以module.exports分配扩展生成器使其可用于生态系统。这是我们在Node.js中导出模块的方式。 覆盖构造函数某些生成器方法只能在constructor函数内部调用。这些特殊方法可能会执行诸如设置重要状态控件之类的操作，并且可能无法在构造函数之外运行。 要覆盖生成器构造函数，请添加如下构造函数方法： 12345678910module.exports = class extends Generator &#123; // The name `constructor` is important here constructor(args, opts) &#123; // Calling the super constructor is important so our generator is correctly set up super(args, opts); // Next, add your custom code this.option('babel'); // This method adds support for a `--babel` flag &#125;&#125;; 添加自己的函数添加到原型的每个方法都会在调用生成器后运行 - 通常按顺序运行。但是，正如我们将在下一节中看到的，一些特殊的方法名称将触发特定的运行顺序。 让我们添加一些方法： 123456789module.exports = class extends Generator &#123; method1() &#123; this.log('method 1 just ran'); &#125; method2() &#123; this.log('method 2 just ran'); &#125;&#125;; 当我们稍后运行生成器时，您将看到这些到控制台的行记录。 运行生成器此时，你有一个可以工作的生成器。下一个合乎逻辑的步骤是运行它并查看它是否有效。 由于您在本地开发生成器，因此它尚未作为全局npm模块提供。可以使用npm创建全局模块并将其符号链接到本地​​模块。这是你想要做的： 在命令行上，从生成器项目的根目录（在generator-name/文件夹中）中键入： 1npm link 这将安装您的项目依赖项和符号链接全局模块到您的本地文件。完成npm后，您将能够调用yo name，您应该看到在终端中呈现前面this.log定义的的内容。恭喜你，你刚刚建造了你的第一台生成器！ 找到项目根目录在运行生成器时，Yeoman将尝试根据其运行的文件夹的上下文来计算出一些内容。 最重要的是，Yeoman在目录树中搜索.yo-rc.json文件。如果找到，它会将文件的位置视为项目的根。在幕后，Yeoman会将当前目录更改为.yo-rc.json文件位置并在那里运行请求的生成器。 存储模块创建.yo-rc.json文件。this.config.save()首次从生成器调用将创建该文件。 因此，如果您的生成器未在当前工作目录中运行，请确保您目录树中的某个位置没有.yo-rc.json。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"}]},{"title":"VSCode Webview API","slug":"vscode-extensions-5","date":"2018-08-11T09:54:45.000Z","updated":"2020-07-25T02:57:18.231Z","comments":true,"path":"2018/08/11/vscode-extensions-5/","link":"","permalink":"https://jigangduan.github.io/2018/08/11/vscode-extensions-5/","excerpt":"","text":"webview API允许扩展在Visual Studio Code中创建完全可定制的视图。例如，内置的Markdown扩展使用webview来呈现Markdown预览。除了VS Code的原生api支持之外，webview还可以用来构建复杂的用户界面。 可以将webview看作是您的扩展控制的VS Code中的iframe。一个webview可以呈现这个框架中几乎所有的HTML内容，它通过消息传递与扩展通信。这种自由使webview变得非常强大，并打开了一个全新的扩展范围。 我应该使用webview吗?Webviews是相当惊人的，但他们也应该被谨慎使用，只有当VS Code的本机API是不够的。webview占用大量的资源，运行在与普通扩展不同的独立上下文中。一个设计不佳的webview也很容易在VS Code中感觉格格不入。 在使用webview之前，请考虑以下几点: 这个功能真的需要存在于VS代码中吗?作为一个单独的应用程序或网站会更好吗? webview是实现你的功能的唯一方法吗?可以使用常规VS代码api吗? 你的webview会增加足够的用户价值来证明它的高资源成本吗? 记住:仅仅因为你可以用webviews做一些事情，并不意味着你应该这样做。但是，如果您确信需要使用webviews，那么本文将提供帮助。让我们开始吧。 webview API基础知识为了解释webview API，我们将构建一个简单的扩展名为Cat编码。这个扩展将使用webview来显示猫写代码的gif(大概是VS Code)。在我们处理API的过程中，我们将继续向扩展添加功能，包括一个计数器，用于跟踪cat编写的源代码行数，以及当cat引入错误时通知用户的通知。 下面是Cat编码扩展的第一个版本的package.json。您可以在这里找到示例应用程序的完整代码。我们扩展的第一个版本提供了一个名为catCoding.start的命令。当用户调用此命令时，我们将显示一个简单的带有cat的webview。用户将能够从命令调色板中调用这个命令作为Cat编码:启动新的Cat编码会话，如果他们愿意，甚至可以为它创建一个键绑定。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"}]},{"title":"例子——语言服务器","slug":"vscode-extensions-4","date":"2018-08-11T08:01:10.000Z","updated":"2020-07-25T02:57:18.231Z","comments":true,"path":"2018/08/11/vscode-extensions-4/","link":"","permalink":"https://jigangduan.github.io/2018/08/11/vscode-extensions-4/","excerpt":"","text":"简要概述语言服务器和语言服务器协议语言服务器是一种特殊的扩展，支持VS代码中许多编程语言的编辑体验。使用语言服务器，您可以实现VS代码中支持的自动完成、错误检查(诊断)、快速定义和许多其他语言特性。 然而，在VS代码中实现对语言特性的支持时，我们发现了三个常见问题: 首先，语言服务器通常是用它们的本地编程语言实现的，这在将它们与具有节点的VS代码集成方面提出了挑战。js运行时。 此外，语言特性可能是资源密集型的。例如，要正确地验证一个文件，Language Server需要解析大量文件，为它们构建抽象语法树并执行静态程序分析。这些操作可能导致大量的CPU和内存使用，我们需要确保VS代码的性能不受影响。 最后，将多种语言工具与多种代码编辑器集成可能需要大量的工作。从语言工具的角度来看，它们需要适应具有不同api的代码编辑器。从代码编辑的角度来看，他们不能期望语言工具提供统一的API。这使得在N个代码编辑器中实现对M语言的支持成为M * N的工作。 为了解决这些问题，微软指定了语言服务器协议，规范了语言工具和代码编辑器之间的通信。通过这种方式，语言服务器可以在任何语言中实现，并在自己的进程中运行，以避免性能成本，因为它们通过语言服务器协议与代码编辑器通信。此外，任何符合lsp的语言工具都可以与多个符合lsp的代码编辑器集成，任何符合lsp的代码编辑器都可以轻松地获取多个符合lsp的语言工具。LSP是语言工具提供商和代码编辑器供应商的双赢! 在本指南中，我们将: 说明如何使用提供的Node SDK在VS代码中构建语言服务器扩展。 解释如何运行、调试、记录和测试语言服务器扩展。 为您介绍一些语言服务器上的高级主题。 实现语言的服务器概述在VS Code中，语言服务器有两部分: 语言客户端:用JavaScript / TypeScript编写的普通VS代码扩展。这个扩展可以访问所有VS Code命名空间API。 语言服务器:在独立进程中运行的语言分析工具。 如上所述，在单独的进程中运行语言服务器有两个好处: 分析工具可以用任何语言实现，只要它能够按照语言服务器协议与语言客户机通信。 由于语言分析工具通常占用大量CPU和内存，因此在单独的进程中运行它们可以避免性能开销。 下面是VS代码运行两个语言服务器扩展的示例。HTML语言客户端和PHP语言客户端是用TypeScript编写的普通VS代码扩展。它们中的每个实例化一个相应的语言服务器，并通过LSP与它们通信。虽然PHP语言服务器是用PHP编写的，但它仍然可以通过LSP与PHP语言客户端通信。 本指南将教你如何使用我们的Node SDK构建语言客户机/服务器。剩下的文档假设您熟悉VS Code的正常扩展开发。 lsp示例 - 一个简单的语言服务器纯文本文件让我们构建一个简单的语言服务器扩展，为纯文本文件实现自动完成和诊断。我们还将介绍客户机/服务器之间配置的同步。 如果你喜欢直接进入代码: lsp示例:本指南的大量文档化源代码。lsp-multiserver-sample:大量文档化的lsp-sample高级版本，每个工作区文件夹启动一个不同的服务器实例，以支持VS代码中的多根工作区特性。克隆存储库Microsoft/vscode-extension-samples并打开示例: 12345&gt; git clone https://github.com/Microsoft/vscode-extension-samples.git&gt; cd vscode-extension-samples/lsp-sample&gt; npm install&gt; npm run compile&gt; code . 上面的步骤将安装所有依赖项，并打开包含客户机和服务器代码的lsp示例工作区。下面是lsp-sample结构的粗略概述: 123456789.├── client // Language Client│ ├── src│ │ ├── test // End to End tests for Language Client / Server│ │ └── extension.ts // Language Client entry point├── package.json // The extension manifest└── server // Language Server └── src └── server.ts // Language Server entry point 解释“语言客户端”让我们首先看一下/package.json，它描述了语言客户机的功能。有三个有趣的部分: 首先看activationEvents: 123\"activationEvents\": [ \"onLanguage:plaintext\"] 本节告诉VS代码在打开纯文本文件(例如带有扩展名.txt的文件)时立即激活扩展名。 接下来看配置部分: 123456789101112\"configuration\": &#123; \"type\": \"object\", \"title\": \"Example configuration\", \"properties\": &#123; \"languageServerExample.maxNumberOfProblems\": &#123; \"scope\": \"resource\", \"type\": \"number\", \"default\": 100, \"description\": \"Controls the maximum number of problems produced by the server.\" &#125; &#125;&#125; 本节为VS代码提供配置设置。这个示例将解释这些设置如何在启动时和每次更改设置时发送到语言服务器。 实际的语言客户端代码和相应的包。json在/client文件夹中。包装中有趣的部分。json文件是它添加了一个依赖于vscode扩展主机API和vscode-languageclient库: 1234\"dependencies\": &#123; \"vscode\": \"^1.1.18\", \"vscode-languageclient\": \"^4.1.4\"&#125; 如前所述，客户端是作为一个普通的VS代码扩展来实现的，它可以访问所有VS Code命名空间API。 下面是对应的extension.ts文件的内容，是lsp-sample extension的条目: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import * as path from 'path';import &#123; workspace, ExtensionContext &#125; from 'vscode';import &#123; LanguageClient, LanguageClientOptions, ServerOptions, TransportKind&#125; from 'vscode-languageclient';let client: LanguageClient;export function activate(context: ExtensionContext) &#123; // The server is implemented in node let serverModule = context.asAbsolutePath( path.join('server', 'out', 'server.js') ); // The debug options for the server // --inspect=6009: runs the server in Node's Inspector mode so VS Code can attach to the server for debugging let debugOptions = &#123; execArgv: ['--nolazy', '--inspect=6009'] &#125;; // If the extension is launched in debug mode then the debug server options are used // Otherwise the run options are used let serverOptions: ServerOptions = &#123; run: &#123; module: serverModule, transport: TransportKind.ipc &#125;, debug: &#123; module: serverModule, transport: TransportKind.ipc, options: debugOptions &#125; &#125;; // Options to control the language client let clientOptions: LanguageClientOptions = &#123; // Register the server for plain text documents documentSelector: [&#123; scheme: 'file', language: 'plaintext' &#125;], synchronize: &#123; // Notify the server about file changes to '.clientrc files contained in the workspace fileEvents: workspace.createFileSystemWatcher('**/.clientrc') &#125; &#125;; // Create the language client and start the client. client = new LanguageClient( 'languageServerExample', 'Language Server Example', serverOptions, clientOptions ); // Start the client. This will also launch the server client.start();&#125;export function deactivate(): Thenable&lt;void&gt; &#123; if (!client) &#123; return undefined; &#125; return client.stop();&#125; 解释语言服务器 注意:从GitHub存储库克隆出来的“服务器”实现有最终的演练实现。要执行演练，您可以创建一个新的server.ts 或修改克隆版本的内容。 在这个示例中，服务器也在TypeScript实现，并使用Node.js执行。因为VS代码已经附带了一个Node.js运行时，没有必要提供你自己的，除非你有非常具体的要求运行时。 语言服务器的源代码在/server。服务器的package.json文件中有趣的部分是: 123\"dependencies\": &#123; \"vscode-languageserver\": \"^4.1.3\"&#125; 这就引入了vscode-languageserver库。 下面是一个服务器实现，它使用提供的简单文本文档管理器来同步文本文档，方法是始终将文件的完整内容从VS Code发送到服务器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235import &#123; createConnection, TextDocuments, TextDocument, Diagnostic, DiagnosticSeverity, ProposedFeatures, InitializeParams, DidChangeConfigurationNotification, CompletionItem, CompletionItemKind, TextDocumentPositionParams&#125; from 'vscode-languageserver';// Create a connection for the server. The connection uses Node's IPC as a transport.// Also include all preview / proposed LSP features.let connection = createConnection(ProposedFeatures.all);// Create a simple text document manager. The text document manager// supports full document sync onlylet documents: TextDocuments = new TextDocuments();let hasConfigurationCapability: boolean = false;let hasWorkspaceFolderCapability: boolean = false;let hasDiagnosticRelatedInformationCapability: boolean = false;connection.onInitialize((params: InitializeParams) =&gt; &#123; let capabilities = params.capabilities; // Does the client support the `workspace/configuration` request? // If not, we will fall back using global settings hasConfigurationCapability = capabilities.workspace &amp;&amp; !!capabilities.workspace.configuration; hasWorkspaceFolderCapability = capabilities.workspace &amp;&amp; !!capabilities.workspace.workspaceFolders; hasDiagnosticRelatedInformationCapability = capabilities.textDocument &amp;&amp; capabilities.textDocument.publishDiagnostics &amp;&amp; capabilities.textDocument.publishDiagnostics.relatedInformation; return &#123; capabilities: &#123; textDocumentSync: documents.syncKind, // Tell the client that the server supports code completion completionProvider: &#123; resolveProvider: true &#125; &#125; &#125;;&#125;);connection.onInitialized(() =&gt; &#123; if (hasConfigurationCapability) &#123; // Register for all configuration changes. connection.client.register( DidChangeConfigurationNotification.type, undefined ); &#125; if (hasWorkspaceFolderCapability) &#123; connection.workspace.onDidChangeWorkspaceFolders(_event =&gt; &#123; connection.console.log('Workspace folder change event received.'); &#125;); &#125;&#125;);// The example settingsinterface ExampleSettings &#123; maxNumberOfProblems: number;&#125;// The global settings, used when the `workspace/configuration` request is not supported by the client.// Please note that this is not the case when using this server with the client provided in this example// but could happen with other clients.const defaultSettings: ExampleSettings = &#123; maxNumberOfProblems: 1000 &#125;;let globalSettings: ExampleSettings = defaultSettings;// Cache the settings of all open documentslet documentSettings: Map&lt;string, Thenable&lt;ExampleSettings&gt;&gt; = new Map();connection.onDidChangeConfiguration(change =&gt; &#123; if (hasConfigurationCapability) &#123; // Reset all cached document settings documentSettings.clear(); &#125; else &#123; globalSettings = &lt;ExampleSettings&gt;( (change.settings.languageServerExample || defaultSettings) ); &#125; // Revalidate all open text documents documents.all().forEach(validateTextDocument);&#125;);function getDocumentSettings(resource: string): Thenable&lt;ExampleSettings&gt; &#123; if (!hasConfigurationCapability) &#123; return Promise.resolve(globalSettings); &#125; let result = documentSettings.get(resource); if (!result) &#123; result = connection.workspace.getConfiguration(&#123; scopeUri: resource, section: 'languageServerExample' &#125;); documentSettings.set(resource, result); &#125; return result;&#125;// Only keep settings for open documentsdocuments.onDidClose(e =&gt; &#123; documentSettings.delete(e.document.uri);&#125;);// The content of a text document has changed. This event is emitted// when the text document first opened or when its content has changed.documents.onDidChangeContent(change =&gt; &#123; validateTextDocument(change.document);&#125;);async function validateTextDocument(textDocument: TextDocument): Promise&lt;void&gt; &#123; // In this simple example we get the settings for every validate run. let settings = await getDocumentSettings(textDocument.uri); // The validator creates diagnostics for all uppercase words length 2 and more let text = textDocument.getText(); let pattern = /\\b[A-Z]&#123;2,&#125;\\b/g; let m: RegExpExecArray; let problems = 0; let diagnostics: Diagnostic[] = []; while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) &#123; problems++; let diagnostic: Diagnostic = &#123; severity: DiagnosticSeverity.Warning, range: &#123; start: textDocument.positionAt(m.index), end: textDocument.positionAt(m.index + m[0].length) &#125;, message: `$&#123;m[0]&#125; is all uppercase.`, source: 'ex' &#125;; if (hasDiagnosticRelatedInformationCapability) &#123; diagnostic.relatedInformation = [ &#123; location: &#123; uri: textDocument.uri, range: Object.assign(&#123;&#125;, diagnostic.range) &#125;, message: 'Spelling matters' &#125;, &#123; location: &#123; uri: textDocument.uri, range: Object.assign(&#123;&#125;, diagnostic.range) &#125;, message: 'Particularly for names' &#125; ]; &#125; diagnostics.push(diagnostic); &#125; // Send the computed diagnostics to VSCode. connection.sendDiagnostics(&#123; uri: textDocument.uri, diagnostics &#125;);&#125;connection.onDidChangeWatchedFiles(_change =&gt; &#123; // Monitored files have change in VSCode connection.console.log('We received an file change event');&#125;);// This handler provides the initial list of the completion items.connection.onCompletion( (_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; &#123; // The pass parameter contains the position of the text document in // which code complete got requested. For the example we ignore this // info and always provide the same completion items. return [ &#123; label: 'TypeScript', kind: CompletionItemKind.Text, data: 1 &#125;, &#123; label: 'JavaScript', kind: CompletionItemKind.Text, data: 2 &#125; ]; &#125;);// This handler resolves additional information for the item selected in// the completion list.connection.onCompletionResolve( (item: CompletionItem): CompletionItem =&gt; &#123; if (item.data === 1) &#123; item.detail = 'TypeScript details'; item.documentation = 'TypeScript documentation'; &#125; else if (item.data === 2) &#123; item.detail = 'JavaScript details'; item.documentation = 'JavaScript documentation'; &#125; return item; &#125;);/*connection.onDidOpenTextDocument((params) =&gt; &#123; // A text document got opened in VSCode. // params.uri uniquely identifies the document. For documents store on disk this is a file URI. // params.text the initial full content of the document. connection.console.log(`$&#123;params.textDocument.uri&#125; opened.`);&#125;);connection.onDidChangeTextDocument((params) =&gt; &#123; // The content of a text document did change in VSCode. // params.uri uniquely identifies the document. // params.contentChanges describe the content changes to the document. connection.console.log(`$&#123;params.textDocument.uri&#125; changed: $&#123;JSON.stringify(params.contentChanges)&#125;`);&#125;);connection.onDidCloseTextDocument((params) =&gt; &#123; // A text document got closed in VSCode. // params.uri uniquely identifies the document. connection.console.log(`$&#123;params.textDocument.uri&#125; closed.`);&#125;);*/// Make the text document manager listen on the connection// for open, change and close text document eventsdocuments.listen(connection);// Listen on the connectionconnection.listen(); 添加一个简单的验证要向服务器添加文档验证，我们向文本文档管理器添加一个侦听器，当文本文档的内容发生更改时，该侦听器就会被调用。然后由服务器决定何时验证文档的最佳时间。在示例实现中，服务器验证纯文本文档并标记使用所有大写字母的所有出现的单词。对应的代码片段如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// The content of a text document has changed. This event is emitted// when the text document first opened or when its content has changed.documents.onDidChangeContent(async (change) =&gt; &#123; // In this simple example we get the settings for every validate run. let settings = await getDocumentSettings(textDocument.uri); // The validator creates diagnostics for all uppercase words length 2 and more let text = textDocument.getText(); let pattern = /\\b[A-Z]&#123;2,&#125;\\b/g; let m: RegExpExecArray; let problems = 0; let diagnostics: Diagnostic[] = []; while ((m = pattern.exec(text))) &#123; problems++; let diagnostic: Diagnostic = &#123; severity: DiagnosticSeverity.Warning, range: &#123; start: textDocument.positionAt(m.index), end: textDocument.positionAt(m.index + m[0].length) &#125;, message: `$&#123;m[0]&#125; is all uppercase.`, source: 'ex' &#125;; if (hasDiagnosticRelatedInformationCapability) &#123; diagnostic.relatedInformation = [ &#123; location: &#123; uri: textDocument.uri, range: Object.assign(&#123;&#125;, diagnostic.range) &#125;, message: 'Spelling matters' &#125;, &#123; location: &#123; uri: textDocument.uri, range: Object.assign(&#123;&#125;, diagnostic.range) &#125;, message: 'Particularly for names' &#125; ]; &#125; diagnostics.push(diagnostic); &#125; // Send the computed diagnostics to VSCode. connection.sendDiagnostics(&#123; uri: textDocument.uri, diagnostics &#125;);&#125; 诊断提示和技巧 如果起始位置和结束位置相同，VS Code将在该位置用一个弯曲的单词下划线。 如果您想在一行的末尾处用波浪线进行下划线，那么请将结束位置的字符设置为Number.MAX_VALUE。 要运行语言服务器，请执行以下操作: 按⇧⌘B开始构建任务。任务同时编译客户机和服务器。 打开debug viewlet，选择Launch Client Launch configuration并按下Start debug按钮来启动VS代码的附加扩展开发主机实例，该实例执行扩展代码。 创建一个test.txt文件在根文件夹中粘贴如下内容: 123TypeScript lets you write JavaScript the way you really want to.TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.ANY browser. ANY host. ANY OS. Open Source. 扩展开发主机实例将如下所示: 调试客户端和服务器调试客户机代码与调试普通扩展一样容易。在客户端代码中设置断点并按F5调试扩展。有关启动和调试扩展的详细描述，请参阅开发扩展。 由于服务器是由扩展(客户机)中运行的LanguageClient启动的，因此我们需要将调试器附加到运行的服务器上。为此，切换到Debug视图并选择服务器的启动配置并按F5。这将把调试器附加到服务器。 对语言服务器的日志记录支持如果使用vscode-languageclient实现客户机，可以指定一个设置[langId].trace.server。指示客户机将语言客户机/服务器之间的通信记录到语言客户机名称的通道的服务器。 对于lsp-sample，您可以设置此设置:&quot;languageServerExample.trace.server&quot;: &quot;verbose&quot;。现在转到频道“语言服务器示例”。您应该看到日志: 由于语言服务器可能很健谈(实际使用的5秒钟可以产生5000行日志)，我们还提供了一个工具来可视化和过滤语言客户机/服务器之间的通信。您可以将通道中的所有日志保存到一个文件中，并使用语言服务器协议检查器[(https://github.com/microsoft/languageserver-protocol-inspector)加载该文件，网址是https://microsoft.github.io/languageserver-protocol/inspector)。 使用服务器中的配置设置在编写扩展的客户端部分时，我们已经定义了一个设置来控制报告的最大问题数量。我们还在服务器端编写代码从客户端读取这些设置: 1234567891011121314function getDocumentSettings(resource: string): Thenable&lt;ExampleSettings&gt; &#123; if (!hasConfigurationCapability) &#123; return Promise.resolve(globalSettings); &#125; let result = documentSettings.get(resource); if (!result) &#123; result = connection.workspace.getConfiguration(&#123; scopeUri: resource, section: 'languageServerExample' &#125;); documentSettings.set(resource, result); &#125; return result;&#125; 我们现在需要做的唯一一件事就是监听服务器端的配置更改，如果设置更改，则重新验证打开的文本文档。为了能够重用文档更改事件处理的验证逻辑，我们将代码提取到validateTextDocument函数中，并修改代码以支持maxNumberOfProblems变量: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546async function validateTextDocument(textDocument: TextDocument): Promise&lt;void&gt; &#123; // In this simple example we get the settings for every validate run. let settings = await getDocumentSettings(textDocument.uri); // The validator creates diagnostics for all uppercase words length 2 and more let text = textDocument.getText(); let pattern = /\\b[A-Z]&#123;2,&#125;\\b/g; let m: RegExpExecArray; let problems = 0; let diagnostics: Diagnostic[] = []; while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) &#123; problems++; let diagnostic: Diagnostic = &#123; severity: DiagnosticSeverity.Warning, range: &#123; start: textDocument.positionAt(m.index), end: textDocument.positionAt(m.index + m[0].length) &#125;, message: `$&#123;m[0]&#125; is all uppercase.`, source: 'ex' &#125;; if (hasDiagnosticRelatedInformationCapability) &#123; diagnostic.relatedInformation = [ &#123; location: &#123; uri: textDocument.uri, range: Object.assign(&#123;&#125;, diagnostic.range) &#125;, message: 'Spelling matters' &#125;, &#123; location: &#123; uri: textDocument.uri, range: Object.assign(&#123;&#125;, diagnostic.range) &#125;, message: 'Particularly for names' &#125; ]; &#125; diagnostics.push(diagnostic); &#125; // Send the computed diagnostics to VSCode. connection.sendDiagnostics(&#123; uri: textDocument.uri, diagnostics &#125;);&#125; 通过向连接添加配置更改的通知处理程序，可以完成配置更改的处理。对应的代码如下: 12345678910111213connection.onDidChangeConfiguration(change =&gt; &#123; if (hasConfigurationCapability) &#123; // Reset all cached document settings documentSettings.clear(); &#125; else &#123; globalSettings = &lt;ExampleSettings&gt;( (change.settings.languageServerExample || defaultSettings) ); &#125; // Revalidate all open text documents documents.all().forEach(validateTextDocument);&#125;); 再次启动客户端，并将设置更改为最大报表1，将导致以下验证: 添加额外的语言特性语言服务器通常实现的第一个有趣特性是文档验证。从这个意义上说，甚至连棉绒都可以算作语言服务器，而在VS中，代码棉绒通常被实现为语言服务器(请参阅eslint和jshint示例)。但是语言服务器还有更多的功能。它们可以提供代码完成、查找所有引用或转到Definition。下面的示例代码将代码完成添加到服务器。它提出了两个词“TypeScript”和“JavaScript”。 1234567891011121314151617181920212223242526272829303132333435// This handler provides the initial list of the completion items.connection.onCompletion( (_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; &#123; // The pass parameter contains the position of the text document in // which code complete got requested. For the example we ignore this // info and always provide the same completion items. return [ &#123; label: 'TypeScript', kind: CompletionItemKind.Text, data: 1 &#125;, &#123; label: 'JavaScript', kind: CompletionItemKind.Text, data: 2 &#125; ]; &#125;);// This handler resolve additional information for the item selected in// the completion list.connection.onCompletionResolve( (item: CompletionItem): CompletionItem =&gt; &#123; if (item.data === 1) &#123; (item.detail = 'TypeScript details'), (item.documentation = 'TypeScript documentation'); &#125; else if (item.data === 2) &#123; (item.detail = 'JavaScript details'), (item.documentation = 'JavaScript documentation'); &#125; return item; &#125;); data字段用于惟一地标识解析处理程序中的完成项。数据属性对协议是透明的。由于底层消息传递协议是基于JSON的，因此数据字段应该只保存可序列化的JSON和可序列化的JSON数据。 所缺少的就是告诉VS Code服务器支持代码完成请求。为此，在initialize处理器中标记相应的功能: 123456789101112connection.onInitialize((params): InitializeResult =&gt; &#123; ... return &#123; capabilities: &#123; ... // Tell the client that the server supports code completion completionProvider: &#123; resolveProvider: true &#125; &#125; &#125;;&#125;); 下面的屏幕截图显示了运行在纯文本文件上的完整代码: 语言测试服务器要创建高质量的语言服务器，我们需要构建一个覆盖其功能的良好测试套件。有两种测试语言服务器的常见方法: 单元测试:如果您想通过模拟发送给语言服务器的所有信息来测试语言服务器中的特定功能，那么这是非常有用的。VS代码的HTML / CSS / JSON语言服务器采用这种方法进行测试。LSP npm模块本身使用这种方法。有关使用npm协议模块编写的单元测试，请参阅此处。 端到端测试:这类似于VS Code扩展测试。这种方法的好处是，它通过使用工作区实例化VS代码实例、打开文件、激活语言客户机/服务器和运行VS Code命令来运行测试。如果您有很难或不可能模拟的文件、设置或依赖项(如node_modules)，那么这种方法会更好。流行的Python扩展采用这种方法进行测试。 可以在您选择的任何测试框架中进行单元测试。在这里，我们描述了如何对语言服务器扩展进行端到端测试。 打开 .vscode/launch.json，您可以找到E2E测试目标: 1234567891011121314&#123; \"name\": \"Language Server E2E Test\", \"type\": \"extensionHost\", \"request\": \"launch\", \"runtimeExecutable\": \"$&#123;execPath&#125;\", \"args\": [ \"--extensionDevelopmentPath=$&#123;workspaceRoot&#125;\", \"--extensionTestsPath=$&#123;workspaceRoot&#125;/client/out/test\", \"$&#123;workspaceRoot&#125;/client/testFixture\" ], \"stopOnEntry\": false, \"sourceMaps\": true, \"outFiles\": [\"$&#123;workspaceRoot&#125;/client/out/test/**/*.js\"]&#125; 如果您运行这个调试目标，它将启动一个VS代码实例，client/testFixture作为活动工作区。VS代码将继续执行 client/src/test中的所有测试。作为一个调试技巧，您可以在client/src/test中的TypeScript文件中设置断点，它们将被命中。 让我们看一下completion.test.ts文件: 1234567891011121314151617181920212223242526272829303132333435363738import * as vscode from 'vscode';import * as assert from 'assert';import &#123; getDocUri, activate &#125; from './helper';describe('Should do completion', () =&gt; &#123; const docUri = getDocUri('completion.txt'); it('Completes JS/TS in txt file', async () =&gt; &#123; await testCompletion(docUri, new vscode.Position(0, 0), &#123; items: [ &#123; label: 'JavaScript', kind: vscode.CompletionItemKind.Text &#125;, &#123; label: 'TypeScript', kind: vscode.CompletionItemKind.Text &#125; ] &#125;); &#125;);&#125;);async function testCompletion( docUri: vscode.Uri, position: vscode.Position, expectedCompletionList: vscode.CompletionList) &#123; await activate(docUri); // Executing the command `vscode.executeCompletionItemProvider` to simulate triggering completion const actualCompletionList = (await vscode.commands.executeCommand( 'vscode.executeCompletionItemProvider', docUri, position )) as vscode.CompletionList; assert.equal(actualCompletionList.items.length, expectedCompletionList.items.length); expectedCompletionList.items.forEach((expectedItem, i) =&gt; &#123; const actualItem = actualCompletionList.items[i]; assert.equal(actualItem.label, expectedItem.label); assert.equal(actualItem.kind, expectedItem.kind); &#125;);&#125; 在这个测试中,我们: 激活扩展。 使用URI和位置运行命令vscode.executeCompletionItemProvider，以模拟完成触发器。 对我们期望的完成项断言返回的完成项。 让我们深入了解一下activate(docURI)函数。客户端/src/test/helper.ts: 123456789101112131415161718192021222324252627import * as vscode from 'vscode';import * as path from 'path';export let doc: vscode.TextDocument;export let editor: vscode.TextEditor;export let documentEol: string;export let platformEol: string;/** * Activates the vscode.lsp-sample extension */export async function activate(docUri: vscode.Uri) &#123; // The extensionId is `publisher.name` from package.json const ext = vscode.extensions.getExtension('vscode.lsp-sample'); await ext.activate(); try &#123; doc = await vscode.workspace.openTextDocument(docUri); editor = await vscode.window.showTextDocument(doc); await sleep(2000); // Wait for server activation &#125; catch (e) &#123; console.error(e); &#125;&#125;async function sleep(ms: number) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms));&#125; 在激活部分，我们: 使用package.json中定义的{publisher.name}.{extensionId}获得扩展。 打开指定的文档，并在活动文本编辑器中显示它。 休眠2秒钟，因此我们确信语言服务器已实例化。 在准备之后，我们可以运行与每种语言特性对应的VS代码命令，并对返回的结果进行断言。 还有一个测试涵盖了我们刚刚实现的诊断特性。在client/src/test/diagnostics.test.ts中查看。 高级的主题到目前为止，本指南包括: 简要概述语言服务器和语言服务器协议。 VS Code中语言服务器扩展的体系结构 lsp示例扩展，以及如何开发/调试/检查/测试它。 还有一些更高级的话题，我们无法适应这个指南。我们将包括这些资源的链接，以进一步研究语言服务器开发。 其他语言的服务器功能语言服务器目前支持以下语言特性以及代码完成: 文档高亮显示:高亮显示文本文档中所有“相等”的符号。 悬停:为文本文档中选择的符号提供悬停信息。 签名帮助:为文本文档中选择的符号提供签名帮助。 G-oto定义:为文本文档中选择的符号提供go - to定义支持。 转到类型定义:为文本文档中选择的符号提供转到类型/接口定义支持。 Goto实现:为文本文档中选择的符号提供go to实现定义支持。 查找引用:查找文本文档中所选符号的所有项目范围的引用。 列出文档符号:列出文本文档中定义的所有符号。 列表工作区符号:列出所有项目范围的符号。 代码操作:为给定的文本文档和范围运行计算命令(通常是美化/重构)。 CodeLens:计算给定文本文档的CodeLens统计数据。 文档格式:这包括对整个文档的格式、文档范围和类型的格式。 重命名:项目范围内的符号重命名。 文档链接:计算和解析文档中的链接。 文档颜色:在文档中计算和解析颜色，以便在编辑器中提供颜色选择器。 语言扩展指南主题描述了上面的每种语言特性，并提供了关于如何通过语言服务器协议或直接使用扩展的可扩展性API来实现它们的指导。 增量文本文档同步这个示例使用vscode-languageserver模块提供的简单文本文档管理器来同步VS代码和语言服务器之间的文档。 这有两个缺点: 由于文本文档的全部内容被反复发送到服务器，因此需要进行大量的数据传输。 如果使用现有的语言库，这些库通常支持增量文档更新，以避免不必要的解析和抽象语法树创建。 因此，协议也支持增量文档同步。 要使用增量文档同步，服务器需要安装三个通知处理程序: onDidOpenTextDocument:在VS代码中打开文本文档时调用。 onDidChangeTextDocument:在VS代码中文本文档的内容发生更改时调用。 onDidCloseTextDocument:当VS代码中关闭文本文档时调用。 下面是一个代码片段，演示了如何将这些通知处理程序与连接挂钩，以及如何在initialize上返回正确的功能: 123456789101112131415161718192021222324252627connection.onInitialize((params): InitializeResult =&gt; &#123; ... return &#123; capabilities: &#123; // Enable incremental document sync textDocumentSync: TextDocumentSyncKind.Incremental, ... &#125; &#125;;&#125;);connection.onDidOpenTextDocument((params) =&gt; &#123; // A text document was opened in VS Code. // params.uri uniquely identifies the document. For documents stored on disk, this is a file URI. // params.text the initial full content of the document.&#125;);connection.onDidChangeTextDocument((params) =&gt; &#123; // The content of a text document has change in VS Code. // params.uri uniquely identifies the document. // params.contentChanges describe the content changes to the document.&#125;);connection.onDidCloseTextDocument((params) =&gt; &#123; // A text document was closed in VS Code. // params.uri uniquely identifies the document.&#125;); 直接使用VS代码API实现语言特性虽然语言服务器有很多优点，但它们并不是扩展VS代码编辑功能的唯一选择。如果您想为一种文档类型添加一些简单的语言特性，可以考虑使用vscode.languages.register[LANGUAGE_FEATURE]Provider作为选项。 下面是一个使用vscode.languages的完整示例。registerCompletionItemProvider添加一些片段作为纯文本文件的补充。 更多说明VS代码API用法的示例可以在https://github.com/Microsoft/vscode-extension-samples找到。 语言服务器的容错解析器大多数时候，编辑器中的代码是不完整的，在语法上是不正确的，但是开发人员仍然希望自动完成和其他语言特性能够工作。因此，语言服务器需要一个容错解析器:解析器从部分完整的代码生成有意义的AST，语言服务器根据AST提供语言特性。 当我们在VS代码中改进PHP支持时，我们意识到官方PHP解析器不能容忍错误，不能在语言服务器中直接重用。因此，我们研究了Microsoft/ tolerance -php解析器，并留下了详细的注释，这些注释可能有助于需要实现容错解析器的语言服务器作者。 常见问题当我试图连接到服务器时，我得到“不能连接到运行时进程(5000毫秒后超时)”? 如果试图附加调试器时服务器没有运行，您将看到这个超时错误。客户端启动语言服务器，所以确保您已经启动了客户端，以便拥有一个正在运行的服务器。如果客户端断点干扰启动服务器，您可能还需要禁用它们。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"}]},{"title":"例子——单词计数","slug":"vscode-extensions-3","date":"2018-08-11T07:08:46.000Z","updated":"2020-07-25T02:57:18.230Z","comments":true,"path":"2018/08/11/vscode-extensions-3/","link":"","permalink":"https://jigangduan.github.io/2018/08/11/vscode-extensions-3/","excerpt":"","text":"本文档假设您已经阅读了第一个扩展，它涵盖了VS Code可扩展性的基础知识。 单词计数是一个端到端教程，向您展示如何创建一个扩展来帮助Markdown创作。在我们深入了解所有这些工作原理之前，让我们先快速演示一下您将要构建的核心特性，这样您就知道会发生什么了。 无论何时编辑标记文件，都会添加状态栏消息。该消息包括当前的字数和更新，当您键入和移动到文件: 提示:如果您有任何问题，可以从GitHub存储库中获得完成的示例。 概述这个示例有三个部分，将带您了解一系列相关概念: 更新状态栏-在VS代码状态栏中显示自定义文本订阅事件——根据编辑事件更新状态栏配置扩展资源——释放事件订阅或UI句柄等资源 首先确保安装了最新的VS Code扩展生成器，然后运行它: 12npm install -g yo generator-codeyo code 这将打开扩展生成器——我们将以TypeScript New扩展选项为基础。现在，按照您在下图中看到的方法填写字段(使用’WordCount’作为扩展名，您自己的名字作为发布者)。 你现在可以打开VS Code在生成器输出描述: 12cd WordCountcode . 运行扩展在继续之前，我们可以通过按F5来运行扩展以确保一切正常。正如您在前面的“Hello World”演练中看到的，VS代码打开了另一个窗口([扩展开发主机]窗口)，在这个窗口中您的扩展将被加载。你应该找“Hello World”命令在命令面板中(按⇧⌘P),当你选择它,您将看到一个通知在窗口的右下角说“Hello World !”。 既然您已经确认了扩展正在正确地运行，那么如果您愿意，您可以继续打开扩展开发窗口。要测试您对扩展所做的任何更改，您可以在开发窗口中再次按F5，或者通过按Ctrl+R (macOS: Cmd+R)重新加载扩展开发窗口。 更新状态栏用下面的代码替换生成的extension.ts文件的内容。它声明并实例化一个WordCounter类，该类可以计数单词，并在VS代码状态栏中显示它们。“Hello Word”命令在调用时将调用updateWordCount。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// The module 'vscode' contains the VS Code extensibility API// Import the necessary extensibility types to use in your code belowimport &#123;window, commands, Disposable, ExtensionContext, StatusBarAlignment, StatusBarItem, TextDocument&#125; from 'vscode';// This method is called when your extension is activated. Activation is// controlled by the activation events defined in package.json.export function activate(context: ExtensionContext) &#123; // Use the console to output diagnostic information (console.log) and errors (console.error). // This line of code will only be executed once when your extension is activated. console.log('Congratulations, your extension \"WordCount\" is now active!'); // create a new word counter let wordCounter = new WordCounter(); let disposable = commands.registerCommand('extension.sayHello', () =&gt; &#123; wordCounter.updateWordCount(); &#125;); // Add to a list of disposables which are disposed when this extension is deactivated. context.subscriptions.push(wordCounter); context.subscriptions.push(disposable);&#125;class WordCounter &#123; private _statusBarItem: StatusBarItem = window.createStatusBarItem(StatusBarAlignment.Left); public updateWordCount() &#123; // Get the current text editor let editor = window.activeTextEditor; if (!editor) &#123; this._statusBarItem.hide(); return; &#125; let doc = editor.document; // Only update status if an Markdown file if (doc.languageId === \"markdown\") &#123; let wordCount = this._getWordCount(doc); // Update the status bar this._statusBarItem.text = wordCount !== 1 ? `$&#123;wordCount&#125; Words` : '1 Word'; this._statusBarItem.show(); &#125; else &#123; this._statusBarItem.hide(); &#125; &#125; public _getWordCount(doc: TextDocument): number &#123; let docContent = doc.getText(); // Parse out unwanted whitespace so the split is accurate docContent = docContent.replace(/(&lt; ([^&gt;]+)&lt;)/g, '').replace(/\\s+/g, ' '); docContent = docContent.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); let wordCount = 0; if (docContent !== \"\") &#123; wordCount = docContent.split(\" \").length; &#125; return wordCount; &#125; dispose() &#123; this._statusBarItem.dispose(); &#125;&#125; 现在让我们尝试对扩展的更新。 我们将TypeScript文件的编译设置在一个手表上(扩展名是.vscode\\tasks.json文件)，所以不需要重新构建。在[扩展开发主机]窗口中按Ctrl+R键，您的代码正在运行，扩展将重新加载(您也可以从您的主开发窗口F5)。我们仍然需要像以前一样使用“Hello World”命令激活代码。假设您在一个标记文件中，您的状态栏将显示单词计数。 这是一个很好的开始，但如果计数随着文件的更改而更新，会更酷。 订阅事件让我们将助手类与一组事件挂钩。 onDidChangeTextEditorSelection -当游标位置发生变化时将引发事件 onDidChangeActiveTextEditor—当活动编辑器更改时引发事件。 为此，我们将在extension.ts文件中添加一个新类。它将设置这些事件的订阅，并要求WordCounter更新单词计数。还要注意这个类如何将订阅管理为可丢弃的，以及如何在自行处理时停止列出。 将下面所示的WordCounterController添加到extension.ts文件的底部。 12345678910111213141516171819202122232425262728class WordCounterController &#123; private _wordCounter: WordCounter; private _disposable: Disposable; constructor(wordCounter: WordCounter) &#123; this._wordCounter = wordCounter; // subscribe to selection change and editor activation events let subscriptions: Disposable[] = []; window.onDidChangeTextEditorSelection(this._onEvent, this, subscriptions); window.onDidChangeActiveTextEditor(this._onEvent, this, subscriptions); // update the counter for the current file this._wordCounter.updateWordCount(); // create a combined disposable from both event subscriptions this._disposable = Disposable.from(...subscriptions); &#125; dispose() &#123; this._disposable.dispose(); &#125; private _onEvent() &#123; this._wordCounter.updateWordCount(); &#125;&#125; 我们不再希望在调用命令时加载单词计数扩展名，而是希望每个标记文件都可用。 首先，将激活功能的主体替换为: 1234567891011// Use the console to output diagnostic information (console.log) and errors (console.error).// This line of code will only be executed once when your extension is activated.console.log('Congratulations, your extension \"WordCount\" is now active!');// create a new word counterlet wordCounter = new WordCounter();let controller = new WordCounterController(wordCounter);// Add to a list of disposables which are disposed when this extension is deactivated.context.subscriptions.push(controller);context.subscriptions.push(wordCounter); 其次，我们必须确保在打开标记文件时激活扩展名。为此，我们需要修改package.json文件。之前，扩展是通过extension.sayHello命令激活的，我们不再需要这个命令，所以我们可以从package.json删除整个贡献属性: 12345678\"contributes\": &#123; \"commands\": [&#123; \"command\": \"extension.sayHello\", \"title\": \"Hello World\" &#125; ] &#125;, 现在更改您的扩展名，以便在打开标记文件时激活它，方法是更新activationEvents属性: 123\"activationEvents\": [ \"onLanguage:markdown\" ] onLanguage:${language}事件接受语言id(在本例中为“markdown”)，并且在打开该语言的文件时将引发该事件。 通过窗口重载Ctrl+R或使用F5运行扩展，然后开始编辑一个标记文件。现在应该有一个实时更新的单词计数。 如果您在activate函数上设置了断点，那么您会注意到，当打开第一个标记文件时，它只调用一次。WordCountController构造函数运行并订阅编辑器事件，这样updateWordCount函数就被称为“标记文件”(Markdown)，它们的文本也会发生变化。 定制状态栏 我们已经看到了如何在状态栏上显示格式化文本。VS代码允许您定制您的状态栏添加进一步与颜色，图标，工具提示等。使用智能感知，您可以看到各种StatusBarItem字段。学习VS代码可扩展性api的另一个很好的资源是生成的扩展项目中包含的node_modules\\vscode\\vscode.d.ts类型声明文件。在编辑器中打开vscode.d.ts，您将看到带有注释的完整VS代码可扩展性API。 将StatusBarItem更新代码替换为: 123// Update the status bar this._statusBarItem.text = wordCount !== 1 ? `$(pencil) $&#123;wordCount&#125; Words` : '$(pencil) 1 Word'; this._statusBarItem.show(); 在计算字数的左边显示一个GitHub Octicon铅笔图标。 处理扩展资源现在，我们将更深入地了解扩展如何通过可丢弃件处理VS代码资源。 当一个扩展被激活时，它会被传递一个ExtensionContext对象，该对象具有一个可丢弃的可订阅集合。扩展可以将它们的一次性对象添加到这个集合中，VS代码将在扩展停用时处理这些对象。 许多创建工作区或UI对象(例如registerCommand)的VS代码api返回一个一次性的，扩展可以通过直接调用它们的dispose方法从VS代码中删除这些元素。 事件是onDid*事件订阅方方法返回一次性消息的另一个例子。通过处理事件的可丢弃性，取消订阅事件。在我们的示例中，WordCountController通过保留自己的一次性集合(在停用时清除)直接处理事件订阅可丢弃项。 1234567// subscribe to selection change and editor activation events let subscriptions: Disposable[] = []; window.onDidChangeTextEditorSelection(this._onEvent, this, subscriptions); window.onDidChangeActiveTextEditor(this._onEvent, this, subscriptions); // create a combined disposable from both event subscriptions this._disposable = Disposable.from(...subscriptions); 在本地安装您的扩展到目前为止，您编写的扩展只在VS代码的一个特殊实例中运行，即扩展开发主机实例。要使您的扩展可以用于所有VS代码实例，请将扩展文件夹内容复制到.vscode/extensions文件夹下的新文件夹中 发布您的扩展阅读如何共享扩展。 下一个步骤继续往下读，你会发现: 扩展生成器-了解Yo代码扩展生成器中的其他选项。扩展API - 获得扩展API的概述。发布工具-学习如何发布一个扩展到公共市场。编辑器API -学习更多关于文本文档，文本编辑器和编辑文本。其他扩展示例—查看我们的示例扩展项目列表。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"}]},{"title":"扩展 - Hello World","slug":"vscode-extensions-2","date":"2018-08-11T04:16:04.000Z","updated":"2020-07-25T02:57:18.230Z","comments":true,"path":"2018/08/11/vscode-extensions-2/","link":"","permalink":"https://jigangduan.github.io/2018/08/11/vscode-extensions-2/","excerpt":"","text":"你的第一个扩展本文档将指导您创建第一个VS Code扩展(“Hello World”)，并解释VS Code可扩展性的基本概念。 在本演练中，您将向VS Code添加一个新命令，该命令将显示一个简单的“Hello World”消息。在随后的演练中，您将与VS Code编辑器交互，并查询用户当前选择的文本。 先决条件你需要的节点。在您的$PATH中安装并可用js。Node.js安装包括npm, Node.js包管理器，它将用于安装扩展生成器。 生成一个新的扩展向VS Code中添加自己的功能的最简单方法是添加一个命令。命令注册一个回调函数，该函数可以从命令调色板调用，也可以通过键绑定调用。 我们编写了一个Yeoman生成器来帮助您开始。安装Yeoman和Yeoman VSCode扩展生成器和脚手架一个新的扩展: 12npm install -g yo generator-codeyo code 对于hello world扩展，您可以创建TypeScript扩展或JavaScript扩展。对于本例，我们选择一个TypeScript扩展。 运行您的扩展 启动VS Code，选择文件&gt;打开文件夹并选择生成的文件夹。 按F5或单击调试图标并单击Start。 VS Code的一个新实例将以特殊模式(扩展开发主机)启动，这个新实例现在知道您的扩展了。 按键⇧⌘P和运行该命令命名为Hello World。 恭喜你!您刚刚创建并执行了第一个VS代码命令! 扩展的结构运行后生成的扩展应该具有以下结构: 123456789101112131415161718192021222324252627.├── .gitignore├── .vscode // VS Code integration│ ├── launch.json│ ├── settings.json│ └── tasks.json├── .vscodeignore // files ignored when publishing extension├── README.md├── src│ └── extension.ts // the source of the extension entry point├── test // test folder│ ├── extension.test.ts // extension.test.js, in case of JavaScript extension│ └── index.ts // index.js, in case of JavaScript extension├── node_modules│ ├── vscode // include vscode type definition file for extension development│ └── typescript // compiler for typescript (TypeScript only)├── out // compilation output (TypeScript only)│ ├── extension.js // the extension entry point│ ├── extension.js.map│ └── test│ ├── extension.test.js│ ├── extension.test.js.map│ ├── index.js│ └── index.js.map├── package.json // extension's manifest├── tsconfig.json // jsconfig.json, in case of JavaScript extension└── vsc-extension-quickstart.md // extension development quick start 让我们看看所有这些文件的用途，并解释它们的用途: 扩展清单:package.json 每个VS Code扩展必须有一个package.json文件描述它和它的功能。 VS Code在启动时读取此文件，并立即对每个投稿部分作出反应。 请阅读package.json扩展清单参考。 更多关于package.json贡献点的信息。 1234567891011121314151617181920212223242526272829303132333435&#123; \"name\": \"myFirstExtension\", \"description\": \"\", \"version\": \"0.0.1\", \"publisher\": \"\", \"engines\": &#123; \"vscode\": \"^1.5.0\" &#125;, \"categories\": [ \"Other\" ], \"activationEvents\": [ \"onCommand:extension.sayHello\" ], \"main\": \"./out/extension\", \"contributes\": &#123; \"commands\": [&#123; \"command\": \"extension.sayHello\", \"title\": \"Hello World\" &#125;] &#125;, \"scripts\": &#123; \"vscode:prepublish\": \"tsc -p ./\", \"compile\": \"tsc -watch -p ./\", \"postinstall\": \"node ./node_modules/vscode/bin/install\", \"test\": \"node ./node_modules/vscode/bin/test\" &#125;, \"devDependencies\": &#123; \"typescript\": \"^2.0.3\", \"vscode\": \"^1.5.0\", \"mocha\": \"^2.3.3\", \"@types/node\": \"^6.0.40\", \"@types/mocha\": \"^2.2.32\" &#125;&#125; 注意:JavaScript扩展不需要scripts字段，因为不需要编译。 这个具体的package.json描述了一个扩展: 一个条目有助于命令面板(⇧⌘P)的标签“Hello world”将调用命令“extension.sayHello”。 当命令“extension.sayHello”被调用时，请求加载(activationEvents)。 它的主要JavaScript代码在一个名为“./out/extension.js”的文件中。 注意:VS代码在启动时并不急于加载扩展的代码。扩展必须通过activationEvents属性描述它在什么条件下应该被激活(加载)。 生成的代码生成的扩展代码为extension.ts(或JavaScript扩展为extension.js): 123456789101112131415161718192021222324// The module 'vscode' contains the VS Code extensibility API// Import the module and reference it with the alias vscode in your code belowimport * as vscode from 'vscode';// this method is called when your extension is activated// your extension is activated the very first time the command is executedexport function activate(context: vscode.ExtensionContext) &#123; // Use the console to output diagnostic information (console.log) and errors (console.error) // This line of code will only be executed once when your extension is activated console.log('Congratulations, your extension \"my-first-extension\" is now active!'); // The command has been defined in the package.json file // Now provide the implementation of the command with registerCommand // The commandId parameter must match the command field in package.json let disposable = vscode.commands.registerCommand('extension.sayHello', () =&gt; &#123; // The code you place here will be executed every time your command is executed // Display a message box to the user vscode.window.showInformationMessage('Hello World!'); &#125;); context.subscriptions.push(disposable);&#125; 每个扩展都应该从它的主文件导出一个名为activate()的函数，当package.json文件中描述的任何activationEvents发生时，VS Code只调用一次。 如果扩展使用OS资源(例如spawns进程)，扩展可以从主文件导出一个名为deactivate()的函数，在这里它可以进行清理工作，VS Code将在关机时调用该函数。 这个特定的扩展导入vscode API，然后注册一个命令，在调用命令“extension.sayHello”时关联要调用的函数。命令的实现在VS代码中显示“Hello world”消息。 注意:package.json的贡献部分向命令调色板添加了一个条目。extension.ts/.js中的代码定义了“extension.sayHello”的实现。注意:对于TypeScript扩展，生成的文件out/extension.js将在运行时加载并由VS代码执行。 其他文件的 .vscode/launch.json在扩展开发模式中定义了启动VS代码。它还将预启动任务指向运行TypeScript编译器的.vscode/tasks.json中定义的任务。 默认情况下，.vscode/settings.json不包括out文件夹。可以修改要隐藏的文件类型。 .gitignore - 告诉Git版本控制要忽略哪些模式 .vscodeignore -告诉打包工具在发布扩展名时忽略哪些文件。 README.md - 描述VS code用户扩展的README文件。 vsc-extension-quickstart.md -一个快速开始指导你。 test/extension.test.ts - 你可以把你的扩展单元测试放在这里，然后根据VSCode API运行你的测试(参见测试你的扩展) 扩展activation现在，扩展中包含的文件的角色已经明确，下面是如何激活扩展的: 扩展开发实例发现扩展并读取其package.json文件。 以后当你按⇧⌘P: 注册的命令显示在命令调色板中。 在这个列表中，现在有一个条目“Hello world”在package.json中定义。 选择“Hello world”命令: 调用命令“extension.sayHello”: 创建一个激活事件“onCommand:extension.sayHello”。 在activationEvents中列出此激活事件的所有扩展都被激活。 ./out/extension.js处的文件被加载到JavaScript VM中。 VS code寻找一个导出函数激活并调用它。 已经注册了命令“extension.sayHello”，现在已经定义了它的实现。 调用命令“extension.sayHello”实现函数。 命令实现显示“Hello World”消息。 调试您的扩展设置断点，例如在已注册的命令中，并在扩展开发VS代码实例中运行“Hello world”命令。 注意:对于TypeScript扩展，即使VS Code加载并执行out/extension.js，由于生成的源代码映射out/extension.js.map，您实际上能够调试初始的TypeScript代码。map和VS Code对源代码映射的调试器支持。提示:调试控制台将显示您登录到控制台的所有消息。 了解更多关于扩展开发环境的信息。 一个简单的改变在extension.ts(或extension.js，在JavaScript扩展中)中，尝试替换extension.sayHello命令实现，以显示编辑器中选择的字符数: 1234567891011121314let disposable = vscode.commands.registerCommand('extension.sayHello', () =&gt; &#123; // The code you place here will be executed every time your command is executed let editor = vscode.window.activeTextEditor; if (!editor) &#123; return; // No open text editor &#125; let selection = editor.selection; let text = editor.document.getText(selection); // Display a message box to the user vscode.window.showInformationMessage('Selected characters: ' + text.length); &#125;); 提示:一旦对扩展源代码进行了更改，就需要重新启动VS Code的扩展开发主机实例。您可以在扩展开发主机实例中使用Ctrl+R (macOS: Cmd+R)，或者单击主VS Code实例顶部的Restart按钮。 创建一个文件(文件&gt;新文件)，输入一些文本并选择它。在运行Hello World命令时，现在应该会看到所选字符的计数。 在本地安装您的扩展到目前为止，您编写的扩展只在VSCode的一个特殊实例中运行，即扩展开发实例。要使您的扩展在VSCode的所有实例中运行，您需要将其复制到本地扩展文件夹下的新文件夹中: Windows: %USERPROFILE%.vscode\\extensions macOS/Linux: $HOME/.vscode/extensions 发布您的扩展阅读如何共享扩展。 下一个步骤在本演练中，我们看到了一个非常简单的扩展。有关更详细的示例，请参阅单词计数示例，该示例展示了如何以特定语言为目标(标记)，并侦听编辑器的文档更改事件。 如果你想了解更多关于扩展api的内容，请尝试以下主题: 扩展API概述-了解VS代码可扩展性的完整模型。 API原则和模式——VS代码可扩展性基于几个指导原则和模式。 贡献点——关于VS代码贡献点的详细信息。 激活事件- VS代码激活事件引用 其他扩展示例—查看我们的示例扩展项目列表。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"}]},{"title":"Yo Code - 扩展生成器","slug":"vscode-extensions-1","date":"2018-08-11T02:32:19.000Z","updated":"2020-07-25T02:57:18.230Z","comments":true,"path":"2018/08/11/vscode-extensions-1/","link":"","permalink":"https://jigangduan.github.io/2018/08/11/vscode-extensions-1/","excerpt":"","text":"我们编写了一个Yeoman 生成器来帮助您开始。 先决条件你需要的节点。在您的$PATH中安装并可用js。Node.js安装包括npm, Node.js包管理器，它将用于安装扩展生成器。 安装生成器从命令提示符安装Yeoman和VS Code扩展生成器: 1npm install -g yo generator-code 运行你代码Yeoman生成器将指导您完成创建自定义或扩展所需的步骤，并提示您输入所需的信息。 要启动生成器，在命令提示符中输入以下命令: 1yo code 生成器的选择生成器可以为新扩展创建扩展框架，也可以根据现有的TextMate定义文件为语言、主题或片段创建现成的扩展。 新建扩展(TypeScript)创建一个实现“hello world”命令的扩展框架。将此作为您自己的扩展的起点。 提示输入扩展标识符，并将在当前目录中创建该名称的文件夹。 创建带有源、测试和输出文件夹的基本文件夹结构。 模板输出package.json文件和扩展名主文件。 设置launch.json和tasks.json，以便F5编译和运行您的扩展并附加调试器。 可以选择设置Git存储库。 创建之后，在创建的文件夹上打开VS代码。该文件夹包含一个文件vsc-extension-quickstart.md，作为接下来步骤的快速指南。这个扩展的设置是为了让你得到扩展API的智能感知。 新建扩展(JavaScript)与新建扩展(TypeScript)相同，但是JavaScript。这个扩展的设置是为了让你得到扩展API的智能感知。 新建颜色主题创建一个能提供新颜色主题的扩展。您可以基于现有的TextMate颜色主题创建主题，或者从头创建新主题。 如果您计划使用 Developer: Generate Color Theme From Current Settings 命令在您的设置中使用自定义颜色创建主题(推荐)，那么从新的扩展开始。 以TextMate颜色主题开始，以现有的主题(如.tmtheme)开始。 生成器将: 提示输入颜色主题名称以及颜色基础主题(亮或暗)。 提示输入扩展标识符，并将在当前目录中创建该名称的文件夹。 创建之后，在创建的文件夹上打开VS Code并运行扩展来测试新主题。查看vsc-extension-quickstart.md。下面是一个快速指南。 新语言支持创建一个扩展，该扩展使用着色器提供语言。 提示输入现有TextMate语言文件(.tmLanguage, .plist or .json)的位置(URL或文件路径)。此文件将导入新扩展名。要开始一个新的语法，您可以通过传递一个空的名称来跳过这个。 提示输入扩展标识符，并将在当前目录中创建该名称的文件夹。 创建好后，在创建的文件夹上打开VS代码并运行扩展来测试着色。查看vsc-extension-quickstart.md以了解接下来的步骤。查看已经创建的语言配置文件，并定义配置选项，比如语言使用的注释和括号。 新建代码片段创建提供新代码片段的扩展。 提示输入包含TextMate片段(.tmsnippet)或Sublime片段(.sublime-snippet)的文件夹位置。这些文件被转换为VS Code片段文件。 提示输入这些片段将被激活的语言。 提示输入扩展标识符，并将在当前目录中创建该名称的文件夹。 创建之后，在创建的文件夹上打开VS Code并运行扩展来测试代码片段。查看vsc-extension-quickstart.md。接下来的步骤。 新建扩展包创建一个扩展，该扩展使用您最喜欢的扩展提供一个新的扩展包。 提示将已安装的扩展添加到扩展包。 提示输入扩展标识符，并将在当前目录中创建该名称的文件夹。 检查包中的扩展依赖关系。发布扩展包之前的json文件。 创建好后，在创建的文件夹上打开VS代码并运行扩展来测试扩展包。查看vsc-extension-quickstart.md接下来的步骤。 你的扩展文件夹要加载扩展，需要将文件复制到VS Code扩展文件夹.vscode/extensions。根据平台的不同，它位于以下文件夹中: Windows %USERPROFILE%\\.vscode\\extensions macOS ~/.vscode/extensions Linux ~/.vscode/extensions 如果每次VS Code运行时都要加载扩展名，请将项目复制到.vscode/extensions下的新文件夹中(“侧加载”)。例如:~/.vscode/extensions/myextension。 下一个步骤发布工具-学习如何发布你的扩展到VS Code市场。Hello World—尝试“Hello World”演练来构建您的第一个扩展。其他扩展示例—查看我们的示例扩展项目列表。 常见问题yo代码生成器不响应Windows 10上的箭头键尝试用yo启动Yeoman生成器，然后选择代码生成器。 如果箭头键仍然没有响应，试着从一个升高的外壳启动Yeoman。为此，右键单击shell并选择Run as administrator。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"}]},{"title":"Sentry服务搭建","slug":"Sentry","date":"2018-08-11T01:08:32.000Z","updated":"2020-07-25T02:57:18.164Z","comments":true,"path":"2018/08/11/Sentry/","link":"","permalink":"https://jigangduan.github.io/2018/08/11/Sentry/","excerpt":"","text":"官方引导运行您自己的 Sentry 使用 Docker. 需求 Docker 1.10.0+ Compose 1.6.0+ (可选) 启动和运行假设您刚刚克隆了这个存储库，下面的步骤将立即启动并运行! 可能需要对包含的docker-compose.yml文件进行修改，以适应您的需要或环境。这些指导方针是你应该做的事情。 mkdir -p data/{sentry,postgres} - 使我们的本地数据库和哨兵配置目录。这个目录是用postgres绑定安装的，所以不会丢失状态! docker-compose build - 构建和标记Docker服务 docker-compose run --rm web config generate-secret-key - 生成一个密钥. 将其添加到 docker-compose.yml in base as SENTRY_SECRET_KEY. docker-compose run --rm web upgrade - 建立数据库. 使用交互式提示创建用户帐户. docker-compose up -d - 解除所有服务(分离/后台模式)。 访问您的实例 localhost:9000! 注意，只要安装了数据库绑定，就可以很好地停止和删除容器，而不用担心。 确保Sentry 使用 SSL/TLS如果您想用SSL/TLS保护您的Sentry安装，那么有一些很棒的SSL/TLS代理，比如HAProxy和Nginx。 \b升级Sentry使用撰写来更新岗哨相对简单。只需使用以下步骤进行更新。确保在Dockerfile中设置了最新的版本。或者使用这个存储库的最新版本。 更新此存储库或Dockerfile后，使用以下步骤: 123docker-compose build # 更新后重新构建服务docker-compose run --rm web upgrade # 运行新的迁移docker-compose up -d # 重新创建服务 资源 文档 Bug追踪 论坛 IRC (chat.freenode.net, #sentry)","categories":[],"tags":[]},{"title":"扩展 VS Code","slug":"vscode-extensions","date":"2018-08-10T13:33:34.000Z","updated":"2020-07-25T02:57:18.231Z","comments":true,"path":"2018/08/10/vscode-extensions/","link":"","permalink":"https://jigangduan.github.io/2018/08/10/vscode-extensions/","excerpt":"","text":"如果您对扩展VS Code感兴趣，那么您的位置就对了。在这里，我们将概述VS代码可扩展性文档，以及如何快速构建您的第一个VS代码扩展。如果您对VS代码的可扩展性的设计方法感到好奇，您可以在这里阅读。 如果您只想使用现有的扩展，请参阅扩展市场主题，在该主题中，我们将向您展示如何从VSCode市场中查找和安装扩展。 所有VS Code扩展都共享一个公共的贡献(注册)、激活(加载)和访问VS Code可扩展性API的模型。但是VS Code扩展有两种特殊的风格，语言服务器和调试器，它们有自己的附加协议，并在各自的文档部分中介绍。 扩展——基本构建块 语言服务器-通过语言服务器协议增强编辑体验的扩展 调试器—通过调试适配器连接外部调试器 扩展激活时，所有扩展在我们的共享扩展主机(extension host)进程中运行。这个单独的扩展过程确保VS Code始终保持响应。 扩展包括支持: 激活 —— 当检测到特定文件类型时，当特定文件存在时，或者通过命令调色板或键组合选择命令时，加载扩展名编辑器 —— 使用编辑器的内容—阅读和操作文本，利用选择工作区 —— 访问开放编辑器、状态栏、信息消息等事件 —— 连接到编辑器生命周期事件，例如:打开、关闭、更改等等进化的编辑-创建丰富的语言支持的提供者，包括智能感知，Peek，悬浮，诊断和更多 我们有两个端到端的教程来让你学习扩展基础知识: Hello World——生成一个基本的扩展，了解一个扩展的文件夹结构，扩展清单，学习激活是如何工作的，运行和调试你的扩展并在本地安装它。 单词计数-根据特定的文件类型激活，更新状态栏，响应文本编辑器中的更改，在移出文件时处理扩展名。 同样有用的还有可扩展性原则和模式，它们描述了贯穿可扩展性API的共享编程模式。 语言的服务器语言服务器是一种特殊的扩展，支持VS代码中多种语言的编辑体验。使用语言服务器，您可以实现对定义的跳转、自动完成、错误检查以及VS Code中支持的许多其他语言特性。 了解更多关于语言服务器的信息。 调试适配器VS Code实现了通用调试器UI，并依赖于调试器扩展和所谓的“调试适配器”将调试UI连接到真正的调试器或运行时。调试适配器是通过VS Code调试协议与VS Code通信的专用过程，可以用任何语言实现。 了解有关创建调试器扩展的更多信息。 查看VS Code扩展的最简单方法是通过扩展市场。您可以浏览有用的扩展，安装它们以试用它们，并了解如何为自己的开发场景扩展VS Code。 语言扩展准则语言扩展指南主题可以帮助您决定在扩展中支持哪些语言特性。它展示了VS Code中可用的各种语言特性(例如，代码建议和操作、格式化、重命名)，以及如何通过语言服务器协议或通过直接使用扩展API来实现它们。 主题、片段和着色器通过语法高亮显示、有用的代码片段和精心设计的颜色主题，您可以对您的编程语言有很好的编辑体验。TextMate定制文件提供了这种支持，VS代码允许您轻松地打包和重用这些文件，这样您就可以直接在扩展名中使用.tmTheme, .tmSnippets和.tmlanguage文件。我们的主题、片段和着色器主题向您展示了如何包含TextMate文件，以及如何创建自己的主题、片段和语言着色器。 编写扩展有一个Yeoman扩展生成器，它使创建简单的扩展项目变得非常容易。这些都是很好的开始，您也可以找到现有的扩展示例。 扩展可以用TypeScript或JavaScript编写。VS Code提供了一流的扩展开发体验，您可以在其中开发、构建、运行、测试和调试VS Code本身。 测试扩展我们还非常支持为您的扩展编写和运行测试。您可以轻松地创建集成测试，这些测试调用VS code api，并在运行VS Code实例中测试您的代码。 扩展的想法许多关于VS Code特性的优秀社区想法都是作为扩展而不是作为核心产品的一部分更好地实现的。通过这种方式，用户可以通过安装正确的扩展集轻松地选择他们想要的功能。VS Code团队跟踪vscode存储库中标记为*extension-candidate的GitHub问题可能的扩展。如果您正在寻找一个很好的扩展来构建，请查看*extension-candidate问题。 下一个步骤您的第一个扩展 —— 尝试创建一个简单的Hello World扩展。扩展API —— 学习VS代码可扩展性API。扩展示例 —— 您可以检查和构建的扩展示例列表。","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"}]},{"title":"Spring MVC","slug":"Spring-5-Recipes-3","date":"2018-08-01T13:19:03.000Z","updated":"2020-07-25T02:57:18.165Z","comments":true,"path":"2018/08/01/Spring-5-Recipes-3/","link":"","permalink":"https://jigangduan.github.io/2018/08/01/Spring-5-Recipes-3/","excerpt":"","text":"MVC是Spring框架中最重要的模块之一。它构建在强大的Spring IoC容器上，并广泛使用容器特性来简化其配置。 模型-视图-控制器(MVC)是UI设计中常见的设计模式。它将模型、视图和控制器的角色分离到应用程序中，从而将业务逻辑与ui分离开来。模型负责为要显示的视图封装应用程序数据。视图应该只显示此数据，而不包含任何业务逻辑。控制器负责接收用户的请求并调用后端服务进行业务处理。处理后，后端服务可以返回一些数据以供视图显示。控制器收集这些数据并为视图准备模型。MVC模式的核心思想是将业务逻辑与ui分离开来，使其能够独立地进行更改，而不会相互影响。 在Spring MVC应用程序中，模型通常由域对象组成，这些域对象由服务层处理并由持久化层保存。视图通常是用Java标准标记库(JSTL)编写的JSP模板。但是，也可以将视图定义为PDF文件、Excel文件、RESTful web服务，甚至是Flex接口，后者通常被称为富Internet应用程序(ria)。完成本章后，您将能够使用Spring MVC开发Java web应用程序。您还将了解Spring MVC的通用控制器和视图类型，其中包括自Spring 3.0发布以来用于创建控制器的注解。此外，您将了解Spring MVC的基本原则，它将作为后续章节中更高级主题的基础。 使用Spring MVC开发一个简单的Web应用程序问题 您希望使用Spring MVC开发一个简单的web应用程序，以了解这个框架的基本概念和配置。 解决方案 Spring MVC的中心组件是前端控制器。在最简单的Spring MVC应用程序中，这个控制器是惟一需要在Java web部署描述符(即web.xml文件或ServletContainerInitializer)中配置的servlet。Spring MVC控制器(通常称为dispatcher servlet)实现了Sun的核心Java EE设计模式之一，称为Front Controller。它充当Spring MVC框架的前端控制器，每个web请求都必须经过它，以便能够管理整个请求处理过程。 当web请求被发送到Spring MVC应用程序时，控制器首先接收请求。然后，它将组织在Spring的web应用程序上下文中配置的不同组件或控制器本身中存在的注释，这些都是处理请求所需的。图3-1显示了Spring MVC中请求处理的主要流程。 要在Spring中定义一个控制器类，必须用@Controller或@RestController注释标记一个类。当@Controller带注释的类(即controller类)接收到请求时，它会寻找合适的处理程序方法来处理请求。这要求控制器类通过一个或多个处理程序映射将每个请求映射到处理程序方法。为此，使用@RequestMapping注释修饰controller类的方法，使它们成为处理程序方法。这些处理程序方法的签名(您可以从任何标准类中看到)是开放的。可以为处理程序方法指定任意名称，并定义各种方法参数。同样，处理程序方法可以返回一系列值中的任何一个(例如，String或void)，这取决于它执行的应用程序逻辑。随着这本书的深入，您将会遇到各种方法参数，这些参数可以使用@RequestMapping注释在处理程序方法中使用。下面只是有效参数类型的部分列表，仅供您了解。 HttpServletRequest或HttpServleResponse 请求任意类型的参数，用@RequestParam注释 任意类型的模型属性，用@ModelAttribute标注。 在传入请求中包含的Cookie值，用@CookieValue标注。 映射或ModelMap，用于处理方法向模型添加属性。 处理程序方法访问命令对象的绑定和验证结果的错误或BindingResult SessionStatus，用来通知处理程序方法完成会话处理 一旦控制器类选择了一个适当的处理程序方法，它将调用处理程序方法的逻辑与请求。通常，控制器的逻辑调用后端服务来处理请求。此外，处理程序方法的逻辑可能会从众多输入参数(例如HttpServletRequest、Map、Errors或SessionStatus)中添加或删除信息，这些参数将构成正在进行的Spring MVC流的一部分。处理完请求后，它将控件委托给一个视图，该视图被表示为处理程序方法的返回值。要提供一种灵活的方法，处理程序方法的返回值并不表示视图的实现(例如，user.jsp report.pdf)。而是逻辑视图(例如，user或report)——注意文件扩展的缺乏。处理程序方法的返回值可以是表示逻辑视图名的字符串，也可以是void，在这种情况下，默认逻辑视图名是根据处理程序方法或控制器的名称确定的。要将信息从控制器传递到视图，处理程序的方法返回逻辑视图名称字符串或voip是不相关的，因为处理程序方法的输入参数将对视图可用。例如，如果处理程序方法以Map和SessionStatus对象作为输入参数——在处理程序方法的逻辑中修改它们的内容——这些相同的对象将被处理程序方法返回的视图访问。当控制器类接收到一个视图时，它将逻辑视图名解析为一个特定的视图实现(例如，user)。通过视图解析器来实现jsp或report.pdf。视图解析器是在实现ViewResolver接口的web应用程序上下文中配置的bean。它的职责是为逻辑视图名返回特定的视图实现(HTML、JSP、PDF或其他)。一旦控制器类将视图名解析为视图实现，根据视图实现的设计，它将呈现控制器处理程序方法传递的对象(例如HttpServletRequest、Map、Errors或SessionStatus)。视图的职责是向用户显示在处理程序方法的逻辑中添加的对象。 它是如何工作的 假设你要为一个体育中心开发一个法庭预约系统。此应用程序的ui是基于web的，以便用户可以通过Internet在线预订。您希望使用Spring MVC开发这个应用程序。首先，在域子包中创建以下域类: 12345678910111213141516171819202122232425262728package com.apress.springrecipes.court.domain;public class Reservation &#123; private String courtName; private Date date; private int hour; private Player player; private SportType sportType; // Constructors, Getters and Setters ...&#125;package com.apress.springrecipes.court.domain;public class Player &#123; private String name; private String phone; // Constructors, Getters and Setters ...&#125;package com.apress.springrecipes.court.domain;public class SportType &#123; private int id; private String name; // Constructors, Getters and Setters ...&#125; 然后，在服务子包中定义以下服务接口，为表示层提供预订服务: 12345678package com.apress.springrecipes.court.service;import com.apress.springrecipes.court.domain.Reservation;import java.util.List;public interface ReservationService &#123; public List&lt;Reservation&gt; query(String courtName);&#125; 在生产应用程序中，应该使用数据库持久性实现这个接口。但是为了简单起见，您可以将预订记录存储在一个列表中，并为测试目的硬编码多个预订。 123456789101112131415161718192021222324252627282930package com.apress.springrecipes.court.service;import com.apress.springrecipes.court.domain.Player;import com.apress.springrecipes.court.domain.Reservation;import com.apress.springrecipes.court.domain.SportType;import org.springframework.stereotype.Service;import java.time.LocalDate;import java.util.ArrayList;import java.util.List;import java.util.Objects;import java.util.stream.Collectors;@Servicepublic class ReservationServiceImpl implements ReservationService &#123; public static final SportType TENNIS = new SportType(1, \"Tennis\"); public static final SportType SOCCER = new SportType(2, \"Soccer\"); private final List&lt;Reservation&gt; reservations = new ArrayList&lt;&gt;(); public ReservationServiceImpl() &#123; reservations.add(new Reservation(\"Tennis #1\", LocalDate.of(2008, 1, 14), 16, new Player(\"Roger\", \"N/A\"), TENNIS)); reservations.add(new Reservation(\"Tennis #2\", LocalDate.of(2008, 1, 14), 20, new Player(\"James\", \"N/A\"), TENNIS)); &#125; @Override public List&lt;Reservation&gt; query(String courtName) &#123; return this.reservations.stream() .filter(reservation -&gt; Objects.equals(reservation.getCourtName(), courtName)).collect(Collectors.toList()); &#125;&#125; 设置一个Spring MVC应用程序接下来，您需要创建一个Spring MVC应用程序布局。通常，使用Spring MVC开发的web应用程序的设置方式与标准Java web应用程序相同，只是需要添加一些配置文件和特定于Spring MVC的必需库。Java EE规范定义了由web archive (WAR文件)组成的Java web应用程序的有效目录结构。例如，您必须提供一个web部署描述符(即:在WEB-INF根或一个或多个实现ServletContainerInitializer的类中。这个web应用程序的类文件和JAR文件应该分别放在WEB-INF/classes 和 WEB-INF/lib目录中。对于您的法庭预订系统，您将创建以下目录结构。注意，突出显示的文件是spring特定的配置文件。 注意，要使用Spring MVC开发web应用程序，您必须将所有普通的Spring依赖项(更多信息请参阅第1章)以及Spring web和Spring MVC依赖项添加到您的类路径中。如果您正在使用Maven，请向您的Maven项目添加以下依赖项: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 如果您使用的是gradle，请添加以下内容: 123dependencies &#123; compile \"org.springframework:spring-webmvc:$springVersion\"&#125; WEB-INF目录之外的文件可以通过url直接访问，因此CSS文件和图像文件必须放在那里。在使用Spring MVC时，JSP文件充当模板。它们被用于生成动态内容的框架读取，因此应该将JSP文件放到WEB-INF目录中，以防止直接访问它们。但是，有些应用服务器不允许WEB-INF内部的文件被web应用程序内部读取。在这种情况下，您只能将它们放在WEB-INF目录之外。 创建配置文件web部署描述符(web.xml或ServletContainerInitializer是Java web应用程序的基本配置文件)。在这个文件中，定义应用程序的servlet以及web请求如何映射到它们。对于Spring MVC应用程序，您必须只定义一个单独的DispatcherServlet实例，它充当Spring MVC的前端控制器，尽管您可以在需要时定义多个。在大型应用程序中，可以方便地使用多个DispatcherServlet实例。这允许将DispatcherServlet实例指定为特定的url，从而使代码管理更加容易，并允许各个团队成员在不妨碍彼此的情况下处理应用程序的逻辑。 12345678910111213141516171819202122package com.apress.springrecipes.court.web;import com.apress.springrecipes.court.config.CourtConfiguration;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.DispatcherServlet;import javax.servlet.ServletContainerInitializer;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletRegistration;import java.util.Set;public class CourtServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException &#123; AnnotationConfigWebApplicationContext applicationContext = new AnnotationConfigWebApplicationContext(); applicationContext.register(CourtConfiguration.class); DispatcherServlet dispatcherServlet = new DispatcherServlet(applicationContext); ServletRegistration.Dynamic courtRegistration = ctx.addServlet(\"court\", dispatcherServlet); courtRegistration.setLoadOnStartup(1); courtRegistration.addMapping(\"/\"); &#125;&#125; 在这个CourtServletContainerInitializer，您定义一个类型为DispatcherServlet的servlet。这是Spring MVC中的核心servlet类，它接收web请求并将它们分派给适当的处理程序。您将此servlet的名称设置为court，并使用斜杠(/)映射所有url，斜杠表示根目录。注意，可以将URL模式设置为更细粒度的模式。在较大的应用程序,在各种servlet之间委托模式可能更有意义，但为了简单起见，应用程序中的所有url都委托给单个法庭servlet。要检测到CourtServletContainerInitializer，还必须在META-INF/services目录中添加一个名为javax.servlet.ServletContainerInitializer的文件。文件的内容应该是CourtServletContainerInitializer的全名。此文件由servlet容器加载，用于引导应用程序。 1com.apress.springrecipes.court.web.CourtServletContainerInitializer 最后，添加CourtConfiguration类，它是一个简单的@Configuration类。 12345678package com.apress.springrecipes.court.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.apress.springrecipes.court\")public class CourtConfiguration &#123;&#125; 这定义了一个@ComponentScan注释，它将扫描com.apress.springrecipes.court包(和子包)并注册所有检测到的bean(在本例中，是ReservationServiceImpl和尚未创建的@Controller带注释类)。 创建Spring MVC控制器基于注解的控制器类可以是一个不实现特定接口或扩展特定基类的任意类。您可以使用@Controller注释它。可以在控制器中定义一个或多个处理程序方法来处理单个或多个操作。处理程序方法的签名足够灵活，可以接受一系列参数。@RequestMapping注释可以应用到类级别或方法级别。第一个映射策略是将特定的URL模式映射到控制器类，然后将特定的HTTP方法映射到每个处理程序方法。 123456789101112131415161718192021package com.apress.springrecipes.court.web;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.Date;@Controller@RequestMapping(\"/welcome\")public class WelcomeController &#123; @RequestMapping(method = RequestMethod.GET) public String welcome(Model model) &#123; Date today = new Date(); model.addAttribute(\"today\", today); return \"welcome\"; &#125;&#125; 该控制器创建一个java.util.Date对象来检索当前日期，然后将其作为属性添加到输入模型对象中，以便目标视图可以显示它。由于您已经激活了对com.apress.springrecipes.court 包的注释扫描，因此在部署时将检测控制器类的注释。@Controller注释将类定义为Spring MVC控制器。@RequestMapping注释更有趣，因为它包含属性，可以在类或处理程序方法级别声明。这个类中使用的第一个值—(“/welcome”)—用于指定控制器可操作的URL，这意味着/welcome URL上收到的任何请求都由WelcomeController类处理。一旦控制器类处理了请求，它将调用委托给控制器中声明的默认HTTP GET处理程序方法。这种行为的原因是URL上的每个初始请求都属于HTTP GET类型。因此，当控制器处理/welcome URL上的请求时，它随后委托给默认的HTTP GET处理程序方法进行处理。注释@RequestMapping(method = RequestMethod.GET)用于将welcome方法修饰为控制器的默认HTTP GET处理程序方法。值得一提的是，如果没有声明默认的HTTP GET处理程序方法，就会抛出ServletException。因此，对于Spring MVC控制器来说，至少有一个URL路由和默认的HTTP GET处理程序方法是很重要的。这种方法的另一种变体是在方法级别使用的@RequestMapping注释中声明value - url路由和默认的HTTP GET处理程序。下面说明本声明: 12345@Controllerpublic class WelcomeController &#123; @RequestMapping(value = \"/welcome\", method=RequestMethod.GET) public String welcome(Model model) &#123; ... &#125;&#125; 这个声明与前面的声明是等价的。值属性指示到其中的URL处理程序方法被映射，方法属性定义处理程序方法作为控制器的默认HTTP GET方法。最后，还有一些方便的注释，如@GetMapping、@PostMapping等等，以最小化配置。下面的映射将与前面提到的声明一样: 12345@Controllerpublic class WelcomeController &#123; @GetMapping(\"/welcome\") public String welcome(Model model) &#123; ... &#125;&#125; @GetMapping注释使类更短，可能更容易阅读。最后一个控制器演示了Spring MVC的基本原理。但是，典型的控制器可能调用后端服务进行业务处理。例如，您可以创建一个控制器来查询某一法院的保留如下: 123456789101112131415161718192021222324252627282930313233343536package com.apress.springrecipes.court.web;import com.apress.springrecipes.court.domain.Reservation;import com.apress.springrecipes.court.service.ReservationService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.util.List;@Controller@RequestMapping(\"/reservationQuery\")public class ReservationQueryController &#123; private final ReservationService reservationService; public ReservationQueryController(ReservationService reservationService) &#123; this.reservationService = reservationService; &#125; @GetMapping public void setupForm() &#123;&#125; @PostMapping public String sumbitForm(@RequestParam(\"courtName\") String courtName, Model model) &#123; List&lt;Reservation&gt; reservations = java.util.Collections.emptyList(); if (courtName != null) &#123; reservations = reservationService.query(courtName); &#125; model.addAttribute(\"reservations\", reservations); return \"reservationQuery\"; &#125;&#125; 如前所述，控制器然后查找默认的HTTP GET处理程序方法。由于公共void setupForm()方法为此分配了必要的@RequestMapping注释，因此它被称为next。与前面的默认HTTP GET处理程序方法不同，请注意，该方法没有输入参数，没有逻辑，并且具有一个空返回值。这意味着两件事。由于没有输入参数和逻辑，视图只显示实现模板(例如JSP)中硬编码的数据，因为没有控制器正在添加数据。如果返回值为空，则使用基于请求URL的默认视图名;因此，由于请求URL是/reservation查询，因此假设有一个名为reservationQuery的返回视图。 其余的处理程序方法使用@PostMapping注释进行修饰。乍一看，只有类级/reservation查询URL语句的两个处理程序方法可能会令人困惑，但实际上非常简单。当在/reservation查询URL上发出HTTP GET请求时，将调用一个方法;当HTTP POST请求在同一个URL上进行时，调用另一个。web应用程序中的大多数请求都是HTTP GET类型，而HTTP POST类型的请求通常是在用户提交HTML表单时发出的。因此，揭示更多应用程序的视图(我们将很快描述它)，在初始加载HTML表单时调用一个方法(即:，而另一个在提交HTML表单时被调用(例如。HTTP POST)。仔细查看HTTP POST默认处理程序方法，请注意这两个输入参数。首先注意@RequestParam(“courtName”)字符串courtName声明，用于提取名为courtName的请求参数。在这种情况下，HTTP POST请求以表单/reservation查询的形式出现?courtName = &lt;价值&gt;;此声明使方法中的变量courtName下的值可用。其次，请注意模型声明，它用于定义一个对象，以便将数据传递到返回的视图。处理程序方法执行的逻辑包括使用控制器的预订服务来使用courtName变量执行查询。从该查询获得的结果被分配给模型对象，模型对象稍后将可用于显示的返回视图。最后，注意该方法返回一个名为reservationQuery的视图。这个方法也可以返回void，就像默认的HTTP GET一样，并且由于请求URL而被分配给相同的reservationQuery默认视图。这两种方法都是相同的。现在您已经了解了Spring MVC控制器是如何构成的，现在是时候探索控制器的处理程序方法将其结果委托给哪些视图了。 创建JSP视图Spring MVC为不同的表示技术支持多种类型的视图。它们包括jsp、HTML、PDF、Excel工作表(XLS)、XML、JSON、Atom和RSS提要、JasperReports和其他第三方视图实现。在Spring MVC应用程序中，视图通常是用JSTL编写的JSP模板。当应用程序的web.xml文件中定义的dispatcherservlet接收处理程序返回的视图名称时，它将逻辑视图名称解析为视图实现以进行呈现。例如，可以在web应用程序上下文的CourtConfiguration中配置InternalResourceViewResolver bean，以便将视图名解析为/WEB-INF/jsp/目录中的JSP文件。 1234567@Beanpublic InternalResourceViewResolver internalResourceViewResolver() &#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix(\"/WEB-INF/jsp/\"); viewResolver.setSuffix(\".jsp\"); return viewResolver;&#125; 通过使用最后的配置，一个名为reservationQuery的逻辑视图被委托给位于/WEB-INF/jsp/reservationQuery.jsp的视图实现。了解了这一点，您可以为welcome控制器创建以下JSP模板，并将其命名为welcome.jsp并将其放在/WEB-INF/ jsp/目录中: 1234567891011&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Welcome to Court Reservation System&lt;/h2&gt;Today is &lt;fmt:formatDate value=\"$&#123;today&#125;\" pattern=\"yyyy-MM-dd\" /&gt;. &lt;/body&gt;&lt;/html&gt; 在这个JSP模板中，您使用JSTL中的fmt标记库将today模型属性格式化为yyyy-MM-dd模式。不要忘记在这个JSP模板的顶部包含fmt标记库定义。接下来，您可以为预订查询控制器创建另一个JSP模板，并将其命名为reservationQuery.jsp以匹配视图名称。 123456789101112131415161718192021222324252627282930313233&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Reservation Query&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\"&gt;Court Name&lt;input type=\"text\" name=\"courtName\" value=\"$&#123;courtName&#125;\" /&gt;&lt;input type=\"submit\" value=\"Query\" /&gt;&lt;/form&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Court Name&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Hour&lt;/th&gt; &lt;th&gt;Player&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;reservations&#125;\" var=\"reservation\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;reservation.courtName&#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"$&#123;reservation.date&#125;\" pattern=\"yyyy-MM-dd\" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;reservation.hour&#125;&lt;/td&gt; &lt;td&gt;$&#123;reservation.player.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 在这个JSP模板中，您包含了一个表单，用户可以输入他们想查询的法院名称，然后使用&lt;c:forEach&gt;标记来循环预订的模型属性来生成结果表。 部署Web应用程序在web应用程序的开发过程中，我们强烈建议安装本地Java EE应用服务器，该服务器附带用于测试和调试的web容器。为了便于配置和部署，我们选择了Apache Tomcat 8.5。x作为web容器。这个web容器的部署目录位于webapps目录中。默认情况下，Tomcat监听端口8080，并将应用程序部署到应用程序WAR的同名上下文。因此，如果您将应用程序打包到一个名为court的WAR中。war、欢迎控制器和预订查询控制器可以通过以下url访问: 12http://localhost:8080/court/welcomehttp://localhost:8080/court/reservationQuery 提示项目还可以使用app. run ../gradlew buildDocker创建一个Docker容器，以获得一个包含tomcat和应用程序的容器。然后，您可以启动一个Docker容器来测试应用程序(docker run -p 8080:8080 spring-recipes-4th/court-web). 1234567891011121314151617181920package com.apress.springrecipes.court.web;import com.apress.springrecipes.court.config.CourtConfiguration;import org.springframework.web.servlet.support. AbstractAnnotationConfigDispatcherServletInitializer;public class CourtWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return null; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[] &#123;CourtConfiguration.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[] &#123; \"/\"&#125;; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"开发范例代码大全","slug":"Spring/开发范例代码大全","permalink":"https://jigangduan.github.io/categories/Spring/开发范例代码大全/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"}]},{"title":"Spring 核心任务","slug":"Spring-5-Recipes-2","date":"2018-07-29T10:05:28.000Z","updated":"2020-07-25T02:57:18.165Z","comments":true,"path":"2018/07/29/Spring-5-Recipes-2/","link":"","permalink":"https://jigangduan.github.io/2018/07/29/Spring-5-Recipes-2/","excerpt":"","text":"在本章中，您将了解与Spring相关的核心任务。Spring框架的核心是Spring控制反转(Io0043)容器。IoC容器用于管理和配置普通的旧Java对象(POJOs)。因为Spring框架的主要诉求之一是使用pojo构建Java应用程序，Spring的许多核心任务都涉及到在IoC容器中管理和配置POJOs。 因此，无论您打算在web应用程序、企业集成或其他类型的项目中使用Spring框架，使用pojo和IoC容器是您需要采取的第一步。本章的大部分食谱涵盖了您将在本书中使用的任务，并在日常基础上开发Spring应用程序。 ■注意术语使用POJO bean交替使用实例在春天在这本书和文档。两者都引用从Java类创建的对象实例。此外，在本书和Spring文档中，术语组件可与POJO类互换使用。两者都引用创建对象实例的实际Java类。■提示下载的源代码组织使用Gradle(通过Gradle包装器)来构建菜谱应用程序。Gradle将负责加载所有必需的Java类和依赖项，并创建一个可执行的JAR文件。第1章描述了如何设置渐变工具。此外，如果一个菜谱演示了不止一种方法，那么源代码将使用罗马字母(例如Recipe_2_1_i、Recipe_2_1_ii、Recipe_2_1_iii等)进行分类。 要构建每个应用程序，请进入Recipe目录(例如Ch2/Recipe_2_1_i/)并执行./gradlew构建命令来编译源代码。编译源代码之后，将使用应用程序可执行文件创建一个build/libs子目录。然后可以从命令行运行应用程序JAR(例如，java -jar Recipe_2_1_i-4.0.0.jar)。 使用Java配置来配置POJOs问题您希望使用Spring的IoC容器管理带有注释的POJOs。 解决方案设计一个POJO类。接下来，使用@Configuration和@Bean注释创建一个Java配置类，以配置POJO实例值，或者使用@Component、@Repository、@Service或@Controller注释设置Java组件，以稍后创建POJO实例值。接下来，实例化Spring IoC容器，以使用注释扫描Java类。然后可以访问POJO实例或bean实例，将它们作为应用程序的一部分放在一起。 它是如何工作的假设您要开发一个应用程序来生成序列号，并且需要许多系列的序列号来满足不同的用途。每个序列都有自己的前缀、后缀和初始值。因此，您必须为应用程序创建和维护多个生成器实例。创建一个POJO类来使用Java配置创建bean。 按照要求，您创建了一个具有三个属性的SequenceGenerator类:前缀、后缀和initial。您还可以创建一个私有字段计数器来存储每个生成器的数值。每次在生成器实例上调用getSequence()方法时，都会得到最后一个序列号，其中包含前缀和后缀。 12345678910111213141516171819202122232425262728293031323334package com.apress.springrecipes.sequence;import java.util.concurrent.atomic.AtomicInteger;public class SequenceGenerator &#123; private String prefix; private String suffix; private int initial; private final AtomicInteger counter = new AtomicInteger(); public SequenceGenerator() &#123; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125; public void setInitial(int initial) &#123; this.initial = initial; &#125; public String getSequence() &#123; StringBuilder builder = new StringBuilder(); builder.append(prefix) .append(initial) .append(counter.getAndIncrement()) .append(suffix); return builder.toString(); &#125;&#125; 使用@Configuration和@Bean创建一个Java配置来创建POJOs要在Spring IoC容器中定义POJO类的实例，可以使用实例化值创建一个Java配置类。带有POJO或bean定义的Java配置类如下: 1234567891011121314151617package com.apress.springrecipes.sequence.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.apress.springrecipes.sequence.SequenceGenerator;@Configurationpublic class SequenceGeneratorConfiguration &#123; @Bean public SequenceGenerator sequenceGenerator() &#123; SequenceGenerator seqgen = new SequenceGenerator(); seqgen.setPrefix(\"30\"); seqgen.setSuffix(\"A\"); seqgen.setInitial(\"100000\"); return seqgen; &#125;&#125; 注意，SequenceGeneratorConfiguration类被@Configuration注释修饰;这告诉Spring它是一个配置类。当Spring遇到带有@Configuration注释的类时，它会在类中查找bean实例定义，这是用@Bean注释修饰的Java方法。Java方法创建并返回一个bean实例。 使用@Bean注释修饰的任何方法定义都会基于方法名生成一个bean名。或者，您可以使用name属性显式地在@Bean注释中指定bean名称。例如，@Bean(name=”mys1”)使bean可用作mys1。 ■注意如果您显式地指定bean名称,方法名被忽略的bean创建。 实例化Spring IoC容器以扫描注释您必须实例化Spring IoC容器来扫描包含注释的Java类。这样，Spring将检测@Configuration和@Bean注释，以便以后可以从IoC容器本身获得bean实例。 Spring提供了两种类型的IoC容器实现。最基本的一个叫做bean factory。更高级的称为应用程序上下文，它与bean工厂兼容。注意，这两种IoC容器的配置文件是相同的。 应用程序上下文提供比bean工厂更高级的特性，同时保持基本特性的兼容性。因此，我们强烈建议在每个应用程序中使用应用程序上下文，除非应用程序的资源受到限制(例如，当为一个applet运行Spring时，或者移动设备)。bean工厂的接口和应用程序上下文分别是BeanFactory和ApplicationContext。ApplicationContext接口是BeanFactory的一个子接口，用于维护兼容性。 由于ApplicationContext是一个接口，您必须实例化一个实现它。Spring有几个应用程序上下文实现;我们建议您使用AnnotationConfigApplicationContext，这是最新且最灵活的实现。通过这个类，您可以加载Java配置文件。 12ApplicationContext context = new AnnotationConfigApplicationContext (SequenceGeneratorConfiguration.class); 一旦实例化了应用程序上下文，对象引用(在本例中是上下文)提供了访问POJO实例或bean的入口点。 从IoC容器获取POJO实例或bean要从bean工厂或应用程序上下文获取已声明的bean，只需调用getBean()方法并传入惟一的bean名称。getBean()方法的返回类型是java.lang.Object，因此必须在使用它之前将它转换为它的实际类型。 12SequenceGenerator generator = (SequenceGenerator) context.getBean(\"sequenceGenerator\"); getBean()方法还支持另一种变体，您可以在其中提供bean类名，以避免强制转换。 1SequenceGenerator generator = context.getBean(\"sequenceGenerator\",SequenceGenerator.class); 如果只有一个bean，则可以省略该bean的名称。 1SequenceGenerator generator = context.getBean(SequenceGenerator.class); 一旦您达到这个步骤，您就可以使用POJO或bean，就像在Spring之外使用构造函数创建的任何对象一样。运行序列生成器应用程序的主类如下所示: 123456789101112131415package com.apress.springrecipes.sequence;import com.apress.springrecipes.sequence.config.SequenceGeneratorConfiguration;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(SequenceGeneratorConfiguration.class); SequenceGenerator generator = context.getBean(SequenceGenerator.class); System.out.println(generator.getSequence()); System.out.println(generator.getSequence()); &#125;&#125; 如果Java类路径中所有内容都可用(SequenceGenerator POJO类和Spring JAR)您应该看到以下输出，以及一些日志消息: 1230100000A30100001A 使用@Component注释创建POJO类，以使用DAO创建Beans到目前为止，Spring bean实例化是通过硬编码Java配置类中的值来完成的。这是简化Spring示例的首选方法。 然而，大多数应用程序的POJO实例化过程都是通过数据库或用户输入完成的。所以，现在是时候向前迈进，使用更真实的场景了。对于本节，我们将使用域类和数据访问对象(DAO)类来创建pojo。您仍然不需要设置数据库—实际上，您将在DAO类中硬编码值—但是熟悉这种类型的应用程序结构非常重要，因为它是大多数真实应用程序和未来菜谱的基础。 假设您被要求开发一个序列生成器应用程序，就像您在前一节中所做的那样。您需要稍微修改类结构以适应域类和DAO模式。首先，创建一个名为Sequence的域类，其中包含id、前缀和后缀属性。 1234567891011121314151617181920212223package com.apress.springrecipes.sequence;public class Sequence &#123; private final String id; private final String prefix; private final String suffix; public Sequence(String id, String prefix, String suffix) &#123; this.id = id; this.prefix = prefix; this.suffix = suffix; &#125; public String getId() &#123; return id; &#125; public String getPrefix() &#123; return prefix; &#125; public String getSuffix() &#123; return suffix; &#125;&#125; 然后，为DAO创建一个接口，这个接口负责从数据库访问数据。getSequence()方法通过ID从数据库表中加载POJO或Sequence对象，而getNextValue()方法检索特定数据库序列的下一个值。 123456package com.apress.springrecipes.sequence;public interface SequenceDao &#123; public Sequence getSequence(String sequenceId); public int getNextValue(String sequenceId);&#125; 在生产应用程序中，您将实现这个DAO接口来使用数据访问技术。但是为了简化这个示例，您将在映射中实现一个带有硬编码值的DAO来存储序列实例和值。 1234567891011121314151617181920212223242526package com.apress.springrecipes.sequence;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;import java.util.concurrent.atomic.AtomicInteger;@Component(\"sequenceDao\")public class SequenceDaoImpl implements SequenceDao &#123; private final Map&lt;String, Sequence&gt; sequences = new HashMap&lt;&gt;(); private final Map&lt;String, AtomicInteger&gt; values = new HashMap&lt;&gt;(); public SequenceDaoImpl() &#123; sequences.put(\"IT\", new Sequence(\"IT\", \"30\", \"A\")); values.put(\"IT\", new AtomicInteger(10000)); &#125; public Sequence getSequence(String sequenceId) &#123; return sequences.get(sequenceId); &#125; public int getNextValue(String sequenceId) &#123; AtomicInteger value = values.get(sequenceId); return value.getAndIncrement(); &#125;&#125; 观察SequenceDaoImpl类是如何用@Component(“sequenceDao”)注释来修饰的。这将标记类，以便Spring可以从中创建POJOs。@Component注释内的值定义了bean实例ID，在本例中为sequenceDao。如果@Component注释中没有提供bean值名，那么默认情况下，bean名被指定为大写的非限定类名。例如，对于SequenceDaoImpl类，默认的bean名称是SequenceDaoImpl。对getSequence方法的调用返回给定sequenceID的值。对getNextValue方法的调用基于给定的sequenceID的值创建一个新值，并返回新值。 POJOs在应用程序层中被分类。在Spring中，有三个层:persistence, service, 和 presentation。@Component是一个通用的注释，用于装饰用于Spring检测的POJOs，而@Repository、@Service和@Controller是@Component的专门化，用于处理与持久性、服务和表示层相关的pojo的更具体的情况。 如果您不确定POJO的用途，可以使用@Component注释来修饰它。但是，最好尽可能地使用专门化注释，因为这些注释提供了基于POJO目的的额外功能(例如，@Repository将异常包装为DataAccessExceptions，这使调试更容易)。 用过滤器实例化Spring IoC容器，以扫描注释在默认情况下，Spring检测所有使用@Configuration、@Bean、@Component、@Repository、@Service和@Controller注释的类，以及其他。您可以自定义扫描过程以包含一个或多个包含/排除过滤器。当Java包有几十或几百个类时，这是很有用的。对于某些Spring应用程序上下文，可能需要排除或包含带有特定注释的pojo。 ■警告扫描每个包都可以降低不必要的启动过程。 Spring支持四种类型的过滤器表达式。注释和可分配的类型是指定一个注释类型和一个用于过滤的类/接口。regex和aspectj类型允许您指定正则表达式和aspectj切入点表达式来匹配类。您还可以使用use-default-filters属性禁用默认过滤器。 例如，下面的组件扫描包括com.apress.springrecipe中的所有类。序列，其名称包含单词Dao或服务，并排除带有@Controller注释的类: 123456789101112@ComponentScan( includeFilters = &#123; @ComponentScan.Filter( type = FilterType.REGEX, pattern = &#123;\"com.apress.springrecipes.sequence.*Dao\", \"com.apress.springrecipes.sequence.*Service\"&#125;) &#125;, excludeFilters = &#123; @ComponentScan.Filter( type = FilterType.ANNOTATION, classes = &#123;org.springframework.stereotype.Controller.class&#125;) &#125;) 当应用包含过滤器时，可以检测所有名称包含“Dao”或“服务”的类。没有注释的类被自动检测。 从IoC容器获取POJO实例或bean然后，您可以使用以下主要类来测试前面的组件: 1234567891011121314package com.apress.springrecipes.sequence;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(\"com.apress.springrecipes.sequence\"); SequenceDao sequenceDao = context.getBean(SequenceDao.class); System.out.println(sequenceDao.getNextValue(\"IT\")); System.out.println(sequenceDao.getNextValue(\"IT\")); &#125;&#125; 通过调用构造函数创建POJOs问题 您希望通过调用其构造函数在Spring IoC容器中创建POJO实例或bean，这是创建bean的最常见和最直接的方式。这相当于使用新的操作符在Java中创建对象。 解决方案 使用构造函数或构造函数定义POJO类。接下来，创建一个Java配置类，用构造函数为Spring IoC容器配置POJO实例值。接下来，实例化Spring IoC容器，以使用注释扫描Java类。POJO实例或bean实例可以作为应用程序的一部分放在一起。 它是如何工作的 假设您要开发一个商店应用程序来在线销售产品。首先，创建Product POJO类，它有几个属性，比如产品名称和价格。由于您的商店中有许多类型的产品，所以您将产品类抽象为不同的产品子类扩展它。 123456789101112131415161718package com.apress.springrecipes.shop;public abstract class Product &#123; private String name; private double price; public Product() &#123;&#125; public Product(String name, double price) &#123; this.name = name; this.price = price; &#125; // Getters and Setters ... public String toString() &#123; return name + \" \" + price; &#125;&#125; 使用构造函数创建POJO类然后创建两个产品子类:电池和磁盘。它们每个都有自己的属性。 12345678910111213141516171819202122232425package com.apress.springrecipes.shop;public class Battery extends Product &#123; private boolean rechargeable; public Battery() &#123; super(); &#125; public Battery(String name, double price) &#123; super(name, price); &#125; // Getters and Setters ...&#125;package com.apress.springrecipes.shop;public class Disc extends Product &#123; private int capacity; public Disc() &#123; super(); &#125; public Disc(String name, double price) &#123; super(name, price); &#125; // Getters and Setters ...&#125; 为POJO创建一个Java配置要在Spring IoC容器中定义POJO类的实例，必须创建具有实例化值的Java配置类。通过调用构造函数生成具有POJO或bean定义的Java配置类应该如下所示: 1234567891011121314151617181920212223package com.apress.springrecipes.shop.config;import com.apress.springrecipes.shop.Battery;import com.apress.springrecipes.shop.Disc;import com.apress.springrecipes.shop.Product;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ShopConfiguration &#123; @Bean public Product aaa() &#123; Battery p1 = new Battery(\"AAA\", 2.5); p1.setRechargeable(true); return p1; &#125; @Bean public Product cdrw() &#123; Disc p2 = new Disc(\"CD-RW\", 1.5); p2.setCapacity(700); return p2; &#125;&#125; 接下来，通过从Spring IoC容器中检索产品，您可以编写以下主要类来测试产品: 123456789101112131415package com.apress.springrecipes.shop;import com.apress.springrecipes.shop.config.ShopConfiguration;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) throws Exception &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ShopConfiguration.class); Product aaa = context.getBean(\"aaa\", Product.class); Product cdrw = context.getBean(\"cdrw\", Product.class); System.out.println(aaa); System.out.println(cdrw); &#125;&#125; 使用POJO引用和自动连接与其他POJO交互问题 组成应用程序的POJO实例或bean通常需要相互协作才能完成应用程序的功能。您希望使用注释来使用POJO引用和自动连接。 解决方案 对于Java配置类中定义的POJO实例，可以使用标准Java代码在bean之间创建引用。要自动连接POJO引用，可以使用@Autowired注释标记字段、setter方法、构造函数，甚至任意方法。 它是如何工作的 首先，我们将介绍使用构造函数、字段和属性的不同的自动配线方法。最后，您将了解如何解决自动装配中的问题。 在Java配置类中引用POJOs当POJO实例在Java配置类中定义时(如2-1和2- POJO引用中所示)，使用起来很简单，因为一切都是Java代码。在下面的示例中，bean属性引用另一个bean: 123456789101112131415161718192021222324package com.apress.springrecipes.sequence.config;import com.apress.springrecipes.sequence.DatePrefixGenerator;import com.apress.springrecipes.sequence.SequenceGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class SequenceConfiguration &#123; @Bean public DatePrefixGenerator datePrefixGenerator() &#123; DatePrefixGenerator dpg = new DatePrefixGenerator(); dpg.setPattern(\"yyyyMMdd\"); return dpg; &#125; @Bean public SequenceGenerator sequenceGenerator() &#123; SequenceGenerator sequence = new SequenceGenerator(); sequence.setInitial(100000); sequence.setSuffix(\"A\"); sequence.setPrefixGenerator(datePrefixGenerator()); return sequence; &#125;&#125; SequenceGenerator类的前缀生成器属性是DatePrefixGenerator bean的实例。第一个bean声明创建一个DatePrefixGenerator POJO。按照约定，bean可以通过bean名称datePrefixGenerator(例如。方法名)。但是由于bean实例化逻辑也是一种标准的Java方法，因此通过进行标准Java调用也可以访问bean。当prefixGenerator属性被放置到第二个bean中时，通过settera对datePrefixGenerator()方法进行标准的Java调用，以引用bean。 使用@Autowired注释自动连接POJO字段接下来，让我们在2-1的第二部分介绍的DAO SequenceDaoImpl类的SequenceDao字段上使用自动布线。您将向应用程序添加一个服务类，以说明与DAO类的自动连接。一个服务类生成服务对象是另一个真实世界的应用程序的最佳实践,充当faç正面直接访问DAOs-instead访问DAOs。在内部，服务对象与DAO交互以处理序列生成请求。 1234567891011121314151617181920package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class SequenceService &#123; @Autowired private SequenceDao sequenceDao; public void setSequenceDao(SequenceDao sequenceDao) &#123; this.sequenceDao = sequenceDao; &#125; public String generate(String sequenceId) &#123; Sequence sequence = sequenceDao.getSequence(sequenceId); int value = sequenceDao.getNextValue(sequenceId); return sequence.getPrefix() + value + sequence.getSuffix(); &#125;&#125; SequenceService类使用@Component注释进行修饰。这允许Spring检测POJO。因为@Component注释没有名称，所以默认的bean名称是sequenceService，它基于类名。 SequenceService类的sequenceDao属性使用@Autowired注释进行修饰。这允许Spring使用sequenceDao bean(即SequenceDaoImpl类)。 @Autowired注解还可以应用于数组类型的属性，使Spring自动连接所有匹配的bean。例如，可以使用@Autowired对前缀生成器[]属性进行注释。然后，Spring将一次自动连接所有类型与前缀生成器兼容的bean。 123456789package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;public class SequenceGenerator &#123; @Autowired private PrefixGenerator[] prefixGenerators; ...&#125; 如果有多个bean的类型与IoC容器中定义的前缀生成器兼容，它们将自动添加到前缀生成器数组中。以类似的方式，您可以将@Autowired注释应用于类型安全的集合。Spring可以读取此集合的类型信息，并自动连接类型兼容的所有bean。 123456789package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;public class SequenceGenerator &#123; @Autowired private List&lt;PrefixGenerator&gt; prefixGenerators; ...&#125; 如果Spring注意到@Autowired注释被应用到类型安全的 java.util.Map，字符串为键，它将把兼容类型的所有bean(以bean名称作为键)添加到这个map中。 12345678package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;public class SequenceGenerator &#123; @Autowired private Map&lt;String, PrefixGenerator&gt; prefixGenerators; ...&#125; 使用@Autowired注解的Autowire POJO方法和构造函数，并可选择自动配线@Autowired注解也可以直接应用于POJO的setter方法。例如，可以使用@Autowired对prefixGenerator属性的setter方法进行注释。然后，Spring尝试连接类型与前缀生成器兼容的bean。 123456789101112package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;public class SequenceGenerator &#123; ... @Autowired public void setPrefixGenerator(PrefixGenerator prefixGenerator) &#123; this.prefixGenerator = prefixGenerator; &#125;&#125; 默认情况下，所有带有@Autowired的属性都是必需的。当Spring无法找到匹配的bean时，它将抛出异常。如果您希望某个属性是可选的，那么将@Autowired的required属性设置为false。然后，当Spring无法找到匹配的bean时，它将保留此属性未设置。 1234567891011package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;public class SequenceGenerator &#123; ... @Autowired(required=false) public void setPrefixGenerator(PrefixGenerator prefixGenerator) &#123; this.prefixGenerator = prefixGenerator; &#125;&#125; 您还可以将@Autowired注释应用于具有任意名称和任意数量参数的方法;在这种情况下，Spring尝试用兼容的类型为每一个方法参数连接一个bean。 12345678910package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;public class SequenceGenerator &#123; ... @Autowired public void myOwnCustomInjectionName(PrefixGenerator prefixGenerator) &#123; this.prefixGenerator = prefixGenerator; &#125;&#125; 最后，还可以将@Autowired注释应用到希望用于自动连接的构造函数。构造函数可以有任意数量的参数，Spring将尝试为每个构造函数参数连接具有兼容类型的bean。 123456789101112131415@Servicepublic class SequenceService &#123; private final SequenceDao sequenceDao; @Autowired public SequenceService(SequenceDao sequenceDao) &#123; this.sequenceDao=sequenceDao; &#125; public String generate(String sequenceId) &#123; Sequence sequence = sequenceDao.getSequence(sequenceId); int value = sequenceDao.getNextValue(sequenceId); return sequence.getPrefix() + value + sequence.getSuffix(); &#125;&#125; 用注释解决自动连接的模糊性默认情况下，当IoC容器中有多个具有兼容类型的bean，并且属性不是组类型(如数组、列表、映射)时，按类型自动连接将不起作用。但是，如果有多个相同类型的bean: @Primary注释和@Qualifier注释，则有两个方法可以根据类型自动连接。 用@Primary注释解决自动连接的歧义Spring允许您通过使用@Primary注释装饰候选bean，按类型指定候选bean。@Primary注释在多个候选对象符合自动连接单值依赖项的条件时，为bean提供优先级。 1234567891011121314package com.apress.springrecipes.sequence;...import org.springframework.stereotype.Component;import org.springframework.context.annotation.Primary;@Component@Primarypublic class DatePrefixGenerator implements PrefixGenerator &#123; public String getPrefix() &#123; DateFormat formatter = new SimpleDateFormat(\"yyyyMMdd\"); return formatter.format(new Date()); &#125;&#125; 注意，前面的POJO实现了PrefixGenerator接口，并使用@Primary注释进行修饰。如果您尝试使用PrefixGenerator类型自动连接一个bean，即使Spring有多个具有相同PrefixGenerator类型的bean实例，Spring也会自动连接DatePrefixGenerator，因为它使用@Primary注释进行标记。 用@Qualifier注解解决自动连接的歧义Spring还允许您通过在@Qualifier注释中提供其名称来按类型指定候选bean。 1234567891011package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;public class SequenceGenerator &#123; @Autowired @Qualifier(\"datePrefixGenerator\") private PrefixGenerator prefixGenerator; ...&#125; 完成此操作之后，Spring尝试在IoC容器中查找具有该名称的bean，并将其连接到属性中。@Qualifier注释也可以应用于自动连接的方法参数。 12345678910111213package com.apress.springrecipes.sequence;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;public class SequenceGenerator &#123; ... @Autowired public void myOwnCustomInjectionName( @Qualifier(\"datePrefixGenerator\") PrefixGenerator prefixGenerator) &#123; this.prefixGenerator = prefixGenerator; &#125;&#125; 如果希望按名称自动连接bean属性，可以使用下一个菜谱中描述的JSR-250 @Resource注释一个setter方法、构造函数或字段。 解析来自多个位置的POJO引用随着应用程序的增长，在单个Java配置类中管理每个POJO会变得很困难。 一个常见的实践是，根据pojo的功能将它们分成多个Java配置类。当您创建多个Java配置类时，获取在不同类中定义的引用和自动连接pojo并不像在单个Java配置类中一样简单。 一种方法是使用每个Java配置类的位置初始化应用程序上下文。通过这种方式，每个Java配置类的pojo都被加载到上下文和引用中，pojo之间的自动连接是可能的。 12AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext (PrefixConfiguration.class, SequenceGeneratorConfiguration.class); 另一种选择是使用@Import注释，因此Spring使来自一个配置文件的pojo在另一个配置文件中可用。 12345678910111213141516171819202122package com.apress.springrecipes.sequence.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Import;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Configuration;import com.apress.springrecipes.sequence.SequenceGenerator;import com.apress.springrecipes.sequence.PrefixGenerator;@Configuration @Import(PrefixConfiguration.class)public class SequenceConfiguration &#123; @Value(\"#&#123;datePrefixGenerator&#125;\") private PrefixGenerator prefixGenerator; @Bean public SequenceGenerator sequenceGenerator() &#123; SequenceGenerator sequence= new SequenceGenerator(); sequence.setInitial(100000); sequence.setSuffix(\"A\"); sequence.setPrefixGenerator(prefixGenerator); return sequence; &#125;&#125; sequenceGenerator bean要求您设置一个prefixGenerator bean。但是请注意，Java配置类中没有定义前缀生成器bean。prefixGenerator bean在一个名为PrefixConfiguration的单独Java配置类中定义。使用@Import(PrefixConfiguration.class)注释，Spring将Java配置类中的所有pojo都带到当前配置类的范围中。在作用域中使用来自PrefixConfiguration的pojo，您可以使用@Value注释和SpEL将名为datePrefixGenerator的bean注入到prefixGenerator字段中。注入bean之后，可以使用它为sequenceGenerator bean设置一个prefixGenerator bean。 使用@Resource和@Inject注解来连接POJOs问题 您希望使用Java标准@Resource和@Inject注解来通过自动连接引用pojo，而不是使用特定于spring的@Autowired注解。 解决方案 JSR-250，或Java平台的通用注释，定义了@Resource注释，以名称自动连接POJO引用。JSR-330，或用于注入的标准注解，定义了@Inject注解，按类型来连接POJO引用。 它是如何工作的 前面的菜谱中描述的@Autowired注释属于Spring框架，具体到org.springframework.beans.factory。注释包。这意味着它只能在Spring框架的上下文中使用。在Spring添加了对@Autowired注释的支持之后，Java语言标准化了各种注释，以实现@Autowired注释的相同目的。这些注释是@Resource，属于javax。注释包和@Inject，属于javax.inject package。 使用@Resource注释自动连接POJOs默认情况下，@Resource注释的工作方式类似于Spring的@Autowired注释，并尝试通过类型来自动连接。例如，下面的POJO属性被修饰为@Resource注释，因此Spring尝试定位匹配PrefixGenerator类型的POJO。 123456789package com.apress.springrecipes.sequence;import javax.annotation.Resource;public class SequenceGenerator &#123; @Resource private PrefixGenerator prefixGenerator; ...&#125; 但是，与@Autowired注释不同，它需要@Qualifier注释来按名称自动连接POJO，如果存在多个相同类型的POJO类型，则可以消除@Resource歧义。本质上，@Resource注释提供了与将@Autowired注释和@Qualifier注释放在一起相同的功能。 使用@Inject注释的Autowire POJOs另外，@Inject注释尝试按类型自动连接，比如@Resource和@Autowired注释。例如，下面的POJO属性被修饰为@Inject注释，因此Spring尝试定位与PrefixGenerator类型匹配的POJO: 123456789package com.apress.springrecipes.sequence;import javax.inject.Inject;public class SequenceGenerator &#123; @Inject private PrefixGenerator prefixGenerator; ...&#125; 但是，就像@Resource和@Autowired注解一样，如果存在多个相同类型的POJO类型，则必须使用不同的方法来匹配POJO的名称或避免歧义。使用@Inject注释进行名称自动连接的第一步是创建自定义注释，以标识POJO注入类和POJO注入点。 123456789101112131415package com.apress.springrecipes.sequence;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.inject.Qualifier;@Qualifier@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.PARAMETER&#125;)@Documented@Retention(RetentionPolicy.RUNTIME)public @interface DatePrefixAnnotation &#123;&#125; 注意，自定义注释使用了@Qualifier注释。这个注释与Spring的@Qualifier注释使用的注释不同，因为最后一个类与@Inject注释属于同一个Java包。(javax.inject)。 一旦完成了自定义注释，就需要装饰生成bean实例的POJO注入类，在本例中是DatePrefixGenerator类。 123456package com.apress.springrecipes.sequence;...@DatePrefixAnnotationpublic class DatePrefixGenerator implements PrefixGenerator &#123; ...&#125; 最后，POJO属性或注入点使用相同的自定义注释来限定POJO并消除任何歧义。 123456789package com.apress.springrecipes.sequence;import javax.inject.Inject;public class SequenceGenerator &#123; @Inject @DataPrefixAnnotation private PrefixGenerator prefixGenerator; ...&#125; 正如您在菜谱2-3和2-4中看到的，@Autowired、@Resource和@Inject这三个注解可以实现相同的结果。@Autowired注释是基于spring的解决方案，而@Resource和@Inject注释是Java标准(即:JSR)解决方案。如果要进行基于名称的自动连接，@Resource注释提供了最简单的语法。对于按类类型自动连接，这三个注释都很容易使用，因为这三个注释都需要一个注释。 使用@Scope注释设置POJO的范围问题 当您使用像@Component这样的注释声明POJO实例时，您实际上是在为bean创建定义一个模板，而不是一个实际的bean实例。当getBean()方法请求bean或从其他bean引用时，Spring根据bean作用域决定应该返回哪个bean实例。有时，您必须为bean设置适当的范围，而不是默认的范围。 解决方案 使用@Scope注释设置bean的范围。默认情况下，Spring为IoC容器中声明的每个bean创建一个实例，这个实例在整个IoC容器的范围内共享。对于所有后续的getBean()调用和bean引用，将返回这个惟一的bean实例。这个范围称为singleton，它是所有bean的默认范围。表2-1列出了Spring中所有有效的bean作用域。 Scope 描述 singleton 每个Spring IoC容器创建一个bean实例 prototype 每次请求时创建一个新的bean实例 request 每个HTTP请求创建一个bean实例;仅在web应用程序的上下文中有效 session 每个HTTP会话创建一个单独的bean实例;仅在web应用程序的上下文中有效 globalSession 每个全局HTTP会话创建一个bean实例;仅在门户应用程序的上下文中有效 它是如何工作的 为了演示bean作用域的概念，让我们考虑购物应用程序中的购物车示例。首先，创建ShoppingCart类如下: 12345678910111213package com.apress.springrecipes.shop;...@Componentpublic class ShoppingCart &#123; private List&lt;Product&gt; items = new ArrayList&lt;&gt;(); public void addItem(Product item) &#123; items.add(item); &#125; public List&lt;Product&gt; getItems() &#123; return items; &#125;&#125; 然后，在Java配置文件中声明一些产品bean，以便稍后将它们添加到购物车中。 123456789101112131415161718192021222324252627282930313233package com.apress.springrecipes.shop.config;import com.apress.springrecipes.shop.Battery;import com.apress.springrecipes.shop.Disc;import com.apress.springrecipes.shop.Product;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.apress.springrecipes.shop\")public class ShopConfiguration &#123; @Bean public Product aaa() &#123; Battery p1 = new Battery(); p1.setName(\"AAA\"); p1.setPrice(2.5); p1.setRechargeable(true); return p1; &#125; @Bean public Product cdrw() &#123; Disc p2 = new Disc(\"CD-RW\", 1.5); p2.setCapacity(700); return p2; &#125; @Bean public Product dvdrw() &#123; Disc p2 = new Disc(\"DVD-RW\", 3.0); p2.setCapacity(700); return p2; &#125;&#125; 一旦您这样做了，您就可以通过添加一些产品来定义一个主类来测试购物车。假设有两个客户同时在您的商店中导航。第一个通过getBean()方法获得购物车并向其中添加两个产品。然后，第二个客户还通过getBean()方法获得一个购物车，并向其中添加另一个产品。 12345678910111213141516171819202122package com.apress.springrecipes.shop;import com.apress.springrecipes.shop.config.ShopConfiguration;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) throws Exception &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ShopConfiguration.class); Product aaa = context.getBean(\"aaa\", Product.class); Product cdrw = context.getBean(\"cdrw\", Product.class); Product dvdrw = context.getBean(\"dvdrw\", Product.class); ShoppingCart cart1 = context.getBean(\"shoppingCart\", ShoppingCart.class); cart1.addItem(aaa); cart1.addItem(cdrw); System.out.println(\"Shopping cart 1 contains \" + cart1.getItems()); ShoppingCart cart2 = context.getBean(\"shoppingCart\", ShoppingCart.class); cart2.addItem(dvdrw); System.out.println(\"Shopping cart 2 contains \" + cart2.getItems()); &#125;&#125; 由于前面的bean声明，您可以看到两个客户获得了相同的购物车实例。 12Shopping cart 1 contains [AAA 2.5, CD-RW 1.5]Shopping cart 2 contains [AAA 2.5, CD-RW 1.5, DVD-RW 3.0] 这是因为Spring的默认bean作用域是单例的，这意味着Spring每个IoC容器只创建一个购物车实例。在您的shop应用程序中，当调用getBean()方法时，您希望每个客户获得不同的购物车实例。为了确保这种行为，需要将shoppingCart bean的范围设置为prototype。然后Spring为每个getBean()方法调用创建一个新的bean实例。 1234567package com.apress.springrecipes.shop;...import org.springframework.stereotype.Component;import org.springframework.context.annotation.Scope;@Component@Scope(\"prototype\")public class ShoppingCart &#123; ... &#125; 现在，如果您再次运行Main类，您可以看到两个客户获得不同的购物车实例。 12Shopping cart 1 contains [AAA 2.5, CD-RW 1.5]Shopping cart 2 contains [DVD-RW 3.0] 使用来自外部资源的数据(文本文件、XML文件、属性文件或图像文件)问题 有时应用程序需要从不同的位置(例如文件系统、类路径或URL)读取外部资源(例如，文本文件、XML文件、属性文件或图像文件)。通常，您必须处理从不同位置加载资源的不同api。 解决方案 Spring提供了@PropertySource注释作为加载.properties文件内容的工具(例如，键-值对)来设置bean属性。Spring还有一个资源加载器机制，该机制提供一个统一的资源接口，用于通过资源路径检索任何类型的外部资源。可以为该路径指定不同的前缀，以便使用@Value注释从不同位置加载资源。要从文件系统加载资源，可以使用文件前缀。要从类路径中加载资源，可以使用类路径前缀。还可以在资源路径中指定URL。 它是如何工作的 读取属性文件的内容(例如要设置bean属性，可以使用带有PropertySourcesPlaceholderConfigurer的Spring的@PropertySource注释。如果希望读取任何文件的内容，可以使用用@Value注释修饰的Spring的资源机制。 使用属性文件数据设置POJO实例化值让我们假设您希望在属性文件中访问一系列值来设置bean属性。通常，这可以是数据库的配置属性或由键值组成的其他应用程序值。例如，取存储在名为discounts.properties文件中的下列关键值: 123specialcustomer.discount=0.1summer.discount=0.15endofyear.discount=0.2 要阅读国际化(i18n)目的的属性文件，请参阅下一个菜谱。提供折扣的内容。属性文件可用于设置其他bean，您可以使用@PropertySource注释将键值转换为Java配置类中的bean。 123456789101112131415161718192021222324252627282930package com.apress.springrecipes.shop.config;import com.apress.springrecipes.shop.Battery;import com.apress.springrecipes.shop.Disc;import com.apress.springrecipes.shop.Product;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;@Configuration @PropertySource(\"classpath:discounts.properties\")@ComponentScan(\"com.apress.springrecipes.shop\")public class ShopConfiguration &#123; @Value(\"$&#123;endofyear.discount:0&#125;\") private double specialEndofyearDiscountField; @Bean public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; @Bean public Product dvdrw() &#123; Disc p2 = new Disc(\"DVD-RW\", 3.0, specialEndofyearDiscountField); p2.setCapacity(700); return p2; &#125;&#125; 您可以定义一个带有类路径值:折扣的@PropertySource注释。属性来修饰Java配置类。类路径:前缀告诉Spring查找折扣。Java类路径中的属性文件。定义了@PropertySource注释以加载属性文件之后，还需要使用@Bean注释定义PropertySourcePlaceholderConfigurer bean。Spring会自动连接@PropertySource折扣。属性文件，使其属性可作为bean属性访问。接下来，您需要定义Java变量，以便从折扣折扣中获取值。属性文件。要使用这些值定义Java变量值，可以使用带有占位符表达式的@Value注释。语法是@Value(&quot;${key:default_value}&quot;)。搜索所有加载的应用程序属性中的键值。如果在属性文件中找到了匹配的键=值，则将相应的值分配给bean属性。如果加载的应用程序属性中没有找到匹配的key=value，那么default_value(即，在${key:)之后分配给bean属性。在用折扣值设置Java变量之后，您可以使用它为bean的折扣属性设置bean实例。如果您希望将属性文件数据用于与设置bean属性不同的目的，那么您应该使用Spring的资源机制，后面将对此进行描述。 在POJO中使用来自任何外部资源文件的数据假设您想在应用程序启动时显示一个横幅。banner由以下字符组成，存储在一个名为banner.txt的文本文件中。这个文件可以放在应用程序的类路径中。 123************************** Welcome to My Shop! ************************** 接下来，让我们编写一个BannerLoader POJO类来加载横幅并将其输出到控制台。 123456789101112131415161718192021222324package com.apress.springrecipes.shop;import org.springframework.core.io.Resource;...import javax.annotation.PostConstruct;public class BannerLoader &#123; private Resource banner; public void setBanner(Resource banner) &#123; this.banner = banner; &#125; @PostConstruct public void showBanner() throws IOException &#123; InputStream in = banner.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); while (true) &#123; String line = reader.readLine(); if (line == null) break; System.out.println(line); &#125; reader.close(); &#125;&#125; 注意，POJO banner字段是一个Spring资源类型。当创建bean实例时，将通过setter注入填充字段值——稍后进行解释。showBanner()方法调用getInputStream()方法来从资源字段检索输入流。一旦有了InputStream，就可以使用标准的Java文件操作类。在本例中，文件内容是逐行读取的，带有BufferedReader和输出到控制台。 还请注意showBanner()方法使用@PostConstruct注释进行装饰。因为您希望在启动时显示banner，所以使用这个注释告诉Spring在创建后自动调用方法。这保证了showBanner()方法是应用程序运行的第一个方法之一，因此确保了横幅出现在开始。接下来，需要将POJO BannerLoader初始化为实例。此外，还需要注入BannerLoader的banner字段。因此，让我们为这些任务创建一个Java配置类。 123456789101112131415161718@Configuration @PropertySource(\"classpath:discounts.properties\")@ComponentScan(\"com.apress.springrecipes.shop\")public class ShopConfiguration &#123; @Value(\"classpath:banner.txt\") private Resource banner; @Bean public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; @Bean public BannerLoader bannerLoader() &#123; BannerLoader bl = new BannerLoader(); bl.setBanner(banner); return bl; &#125;&#125; 查看如何使用@Value(“classpath:banner.txt”)注释修饰banner属性。这告诉春天去搜索横幅。在类路径中插入txt文件。Spring使用预先注册的属性编辑器ResourceEditor将文件定义转换为资源对象，然后将其注入到bean中。注入banner属性后，通过setter注入将其分配给BannerLoader bean实例。由于banner文件位于Java类路径中，资源路径从classpath: prefix开始。前面的资源路径指定文件系统的相对路径中的资源。也可以指定绝对路径。 file:c:/shop/banner.txt 当资源位于Java的类路径中时，必须使用类路径前缀。如果没有显示路径信息，它将从类路径的根加载。 classpath:banner.txt 如果资源位于特定的包中，您可以指定来自类路径根的绝对路径。 classpath:com/apress/springrecipes/shop/banner.txt 除了支持从文件系统路径或类路径加载外，还可以通过指定URL来加载资源。 http://springrecipes.apress.com/shop/banner.txt 由于bean类在showBanner()方法上使用@PostConstruct注释，所以banner在IoC容器建立时被发送到输出。正因为如此，没有必要去修补应用程序的上下文或显式调用bean来输出横幅。然而，有时需要访问外部资源来与应用程序的上下文进行交互。现在，假设您希望在应用程序的末尾显示一个图例。图例包含了折扣中先前描述的折扣。属性文件。要访问属性文件的内容，还可以利用Spring的资源机制。接下来，让我们使用Spring的资源机制，但这一次是直接在应用程序的主类中，在应用程序完成时输出一个图例。 12345678910111213import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.support.PropertiesLoaderUtils;......public class Main &#123; public static void main(String[] args) throws Exception &#123; ... Resource resource = new ClassPathResource(\"discounts.properties\"); Properties props = PropertiesLoaderUtils.loadProperties(resource); System.out.println(\"And don't forget our discounts!\"); System.out.println(props); &#125;&#125; Spring的ClassPathResource类用于访问discounts.properties文件，该文件将文件的内容转换为资源对象。接下来，资源对象被处理成具有Spring的PropertiesLoaderUtils类的属性对象。最后，属性对象的内容作为应用程序的最终输出发送到控制台。因为图例文件(即在Java类路径中，资源通过Spring的ClassPathResource类来访问。如果外部资源位于文件系统路径中，则资源将被加载到Spring的文件系统资源中。 1Resource resource = new FileSystemResource(\"c:/shop/banner.txt\") 如果外部资源位于URL中，则资源将被加载到Spring的UrlResource中。 1Resource resource = new UrlResource(\"http://www.apress.com/\") 解析属性文件中不同地区的I18N文本消息问题 您希望应用程序通过注释支持国际化。 解决方案 MessageSource是一个接口，定义了用于解析资源包中的消息的几种方法。ResourceBundleMessageSource是最常见的MessageSource实现，它从不同的地区解决来自资源包的消息。在实现ResourceBundleMessageSource POJO之后，您可以在Java配置文件中使用@Bean注释，以使应用程序中的i18n数据可用。 它是如何工作的 例如，在美国为英语创建一个名为messages_en_US.properties的资源包。资源包是从类路径的根加载的，所以要确保它在Java类路径中可用。在文件中放置以下键值: 12alert.checkout=A shopping cart has been checked out.alert.inventory.checkout=A shopping cart with &#123;0&#125; has been checked out at &#123;1&#125;. 为了解析资源包中的消息，让我们使用ReloadableResourceBundleMessageSource bean的实例创建一个Java配置文件。 12345678910111213141516package com.apress.springrecipes.shop.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ReloadableResourceBundleMessageSource;@Configurationpublic class ShopConfiguration &#123; @Bean public ReloadableResourceBundleMessageSource messageSource() &#123; ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasenames(\"classpath:messages\"); messageSource.setCacheSeconds(1); return messageSource; &#125;&#125; bean实例必须有应用程序上下文的名称messageSource来检测它。在bean定义中，您通过setBasenames方法声明一个字符串列表，以便为ResourceBundleMessageSource定位bundle。在这种情况下，您只需指定默认约定来查找位于以消息开头的Java类路径中的文件。此外，setCacheSeconds方法将缓存设置为1秒，以避免读取过时的消息。注意，刷新尝试在重新加载属性文件之前首先检查属性文件的最后修改时间戳，因此如果文件没有更改，则可以将setCacheSeconds间隔设置得相当低，因为刷新尝试实际上并没有重新加载。对于这个MessageSource定义，如果您查找美国语言环境的文本消息(其首选语言是英语)，则查找messages_en_US资源包。属性被认为是第一个。如果没有这样的资源束，或者无法找到消息，那么messages_en。考虑与语言匹配的属性文件。如果仍然找不到资源包，则默认消息。属性选择所有地区。有关资源包加载的更多信息，可以参考java.util.ResourceBundle类的Javadoc。接下来，您可以配置应用程序上下文来使用getMessage()方法解析消息。第一个参数是消息对应的键，第三个参数是目标语言环境。 123456789101112131415161718package com.apress.springrecipes.shop;import com.apress.springrecipes.shop.config.ShopConfiguration;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import java.util.Date;import java.util.Locale;public class Main &#123; public static void main(String[] args) throws Exception &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ShopConfiguration.class); String alert = context.getMessage(\"alert.checkout\", null, Locale.US); String alert_inventory = context.getMessage(\"alert.inventory.checkout\", new Object[] &#123;\"[DVD-RW 3.0]\", new Date()&#125;, Locale.US); System.out.println(\"The I18N message for alert.checkout is: \" + alert); System.out.println(\"The I18N message for alert.inventory.checkout is: \" + alert_inventory); &#125;&#125; getMessage()方法的第二个参数是消息参数数组。在第一个字符串语句中，值为null，在第二个字符串语句中，使用一个对象数组来填充消息参数。在Main类中，可以解析文本消息，因为可以直接访问应用程序上下文。但是要让bean解析文本消息，您必须将MessageSource实现注入到需要解析文本消息的bean中。让我们为购物应用程序实现一个出纳员类，它演示了如何解析消息。 123456789101112131415161718package com.apress.springrecipes.shop;...@Componentpublic class Cashier &#123; @Autowired private MessageSource messageSource; public void setMessageSource(MessageSource messageSource) &#123; this.messageSource = messageSource; &#125; public void checkout(ShoppingCart cart) throws IOException &#123; String alert = messageSource.getMessage(\"alert.inventory.checkout\", new Object[] &#123; cart.getItems(), new Date() &#125;, Locale.US); System.out.println(alert); &#125;&#125; 注意，POJO messageSource字段是Spring messageSource类型。字段值用@Autowired注释修饰，因此在创建bean实例时通过注入填充。然后，checkout方法可以访问messageSource字段，该字段允许bean访问getMessage方法，以便基于i18n标准访问文本消息。 使用注释定制POJO初始化和销毁问题 有些pojo在使用前必须执行某些类型的初始化任务。这些任务可以包括打开文件、打开网络/数据库连接、分配内存等。此外，这些pojo必须在生命周期结束时执行相应的销毁任务。因此，有时需要在Spring IoC容器中定制bean的初始化和销毁。 解决方案 Spring可以通过在Java配置类中设置@Bean定义的initMethod和驱逐舰方法属性来识别初始化和销毁回调方法。或者，如果POJO方法分别用@PostConstruct和@PreDestroy注解修饰，Spring也可以识别初始化和销毁回调方法。Spring还可以使用@Lazy注释将bean的创建延迟到需要的时候(一个称为惰性初始化的过程)。Spring还可以使用@DependsOn注释确保某些bean的初始化。 它是如何工作的 定义在使用@Bean初始化和销毁POJO之前要运行的方法。让我们以购物应用程序为例，考虑一个涉及checkout函数的示例。让我们修改出纳员类，将购物车的产品和结帐时间记录到文本文件中。 123456789101112131415161718192021222324252627282930313233343536373839package com.apress.springrecipes.shop;import java.io.*;import java.util.Date;public class Cashier &#123; private String fileName; private String path; private BufferedWriter writer; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; public void setPath(String path) &#123; this.path = path; &#125; public void openFile() throws IOException &#123; File targetDir = new File(path); if (!targetDir.exists()) &#123; targetDir.mkdir(); &#125; File checkoutFile = new File(path, fileName + \".txt\"); if (!checkoutFile.exists()) &#123; checkoutFile.createNewFile(); &#125; writer = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(checkoutFile, true))); &#125; public void checkout(ShoppingCart cart) throws IOException &#123; writer.write(new Date() + \"\\t\" + cart.getItems() + \"\\r\\n\"); writer.flush(); &#125; public void closeFile() throws IOException &#123; writer.close(); &#125;&#125; 在出纳员类中，openFile()方法首先验证要写入数据的目标目录和文件是否存在。然后在指定的系统路径中打开文本文件并将其分配给writer字段。然后每次调用checkout()方法时，将日期和购物车项目附加到文本文件中。最后，closeFile()方法关闭文件，释放其系统资源。接下来，让我们研究如何在Java config类中设置这个bean定义，以便在创建bean之前执行openFile()方法，在销毁bean之前执行closeFile()方法。 1234567891011@Configurationpublic class ShopConfiguration &#123; @Bean(initMethod = \"openFile\", destroyMethod = \"closeFile\") public Cashier cashier() &#123; String path = System.getProperty(\"java.io.tmpdir\") + \"/cashier\"; Cashier c1 = new Cashier(); c1.setFileName(\"checkout\"); c1.setPath(path); return c1; &#125;&#125; 注意，POJO的初始化和销毁任务是使用@Bean注释的initMethod和驱逐舰方法属性定义的。通过在bean声明中设置这两个属性，当创建出纳类时，它首先触发openFile()方法，验证目标目录和文件是否存在，以及打开文件以添加记录。当bean被销毁时，它触发closeFile()方法，确保关闭文件引用以释放系统资源。 定义使用@PostConstruct和@PreDestroy在POJO初始化和销毁之前运行的方法如果在Java配置类之外定义POJO实例(例如，使用@Component注释)，另一种替代方法是直接在POJO类中使用@PostConstruct和@PreDestroy注解。 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class Cashier &#123; @Value(\"checkout\") private String fileName; @Value(\"c:/Windows/Temp/cashier\") private String path; private BufferedWriter writer; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; public void setPath(String path) &#123; this.path = path; &#125; @PostConstruct public void openFile() throws IOException &#123; File targetDir = new File(path); if (!targetDir.exists()) &#123; targetDir.mkdir(); &#125; File checkoutFile = new File(path, fileName + \".txt\"); if(!checkoutFile.exists()) &#123; checkoutFile.createNewFile(); &#125; writer = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(checkoutFile, true))); &#125; public void checkout(ShoppingCart cart) throws IOException &#123; writer.write(new Date() + \"\\t\" +cart.getItems() + \"\\r\\n\"); writer.flush(); &#125; @PreDestroy public void closeFile() throws IOException &#123; writer.close(); &#125;&#125; @Component注释告诉Spring管理POJO，就像在以前的菜谱中使用的那样。POJO字段的两个值用@Value注释设置，在之前的菜谱中也讨论了这个概念。openFile()方法由@PostConstruct注释修饰，该注释告诉Spring在构造bean之后立即执行该方法。closeFile()方法被修饰为@PreDestroy注释，它告诉Spring在销毁bean之前执行这个方法。 使用@Lazy为pojo定义延迟初始化默认情况下，Spring对所有pojo执行热切初始化。这意味着pojo在启动时初始化。但是，在某些情况下，可以方便地将POJO初始化过程延迟到需要bean时。延迟初始化称为延迟初始化。延迟初始化有助于限制启动时的资源消耗峰值，并保存整个系统资源。延迟初始化对于执行重量级操作(例如，网络连接、文件操作)的pojo尤其相关。要使用惰性初始化标记bean，您可以使用@Lazy注释来修饰bean。 123456789101112131415161718package com.apress.springrecipes.shop;...import org.springframework.stereotype.Component;import org.springframework.context.annotation.Scope;import org.springframework.context.annotation.Lazy;@Component @Scope(\"prototype\")@Lazypublic class ShoppingCart &#123; private List&lt;Product&gt; items = new ArrayList&lt;&gt;(); public void addItem(Product item) &#123; items.add(item); &#125; public List&lt;Product&gt; getItems() &#123; return items; &#125;&#125; 在前面的声明中，由于POJO被@Lazy注释修饰，如果应用程序从不需要POJO或被另一个POJO引用，它就不会实例化。 在使用@DependsOn的其他pojo之前定义pojo的初始化作为应用程序的POJO增长，POJO初始化的数量也是如此。如果pojo相互引用，并且分布在不同的Java配置类中，则可以创建竞争条件。如果bean C需要bean B和bean F的逻辑，会发生什么呢?如果首先检测到bean C，而Spring没有初始化bean B和bean F，您将会得到一个很难检测到的错误。为了确保在其他pojo之前对某些pojo进行初始化，并在初始化过程失败时获得更具描述性的错误，Spring提供了@DependsOn注释。@DependsOn注释确保给定的bean在另一个bean之前被初始化。 1234567891011121314151617181920package com.apress.springrecipes.sequence.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.DependsOn;import org.springframework.context.annotation.Configuration;import com.apress.springrecipes.sequence.DatePrefixGenerator;import com.apress.springrecipes.sequence.NumberPrefixGenerator;import com.apress.springrecipes.sequence.SequenceGenerator;@Configurationpublic class SequenceConfiguration &#123; @Bean @DependsOn(\"datePrefixGenerator\") public SequenceGenerator sequenceGenerator() &#123; SequenceGenerator sequence= new SequenceGenerator(); sequence.setInitial(100000); sequence.setSuffix(\"A\"); return sequence; &#125;&#125; 创建Post-Processors以验证和修改POJOs问题 您希望在构建期间将任务应用到所有bean实例或特定类型的实例，以根据特定的标准验证或修改bean属性。 解决方案 bean后处理器允许在初始化回调方法之前和之后进行bean处理(i.e. 分配给@Bean注释的initMethod属性或用@PostConstruct注释修饰的方法的属性)。bean后处理器的主要特性是它处理IoC容器中的所有bean实例，而不只是单个bean实例。通常，bean后处理器用于检查bean属性的有效性，根据特定的标准修改bean属性，或者将某些任务应用到所有bean实例。Spring还支持@Required注释，它由内置的Spring post-processor RequiredAnnotationBeanPostProcessor支持。RequiredAnnotationBeanPostProcessor bean事后处理器检查是否设置了所有带有@Required注释的bean属性。 它是如何工作的 假设您希望审计每个bean的创建。您可能希望这样做来调试应用程序、验证每个bean的属性，或者在其他场景中。bean后处理器是实现这个特性的理想选择，因为您不必修改任何现有的POJO代码。 创建POJO来处理每个Bean实例使用工厂(静态方法、实例方法、Spring的FactoryBean)创建POJOs使用Spring环境和Profiles加载不同的POJOs集让POJOs了解Spring的IoC容器资源使用面向切面的编程和注释访问连接点信息用@Order注释指定切面的优先级重用方面切入点定义写AspectJ切入点表达式将AOP用于POJOs的介绍用AOP向POJOs引入状态在Spring使用Load-Time编织AspectJ切面在Spring中配置AspectJ切面用AOP将POJOs注入域对象使用Spring和TaskExecutors应用并发在POJOs之间通信应用程序事件","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"开发范例代码大全","slug":"Spring/开发范例代码大全","permalink":"https://jigangduan.github.io/categories/Spring/开发范例代码大全/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"}]},{"title":"Spring 5 开发工具","slug":"Spring-5-Recipes-1","date":"2018-07-29T07:42:17.000Z","updated":"2020-07-25T02:57:18.164Z","comments":true,"path":"2018/07/29/Spring-5-Recipes-1/","link":"","permalink":"https://jigangduan.github.io/2018/07/29/Spring-5-Recipes-1/","excerpt":"","text":"在本章中，您将学习如何设置和使用最流行的开发工具来创建Spring应用程序。与许多其他软件框架一样，Spring也有大量的开发工具可供选择，从简单的命令行工具到复杂的图形化工具，称为集成开发环境(IDE)。 无论您是已经使用了某些Java开发工具，还是第一次使用Java开发工具，以下食谱将指导您如何设置不同的工具箱，以便在接下来的章节中进行练习，以及开发任何Spring应用程序。 以下是启动Spring应用程序所需的三个工具箱和相应的章节: Spring工具套件: 章节1-1 IntelliJ IDE:章节1-2(以及Maven命令行接口的章节1-3和1-4;用于Gradle命令行界面的章节1-5和1-6) Text editor:Maven命令行界面的章节1-3和1-4;用于level命令行接口的章节1-5和1-6 Spring工具套件使用IntelliJ IDE构建一个Spring应用程序问题您希望使用IntelliJ IDE来构建Spring应用程序。 解决方案要在IntelliJ Quick start窗口中启动一个新的Spring应用程序，请单击Create new Project链接。在下一个窗口中，为项目分配一个名称，选择一个运行时JDK，并选择Java模块选项。在下一个窗口中，单击各种Spring复选框，以便IntelliJ下载项目所需的Spring依赖项。 要打开一个使用Maven的Spring应用程序，您首先需要安装Maven以从命令行接口工作(请参阅配方1-4)。从IntelliJ顶级文件菜单中，选择Import Project选项。接下来，从您的工作站上基于Maven选择Spring应用程序。在下一个屏幕上，选择“从外部模型导入项目”选项并选择Maven类型。 要打开使用Gradle的Spring应用程序，首先需要从命令行界面安装Gradle(参见菜谱1-5)。在IntelliJ顶级文件菜单中，选择Import Project选项。接下来，根据您的工作站上的Gradle选择Spring应用程序。在下一个屏幕中，选择“从外部模型导入项目”选项并选择一个Gradle类型。 它是如何工作的IntelliJ是市场上最受欢迎的商业ide之一。与其他由基金会(如Eclipse)或支持公司旗舰软件(如Spring框架的STS)生成的ide不同，IntelliJ是由JetBrains公司(JetBrains)生产的，该公司的唯一业务是将开发工具商业化。正是这种关注，使得IntelliJ在企业环境中特别受专业开发人员的欢迎。 对于这个食谱，我们假设您已经安装了IntelliJ Ultimate edition，并且只需要启动和运行Spring应用程序。 ■警告intelliJ最终有一个免费的社区版和一个30天免费试用版。尽管免费社区版为应用程序开发提供了良好的价值，但是Community edition并不包括对Spring应用程序的支持。下面的指令是基于假设您正在使用intelliJ终极版本的。 创建一个Spring应用程序要启动Spring应用程序，请在IntelliJ Quick start窗口中单击Create New Project链接。在新项目窗口中，选择Spring选项并单击各种Spring复选框，如图1-8所示。 导入并构建Maven项目比从头创建Spring应用程序更常见的情况是继续开发现有的Spring应用程序。在这种情况下，应用程序的所有者通常使用构建脚本分发应用程序的源代码，以促进其正在进行的开发。大多数Java应用程序选择的构建脚本是pom。围绕Maven构建工具或最近的构建设计的xml文件。围绕渐变工具设计的渐变文件。这本书的源代码及其应用程序提供了渐变构建文件，以及一个带有Maven构建文件的应用程序。下载了该书的源代码并将其解压缩到本地目录后，单击IntelliJ顶级文件菜单并选择Import Project选项。弹出窗口，如图1-9所示。 在此窗口中，在目录树中向下展开，直到您到达ch01中图书源代码的目录，然后选择springintro_mvn。点击打开按钮。在下一个屏幕中，选择“从外部模型导入项目”选项并选择Maven类型，如图1-10所示。 在下一个窗口中(参见图1-11)，您可以对一些Maven项目设置进行微调，例如自动将更改导入到pom.xml，下载依赖源，等等。当满足设置时，单击Next 确保选中了项目复选框，如图1-12所示，并单击Next按钮导入项目。 接下来，为项目选择SDK版本。确认项目名称和位置并单击Finish按钮。IntelliJ中的所有项目都被加载到项目窗口的左边。在本例中，项目以名称springintro_mvn出现。如果您单击项目图标，您将能够看到项目结构(即Java类、依赖项、配置文件等)。如果双击项目窗口中的任何一个项目文件，文件将在中心窗口的一个单独的选项卡中打开。您可以检查文件的内容，以及编辑或删除它的内容。接下来，您需要设置Maven来使用IntelliJ。按照食谱1-3中的说明，从命令行安装Maven。这样做之后，您就可以设置IntelliJ来与Maven一起工作了。 单击IntelliJ顶级文件菜单并选择Settings选项。出现一个弹出窗口来配置IntelliJ设置。单击Maven选项，在Maven主目录中介绍基于系统的Maven安装目录，如图1-13所示。单击Apply按钮，然后单击OK按钮。 接下来，在IntelliJ的右侧，单击垂直选项卡Maven项目来显示Maven项目窗格，如图1-14所示。 在Maven Projects窗格中选择项目的“Spring line简介”，然后右键单击以打开包含项目各种命令的上下文菜单。选择Run Maven构建选项。在IntelliJ的底部中心，你会看到Run窗口出现。在这种情况下，Run窗口将显示Maven生成的一系列构建消息，以及在构建过程失败时可能出现的任何错误。 警告如果您看到错误消息“没有找到有效的maven安装。要么在配置对话框中设置主目录，要么在系统上设置m2_home环境变量。验证maven的安装和配置过程。 您刚刚构建了应用程序，祝贺您!现在,让我们来运行它。如果没有看到目标目录，请按Ctrl+Alt+Y组合键来同步项目。通过单击展开目标目录它的图标。接下来，右键单击文件springintro_mvn-4.0.0-SNAPSHOT.jar，如图1-15所示，并选择Run选项。 在运行窗口IntelliJ的底部中心，您将看到应用程序日志消息，以及应用程序定义的问候语消息。 导入和建设Gradle项目现在，让我们用IntelliJ构建一个Gradle应用程序。首先你需要安装等级。按照配方1-4中的说明从命令行安装Gradle。一旦您这样做了，您就可以设置IntelliJ来处理Gradle。单击IntelliJ顶级文件菜单并选择Import Project选项。弹出窗口，如图1-9所示。在弹出窗口中向下挖掘目录树，直到您可以选择文件构建。在ch01/springintro目录的书的源代码。点击打开按钮。在下一个屏幕上，选择“从外部模型导入项目”选项并选择Gradle。在下一个屏幕上，根据系统的Gradle安装，在“Gradle home”框中输入Gradle home目录，如图1-16所示。 单击Finish按钮确认导入过程，然后单击Finish按钮完成导入过程。接下来，在项目窗口中，右键单击build。渐变并选择运行构建。您刚刚构建了应用程序。现在,让我们来运行它。在项目窗口中，展开构建目录并进入libs目录。找到springintro-all.jar，如图1-17所示。 注意，build.gradle文件被配置为生成一个影子Jar，这意味着它包含运行所需的所有类和依赖项。 现在右键单击springintro-all.jar 文件并选择Run选项。在运行窗口IntelliJ的底部中心，您将看到应用程序日志消息，以及应用程序定义的问候语消息。 使用Maven命令行接口构建一个Spring应用程序问题您希望使用命令行中的Maven构建一个Spring应用程序。 解决方案从http://maven.apache.org/download.cgi下载Maven。确保将JAVA_HOME环境变量设置为Java的SDK主目录。修改PATH环境变量以包含Maven的bin目录。 它是如何工作的Maven是一个独立的命令行接口工具。这允许从各种开发环境中使用Maven。例如,如果您更喜欢使用一个文本编辑器如emacs或vi编辑应用程序的代码,就基本能够访问Maven这样的构建工具来自动化的繁重工作(例如,复制文件,一步编译)通常与Java应用程序的构建过程相关联。 可以从http://maven.apache.org/download.cgi免费下载Maven。Maven可以在源代码和二进制版本中使用。由于Java工具是跨平台的，我们建议您下载二进制版本，以避免额外的编译步骤。在撰写本文时，Maven的最新稳定版本是3.5.0版本。 下载Maven之后，确保在系统上安装了Java SDK，因为Maven在运行时需要它。通过解压Maven并定义JAVA_HOME和PATH环境变量，继续安装Maven。 运行以下命令解压: 1www@ubuntu:~$ tar -xzvf apache-maven-3.5.0-bin.tar.gz 使用以下命令添加JAVA_HOME变量: 1www@ubuntu:~$ export JAVA_HOME=/usr/lib/jvm/java-8-openjdk/ 使用以下命令将Maven可执行文件添加到PATH变量: 1www@ubuntu:~$ export PATH=$PATH:/home/www/apache-maven-3.5.0/bin/ ■提示如果你声明JAVA_HOME变量和路径说明之前,你需要做这个过程你每次打开一个新的shell会话使用maven。在Unix/linux系统上，您可以在用户的主目录中打开.bashrc文件，并添加相同的导出行，以避免在每个会话中声明环境变量。在Windows系统上，您可以通过选择我的计算机图标，右键单击，然后选择properties选项来永久设置环境变量。在弹出窗口中，选择advanced选项卡并单击“环境变量”按钮。 Maven可执行文件通过mvn命令可用。如果您按照前面的描述正确地设置了环境变量，那么从系统上的任何目录输入mvn将调用Maven。描述关于Maven执行的更多细节将超出此菜谱的范围。然而，接下来我们将描述如何使用Maven从该书的源代码构建Spring应用程序。一旦下载了该书的源代码并将其解压到本地目录，请转到名为ch01/springintro_mvn的目录。键入mvn调用Maven，并在springintro_mvn下构建应用程序。输出应该如图1-18所示。 您刚刚构建了应用程序，祝贺您!现在,让我们来运行它。深入到由Maven在ch01/springintro_mvn目录下创建的名为target的目录中。您将看到文件springintro_mvn- 4.0.0-SNAPSHOT.jar，它是构建的应用程序。执行命令java -jar springintro_mvn- 1-0.SNAPSHOT.jar来运行应用程序。您将看到应用程序日志消息，以及应用程序定义的问候消息。 使用Gradle命令行界面构建一个Spring应用程序问题您希望使用命令行中的Gradle构建Spring应用程序。 解决方案从www.gradle.org/downloads下载它。确保将JAVA_HOME环境变量设置为。Java SDK主要目录。修改PATH环境变量以包含Gradle的bin目录。 它是如何工作的Gradle是一个独立的命令行工具。这允许从广泛的开发环境中使用Gradle。例如,如果您更喜欢使用一个文本编辑器如emacs或vi编辑应用程序的代码,就基本能够访问像Gradle自动化构建工具繁重工作(例如,复制文件,一步编译)通常与Java应用程序的构建过程相关联。Gradle可以通过www.gradle.org/downloads免费下载。Gradle可以在源代码和二进制版本中使用。由于Java工具是跨平台的，我们建议您下载二进制版本，以避免额外的编译步骤。在撰写本文时，Gradle的最新稳定版本是3.5版本。一旦您下载了Gradle，确保在系统上安装了Java SDK，因为Gradle在运行时需要它。通过解压并定义JAVA_HOME和PATH环境变量，继续安装Gradle。 运行以下命令解压: 1www@ubuntu:~$ unzip gradle-3.5-bin.zip 使用以下命令添加JAVA_HOME变量: 1www@ubuntu:~$ export JAVA_HOME=/usr/lib/jvm/java-8-openjdk/ 使用以下命令将可执行等级添加到路径变量: 1www@ubuntu:~$ export PATH=$PATH:/home/www/gradle-3.5/bin/ 尽管Gradle(参见1-3)作为一个独立的命令行工具可用，但是很多(开源)项目使用Maven包装器来访问Maven。这种方法的优点是应用程序完全是自提供的。作为开发人员，您不需要安装Maven，因为Maven包装器将下载特定版本的Maven来构建项目。 提示:如果您如前面所示声明了变量JAVA_HOME和PATH，那么每次打开一个新的shell会话使用gradle时，您都需要执行这个过程。在Unix/linux系统上，您可以在用户的主目录中打开.bashrc文件，并添加相同的导出行，以避免在每个会话中声明环境变量。在Windows系统上，您可以通过选择我的计算机图标，右键单击，然后选择properties选项来永久设置环境变量。在弹出窗口中，选择advanced选项卡并单击“环境变量”按钮。 Gradle可执行文件通过gradle命令可用。如果您按照前面描述的那样正确地设置环境变量，那么从系统上的任何目录输入gradle将调用gradle。描述更多关于等级执行的细节将超出这个食谱的范围。然而，由于本书的源代码中有许多使用Gradle的Spring应用程序，我们将描述如何使用Gradle来构建这些Spring应用程序中的一个。 一旦下载了该书的源代码并将其解压缩到本地目录，请转到名为ch01/springintro的目录。类型gradle调用gradle并在springintro下构建应用程序。输出应该如图1-20所示。 您刚刚构建了应用程序，祝贺您!现在,让我们来运行它。深入到ch01/springintro目录下的Gradle创建的名为libs的目录中。您将看到文件springintro-all.jar，它是构建的应用程序。执行命令java -jar springintro-all.jar torunthe应用程序。您将看到应用程序日志消息，以及应用程序定义的问候消息。 使用Gradle包装器构建一个Spring应用程序问题您希望使用命令行中的Gradle包装器构建一个Spring应用程序。 解决方案从命令行运行gradlew脚本。 它是如何工作的尽管Gradle(参见秘诀1-5)可以作为独立的命令行工具，但是很多(开源的)项目都使用Gradle包装器来提供对Gradle的访问。这种方法的优点是应用程序完全是自提供的。作为开发人员，您不需要安装Gradle，因为Gradle包装器将下载特定版本的Gradle来构建项目。一旦您有了一个使用Gradle包装器的项目，您就可以简单地在命令行上输入./gradlew构建，这样Gradle就可以自动下载并运行构建。惟一的先决条件是安装Java SDK，因为Gradle在运行时需要它，而Gradle包装器需要它运行。 下载这本书的源代码并将其解压到本地目录之后，转到名为ch01/Recipe_1_6的目录。键入./gradlew以调用Gradle包装器，并在Recipe_1_6下自动构建应用程序。输出将如图1-21所示。 ■提示书的源代码可以用纯gradle或gradle包装。后者更可取，因为在开发示例时，代码将使用相同的级别版本构建。 总结在本章中，您了解了如何设置最流行的开发工具来创建Spring应用程序。您了解了如何使用四个工具箱构建和运行Spring应用程序。两个工具箱由使用IDE组成:Spring框架创建者分发的Spring工具套件和JetBrains分发的IntelliJ IDE。另外两个工具箱包括使用命令行工具:Maven构建工具和更新的Gradle构建工具，它们比Maven构建工具更受欢迎","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"开发范例代码大全","slug":"Spring/开发范例代码大全","permalink":"https://jigangduan.github.io/categories/Spring/开发范例代码大全/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"}]},{"title":"Spring 5 开发范例代码大全","slug":"Spring-5-Recipes","date":"2018-07-29T07:16:04.000Z","updated":"2020-07-25T02:57:18.166Z","comments":true,"path":"2018/07/29/Spring-5-Recipes/","link":"","permalink":"https://jigangduan.github.io/2018/07/29/Spring-5-Recipes/","excerpt":"","text":"介绍Spring框架正在增长。关于选择。Java EE专注于一些技术，主要是为了损害替代的、更好的解决方案。当Spring框架初次亮相时，很少有人会认为Java EE代表了当今最好的体系结构。Spring首次大张旗鼓地亮相，是因为它寻求简化Java EE。此后的每一个版本都标记了新特性的引入，这些新特性既简化了解决方案，又简化了解决方案。 随着版本2.0和更新，Spring框架开始针对多个平台。框架一如既往地在现有平台之上提供服务，但尽可能地与底层平台分离。Java EE仍然是一个主要的参考点，但它不是唯一的目标。此外，Spring框架在不同的云环境中运行。构建于Spring之上的框架已经出现，以支持应用程序集成、批处理、消息传递等等。Spring框架的版本5是一个主要的升级，基线被提升到Java 8，增加了对基于注释的配置的更多支持，并引入了对jUnit 5的支持。新增加的功能是支持在Spring WebFlux的形式中进行的 响应性编程。 这是这本极好的食谱书的第四版，它涵盖了更新后的框架，描述了新特性并解释了不同的配置选项。 要描述Spring生态系统中的每个项目都是不可能的，所以我们必须决定要保留什么，添加什么，以及更新什么。这是一个艰难的决定，但我们认为我们已经包含了最重要的内容。 结构 第1章“Spring开发工具”概述了支持Spring框架的工具以及如何使用它们。 第2章“Spring核心任务”给出了Spring框架的概述，包括如何设置它、它是什么以及如何使用它。 第3章“Spring MVC”介绍了使用Spring Web MVC框架进行基于Web的应用程序开发。 第4章“Spring REST”介绍了Spring对RESTful web服务的支持。 第5章“Spring MVC: Async处理”介绍了使用Spring MVC的异步处理。 第6章，“Spring Social”，介绍了Spring Social，它可以让你轻松地融入到社交网络中。 第7章“Spring Security”提供了Spring Security项目的概述，以帮助您更好地保护应用程序。 第八章“Spring Mobile”介绍了Spring Mobile，它允许您在应用程序中集成移动设备检测和使用。 第9章“数据访问”讨论了如何使用Spring使用JDBC、Hibernate和JPA等api与数据存储对话。 第10章“Spring事务管理”介绍了Spring健壮的事务管理功能背后的概念。 第11章“Spring Batch”介绍了Spring Batch框架，它提供了一种为传统上被认为是大型机领域的解决方案建模的方法。 第12章“带NoSQL的Spring”介绍了多个Spring数据组合项目，涵盖了不同的NoSQL技术和使用Hadoop的大数据。 第13章，“Spring Java企业服务和远程技术”，向您介绍了JMX支持、调度、电子邮件支持以及RPC的各种设施，包括Spring Web服务项目。 第14章“Spring消息传递”讨论了通过JMS和RabbitMQ使用Spring和面向消息的中间件，以及简化Spring抽象。 第15章“Spring集成”讨论了如何使用Spring集成框架集成不同的服务和数据。 第16章“Spring测试”讨论了使用Spring框架的单元测试。 第17章“Grails”讨论了Grails框架，使用它可以提高生产率,最好的片段并与Groovy代码绑定在一起。 先决条件因为Java编程语言是平台独立的，所以您可以自由地选择任何受支持的操作系统。然而，本书中的一些例子使用了特定于平台的路径。在输入示例之前，必须将它们翻译成操作系统的格式。 要充分利用这本书，请安装JDK 1.8或更高版本。您应该安装一个Java IDE以简化开发。对于本书，示例代码是基于层次的。如果您正在运行Eclipse并安装Gradle插件，您可以在Eclipse中打开相同的代码，并且类路径和依赖项将由Gradle元数据填充。如果您正在使用Eclipse，您可能更喜欢SpringSource工具套件(STS)，因为它预装了在Eclipse中使用Spring框架所需的插件。如果您使用IntelliJ IDEA，您需要启用Gradle(和Groovy)插件。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"开发范例代码大全","slug":"Spring/开发范例代码大全","permalink":"https://jigangduan.github.io/categories/Spring/开发范例代码大全/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"}]},{"title":"CAS企业单点登录-安装(Maven)","slug":"cas-Maven-Overlay-Installation","date":"2018-07-13T02:03:13.000Z","updated":"2020-07-25T02:57:18.195Z","comments":true,"path":"2018/07/13/cas-Maven-Overlay-Installation/","link":"","permalink":"https://jigangduan.github.io/2018/07/13/cas-Maven-Overlay-Installation/","excerpt":"","text":"CAS安装基本上是一个面向源的过程，我们推荐一个WAR overlay(1)项目来组织定制，比如组件配置和UI设计。WAR覆盖构建的输出是cas。可以部署到servlet容器(如Apache Tomcat)的war文件。 需求参见本指南了解更多信息。 什么是WAR覆盖覆盖是一种对抗重复代码和/或资源的策略。覆盖允许您下载由项目本身提供的预构建的普通CAS web应用服务器，并覆盖/插入特定的行为，而不是从源代码下载CAS代码库和构建。在构建时，Maven/Gradle安装过程将首先尝试下载提供的二进制工件。然后，该工具将定位您在同一项目目录中可用的配置文件和设置，并将它们合并到下载的工件中，以便生成一个完整的存档(例如，cas.war)。覆盖的工件可能包括资源、java类、图像、CSS和javascript文件。为了成功地执行合并进程，在本地被覆盖的工件的位置和名称必须与最初下载的归档文件中项目提供的位置和名称完全匹配。 毫无疑问，尽管前期准备阶段可能会稍微复杂一些，但是这种方法有显著的优势: 不需要从源代码下载/构建。 通过简单地调整构建脚本以下载更新的CAS版本，升级在大多数情况下都非常容易。 与托管整个软件源代码不同，作为部署人员，您只保留您自己的本地自定义，这使得更改跟踪更加容易。 跟踪源代码控制存储库中的更改是非常轻量级的，这同样是因为只管理相关的更改(而不是整个软件)。 管理覆盖CAS的每个方面都可以通过叠加中添加、删除或修改文件进行控制;通过添加第三方组件(将CAS api实现为Java源文件或依赖项引用)来定制CAS的行为也是可能的，也是常见的。 使用覆盖层的过程，不管是Maven还是Gradle，可以通过以下步骤进行总结: 开始并构建提供的基本构建/部署。 从生成的构建中识别需要更改的构件。这些构件通常由目标或Maven或Gradle的构建目录中生成。 将上述目录中标识的构件复制到src目录中。 创建src目录及其所有子节点，如果它们还不存在的话。 复制的路径和文件名必须与构建版本完全匹配，否则更改不会生效。请参阅下面的表格，了解如何将文件夹和文件从构建映射到src。 更改之后，尽可能多地重新构建和重复这个过程。 在构建的二进制工件中再次检查您的更改，以确保覆盖过程正在工作。 是准确的不要复制构建生成的所有内容。尝试将更改和自定义保持到最小，只获取实际需要的内容。确保部署环境保持干净和精确，否则您将面临严重升级问题和令人头痛的风险。 CAS WAR覆盖提供CAS WAR覆盖项目供参考和研究。 审查分支!下面的存储库指向它们的主分支。您应该始终确保您所在的分支与您希望配置和部署的CAS版本匹配。主分支通常指向CAS服务器的最新稳定版本。检查构建配置，如果不合适，使用git分支a查看可用的分支，然后git签出[branch-name]以在必要时进行切换。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"CAS企业单点登录","slug":"Spring/CAS企业单点登录","permalink":"https://jigangduan.github.io/categories/Spring/CAS企业单点登录/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"单点登录","slug":"单点登录","permalink":"https://jigangduan.github.io/tags/单点登录/"}]},{"title":"CAS企业单点登录-安装要求","slug":"cas-Installation-Requirements","date":"2018-07-13T01:21:07.000Z","updated":"2020-07-25T02:57:18.195Z","comments":true,"path":"2018/07/13/cas-Installation-Requirements/","link":"","permalink":"https://jigangduan.github.io/2018/07/13/cas-Installation-Requirements/","excerpt":"","text":"根据配置组件的选择，可能会有其他需求，如LDAP目录、数据库和缓存基础设施。然而，在大多数情况下，对于选择具有明确硬件和软件依赖关系的组件的部署人员来说，需求应该是不言而喻的。在任何其他需求不明显的情况下，组件配置的讨论都应该提到系统、软件、硬件和其他需求。 JavaCAS的核心是一个基于java的web应用程序。在部署之前，需要安装JDK v1.8 Servlet容器没有官方支持的CAS的servlet容器，但是Apache Tomcat是最常用的。对特定servlet容器的支持取决于社区成员的专业知识。 更多信息请参见本指南。 构建工具提供了Maven或Gradle覆盖，以支持简单而灵活的部署解决方案。诚然，它需要高昂的前期学习成本，但从长远来看，它能带来很多好处。 少做一些在安装之前，您不需要安装Maven或Gradle。它们是自动提供给您的。 Git(可选)虽然不是严格的要求，但是强烈建议您为您的CAS部署安装Git，并管理所有CAS构件、配置文件、构建脚本和源代码控制存储库中的设置。 操作系统虽然基于linux的安装通常比Windows更常见，但在操作系统上没有特别的偏好。 网络连接Internet连接通常用于任何基于Maven/Gradle的项目的构建阶段，包括用于安装CAS的推荐WAR覆盖。构建过程通过搜索包含在本地下载和安装的工件(大多数情况下是jar文件)的在线存储库来解决依赖关系。 硬件坊间证据似乎表明，在具有8GB内存的双核3.00Ghz处理器上，CAS部署至少可以执行得很好。如果日志保存在服务器上，那么还需要足够的磁盘空间(最好是SSD)来存放由casas生成的日志。 记住，上面的要求只是建议。根据您的部署和请求量的不同，您或多或少都可以得到完美的结果。从最低限度开始，准备根据需要调整和加强能力。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"CAS企业单点登录","slug":"Spring/CAS企业单点登录","permalink":"https://jigangduan.github.io/categories/Spring/CAS企业单点登录/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"单点登录","slug":"单点登录","permalink":"https://jigangduan.github.io/tags/单点登录/"}]},{"title":"CAS企业单点登录-入门指南","slug":"cas-Getting-Started","date":"2018-07-12T14:33:48.000Z","updated":"2020-07-25T02:57:18.194Z","comments":true,"path":"2018/07/12/cas-Getting-Started/","link":"","permalink":"https://jigangduan.github.io/2018/07/12/cas-Getting-Started/","excerpt":"","text":"本文档提供了关于如何开始使用CAS服务器部署的高级指南。该指南的唯一重点是描述CAS部署人员必须遵循和采用的过程，以便获得成功和可持续的体系结构和部署。 收集用例在部署之前，记录、编目和分析所需的用例和需求是非常重要的。一旦您有了一些想法，请与CAS社区讨论并分享那些可能已经解决了您今天面临的相同问题的共同趋势、实践和模式。 学习架构了解什么是CAS，可以做什么。这将帮助您开发一个基础，以实现您的哪些用例和需求在CAS中可能已经是可能的。看一下CAS架构的基本原理，看看部署和应用程序集成可能有哪些选项和选择。 同样，研究CAS支持的协议和规范列表也同样重要。 评论博客有时，当你在考虑需求和评估特性时，博客文章会出现在Apereo博客上。一般建议您关注这个博客，尽可能关注项目新闻和公告，在整个CAS部署过程中，不要羞于撰写和发布您自己的博客文章、经验和更新。 准备环境很简单，研究部署环境的安装需求。 部署CAS建议使用WAR Overlay方法在本地构建和部署CAS。这种方法不需要采用者显式地下载任何版本的CAS，而是利用覆盖机制将CAS原始构件和本地自定义结合起来，以进一步简化未来的升级和维护。 注意:不要直接克隆或下载CAS代码基。只有当您希望为项目的开发做出贡献时，才需要这样做。 在做任何其他事情之前，您都应该先建立一个功能基线。避免立即进行临时更改以定制部署。坚持使用cas-提供的默认设置和设置，并一次改变一个步骤。跟踪进程和在源代码控制和标记更改中应用的更改。 定制这就是用例被映射到CAS特性的地方。浏览文档以找到最接近的匹配并应用。同样，重要的是尽可能坚持CAS基线: 避免对软件内部进行特别的更改。 避免手工更改核心配置组件，如Spring和Spring Webflow。 如果遇到问题，避免对部署进行一次性的错误修复。 如前所述，所有这些策略都会导致头痛和成本。 相反，试着准备以下建议: 错误修复和小的改进属于核心的CAS软件。不是你的部署。尽一切努力报告问题，提供修复和补丁，并与CAS社区一起彻底解决问题。 某些内部CAS组件很难增加和修改。在大多数情况下，这种方法的目的是让您远离危险和不必要的复杂变化。如果您遇到一个需要和有一个特性或用例的配置和实现需要修改的核心内部软件,与中科院社区讨论,并尝试增强直接构建到CAS软件,而不是把它作为一个雪花。 总而言之，只有当部署配置真正和完全特定于您的需求时，才对其进行更改。否则，试着去归纳和回馈以降低维护成本。反复地，不遵守这一策略将可能导致长期的灾难性后果。 故障排除故障排除指南可能对您可能遇到的问题有一些答案，它通常试图描述一种对故障排除和诊断有用的策略。你也可以向CAS社区寻求帮助。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"CAS企业单点登录","slug":"Spring/CAS企业单点登录","permalink":"https://jigangduan.github.io/categories/Spring/CAS企业单点登录/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"单点登录","slug":"单点登录","permalink":"https://jigangduan.github.io/tags/单点登录/"}]},{"title":"CAS企业单点登录-架构","slug":"cas-architecture","date":"2018-07-12T14:00:17.000Z","updated":"2020-07-25T02:57:18.195Z","comments":true,"path":"2018/07/12/cas-architecture/","link":"","permalink":"https://jigangduan.github.io/2018/07/12/cas-architecture/","excerpt":"","text":"系统组件CAS服务器和客户端包含CAS系统体系结构的两个物理组件，通过各种协议进行通信。 CAS服务器CAS服务器是构建在Spring框架上的Java servlet，其主要职责是通过发出和验证票据，对用户进行身份验证并授予对启用了casas的服务(通常称为CAS客户机)的访问权。当服务器在成功登录时向用户发出通知票(TGT)时，将创建SSO会话。服务票证(ST)是通过浏览器重定向使用TGT作为令牌来发送给服务的。ST随后通过后通道通信在CAS服务器上进行验证。在CAS协议文档中详细描述了这些交互。 CAS客户端术语“CAS客户端”在其常用中有两个不同的含义。CAS客户端是任何支持casa的应用程序，可以通过受支持的协议与服务器通信。CAS客户机也是一个软件包，可以与各种软件平台和应用程序集成，以便通过一些身份验证协议(例如CAS、SAML、OAuth)与CAS服务器通信。支持多种软件平台和产品的CAS客户端已经开发出来。 平台: Apache httpd服务器(mod_auth_cas模块) Java(Java CAS客户端) .NET(.NETCAS客户端) PHP(phpCAS) Perl(PerlCAS) Python(pycas) Ruby(rubycas-client) Applications: Canvas Atlassian Confluence Atlassian JIRA Drupal Liferay uPortal … 当“CAS客户端”一词在本手册中出现时，它指的是集成组件，如Java CAS客户端，而不是依赖于(CAS服务器的客户端)的应用程序。 支持的协议客户端通过任何支持的协议与服务器通信。所有受支持的协议在概念上都是相似的，但是有些协议的特性或特征使它们适合于特定的应用程序或用例。例如，CAS协议支持委托(代理)身份验证，SAML协议支持属性释放和单点退出。 支持的协议: CAS (versions 1, 2, and 3) SAML 1.1 and 2 OpenID Connect OpenID OAuth 2.0 WS Federation 软件组件将CAS服务器描述为三层子系统是有帮助的: 网络(Spring MVC / Spring Webflow)票务身份验证 几乎所有的部署考虑事项和组件配置都涉及这三个子系统。Web层是与包括CAS客户端在内的所有外部系统通信的端点。Web层委托票务子系统为CAS客户端访问生成票证。SSO会话开始于在成功的身份验证时发出一张票据，因此票务子系统经常委托给身份验证子系统。 身份验证系统通常只在SSO会话开始时处理请求，但也有其他可以调用它的情况(例如强制身份验证)。 Spring FrameworkCAS使用Spring框架的许多方面;最值得注意的是Spring MVC和Spring Webflow。Spring为核心CAS代码库以及部署人员提供了完整的可扩展框架;通过连接CAS和Spring API扩展点来定制或扩展CAS行为非常简单。Spring的一般知识有助于理解某些框架组件之间的相互作用，但并不是严格要求的。 Spring BootCAS也很大程度上基于Spring Boot，它允许使用Spring平台和第三方库的固执观点来创建一个独立的web应用程序，而无需进行尽可能多的XML配置。Spring Boot允许CAS隐藏其组件及其配置的内部复杂性，而是提供自动配置模块，这些模块可以简单而自动地配置正在运行的应用程序上下文，不需要太多人工干预。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"CAS企业单点登录","slug":"Spring/CAS企业单点登录","permalink":"https://jigangduan.github.io/categories/Spring/CAS企业单点登录/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"单点登录","slug":"单点登录","permalink":"https://jigangduan.github.io/tags/单点登录/"}]},{"title":"CAS企业单点登录","slug":"cas","date":"2018-07-12T12:37:09.000Z","updated":"2020-07-25T02:57:18.196Z","comments":true,"path":"2018/07/12/cas/","link":"","permalink":"https://jigangduan.github.io/2018/07/12/cas/","excerpt":"","text":"介绍 Spring Webflow/Spring Boot Java服务器组件。 可插认证支持(LDAP、数据库、X.509、SPNEGO、JAAS、JWT、RADIUS、MongoDb等) 支持多种协议(CAS、SAML、WS-Federation、OAuth2、OpenID、OpenID连接、REST) 通过各种提供者支持多因素身份验证(Duo Security、FIDO U2F、YubiKey、谷歌身份验证器、Microsoft Azure、Authy等) 支持将身份验证委托给外部提供者，如ADFS、Facebook、Twitter、SAML2 IdPs等。 内置对密码管理、通知、使用条款和模拟的支持。 支持属性发布，包括用户同意。 实时监控和跟踪应用程序的行为、统计数据和日志。 使用特定的身份验证策略管理和注册客户端应用程序和服务。 跨平台客户端支持(Java、. net、PHP、Perl、Apache等)。 与InCommon、Box、Office365、ServiceNow、Salesforce、Workday、WebAdvisor、Drupal、Blackboard、Moodle、谷歌应用等集成。 贡献要了解如何为项目做出贡献，请参阅本指南。 入门指南我们建议阅读以下文档，以便计划和执行CAS部署。 体系结构 入门指南 安装要求 安装 Demos 使用警告!请注意，这些是公共演示站点，用于基本展示和集成测试项目。它们不是为内部演示而设置的，因为它们可以在项目需要时上下波动，而无需通知。 Apereo CAS项目提供了以下演示: 话题 源分支 位置 CAS覆盖项目initializr heroku-casinitializr 链接 CAS Web应用服务器 heroku-caswebapp 链接 CAS服务管理服务器 heroku-mgmtwebapp 链接 CAS Boot Administration Server heroku-bootadminserver 链接 CAS Zipkin 服务器 heroku-zipkinserver 链接 CAS服务发现服务器 heroku-discoveryserver 链接 CAS配置服务器 heroku-casconfigserver 链接 在需要时，用于上述演示的凭证是:casuser / Mellon 驱动CAS开发由以下工具、项目和服务驱动:","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"CAS企业单点登录","slug":"Spring/CAS企业单点登录","permalink":"https://jigangduan.github.io/categories/Spring/CAS企业单点登录/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"单点登录","slug":"单点登录","permalink":"https://jigangduan.github.io/tags/单点登录/"}]},{"title":"Hexi","slug":"Hexi","date":"2018-07-04T12:11:28.000Z","updated":"2020-07-25T02:57:18.156Z","comments":true,"path":"2018/07/04/Hexi/","link":"","permalink":"https://jigangduan.github.io/2018/07/04/Hexi/","excerpt":"Hexi是一种有趣而简单的方法，可以用纯JavaScript代码制作HTML5游戏或任何其他类型的交互媒体。看看开始的特性列表和示例文件夹。继续滚动，你会找到一个完整的快速入门指南和初学者指南。如果你以前从来没有做过游戏，教程是最好的开始。 Hexi有什么?您可以使用streamlined API获得WebGL呈现的所有功能，该API允许您以极简的、声明性的方式编写代码。它使得编写一款游戏像写诗或画一样简单有趣。试一试!如果您需要任何帮助或有任何问题，请在此存储库的问题中发布一些内容。问题页面是Hexi友好的聊天室——不要害怕寻求帮助:) 使用Hexi: hexi.min.js只需要从这个存储库中获取一个文件。这是所有!用&lt;script&gt;标签链接到您的HTML文档，然后开始!Hexi是在最新版本的JavaScript (ES6/7, 2005 /6)中从头开始编写的，但是它被编译成ES5(使用Babel)，这样它就可以在任何地方运行。在开始使用河西之前，你需要知道什么?您应该对HTML和JavaScript有合理的理解。你不必是一个专家，只是一个雄心勃勃的初学者和一个渴望学习的人。如果你不知道HTML和JavaScript，最好的开始学习它的地方是这本书: 基于HTML5和JavaScript的基础游戏设计 Pixi教程 好吧,明白了吗?您知道JavaScript变量、函数、数组和对象是什么以及如何使用它们吗?您知道JSON数据文件是什么吗?你使用过Canvas绘图API吗?然后你就可以开始使用Hexi了! 当然，河西是完全免费使用:为任何事，永远!它的作者是加拿大(多伦多，哈密顿)，印度(Kullu Valley, Ladakh)，尼泊尔(加德满都，Pokhara, Annapurna大本营)，泰国(Ko Phangan, Ko Tao)和南非(开普敦)，这是15年来对游戏设计的API可用性研究的结果。”Hexi” 这个名字来源于”Hex” + “Pixi”。它绝对没有其他意义。","text":"Hexi是一种有趣而简单的方法，可以用纯JavaScript代码制作HTML5游戏或任何其他类型的交互媒体。看看开始的特性列表和示例文件夹。继续滚动，你会找到一个完整的快速入门指南和初学者指南。如果你以前从来没有做过游戏，教程是最好的开始。 Hexi有什么?您可以使用streamlined API获得WebGL呈现的所有功能，该API允许您以极简的、声明性的方式编写代码。它使得编写一款游戏像写诗或画一样简单有趣。试一试!如果您需要任何帮助或有任何问题，请在此存储库的问题中发布一些内容。问题页面是Hexi友好的聊天室——不要害怕寻求帮助:) 使用Hexi: hexi.min.js只需要从这个存储库中获取一个文件。这是所有!用&lt;script&gt;标签链接到您的HTML文档，然后开始!Hexi是在最新版本的JavaScript (ES6/7, 2005 /6)中从头开始编写的，但是它被编译成ES5(使用Babel)，这样它就可以在任何地方运行。在开始使用河西之前，你需要知道什么?您应该对HTML和JavaScript有合理的理解。你不必是一个专家，只是一个雄心勃勃的初学者和一个渴望学习的人。如果你不知道HTML和JavaScript，最好的开始学习它的地方是这本书: 基于HTML5和JavaScript的基础游戏设计 Pixi教程 好吧,明白了吗?您知道JavaScript变量、函数、数组和对象是什么以及如何使用它们吗?您知道JSON数据文件是什么吗?你使用过Canvas绘图API吗?然后你就可以开始使用Hexi了! 当然，河西是完全免费使用:为任何事，永远!它的作者是加拿大(多伦多，哈密顿)，印度(Kullu Valley, Ladakh)，尼泊尔(加德满都，Pokhara, Annapurna大本营)，泰国(Ko Phangan, Ko Tao)和南非(开普敦)，这是15年来对游戏设计的API可用性研究的结果。”Hexi” 这个名字来源于”Hex” + “Pixi”。它绝对没有其他意义。 特性以下是Hexi的核心功能列表: 你需要的所有最重要的精灵:矩形、圆圈、线条、文本、图像精灵和动画“MovieClip”样式精灵。您可以使用一行代码来创建这些精灵中的任何一个。您还可以创建自己的定制精灵类型。 完整的场景图，包含嵌套的子-父层次结构(包括stage和addChild/removeChild方法)、本地和全局坐标、深度层和旋转支点。 将精灵分组在一起制作游戏场景。 具有用户可定义的fps和完全可定制和完全可删除的简单游戏状态管理器的游戏循环。暂停并恢复在任何时候游戏循环。 Tileset (spritesheet)支持使用frame和filmstrip方法来使用Tileset框架制作精灵。 内置纹理图集支持流行的纹理包装格式。 精灵的关键帧动画和状态管理器。使用show显示精灵的图像状态。使用playAnimation来播放一系列的帧(如果您愿意，可以在循环中)。使用show显示特定的帧号。使用fps设置精灵动画的帧速率与游戏的帧速率无关。 交互按钮精灵有up,over和down的状态 可以将任何精灵设置为交互以接收鼠标和触摸操作。为按钮和交互精灵提供直观的press, release, over, out和tap方法 易于使用的键盘键绑定。使用keyboard方法轻松定义您自己的 一个内置的通用指针，可以同时使用鼠标和触摸。分配您自己的自定义press, release和tap方法或使用任何指针的内置属性:isUp、isDown、tap、x和y。(它也适用于等距地图!) 使用putTop, putRight, putBottom, putLeft和putCenter，方便地放置与其他精灵相对的位置。使用flowRight、flowLeft、flowUp或flow将精灵水平或垂直对齐。 用于预加载图像、字体、声音和JSON数据文件的通用资产加载程序。支持所有流行的文件格式。您可以在任何时候将新资产加载到游戏中。 可选的加载状态，允许您在加载资产时运行操作。可以使用load状态添加加载进度条。 基于pixi的快速聚焦渲染引擎。如果Pixi能做到，那么Hexi也能做到! Hexi只是位于Pixi之上的一层薄薄的代码。您可以随时访问全局PIXI对象，如果您愿意，可以直接编写纯PIXI代码。Hexi包括最新稳定版本的Pixi v3.0自动绑定。 一个复杂的游戏循环，使用一个固定的时间步长，具有可变渲染和精灵插值。这意味着你可以在任何帧中获得光滑的精灵动画。 一个紧凑而强大的“俳句”风格的API，其核心是浅显的、可组合的组件。多做点事情，少写点代码。 使用内置的WebAudio API声音管理器导入和播放声音。用play、pause、stop、restart、playFrom、fadeIn和fadeOut方法控制声音。改变声音的volume和pan。 使用通用的soundEffect方法从纯代码生成您自己的自定义声音效果。 使用shake摇动精灵或场景。 精灵和场景转换的补间功能: slide、fadeIn、fadeOut、pulse、breathe、wobble、strobe和一些有用的低级补间方法，可以帮助您创建自定义补间。 按照walkPath和walkCurve的连接路径点序列创建一个精灵。 一些有用的方便函数:followEase, followConstant, angle, distance, rotateAroundSprite, rotateAroundPoint, wait, randomInt, randomFloat, contains和outsideBounds。 一种快速、通用的hit方法来处理所有类型的精灵的碰撞测试和反应(拦截和反弹)。对所有的东西都使用一种碰撞方法:矩形、圆形、点和精灵的数组。简单! 一套轻量级的、低级的2D几何碰撞方法。 游戏资产的加载进度条。 让精灵用shoot拍摄东西 很容易用grid绘制网格中的精灵 使用tilingSprite轻松创建无缝滚动背景 createParticles函数，用于为游戏创建各种粒子效果。使用particleEmitter函数来创建一个恒定的粒子流 使用scaleToWindow使游戏自动缩放到它的最大尺寸，并使其与浏览器窗口内的最佳匹配 使用makeTiledWorld对编辑器的支持。在平铺编辑器中设计游戏，并直接访问游戏代码中的所有精灵、层和对象。这是一个非常有趣，快速和容易的方法来制作游戏。 一个通用的hitTestTile方法，用于处理基于瓷砖的游戏所需的所有碰撞检查。如果您愿意，您可以将它与任何二维几何碰撞方法结合使用，以优化大相位/窄相位碰撞检查。 使用updateMap保持基于瓷砖的世界地图数据数组与移动精灵最新 创建一个在滚动游戏世界中跟随精灵的worldCamera。 一个lineOfSight函数，告诉您一个精灵对另一个精灵是否可见 与HTML和CSS元素的无缝集成，以创建丰富的用户界面。使用Hexi也适用于Angular, React和Elm! 一套完整的工具，易于创建等距游戏世界，包括:等距鼠标/触摸指针，使用hitTestIsoTile的等距瓷砖碰撞，和使用makeIsoTiledWorld的全平铺编辑器等距地图支持。 shortestPath函数，用于通过类似迷宫这样的基于瓷砖的环境进行A-star寻路，tileBasedLineOfSight函数告诉你迷宫游戏环境中的精灵是否可以看到彼此。 是的，由于Pixi渲染器提供的可访问属性(yay Pixi!)， Hexi应用程序符合W3C的可访问性指南 Hexi的模块Hexi包含了一个有用的模块集合，您可以使用这些模块的任何属性或方法在您的高级Hexi代码中。 Pixi:世界上最快的2D WebGL和canvas渲染器 Bump:一套完整的2D游戏碰撞功能。 Tink:拖放、按钮、通用指针和其他有用的交互性工具。 Charm: 简单易用的Pixi精灵动画效果 Dust:用于制造爆炸、火焰和魔法的粒子效应 Sprite Utilities:更简单、更直观的方法来创建和使用Pixi精灵，并添加状态机和动画播放器 Game Utilities: 为游戏收集的有用方法. Tile Utilities: 一组有用的方法，用于制作以Tiled Editor为基础的游戏世界。包括一套完整的等距地图实用程序。 Sound.js: 用于加载、控制和生成声音和音乐效果的微型库。为游戏添加声音所需要的一切。 Smoothie: 超光滑的精灵动画使用真正的三角时间插值。它还允许您指定游戏或应用程序运行的fps(每秒帧数)，并将精灵呈现循环与应用程序逻辑循环完全分开。 阅读每个模块的代码库中的文档，了解如何使用它们，以及它们是如何工作的。因为它们都内置在Hexi中，你不需要自己安装它们——它们可以直接使用 Hexi允许您作为顶级对象访问这些模块方法和属性。例如，如果您想从Bump collision module访问hit方法，您可以这样做: 1g.hit(spriteOne, spriteTwo); 但如果需要的话，也可以直接访问Bump模块，比如: 1g.bump.hit(spriteOne, spriteTwo); (假设你的Hexi实例被称为g); 只需使用lowerCamelCase引用模块名。这意味着您可以使用smoothie和Sprite实用程序模块作为spriteUtilities来访问Smoothie模块。 本公约有两个例外。您可以直接访问Pixi全局对象作为Pixi。此外，Sound.js模块中的函数也只能作为顶级全局对象访问。这样做是为了简化这些模块与Hexi集成的方式，并保持尽可能广泛的跨平台兼容性。 如果您是一名开发人员，并且希望为Hexi做贡献，最好的方法是为这些模块提供新的和改进的特性。或者，如果你真的很有野心，向Hexi开发团队提出一个新的模块(在这个repo的问题中，也许我们会把它添加到Hexi的核心中!) Hexi 快速启动要快速开始使用Hexi，请查看Hexi示例文件夹中的Quick start项目。这里是HTML容器页面，这里是JavaScript源文件。源代码得到了完整的注释并解释了所有的工作原理，因此，如果您想这样做，您可以直接跳转到该文件并阅读它。(您将在bin文件夹中找到已编译的ES5 JavaScript文件版本。) 快速启动项目是对所有Hexi的主要特性的访问，您可以将它用作创建您自己的新Hexi应用程序的模板。点击这里尝试一个工作例子: 您将首先看到一个加载栏，它显示正在加载的文件(声音和图像)的百分比。然后，您将看到一个旋转消息，要求您在屏幕上单击以创建猫。当音乐在背景中播放时，只要你点击鼠标，猫就会出现在屏幕上。(噢,对不起!我忘记警告你音乐了!文本字段会旋转并计算您创建的猫的数量。这些猫自己在屏幕上来回移动和反弹，同时在大小上进行缩放，并摆动它们的透明度。这里有一个你将看到的例子: 为什么是猫?因为。 如果您知道这个快速启动应用程序是如何开发的，那么您就可以快速地使用Hexi来提高效率了——让我们来看看吧! (注意: 如果你是游戏编程新手，觉得需要一个更温和、更有条理的Hexi入门，请查看前面的教程部分。你将学习如何从头开始制作3个完整的游戏，并且每一个游戏逐渐建立在你在之前的游戏中学到的技能上。 HTML容器惟一需要开始使用Hexi的文件是hexi.min.js。它有一个非常简单的“安装”:只需将它链接到带有&lt;script&gt;标记的HTML页面。然后链接包含游戏或应用程序代码的主JavaScript文件。下面是一个典型的Hexi HTML容器页面: 1234567&lt;!doctype html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Hexi&lt;/title&gt;&lt;body&gt;&lt;script src=\"hexi.min.js\"&gt;&lt;/script&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt; 当然，您可以加载游戏所需的所有外部脚本文件。 如果您需要更精细的控制，您可以使用三个独立的文件来加载河西:Pixi渲染器、Hexi模块和Hexi core.js文件。 12345678910111213&lt;!doctype html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Hexi&lt;/title&gt;&lt;body&gt;&lt;!-- Pixi renderer, Hexi's modules, and Hexi's core --&gt;&lt;script src=\"pixi.js\"&gt;&lt;/script&gt;&lt;script src=\"modules.js\"&gt;&lt;/script&gt;&lt;script src=\"core.js\"&gt;&lt;/script&gt;&lt;!-- Main application file --&gt;&lt;script src=\"bin/quickStart.js\"&gt;&lt;/script&gt;&lt;/body&gt; 这样做的一个好处是，它允许您使用自己的自定义Pixi构建，或者您希望使用的特定版本的Pixi来交换Hexi的内部版本。或者你对Hexi的模块做了一些疯狂的修改，你想尝试一下。但通常，你可能永远都不需要这样做。 Hexi 架构所有的乐趣都发生在您的主JavaScript文件中。Hexi应用程序有一个非常简单但灵活的架构，您可以扩展到任何您需要的大小。小游戏用几百行代码或大游戏用几百个文件-河西可以做到!这是典型的Hexi应用的结构: 启动Hexi load函数，在文件加载时运行 setup函数，初始化你的游戏对象，变量和精灵。 play函数，它是在循环中运行的游戏或应用程序逻辑。 这是真实代码的样子: 123456789101112131415161718192021222324252627282930313233//1. Setting up and starting Hexi//An array of files you want to loadlet thingsToLoad = [\"anyFiles\", \"youWant\", \"toLoad\"];//Initialize and start Hexilet g = hexi(canvasWidth, canvasHeight, setup, thingsToLoad, load);g.start();//2. The `load` function that will run while your files are loadingfunction load()&#123; //Display an optional loading bar g.loadingBar();&#125;//3. The `setup` function, which initializes your game objects, variables and spritesfunction setup() &#123; //Create your game objects here //Set the game state to `play` to start the game loop g.state = play;&#125;//4. The `play` function, which is your game or application logic that runs in a loopfunction play()&#123; //This is your game loop, where you can move sprites and add your //game logic&#125; 创建任何类型的游戏或应用程序都需要这个简单的模型。您可以使用它作为您自己的项目的启动模板，同样的基本模型可以扩展到任何大小。 让我们了解如何使用这个体系结构模型来构建快速启动应用程序。 建立和启动Hexi首先，创建一个数组，列出要加载的所有文件。快速启动项目加载一个图像文件、一个字体文件和一个音乐文件。 12345let thingsToLoad = [ \"images/cat.png\", \"fonts/puzzler.otf\", \"sounds/music.wav\"]; 如果没有要加载的文件，请跳过这一步。 接下来，用hexi函数初始化Hexi。下面介绍如何初始化屏幕大小为512x512像素的Hexi应用程序。它告诉Hexi在thingsToLoad数组中加载文件，在加载时运行一个名为load的函数，然后在一切准备就绪时运行一个名为setup的函数。 1let g = hexi(512, 512, setup, thingsToLoad, load); 现在，您可以通过一个名为g的对象访问应用程序中的Hexi实例(不过，您可以给它取任何名称。我喜欢用“g”，因为它代表“game”，而且打字很短。 hexi函数有5个参数，尽管只需要前3个参数。 画布宽度 画布高度 setup函数 你在上面定义的thingsToLoad数组。可选 load函数。可选 如果您跳过最后两个参数，Hexi将跳过加载过程并直接跳转到setup函数。 可选地设置游戏逻辑循环应该运行的每秒帧数。(精灵将被独立地呈现，并进行插值，达到60 fps)如果不设置fps, Hexi将默认为60 fps。 1g.fps = 30; 设置一个低于60的fps会给你带来更多的性能开销，你的游戏也会看起来很棒。 您还可以选择添加边框并设置背景颜色。 12g.border = \"2px red dashed\";g.backgroundColor = 0x000000; 如果你想要缩放和对齐游戏屏幕到最大的浏览器窗口大小，你可以使用scaleToWindow方法。 1g.scaleToWindow(); 最后，调用start方法使Hexi运行 1g.start(); 这是很重要的!如果不调用start方法，Hexi将不会启动! load函数，在加载时运行如果您在初始化时提供了一个名为load的函数，您可以显示一个加载栏并加载进度信息。只需创建一个名为load的函数，如下所示: 1234567891011function load()&#123; //显示当前正在加载的文件 console.log(`loading: $&#123;g.loadingFile&#125;`); //显示当前加载的文件的百分比 console.log(`progress: $&#123;g.loadingProgress&#125;`); //添加可选的加载条 g.loadingBar();&#125; setup函数，初始化并创建游戏对象现在您已经启动了Hexi，并加载了所有的文件，您可以开始制作东西了!这在setup函数中发生。如果您有任何对象或变量要跨多个函数使用，请在setup函数之外定义它们，如下所示: 12345678//These things will be used in more than one functionlet cats, message;//Use the `setup` function to create thingsfunction setup()&#123; //... create things here! ...&#125; 让我们看看安装函数中的代码是如何工作的。我们要做猫——很多的猫!-所以创建一个叫cats的分组来把它们放在一起是很有用的。 1cats = g.group(); 在快速启动项目中，你可以用鼠标(或触摸)轻击屏幕来制作一个新的猫。所以，我们需要一个能为我们产生新的猫精灵的函数。(精灵是交互图形，你可以在屏幕上进行动画和移动。)Hexi允许您使用sprite方法创建一个新的精灵。只要为精灵提供您想要使用的文件名。应该使用addChild方法将创建的每个新的cat精灵定位并添加到cats组中。我们还希望猫用呼吸法使它的鳞片动起来，用breathe方法使它的透明度动起来。一个叫做makeCats的函数可以做到这一切。makeCats有两个参数:x和y的位置，相对于屏幕左上角，你希望猫出现的位置。 123456789101112131415161718192021222324252627let makeCat = (x, y) =&gt; &#123; //Create the cat sprite. Supply the `sprite` method with //the name of the loaded image that should be displayed let cat = g.sprite(\"images/cat.png\"); //Set the cat's position cat.setPosition(x, y); //You can alternatively set the position my modifying the sprite's `x` and //`y` properties directly, like this //cat.x = x; //cat.y = y; //Add some optional tween animation effects from the Hexi's //built-in tween library (called Charm). `breathe` makes the //sprite scale in and out. `pulse` oscillates its transparency g.breathe(cat, 2, 2, 20); g.pulse(cat, 10, 0.5); //Set the cat's velocity to a random number between -10 and 10 cat.vx = g.randomInt(-10, 10); cat.vy = g.randomInt(-10, 10); //Add the cat to the `cats` group cats.addChild(cat);&#125;; (在示例文件夹中的tweening示例中，您可以了解更多关于breathe和pulse方法如何工作以使cat具有动画效果的信息。) 我们还需要创建一个文本精灵来显示”Tap for cats!”我们可以使用Hexi的text方法。 1message = g.text(\"Tap for cats!\", \"38px puzzler\", \"red\"); text方法的参数是您想要显示的文本、字体大小和家族以及颜色(您可以使用任何HTML/CSS颜色字符串值、RGBA或HSLA值)。 使用Hexi的putCenter方法将文本居中 stage是什么?它是所有Hexi精灵在第一次创建时都属于的根容器。 您还可以使用putLeft、putRight、putTop或putBottom方法来帮助您对齐相对于其他对象的对象。这些方法的可选的第2和第3个参数定义x和y偏移量，这有助于您微调定位。 因为我们希望文本消息围绕中心点旋转，所以我们必须将其pivotX和pivotY值设置为0.5。 12message.pivotX = 0.5;message.pivotY = 0.5; 0.5表示“精灵的中心” 您也可以使用这种替代语法来设置轴心点: 1message.setPivot(0.5, 0.5); 我们需要一些方法来告诉Hexi，当屏幕被点击或点击时，创建一个新的猫。我们还希望文本信息告诉我们当前屏幕上有多少只猫。Hexi有一个内建的指针对象和一个tap方法，我们可以通过编程来帮助我们做到这一点 12345678g.pointer.tap = () =&gt; &#123; //Supply `makeCat` with the pointer's `x` and `y` coordinates. makeCat(g.pointer.x, g.pointer.y); //Make the `message.content` display the number of cats message.content = `$&#123;cats.children.length&#125;`;&#125;; 我们还想要加载的音乐文件开始播放。我们可以使用Hexi的声音方法访问音乐声音对象。使用声音对象的循环方法使其连续循环，并使用play立即开始播放。 123let music = g.sound(\"sounds/music.wav\");music.loop = true;music.play(); 我们现在已经把一切都安排好了!这意味着我们已经完成了应用程序的设置状态，现在可以切换到play。如何做到这一点: 1g.state = play; play状态是一个在循环中运行的函数，它是我们所有应用程序逻辑的所在。下面我们来看看它是如何工作的。 play函数:循环应用程序逻辑Hexi应用程序中最后需要的就是一个play函数。 1234function play() &#123; //All this code will run in a loop&#125; play函数在一个连续循环中被调用，无论您设置什么fps(每秒帧数)值。这是您的游戏逻辑循环。(渲染循环将由Hexi在后台运行，在您的系统可以处理的最大fps中。)您可以使用pause方法随时暂停Hexi的游戏循环，并使用resume方法重新启动它。(查看Flappy Fairy 项目，了解如何使用pause和resume来管理状态复杂的应用程序。) Quick Start项目的play功能只做两件事:它使文本旋转，并在屏幕上移动和反弹猫。这是整个play函数。 12345678910111213141516function play() &#123; //Rotate the text message.rotation += 0.1; //Loop through all of the cats to make them move and bounce off the //edges of the stage cats.children.forEach(cat =&gt; &#123; //让猫从屏幕边缘反弹 let collision = g.contain(cat, g.stage, true); //Move the cat g.move(cat); &#125;);&#125; 这是所有!与我们在设置函数中所做的所有工作相比，play函数实际上什么都不做!但是它是如何工作的呢? 它首先通过将消息文本精灵的rotation(旋转)属性更新0.1弧度，使文本围绕中心旋转。 1message.rotation += 0.1; 由于这个新的旋转值被应用到一个连续循环内的旧旋转值中，它逐渐增加了值并使文本旋转。 接下来，代码将遍历cat组的子数组中的所有精灵。 123cats.children.forEach(cat =&gt; &#123; //Loop through each `cat` sprite in the `chidren` array&#125;); 所有的Hexi组都有一个名为children的数组，它告诉你它们包含哪些精灵。无论何时使用addChild方法向组添加精灵，精灵都会被添加到组的子数组中。Hexi的根容器，叫做stage，它还有一个子数组，它包含了你的Hexi应用程序中的所有精灵和组。即使sprite对象也有一个子数组，这意味着您可以使用addChild与其他精灵分组来创建复杂的游戏对象。 当代码循环遍历每只猫时，它首先检查猫是否触碰了屏幕的边缘，如果触碰了，它会朝相反的方向反弹。Hexi contain方法可以帮助我们做到这一点。 1let collision = g.contain(cat, g.stage, true); 将第三个参数设置为true是导致猫反弹的原因 猫在move方法的帮助下在屏幕上移动。 1g.move(cat); move方法通过其vx和vy速度值更新精灵的位置。(所有的Hexi精灵都有vx和vy值，初始化为0)。通过向move提供一个由逗号分隔的精灵列表，您可以一次移动多个精灵。您甚至可以为它提供包含您想要移动的所有精灵的数组。以下是移动实际上在幕后所做的: 12cat.x += cat.vx;cat.y += cat.vy; 这就是一切!这就是关于Quick Start应用程序的所有知识，以及关于Hexi所需的几乎所有知识! 把它进一步使用这个基本的Hexi架构，您可以创建任何东西。只需将Hexi的状态属性设置为任何其他函数，以切换应用程序的行为。方法如下: 1g.state = anyStateFunction; 状态只是普通的旧JavaScript函数!很简单! 根据需要编写尽可能多的状态函数。如果是一个小项目，您可以将所有这些功能保存在一个文件中。但是，对于一个大项目，在需要时从外部JS文件加载函数。使用您喜欢的任何模块系统，如ES6模块、CommonJS、AMD或旧的HTML &lt;script&gt;标签。这个简单的架构模型可以扩展到任何大小，并且是您需要知道的唯一的体系结构模型。保持简单，保持快乐! 现在您已经大致了解了Hexi是如何工作的，请阅读教程来深入了解细节。 教程我们要做的第一个游戏是一个简单的对象收集和敌人躲避游戏叫做寻宝猎人。在web浏览器中打开文件01_treasurehunter.html。(您可以在Hexi的教程文件夹中找到它，您需要在webserver中运行它)。如果您不想费事设置一个webserver，请使用一个文本编辑器，比如方括号，它将自动为您启动一个方括号(请参阅方括号的文档)。 游戏入口 (按照上面的链接来玩这个游戏。)使用键盘移动资源管理器(蓝色方块)，收集宝藏(黄色方块)，避开怪物(红色方块)，到达出口(绿色方块)。是的，你现在必须发挥你的想象力。 以下是完整的JavaScript源代码: !寻宝猎人源码 不要被它表面上的简单所迷惑。寻宝者包含了游戏所需的一切: 交互性 碰撞 精灵 游戏循环 场景 游戏逻辑 “Juice” (以声音的形式) (什么果汁?请观看本视频并阅读本文，以了解这一游戏设计要素。 如果你能做一个简单的游戏，如寻宝游戏，你几乎可以做任何其他类型的游戏。是的,真的!从寻宝人到Skyrim或塞尔达只是很多小步骤的事情;添加更多的细节。你想要加多少细节取决于你自己。 在本教程的第一阶段，您将了解如何制作基本的寻宝游戏，然后我们将添加一些有趣的特性，如图像和字符动画，这将使您全面了解Hexi如何工作。 如果你是一个经验丰富的游戏程序员和快速的自我启动者，你可能会发现在Hexi的例子文件夹里的代码是一个更有效率的开始学习的地方——看看它。示例文件夹中的完整注释代码还详细说明了这些教程中没有涉及的特性的具体和高级用法。当您完成这些教程的学习后，这些示例将带您进入下一个阶段。 设置HTML容器页面在开始使用JavaScript编程之前，需要设置一个最小的HTML容器页面。HTML页面加载hexi.min.js是唯一需要使用Hexi所有特性的文件。它还装载了treasureHunter.js文件，即包含所有游戏代码的JavaScript文件。 12345678910&lt;!doctype html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Treasure hunter&lt;/title&gt;&lt;body&gt;&lt;!-- Hexi --&gt;&lt;script src=\"../bin/hexi.min.js\"&gt;&lt;/script&gt;&lt;!-- Main application file --&gt;&lt;script src=\"bin/treasureHunter.js\"&gt;&lt;/script&gt;&lt;/body&gt; 这是有效的HTML5文档所需的HTML代码的最小数量。 文件路径在您的系统上可能不同，这取决于您如何设置项目文件结构。 初始化Hexi下一步是编写一些JavaScript代码，根据指定的一些参数初始化和启动Hexi。下面这段代码初始化了一个屏幕大小为512×512像素的游戏。它还从sounds文件夹预先加载chimes.wav声音文件。 12345678//Initialize Hexi and load the chimes sound filelet g = hexi(512, 512, setup, [\"sounds/chimes.wav\"]);//Scale the game canvas to the maximum size in the browserg.scaleToWindow();//Start the Hexi engine.g.start(); 你可以看到，hexi函数的结果被分配给一个叫做g的变量。 1let g = hexi(//... 现在，无论何时你想在游戏中使用Hexi的任何自定义方法或对象，只要在其前面加上g。(g很好，很短，很容易记住;g = “game”) 在本例中，Hexi创建一个大小为512×512像素的画布元素。由前两个参数指定: 1512, 512, setup, 第三个参数setup意味着只要Hexi初始化，它就应该在你的游戏代码中查找并运行一个叫做setup的函数。在setup函数中，任何代码都完全取决于您，您将很快看到如何使用它来初始化一个游戏。(你不必调用这个函数setup，你可以使用任何你喜欢的名字) Hexi允许你用一个可选的第4个参数预加载游戏资产，它是一个文件名数组。在第一个示例中，您只需要预加载一个文件:chimes.wav，您可以看到将chimes.wav的完整文件路径作为一个字符串在初始化数组中列出: 1[\"sounds/chimes.wav\"] 您可以在这里列出任意数量的游戏资产，包括图像、字体和JSON文件。在运行任何游戏代码之前，Hexi将为您加载所有这些资产。 Hexi实现了Pixi的超级资源加载器。您可以直接通过Hexi的loader属性访问加载器，您可以通过resources属性访问资源。或者,直接使用PIXI.loader，如果你想。您可以在这里了解更多关于Pixi的加载程序是如何工作的。 我们希望游戏画布能够扩展到浏览器窗口的最大大小，以便显示尽可能大的内容。我们可以使用一个叫做scaleToWindow的有用方法来为我们做这个。 1g.scaleToWindow(); scaleToWindow将会在你的游戏中找到最适合的。长、宽的游戏屏幕垂直居中。高或方的屏幕水平居中。如果您想指定您自己的浏览器背景颜色来边框游戏，请提供scaleToWindow的参数，如下所示: 1g.scaleToWindow(\"seaGreen\"); 最后你需要做的是调用河西的start方法 1g.start(); 这是打开Hexi引擎的开关 定义你的全局变量在Hexi开始后，声明游戏函数需要使用的所有变量 12let dungeon, player, treasure, enemies, chimes, exit, healthBar, message, gameScene, gameOverScene; 因为它们不包含在函数中，所以这些变量是“全局的”，因为你可以在所有的游戏函数中使用它们。(它们不一定是“全局的”，因为它们驻留在全局JavaScript名称空间中。如果您想确保它们不存在，那么将所有JavaScript代码封装在一个封闭的函数中，以将其与全局空间隔离开来。或者，如果您想用一种奇特的方式，使用JavaScript ES6/2015模块或类来执行本地范围。 用setup函数初始化游戏只要Hexi启动，它就会在你的游戏代码中查找并运行一个叫setup的函数(或者你想给这个函数起的其他名字)。setup函数只运行一次，允许您为您的游戏执行一次设置任务。它是创建和初始化对象、创建精灵、游戏场景、填充数据数组或解析加载的JSON游戏数据的好地方。 这是《寻宝猎人》中setup函数的简要鸟瞰视图，以及它执行的任务 123456789101112131415function setup() &#123; //Create the `chimes` sound object //Create the `gameScene` group //Create the `exit` door sprite //Create the `player` sprite //Create the `treasure` sprite //Make the enemies //Create the health bar //Add some text for the game over message //Create a `gameOverScene` group //Assign the player's keyboard controllers //set the game state to `play` g.state = play;&#125; 最后一行代码g.state = play可能是最重要的，因为它启动了play函数。play函数在一个循环中运行所有的游戏逻辑。但是在我们看它如何工作之前，让我们看看setup函数中的特定代码是做什么的。 创建chimes声音对象从上面的代码中可以看到，我们在游戏中预装了一个名为chimes.wav的声音文件。在你可以在游戏中使用它之前，你必须使用Hexi的sound方法来引用它，比如: 1chimes = g.sound(\"sounds/chimes.wav\"); 创建游戏场景Hexi有一个有用的方法叫做group，它可以让你把游戏对象分组在一起，这样你就可以把它们作为一个单元来使用。组用于将称为 精灵 的特殊对象分组(您将在下一节中了解这些对象)。但它们也被用来制作游戏场景。 《寻宝猎人》使用了两个游戏场景:游戏主游戏gameScene和游戏结束时显示的gameOverScene。以下是使用group方法制作gameScene的方式: 1gameScene = g.group(); 创建组之后，可以使用addChild方法向gameScene添加精灵(游戏对象)。 1gameScene.addChild(anySprite); 或者，您可以使用add方法一次添加多个精灵，如下所示: 1gameScene.add(spriteOne, spriteTwo, spriteThree); 或者，如果你喜欢，你可以在你完成所有的精灵之后创建游戏场景，然后用一行代码将所有的精灵分组，如下所示: 1gameScene = g.group(spriteOne, spriteTwp, spriteThree); 在前面的示例中，您将看到一些如何向组添加精灵的不同示例。 但是什么是精灵，你是怎么做的呢? 制作精灵精灵是任何游戏中最重要的元素。精灵只是你可以用特殊属性控制的图形(形状或图像)。你能在游戏中看到的一切，比如游戏角色、对象和背景，都是精灵。Hexi允许你制作5种基本的精灵:矩形、圆形、直线、文本和精灵(基于图像的精灵)。你几乎可以用这些基本的精灵类型制作任何2D动作游戏。(如果还不够，还可以定义自己的自定义精灵类型。)第一个版本的宝藏猎人只使用矩形精灵。你可以做一个这样的矩形精灵: 123456789let box = g.rectangle( widthInPixels, heightInPixels, \"fillColor\", \"strokeColor\", lineWidth, xPosition, yPosition); 你可以用Hexi circle方法做一个圆形精灵: 12345678let ball = g.circle( diameterInPixels, \"fillColor\", \"strokeColor\", lineWidth, xPosition, yPosition); 仅仅使用矩形和圆形精灵来设计一个新游戏的原型通常很有用，因为这样可以帮助你以一种纯粹的、基本的方式专注于游戏的机制。这就是《寻宝猎人》的第一个版本。下面是创建出口、玩家和宝物精灵的setup函数的代码。 12345678910111213141516171819202122232425262728//The exit doorexit = g.rectangle(48, 48, \"green\");exit.x = 8;exit.y = 8;gameScene.addChild(exit);//The player spriteplayer = g.rectangle(32, 32, \"blue\");player.x = 68;player.y = g.canvas.height / 2 - player.halfHeight;gameScene.addChild(player);//Create the treasuretreasure = g.rectangle(16, 16, \"gold\");//Position it next to the left edge of the canvastreasure.x = g.canvas.width - treasure.width - 10;treasure.y = g.canvas.height / 2 - treasure.halfHeight;//Alternatively, you could use Ga's built in convience method//called `putCenter` to postion the sprite like this://g.stage.putCenter(treasure, 208, 0);//在宝藏上创建一个“pickedUp”属性，帮助我们弄清楚这个宝藏是否被玩家捡走了treasure.pickedUp = false;//Add the treasure to the `gameScene`gameScene.addChild(treasure); 注意，在创建每个精灵之后，都使用addChild将其添加到gameScene中。以下是上述代码产生的结果: 让我们进一步了解这些精灵是如何定位在画布上的。 定位精灵所有精灵都有x和y属性，您可以使用它们来精确地定位画布上的精灵。x和y值指的是相对于画布左上角的精灵像素坐标。左上角的x和y值为0。这意味着你给精灵赋值的任何正的x和y值会将它们与那个角点的位置分别放在左边(x)和下面(y)。例如，这是位置在出口门(绿色方块)的代码。 12exit.x = 8;exit.y = 8; 您可以看到，这段代码将门设置为右8像素，在画布左上角以下8像素。正x值将精灵定位在画布左边缘的右边。正y值将它们放置在画布的上边缘以下。 精灵也有width和height属性，以像素为单位告诉你它们的宽度和高度。如果你想知道精灵的一半宽度或一半高度是多少，可以使用halfWidth和halfHeight。 Hexi也有一些方便的方法，帮助您快速定位精灵相对于其他精灵的位置:putTop、putRight、putBottom、putLeft和putCenter。例如，下面是位于宝藏精灵(黄金盒)上面的代码行。代码将宝藏放置在画布右边缘左边的26像素处，并将其垂直居中。 12treasure.x = g.canvas.width - treasure.width - 10;treasure.y = g.canvas.height / 2 - treasure.halfHeight; 这是一大堆复杂的定位代码。相反，您可以使用Hexi的内置putCenter方法来实现同样的效果: 1g.stage.putCenter(treasure, 220, 0); (stage)舞台 是什么?它是所有精灵的根容器，与画布的尺寸完全相同。你可以把舞台想象成一个巨大的、看不见的精灵，和画布一样大，它包含了游戏中的所有精灵，以及那些精灵可能被分组的任何容器(比如gameScene)。putCenter的工作原理是将宝物放在舞台中心，然后将其x位置偏移220像素。以下是使用putCenter的格式: 1anySprite.putCenter(anyOtherSprite, xOffset, yOffset); 您可以用同样的方式使用其他put方法。例如，如果您想将一个精灵直接定位到另一个精灵的左边，而没有任何偏移，您可以使用putLeft，如下所示: 1spriteOne.putLeft(spriteTwo); 这将把spriteTwo直接放在spriteOne的左边，并垂直对齐它。 分配动态属性在我们继续之前，您需要注意一个小细节。创建精灵的代码还向宝藏精灵添加了一个pickedUp属性: 1treasure.pickedUp = false; 您将看到我们将如何在游戏逻辑中使用treasure.pickedUp，以帮助我们确定游戏的进度。如果需要，可以动态地将任何自定义属性或方法分配给这样的精灵。 创建敌人精灵寻宝游戏中有6个敌人精灵(红色方块)。它们水平间隔，但有随机的初始垂直位置。所有的敌人精灵都是在一个for循环中使用这个代码在setup函数中创建的: 12345678910111213141516171819202122232425262728293031323334353637383940414243//Make the enemieslet numberOfEnemies = 6, spacing = 48, xOffset = 150, speed = 2, direction = 1;//An array to store all the enemiesenemies = [];//Make as many enemies as there are `numberOfEnemies`for (let i = 0; i &lt; numberOfEnemies; i++) &#123; //Each enemy is a red rectangle let enemy = g.rectangle(32, 32, \"red\"); //Space each enemey horizontally according to the `spacing` value. //`xOffset` determines the point from the left of the screen //at which the first enemy should be added. let x = spacing * i + xOffset; //Give the enemy a random y position let y = g.randomInt(0, g.canvas.height - enemy.height); //Set the enemy's direction enemy.x = x; enemy.y = y; //Set the enemy's vertical velocity. `direction` will be either `1` or //`-1`. `1` means the enemy will move down and `-1` means the enemy will //move up. Multiplying `direction` by `speed` determines the enemy's //vertical direction enemy.vy = speed * direction; //Reverse the direction for the next enemy direction *= -1; //Push the enemy into the `enemies` array enemies.push(enemy); //Add the enemy to the `gameScene` gameScene.addChild(enemy);&#125; 这段代码产生的结果如下: 代码通过Hexi的randomInt方法给每个敌人一个随机的y位置: 1let y = g.randomInt(0, g.canvas.height - enemy.height); randomInt将给出参数中提供的任意两个整数之间的随机数。(如果你需要一个随机小数，可以使用randomFloat来代替)。 所有的精灵都有称为vx和vy的属性。它们决定了精灵在水平方向(vx)和垂直方向(vy)移动的速度和方向。《寻宝人》中的敌人只是上下移动，所以他们只需要一个vy值。它们的vy是速度(2)乘以方向(1或-1) 1enemy.vy = speed * direction; 如果方向是1，敌人的vy就是2。这意味着敌人将以每帧2像素的速度移动屏幕。如果方向是-1，敌人的速度是-2。这意味着敌人将以每帧2像素的速度在屏幕上移动。 当敌人的vy被设置好后，方向就会颠倒，这样下一个敌人就会朝相反的方向移动 1direction *= -1; 您可以看到，创建的每个敌人都被推进到一个称为enemies的数组中 1enemies.push(enemy); 在后面的代码中，您将看到我们将如何访问这个数组中的所有敌人，以确定他们是否正在触摸播放器。 健康条你会注意到当玩家触碰到一个敌人时，屏幕右上角的健康条的宽度会减小。 这个健康条是怎么做的?它只是两个相同位置的矩形精灵:一个黑色的矩形在后面，一个绿色的矩形在前面。它们被组合在一起组成一个叫做healthBar的单一化合物sprite。然后将健康条添加到gameScene中。 12345678910111213141516//Create the health barlet outerBar = g.rectangle(128, 16, \"black\"), innerBar = g.rectangle(128, 16, \"yellowGreen\");//Group the inner and outer barshealthBar = g.group(outerBar, innerBar);//Set the `innerBar` as a property of the `healthBar`healthBar.inner = innerBar;//Position the health barhealthBar.x = g.canvas.width - 148;healthBar.y = 16;//Add the health bar to the `gameScene`gameScene.addChild(healthBar); 您可以看到一个名为inner的属性被添加到healthBar。它只是引用了innerBar(绿色矩形)，以便以后可以方便地访问它。 1healthBar.inner = innerBar; 你不需要这么做;但是,嘿,为什么不呢!这意味着如果你想控制内栏的宽度，你可以写一些流畅的代码，如下所示: 1healthBar.inner.width = 30; 这是相当整洁和可读的，所以我们将保持它! 游戏结束的场景如果玩家的生命值降至零，或者玩家设法将宝物带到出口，游戏结束，游戏在屏幕上显示。现场游戏只是显示“你赢了”或“你输了”的一些文本，这取决于结果。 这使得怎么样?文本由文本精灵构成。 123let anyText = g.text( \"Hello!\", \"CSS font properties\", \"fillColor\", xPosition, yPosition); 在上面的示例中，第一个参数“Hello!”是要显示的文本内容。使用content属性稍后更改文本精灵的内容。 1anyText.content = \"Some new content\"; 以下是如何在setup函数中创建消息文本的游戏 1234//Add some text for the game over messagemessage = g.text(\"Game Over!\", \"64px Futura\", \"black\", 20, 20);message.x = 120;message.y = g.canvas.height / 2 - 64; 接下来，创建一个名为gameOverScene的新组。消息文本被添加到其中。gameOverScene的可视属性设置为false，以便在游戏开始时不可见。 1234gameOverScene = g.group(message);//Make the `gameOverScene` invisible for nowgameOverScene.visible = false; 在游戏结束时，我们将设置游戏场景的可见属性为true以显示文本消息。我们还将gameScene的可见属性设置为false，以便所有的游戏精灵都隐藏起来。 键盘交互你用键盘箭头键控制玩家(蓝色方块)。Hexi有一个内置的箭头控制arrowControl方法，让您快速添加箭头键的交互性游戏。提供要作为第一个参数移动的精灵，以及作为第二个参数移动的每帧像素数。以下是如何使用arrowControl方法来帮助玩家在按下箭头键时每帧移动5个像素。 1g.arrowControl(player, 5); 使用arrowControl是实现键盘交互性的一种简单而快速的方法，但是通常需要更好地控制按下键时发生的情况。Hexi有一个内置的keyboard方法，你可以定义自定义键。 1let customKey = g.keyboard(asciiCode); 为要作为第一个参数使用的键提供ascii码号 所有这些键都有可定义的press和release方法。以下是如何可选地创建和使用这些键盘对象来帮助移动宝藏猎人中的玩家角色。(您将在setup函数中定义此代码): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Create some keyboard objects using Hexi's `keyboard` method.//You would usually use this code in the `setup` function.//Supply the ASCII key code value as the single argumentlet leftArrow = g.keyboard(37), upArrow = g.keyboard(38), rightArrow = g.keyboard(39), downArrow = g.keyboard(40);//Left arrow key `press` methodleftArrow.press = () =&gt; &#123; //Change the player's velocity when the key is pressed player.vx = -5; player.vy = 0;&#125;;//Left arrow key `release` methodleftArrow.release = () =&gt; &#123; //If the left arrow has been released, and the right arrow isn't down, //and the player isn't moving vertically: //Stop the player if (!rightArrow.isDown &amp;&amp; player.vy === 0) &#123; player.vx = 0; &#125;&#125;;//The up arrowupArrow.press = () =&gt; &#123; player.vy = -5; player.vx = 0;&#125;;upArrow.release = () =&gt; &#123; if (!downArrow.isDown &amp;&amp; player.vx === 0) &#123; player.vy = 0; &#125;&#125;;//The right arrowrightArrow.press = () =&gt; &#123; player.vx = 5; player.vy = 0;&#125;;rightArrow.release = () =&gt; &#123; if (!leftArrow.isDown &amp;&amp; player.vy === 0) &#123; player.vx = 0; &#125;&#125;;//The down arrowdownArrow.press = () =&gt; &#123; player.vy = 5; player.vx = 0;&#125;;downArrow.release = () =&gt; &#123; if (!upArrow.isDown &amp;&amp; player.vx === 0) &#123; player.vy = 0; &#125;&#125;; 您可以看到玩家的vx和vy属性的值根据按下或释放的键而改变。一个正值的vx值将使玩家向右移动，一个负值将使玩家向左移动。一个正值的vy值会让玩家向下移动，一个负值会让玩家向上移动。 第一个参数是要控制的精灵:player。第二个参数是精灵移动每一帧的像素数:5。最后四个参数是顶键、右键、底键和左键的ascii码。(你可以记住这一点，因为它们的顺序是顺时针的，从顶部开始。) 设置游戏状态游戏状态 是Hexi当前运行的函数。当Hexi第一次启动时，它会运行setup函数(或者你在Hexi的构造函数参数中指定的其他函数)。如果您想要更改游戏状态，请为Hexi的状态属性分配一个新函数。方法如下: 1g.state = anyFunction; 在《寻宝游戏》中，当设置功能完成后，游戏状态设置为: 1g.state = play; 这使得Hexi查找并运行一个叫做play的函数。默认情况下，分配给游戏状态的任何函数都将以每秒60帧的速度连续循环运行。(您可以通过设置Hexi的fps属性随时改变帧速率)。游戏逻辑通常在一个连续循环中运行，这就是游戏循环。Hexi为您处理循环管理，所以您不必担心它是如何工作的。 (如果您好奇，Hexi使用一个requestAnimationFrame循环，它具有一个固定的逻辑时间步长和可变渲染时间。它也做雪碧位置插值，以消除任何不一致的峰值在帧率。它运行的是秘密的冰沙，所以你可以使用它的任何属性来调整你的Hexi应用游戏循环以获得最好的效果。 如果您需要暂停循环，只需使用Hexi的暂停方法，如下所示: 1g.pause(); 您可以使用resume方法再次启动游戏循环，如下所示: 1g.resume(); 现在让我们来看看宝藏猎人的游戏功能是如何工作的。 游戏逻辑与play函数循环正如您刚刚学到的，play函数中的所有内容都是在一个连续循环中运行的。 123function play() &#123; //This code loops from top to bottom 60 times per second &#125; 这就是所有游戏逻辑发生的地方。这是有趣的部分，让我们看看play函数中的代码是做什么的。 移动玩家精灵寻宝者在游戏中使用Hexi的move方法来移动精灵。 1g.move(player); 这相当于这样写代码: 12player.x += player.vx;player.y += player.vy; 它通过添加vx和vy速度值来更新玩家的x和y位置。使用move可以省去输入和查看这个标准的样板代码的麻烦。 您还可以通过提供数组作为参数来移动一个完整的精灵数组。 1g.move(arrayOfSprites); 现在你可以很容易地移动玩家，但是当玩家到达屏幕边缘时会发生什么? 包含屏幕边界内的精灵使用Hexi’s contains方法将精灵保持在屏幕的边界内 1g.contain(player, g.stage); 第一个参数是要包含的精灵，第二个参数是任何带有x、y、width和height属性的JavaScript对象。 如前所述，stage是所有河西精灵的根容器对象，它的宽度和高度与画布相同 但是，您也可以使用自定义对象来提供包含方法，以执行相同的操作。方法如下: 123456789g.contain( player, &#123; x: 0, y: 0, width: 512, height: 512 &#125;); 这将包含玩家精灵到由对象的维度定义的区域。如果您想精确地调整对象应该包含的区域，这将非常方便。 contain有一个特别有用的特性。如果精灵到达一个包含边，contains将返回一个JavaScript集，告诉您它到达了哪个边:“top”、“right”、“bottom”或“left”。以下是如何使用这个特性来找出精灵在画布上触碰的边缘: 1234567891011121314let playerHitsEdges = g.contain(player, g.stage);if(playerHitsEdges) &#123; //Find out on which side the collision happened let collisionSide; if (playerHitsEdges.has(\"left\")) collisionSide = \"left\"; if (playerHitsEdges.has(\"right\")) collisionSide = \"right\"; if (playerHitsEdges.has(\"top\")) collisionSide = \"top\"; if (playerHitsEdges.has(\"bottom\")) collisionSide = \"bottom\"; //Display the result in a text sprite message.content = `The player hit the $&#123;collisionSide&#125; of the canvas`; &#125; 与敌人碰撞当玩家攻击被任何一个敌人时，健康栏的宽度会减少，玩家会变成半透明的。 这是如何工作的呢?Hexi有一整套有用的二维几何和基于瓷砖的碰撞检测方法。Hexi实现了Bump碰撞模块，所以Bump的所有碰撞方法都和Hexi一起工作。 寻宝游戏只使用其中一种碰撞方法: hitTestRectangle。它用两个矩形的精灵告诉你它们是否重叠。如果是，它将返回true;如果不是，则返回false。 1g.hitTestRectangle(spriteOne, spriteTwo); 下面是play函数中的代码如何使用hitTestRectangle检查任何敌人和玩家之间的冲突。 12345678910111213141516171819202122232425262728293031323334353637383940//Set `playerHit` to `false` before checking for a collisionlet playerHit = false;//Loop through all the sprites in the `enemies` arrayenemies.forEach(enemy =&gt; &#123; //Move the enemy g.move(enemy); //Check the enemy's screen boundaries let enemyHitsEdges = g.contain(enemy, g.stage); //If the enemy hits the top or bottom of the stage, reverse //its direction if (enemyHitsEdges) &#123; if (enemyHitsEdges.has(\"top\") || enemyHitsEdges.has(\"bottom\")) &#123; enemy.vy *= -1; &#125; &#125; //Test for a collision. If any of the enemies are touching //the player, set `playerHit` to `true` if (g.hitTestRectangle(player, enemy)) &#123; playerHit = true; &#125;&#125;);//If the player is hit...if (playerHit) &#123; //Make the player semi-transparent player.alpha = 0.5; //Reduce the width of the health bar's inner rectangle by 1 pixel healthBar.inner.width -= 1;&#125; else &#123; //Make the player fully opaque (non-transparent) if it hasn't been hit player.alpha = 1;&#125; 这段代码创建了一个名为playerHit的变量，该变量在forEach循环检查所有敌人是否发生冲突之前被初始化为false。 1let playerHit = false; (因为play函数每秒运行60次，所以playerHit在每个新帧中将被重新初始化为false) 如果hitTestRectangle返回true, forEach循环将playerHit设置为true 123if(g.hitTestRectangle(player, enemy)) &#123; playerHit = true;&#125; 如果玩家被击中，代码会将alpha值设置为0.5，使玩家半透明。它还可以将healthBar的内部精灵的宽度减少1像素。 12345678910111213if(playerHit) &#123; //Make the player semi-transparent player.alpha = 0.5; //Reduce the width of the health bar's inner rectangle by 1 pixel healthBar.inner.width -= 1;&#125; else &#123; //Make the player fully opaque (non-transparent) if it hasn't been hit player.alpha = 1;&#125; 您可以将精灵的alpha属性设置为0(完全透明)到1(完全不透明)之间的任何值。0.5的值使它成为半透明 (Alpha是一个久经考验的平面设计术语，只意味着透明) 这段代码还使用move方法来移动敌人，并包含在画布中。代码还使用contain的返回值来确定敌人是在攻击画布的顶部还是底部。如果它击中顶部或底部，敌人的方向会在以下代码的帮助下颠倒: 12345678910//Check the enemy's screen boundarieslet enemyHitsEdges = g.contain(enemy, g.stage);//If the enemy hits the top or bottom of the stage, reverse//its directionif (enemyHitsEdges) &#123; if (enemyHitsEdges.has(\"top\") || enemyHitsEdges.has(\"bottom\")) &#123; enemy.vy *= -1; &#125;&#125; 将敌人的vy(垂直速度)值乘以- 1会使它朝相反的方向前进。这是一个非常简单的反弹效应。 碰撞的宝藏如果玩家触摸到宝藏(黄色方块)，钟声就会响起。然后玩家可以把宝物带到出口。宝藏集中在玩家身上，并随之移动。 这是play函数实现这些效果的代码 123456789101112131415//Check for a collision between the player and the treasureif (g.hitTestRectangle(player, treasure)) &#123; //If the treasure is touching the player, center it over the player treasure.x = player.x + 8; treasure.y = player.y + 8; if(!treasure.pickedUp) &#123; //If the treasure hasn't already been picked up, //play the `chimes` sound chimes.play(); treasure.pickedUp = true; &#125;;&#125; 您可以看到代码在if语句中使用hitTestRectangle来测试玩家和宝藏之间的冲突 1if (g.hitTestRectangle(player, treasure)) &#123; 如果这是真的，宝藏就集中在玩家身上 12treasure.x = player.x + 8;treasure.y = player.y + 8; 如果treasure.pickedUp是false，那么你知道宝藏还没有被取走，你可以播放钟声: 1chimes.play(); 除了播放Hexi的声音对象，你还可以使用更多的方法来控制它们:暂停、重新启动和播放。(使用playFrom从声音文件中的特定秒开始播放声音，如:soundObject.playFrom(5)。这将使声音从5秒开始播放。 您还可以通过在0和1之间分配值来设置声音对象的音量。以下是如何将音量设置为中等(50%)。 1soundObject.volume = 0.5; 您可以通过将-1(左扬声器)值设置为1(右扬声器)来设置声音对象的pan。泛音值为0时，两个扬声器的音量都相等。以下是如何将pan设置为在左扬声器中稍微突出一些。 1soundObject.pan = -0.2; 如果您想要使一个声音连续重复，请将其loop属性设置为true。 1soundObject.loop = true; Hexi实现了Sound.js模块来控制声音，因此您可以在Hexi应用程序中使用Sound.js的任何属性和方法。 因为您不想在拾取宝藏后再播放一次钟声，所以代码在声音播放后将treasure.pickedUp设置为true。 1treasure.pickedUp = true; 现在玩家拿起了宝物，你怎么能检查游戏的结局呢? 结束游戏游戏有两种结局。玩家的健康状况可能会耗尽，在这种情况下，比赛就会失败。或者，玩家可以成功地把宝物带到出口，这样游戏就赢了。如果满足这两个条件中的任何一个，游戏的状态将被设置为结束，消息文本的内容将显示结果。下面是play函数中的最后一段代码: 12345678910111213//Does the player have enough health? If the width of the `innerBar`//is less than zero, end the game and display \"You lost!\"if (healthBar.inner.width &lt; 0) &#123; g.state = end; message.content = \"You lost!\";&#125;//If the player has brought the treasure to the exit,//end the game and display \"You won!\"if (g.hitTestRectangle(treasure, exit)) &#123; g.state = end; message.content = \"You won!\";&#125; 结束函数非常简单。它只是隐藏了gameScene并显示了gameOverScene。 1234function end() &#123; gameScene.visible = false; gameOverScene.visible = true;&#125; 这就是寻宝猎人!在继续之前，尝试使用这些相同的技术从头开始制作您自己的游戏。当你准备好了，继续读下去! 使用图像在你的Hexi游戏中有三种主要的使用图像的方法 为每个精灵使用单独的图像文件 使用一个 纹理地图集 。这是一个单独的图像文件，包含游戏中每个精灵的子图像。图像文件附带一个匹配的JSON数据文件，该文件描述每个子图像的名称、大小和位置 使用tileset(也称为spritesheet)。这也是一个单一的图像文件，包括每个精灵的子图像。然而，与纹理图集不同，它没有一个描述精灵数据的JSON文件。相反，您需要使用JavaScript在游戏代码中指定每个精灵的大小和位置。在某些情况下，这可以比纹理图集有一些优势 这三种制作图像精灵的方法都使用了Hexi的sprite方法。这是使用它来制作图像精灵的最简单的方法。 1let imageSprite = g.sprite(\"images/theSpriteImage.png\"); 在下一节中，我们将使用图像精灵更新“宝藏猎人”，您将了解将图像添加到游戏中的三种方法。 这部分的所有图片都是由Lanea Zimmerman创作的。你可以在这里找到更多她的艺术作品。谢谢,Lanea ! 个人形象打开并播放下一个版本的宝藏猎人:02_treasureHunterImages.html(在教程文件夹中可以找到)它和第一个版本完全一样，但是所有的彩色方块都被图像所取代。 (点击，点击链接玩游戏。)看看源代码，你会发现游戏的逻辑和结构与游戏的第一个版本完全相同。唯一改变的是精灵的外表。这是如何做的呢? 加载图片文件游戏中的每个精灵都使用一个PNG图像文件。您将在教程的images子文件夹中找到所有的图像。 在使用它们制作精灵之前，您需要预先将它们加载到Hexi的资产中。最简单的方法是在第一次初始化引擎时，在Hexi的资产数组中列出图像名称及其完整的文件路径。创建一个名为thingsToLoad的数组，列出要加载的文件名。然后提供该数组作为hexi方法的第四个参数。方法如下: 123456789101112131415//An array that contains all the files you want to loadlet thingsToLoad = [ \"images/explorer.png\", \"images/dungeon.png\", \"images/blob.png\", \"images/treasure.png\", \"images/door.png\", \"sounds/chimes.wav\"];//Create a new Hexi instance, and start itlet g = hexi(512, 512, setup, thingsToLoad);//Start Hexig.start(); 如果在web浏览器中打开JavaScript控制台，就可以监视这些资产的加载进度 现在你可以在你的游戏代码中访问这些图像: 1g.image(\"images/blob.png\") 尽管预加载图像和其他资产是使它们进入游戏的最简单的方法，但是您也可以使用loader对象及其方法在任何其他时候加载资产。正如我前面提到的，加载程序只是运行在底层的Pixi加载程序的别名，您可以在这里了解如何使用它。 现在您已经将这些图像加载到游戏中，让我们看看如何使用它们来制作精灵。 用图片制作精灵使用sprite方法创建一个图像精灵，使用您之前了解的格式。下面介绍如何使用dungeon.png映像创建精灵。(dungeon.png是512×512像素的背景图像) 1dungeon = g.sprite(\"images/dungeon.png\"); 这是所有!现在，精灵不再显示为一个简单的彩色矩形，而是显示为一个512×512的图像。没有必要指定宽度或高度，因为Hexi根据图像的大小自动计算。您可以使用所有其他的精灵属性，如x、y、宽度和高度，就像使用普通矩形精灵一样。 下面是设置函数的代码，该函数创建了地牢背景、退出门、玩家和宝藏，并将它们全部添加到gameScene组。 123456789101112131415161718192021222324//The dungeon backgrounddungeon = g.sprite(\"images/dungeon.png\");//The exit doorexit = g.sprite(\"images/door.png\");exit.x = 32;//The player spriteplayer = g.sprite(\"images/explorer.png\");player.x = 68;player.y = g.canvas.height / 2 - player.halfWidth;//Create the treasuretreasure = g.sprite(\"images/treasure.png\");//Position it next to the left edge of the canvas//g.stage.putCenter(treasure, 208, 0);//Create a `pickedUp` property on the treasure to help us Figure//out whether or not the treasure has been picked up by the playertreasure.pickedUp = false;//Create the `gameScene` group and add the spritesgameScene = g.group(dungeon, exit, player, treasure); 作为对该代码原始版本的稍微更有效的改进，group创建了gameScene并在单个步骤中对精灵进行分组 看起来熟悉吗?没错，唯一改变的代码是创建精灵的行。这种模块化是Hexi的一个特性，它可以让你使用简单的形状创建快速的游戏原型，当你的游戏思想发展的时候，你可以很容易地把它换成详细的图片。游戏中的其余代码可以保持原样。 微调控制区域这个新版本的宝藏猎人有一个小的改进，那就是精灵被包含在地牢里的新方式。它们以一种自然地与艺术品的2.5D视角相匹配的方式被包含在其中，如这张屏幕截图中的绿色方块所示: 这是一个很容易修改的地方。您所需要做的就是提供包含一个定义包含矩形的大小和位置的自定义对象的包含方法。方法如下: 12345678g.contain( player, &#123; x: 32, y: 16, width: g.canvas.width - 32, height: g.canvas.height - 32 &#125;); 只需调整x、y、宽度和高度值，这样包含的区域对于您正在制作的游戏来说就显得自然了。 使用一个纹理地图集如果您正在开发一个大型、复杂的游戏，您将需要一种快速、高效的图像处理方法。纹理图谱可以帮助你做到这一点。一个纹理图集实际上是两个独立的文件，它们是紧密相关的: 一个PNG tileset图像文件，其中包含您希望在游戏中使用的所有图像。(tileset图像有时被称为spritesheet) 一个JSON文件，描述这些子图像在tileset中的大小和位置 使用纹理图集是一个很大的节省时间。您可以按任何顺序排列tileset的子图像，JSON文件将为您跟踪它们的大小和位置。这非常方便，因为这意味着子图像的大小和位置不会硬编码到游戏程序中。如果您对tileset做了更改，比如添加图像、调整它们的大小或删除它们，那么只需重新发布JSON文件，您的游戏将使用更新后的数据来正确显示图像。如果你要制作比一个小游戏更大的东西，你一定要使用纹理图集。 ileset JSON数据的实际标准是一种格式，这种格式由一种叫做纹理包装器的流行软件工具输出(纹理包装器的“基本”许可证是免费的)。即使您不使用纹理包装器，类似的工具如Shoebox以相同的格式输出JSON文件。让我们来看看如何使用它来制作一个纹理贴图，以及如何将它加载到游戏中。 准备的图片您首先需要为您的游戏中的每个图像提供单独的PNG图像。您已经为“寻宝者”找到了它们，所以您都已经设置好了。打开Texture Packer并选择{JS}配置选项。将你的游戏图像拖到它的工作区中。您还可以将纹理封隔器指向任何包含图像的文件夹。纹理封隔器将自动将图像排列在一个小块图像上，并为它们提供与原始图像文件名匹配的名称。默认情况下，它会给他们一个2像素的填充。 地图集中的每一个子图像都被称为帧。虽然只是一个大的图像，纹理图集有5帧。每个帧的名称都是它的原始PNG文件名:”dungeon.png”, “blob.png”, “explorer.png”, “treasure.png” 和 “door.png”。这些帧名用于帮助atlas引用每个子映像。 完成后，请确保数据格式设置为JSON(Hash)并单击Publish按钮。选择文件名和位置，并保存已发布的文件。您将得到一个PNG文件和一个JSON文件。在这个例子中，我的文件名是treasureHunter.json和treasureHunter.png。为了让你的生活更简单，只需将两个文件保存在项目的images文件夹中。(可以将JSON文件视为图像文件的额外元数据) Texture Packer使用起来可能会很麻烦，因为您需要使所有这些设置都正确，以便在不告诉您有错误的情况下正确地发布。并且，它将试图通过使用不支持免费版本的默认设置来欺骗您升级到付费版本。因此，您需要显式地关闭这些(正如我上面所描述的)，以使其工作没有错误。尽管如此，最后的努力还是值得的——所以如果你遇到不可能的困难，继续尝试并在这个资源库中发布一个问题吧! 加载纹理地图集要将纹理图集加载到游戏中，只需在初始化游戏时将JSON文件包含在Hexi的资产数组中。 1234567let thingsToLoad = [ \"images/treasureHunter.json\", \"sounds/chimes.wav\"];let g = hexi(512, 512, setup, thingsToLoad);g.scaleToWindow();g.start(); 这是所有!你不必加载PNG文件- Hexi在后台自动完成。只需告诉Hexi显示哪个tileset帧(子图像)就可以了。 如果你想用纹理图谱的框架来制作精灵，你可以这样做: 1anySprite = g.sprite(\"frameName.png\"); Ga将创建精灵，并显示纹理贴图中正确的图像。 以下是如何使用纹理图集框架创建寻宝游戏中的精灵: 1234567891011121314//The dungeon backgrounddungeon = g.sprite(\"dungeon.png\");//The exit doorexit = g.sprite(\"door.png\");exit.x = 32;//The player spriteplayer = g.sprite(\"explorer.png\");player.x = 68;player.y = g.canvas.height / 2 - player.halfWidth;//Create the treasuretreasure = g.sprite(\"treasure.png\"); Hexi知道这些是纹理地图集的帧名，而不是单独的图像，它直接显示它们来自tileset。 如果你需要在游戏中访问纹理地图集的JSON文件，你可以这样获取: 1jsonFile = g.json(\"jsonFileName.json\"); 查看教程文件夹中的treasureHunterAtlas.js文件，查看如何加载纹理图集并使用它制作精灵的工作示例。 外星人武装本系列教程中的下一个示例游戏是Alien Armada。你能在60个外星人着陆前摧毁他们并毁灭地球吗?点击下面的图片链接玩游戏: 使用箭头键移动并按空格键射击。随着游戏的进行，外星人越来越频繁地从屏幕顶端降落。游戏规则如下: 加载并使用自定义字体。 在加载游戏资产时显示加载进度条。 射击子弹。 创建具有多个图像状态的精灵。 生成随机的敌人。 从游戏中移除精灵。 显示一个游戏分数。 重置并重新启动游戏。 您将在教程文件夹中找到完整注释的外星无敌舰队源代码。请务必查看它，以便您能够在正确的上下文中看到所有这些代码。它的一般结构与《寻宝者》相同，并加入了这些新技术。让我们看看它们是如何实现的。 加载并使用自定义字体Alien Armada使用自定义字体emulogic.ttf显示屏幕右上角的分数。字体文件预先加载了初始化游戏的资产数组中的其余资产文件(声音和图像) 12345678910let thingsToLoad = [ \"images/alienArmada.json\", \"sounds/explosion.mp3\", \"sounds/music.mp3\", \"sounds/shoot.mp3\", \"fonts/emulogic.ttf\" //&lt;- The custom font];let g = hexi(480, 320, setup, thingsToLoad, load);g.scaleToWindow();g.start(); 要使用该字体，请在游戏的设置函数中创建一个文本精灵。text方法的第二个参数是一个字符串，描述字体的点大小和名称:“20px emulogic”。 1scoreDisplay = g.text(\"0\", \"20px emulogic\", \"#00FF00\", 400, 10); 您可以加载和使用TTF、OTF、TTC或WOFF格式的任何字体 加载进度条外星人无敌舰队装载了3个MP3音频文件:一个射击声，一个爆炸声和音乐。音乐声音的大小约为2 MB，所以在网络连接缓慢的情况下，这种声音需要几秒钟才能被加载。当这种情况发生时，玩家只能看到空白的画布，而外星人的无敌舰队则装载。有些玩家可能会认为游戏已经冻结，所以游戏会有帮助地实现一个加载栏来通知玩家资产正在加载。它是一个从左向右展开的蓝色矩形，并显示一个数字，告诉您目前加载的游戏资产的百分比 这是一个内置在Hexi引擎的特性。Hexi有一个可选的加载状态，在加载游戏资产时运行。在加载状态下，您可以决定要发生什么。您所需要做的就是编写一个函数，其中包含在加载资产时应该运行的代码，并告诉Hexi这个函数的名称。Hexi的引擎会自动在循环中运行这个函数，直到资产加载完成。 让我们来看看外星人无敌舰队是如何运作的。游戏代码告诉Hexi在加载状态下使用一个名为load的函数。它通过列出load作为Hexi的初始化构造函数的最后一个参数来实现这一点。(请在下面的代码中查找负载): 1let g = hexi(480, 320, setup, thingsToLoad, load); //&lt;- It's here! 这告诉Hexi在资产加载时在循环中运行load函数 这是来自外星舰队的load函数。它实现了一个loadingBar对象，它显示了正在扩展的blue bar和加载的文件的百分比。 123function load()&#123; g.loadingBar();&#125; 资产加载后，setup状态自动运行 您将在Hexi的core.js文件中找到loadingBar代码。这是一个非常简单的例子，如果您愿意，您可以使用它作为编写自定义加载动画的基础。您可以在load函数中运行任何您喜欢的代码，因此完全由您决定什么应该发生，什么在您的游戏加载时显示。 发射子弹你怎么能让大炮射出子弹? 当你按下空格键时，大炮向敌人发射子弹。子弹从炮塔的末端开始，以每帧7像素的速度在画布上移动。如果他们撞到外星人，外星人就会爆炸。如果一颗子弹没有击中并飞过舞台顶部，游戏代码就会移除它。 1bullets = []; 此bullets数组在游戏的setup函数中初始化。 然后，您可以使用Here的自定义shoot方法来制作任意方向的精灵射击子弹。下面是实现shoot方法的一般格式。 12345678910111213g.shoot( cannon, //大炮 4.71, //射击角度 (4.71 是向上) cannon.halfWidth, //子弹在大炮上的x位置 0, //子弹在大炮上的y位置 g.stage, //应该添加子弹的容器 7, //子弹的速度 (像素每帧) bullets, //用于存储子弹的数组 //A function that returns the sprite that should //be used to make each bullet () =&gt; g.sprite(\"bullet.png\")); 第二个参数决定了子弹应该以弧度表示的角度。4.71弧度，在本例中使用，向上。0在右边，1.57在下面，3.14在左边。 第三和第四个参数是子弹在正典上的起始x和y位置。第5个参数是应该添加子弹的容器，第6个参数是应该放入子弹的数组。 最后一个参数是一个函数，它返回一个应该用作子弹的精灵。在这个例子中，子弹是使用游戏中加载的纹理图集中的”bullet.png”帧创建的。 1() =&gt; g.sprite(\"bullet.png\") 用您自己的函数替换此函数，以创建您可能需要的任何类型的自定义子弹。 你的子弹什么时候发射?您可以随时调用shoot方法，无论何时您想要创建项目符号，在代码中的任何位置。在外星无敌舰队中，当玩家按下空格键时，子弹会被发射。游戏通过在空格键的press方法中调用shoot来实现这一点。方法如下: 1234567891011121314151617181920g.spaceBar.press = () =&gt; &#123; //Shoot the bullet g.shoot( cannon, //The shooter 4.71, //The angle at which to shoot (4.71 is up) cannon.halfWidth, //Bullet's x position on the cannon 0, //Bullet's y position on the canon g.stage, //The container to which the bullet should be added 7, //The bullet's speed (pixels per frame) bullets, //The array used to store the bullets //A function that returns the sprite that should //be used to make each bullet () =&gt; g.sprite(\"bullet.png\") ); //Play the shoot sound. shootSound.play();&#125;; 您可以看到press方法也使shootSound发挥作用。(上面的代码是在游戏的setup函数中初始化的) 还有一件事你需要做:你必须让子弹move。你可以在游戏循环play函数中使用一些代码。使用Hexi的move方法并提供子弹阵列作为参数: 1g.move(bullets); move方法自动循环遍历阵列中的所有精灵，并以其vx和vy速度值的值更新它们的x和y位置。 现在你知道子弹是如何创建和动画的了。但是当他们击中一个外星人会发生什么呢? 精灵状态当一颗子弹击中一个外星人时，会出现一个黄色的爆炸图像。这个简单的效果是通过给每个外星精灵两个状态来创造的:一个正常的状态和一个被破坏的状态。外星人被创造，他们的状态被设定为正常。如果他们被击中，他们的状态就会被摧毁。 这个系统是如何工作的? 首先，让我们来看看外星无敌舰队，这里展示的是: 您可以看到定义这两种状态的两个图像帧:alien.png和explosion.png。在创建sprite之前，首先创建一个数组来列出这两帧: 1234let alienFrames = [ \"alien.png\", \"explosion.png\"]; 接下来使用alienframe数组初始化外星精灵 1alien = g.sprite(alienFrames); 如果你愿意，你可以把这两个步骤合并成一个，像这样: 1234alien = g.sprite([ \"alien.png\", \"explosion.png\"]); 这将为精灵加载两个帧。第0帧是alien.png 帧，第一帧是explosion.png帧。在第一次创建精灵时，默认显示第0帧。 您可以使用sprite的show方法在sprite上显示任何其他帧号，如下所示: 1alien.show(1); 上面的代码将把外星人设置为第一帧，这就是explosion.png帧 为了使您的代码更具可读性，在一个特殊的状态对象中定义sprite的状态是一个好主意。给每个状态一个名称，其值对应于该状态的帧号。以下是如何定义外星人的两种状态: normal和destroyed: 1234alien.states = &#123; normal: 0, destroyed: 1&#125;; 现在alien.states.normal的值为0,alien.states.destroyed的值为1。这意味着你可以像这样显示外星人的normal状态: 1alien.show(alien.states.normal); 展示外星人destroyed的状态: 1alien.show(alien.states.destroyed); 这使您的代码可读性更强，因为您可以一眼看出哪个sprite状态正在显示 注意:Hexi也有一个低级的gotoAndStop方法，它的功能和show一样。尽管你可以在游戏代码中自由使用gotoAndStop，但按照惯例，只有Hexi的渲染引擎在内部使用它 生成随机的外星人外星人无敌舰队在14个随机选择的位置中的任何一个产生外星人，就在舞台的顶部边界上。外星人最初出现的频率很低，但逐渐开始以越来越高的速度出现。随着游戏的进行，这使得游戏变得越来越困难。让我们看看这两个特性是如何实现的。 外星人时机当游戏开始时，第一个新的外星人在100帧后产生。在游戏的setup函数中初始化的一个叫做alienFrequency的变量用来帮助跟踪这个。初始化为100。 1alienFrequency = 100; 另一个名为alienTimer的变量用于计算前面生成的外星人与下一个外星人之间经过的帧数。 1alienTimer = 0; 在play函数(游戏循环)中，每个帧都更新了一个alienTimer。当alienTimer达到alienFrequency的值时，会产生一个新的异形精灵。这是play函数的代码。(此代码省略了生成外星精灵的实际代码——我们将在前面看到) 1234567891011121314151617//Add one to the alienTimeralienTimer++;//Make a new alien if `alienTimer` equals the `alienFrequency`if(alienTimer === alienFrequency) &#123; //... Create the alien: see ahead for the missing code that does this... //Set the `alienTimer` back to zero alienTimer = 0; //Reduce `alienFrequency` by one to gradually increase //the frequency that aliens are created if(alienFrequency &gt; 2)&#123; alienFrequency--; &#125;&#125; 您可以在上面的代码中看到，创建精灵之后，alienFrequency减少了1。这将使下一个外星人出现的时间比前一个外星人早1帧，这也是为什么下降的外星人的速度缓慢增加。您还可以看到，在创建精灵之后，alienTimer被设置为0，以便它可以重新计数，以生成下一个新的外星人。 外星人的随机起始位置在生成任何外星人之前，我们需要一个数组来存储所有的外星人精灵。为此，在setup函数中初始化一个名为alien的空数组。 1aliens = []; 然后在play函数中创建每个异形，在相同的if语句中，我们看上面。这段代码有很多工作要做: 它设置外星人的图像帧和状态。 它设定了外星人的速度(vx和vy)。 它将外星人定位在顶端边界上的任意水平位置。 最后，它把外星人推进了aliens的数组。 这里有完整的代码来完成这一切: 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Add one to the alienTimeralienTimer++;//Make a new alien if `alienTimer` equals the `alienFrequency`if(alienTimer === alienFrequency) &#123; //Create the alien. //Assign two frames from the texture atlas as the //alien's two states let alienFrames = [ \"alien.png\", \"explosion.png\" ]; //Initialize the alien sprite with the frames let alien = g.sprite(alienFrames); //Define some states on the alien that correspond //to its two frames. alien.states = &#123; normal: 0, destroyed: 1 &#125;; //Set its y position above the screen boundary alien.y = 0 - alien.height; //Assign the alien a random x position alien.x = g.randomInt(0, 14) * alien.width; //Set its speed alien.vy = 1; //Push the alien into the `aliens` array aliens.push(alien); //Set the `alienTimer` back to zero alienTimer = 0; //Reduce `alienFrequency` by one to gradually increase //the frequency that aliens are created if(alienFrequency &gt; 2)&#123; alienFrequency--; &#125;&#125; 你可以在上面的代码中看到外星人的y位置将它放置在舞台的顶部边界上。 1alien.y = 0 - alien.height; 它的x位置是随机的 1alien.x = g.randomInt(0, 14) * alien.width; 这段代码将其放置在15个可能的随机位置(0到14)之上。以下是这些立场的说明: 最后，也是非常重要的一点，代码将外星人精灵推入aliens数组 1aliens.push(alien); 所有这些代码开始以稳定增长的速度输出外星人 移动外星人我们如何让外星人移动?用让子弹移动的同样方式。您将在上面的代码中注意到，每个外星人都用vy(垂直速度)值1初始化。 1alien.vy = 1; 当这个值应用到外星人的y位置时，它将使外星人以每帧1像素的速度向下移动，向舞台的底部移动。游戏中所有的外星人精灵都在外星人阵中。所以要让它们都移动，你需要遍历异形数组中的每个精灵每个帧并将它们的vy值添加到它们的y位置。在play函数中类似的一些代码可以工作: 123aliens.forEach(alien =&gt; &#123; alien.y += alien.vy;&#125;); 不过，使用Hexi便捷的内置移动功能更简单。只需提供你想要移动的精灵数组，如下所示: 1g.move(aliens); 这将自动使用速度更新外星人的位置 让外星人爆炸既然你已经知道如何改变外星人的状态，你怎么能用这个技能创造爆炸效果呢?下面是来自外星舰队的简化代码，它向您展示了如何做到这一点。使用hittest矩形来检查外星人和子弹之间的碰撞。如果发现了碰撞，取出子弹，显示外星人被摧毁的状态，然后在一秒钟后移除外星人。 123456789101112if (g.hitTestRectangle(alien, bullet)) &#123; //Remove the bullet sprite. g.remove(bullet); //Show the alien's `destroyed` state. alien.show(alien.states.destroyed); //Wait for 1 second (1000 milliseconds) then //remove the alien sprite. g.wait(1000, () =&gt; g.remove(alien));&#125; 你可以使用Hexi的万能remove函数从游戏中移除精灵，就像这样: 1g.remove(anySprite); 您可以通过列出参数中要删除的精灵来选择一次删除多个精灵，如下所示: 1g.remove(spriteOne, spriteTwo, spriteThree); 您甚至可以使用它来删除一系列精灵中的精灵。只需提供sprite数组作为移除的唯一参数: 1g.remove(arrayOfSprites); 这将使精灵从屏幕中消失，并将它们从它们所在的数组中清空。 Hexi还有一个方便的方法叫wait，它可以在你指定的任何延迟(以毫秒为单位)之后运行一个函数。外星人的无敌舰队游戏代码使用等待移除外星人后的一个第二次延迟，像这样: 1g.wait(1000, () =&gt; g.remove(alien)); 这允许外星人在它从游戏中消失之前显示它的爆炸图像状态一秒钟。 这些都是使外星人爆炸的基本技术，当他们碰撞时把外星人和子弹从游戏中移除。但是在《异形无敌舰队》中使用的实际代码要复杂一些。这是因为代码使用嵌套的filter循环遍历所有的子弹和异形，以便可以相互检查它们是否发生冲突。当发生碰撞时，代码也会播放爆炸声音，并将分数更新为1。这是游戏的play函数的所有代码。(如果您是JavaScript的filter循环的新手，您可以在这里阅读如何使用它们。) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//Check for a collision between the aliens and the bullets.//Filter through each alien in the `aliens` array.aliens = aliens.filter(alien =&gt; &#123; //A variable to help check if the alien is //alive or dead. let alienIsAlive = true; //Filter though all the bullets. bullets = bullets.filter(bullet =&gt; &#123; //Check for a collision between an alien and bullet. if (g.hitTestRectangle(alien, bullet)) &#123; //Remove the bullet sprite. g.remove(bullet); //Show the alien's `destroyed` state. alien.show(alien.states.destroyed); //You could alternatively use the frame number, //like this: //alien.show(1); //Play the explosion sound. explosionSound.play(); //Stop the alien from moving. alien.vy = 0; //Set `alienAlive` to false so that it can be //removed from the array. alienIsAlive = false; //Wait for 1 second (1000 milliseconds) then //remove the alien sprite. g.wait(1000, () =&gt; g.remove(alien)); //Update the score. score += 1; //Remove the bullet from the `bullets array. return false; &#125; else &#123; //If there's no collision, keep the bullet in the //bullets array. return true; &#125; &#125;); //Return the value of `alienIsAlive` back to the //filter loop. If it's `true`, the alien will be //kept in the `aliens` array. //If it's `false` it will be removed from the `aliens` array. return alienIsAlive;&#125;); 只要filter循环返回true，当前正在检查的sprite将保留在数组中。但是，如果发生碰撞，循环返回false，当前的外星人和子弹将从它们的数组中删除。 这就是游戏的碰撞原理! 显示分数外星人无敌舰队引入的另一个新特性是动态分数显示。每次外星人被击中，游戏屏幕右上角的分数就会增加1分。这是如何工作的呢? 外星人无敌舰队初始化一个被称为scoreDisplay的文本精灵在游戏的setup功能。 1scoreDisplay = g.text(\"0\", \"20px emulogic\", \"#00FF00\", 400, 10); 你在前一节中看到，当一个外星人被击中时，游戏的得分变量会增加1: 1score += 1; 要明显地更新分数，您只需将分数值设置为记分显示器的内容，如下所示: 1scoreDisplay.content = score; 这就是一切! 结束并重新设置游戏游戏有两种结局。要么玩家击落60个外星人，这样玩家就赢了。或者，其中一个外星人必须穿越舞台的底部边缘，这样外星人就赢了。 一个简单的if语句在播放函数检查这个。如果任一条件变为真，胜者将被设置为“玩家”或“外星人”，游戏的状态将被更改为结束。 1234567891011121314151617181920212223242526//The player wins if the score matches the value//of `scoreNeededToWin`, which is 60if (score === scoreNeededToWin) &#123; //Set the player as the winner. winner = \"player\"; //Change the game's state to `end`. g.state = end;&#125;//The aliens win if one of them reaches the bottom of//the stage.aliens.forEach(alien =&gt; &#123; //Check to see if the `alien`'s `y` position is greater //than the `stage`'s `height` if (alien.y &gt; g.stage.height) &#123; //Set the aliens as the winner. winner = \"aliens\"; //Change the game's state to `end`. g.state = end; &#125;&#125;); 结束函数暂停游戏，使动画冻结。然后它会显示游戏的信息，它要么是“地球被拯救”，要么是“地球毁灭!”取决于结果。另外，音乐音量也被设置为50%。然后在延迟3秒后，调用名为reset的函数。这是完成这一切的完整的结束函数: 1234567891011121314151617181920212223242526function end() &#123; //Pause the game loop. g.pause(); //Create the game over message text. gameOverMessage = g.text(\"\", \"20px emulogic\", \"#00FF00\", 90, 120); //Reduce the music volume by half. //1 is full volume, 0 is no volume, and 0.5 is half volume. music.volume = 0.5; //Display \"Earth Saved!\" if the player wins. if (winner === \"player\") &#123; gameOverMessage.content = \"Earth Saved!\"; gameOverMessage.x = 120; &#125; //Display \"Earth Destroyed!\" if the aliens win. if (winner === \"aliens\") &#123; gameOverMessage.content = \"Earth Destroyed!\"; &#125; //Wait for 3 seconds then run the `reset` function. g.wait(3000, () =&gt; reset());&#125; reset函数将所有的游戏变量重置为它们的初始值。它还将音乐音量调回到1。它使用删除函数从异形和子弹数组中删除所有剩余的精灵，以便当游戏再次开始时可以重新填充这些数组。删除也用于删除gameOverMessage，加农炮精灵被重新集中在舞台的底部。最后，游戏状态被设置回播放，而游戏循环通过调用Hexi的恢复方法而停止。 1234567891011121314151617181920212223242526272829function reset() &#123; //Reset the game variables. score = 0; alienFrequency = 100; alienTimer = 0; winner = \"\"; //Set the music back to full volume. music.volume = 1; //Remove any remaining alien and bullet sprites. //The universal `remove` method will loop through //all the sprites in an array of sprites, removed them //from their parent container, and splice them out of the array. g.remove(aliens); g.remove(bullets); //You can also use the universal `remove` function to remove. //a single sprite. g.remove(gameOverMessage); //Re-center the cannon. g.stage.putBottom(cannon, 0, -40); //Change the game state back to `play`. g.state = play; g.resume();&#125; 这是重新开始游戏所需的所有代码。你可以像你喜欢的那样玩外星无敌舰队，它会像这样不断地重置和重启自己。 飞扬的仙女Flappy Fairy是对有史以来最臭名昭著的游戏之一的致敬:Flappy Bird。点击链接玩游戏: 点击“Go”按钮，游戏将以全屏模式启动。点击屏幕上的任何地方，让仙女飞起来，帮助她通过15根柱子的缝隙到达终点。当仙女在迷宫中飞翔时，一串五颜六色的仙女尘埃尾随着她。如果她撞到一个绿色的街区，她就会在一阵尘土中爆炸。但如果她能在这15根柱子之间不断缩小的缝隙中穿行，她就能看到一个巨大的漂浮“终点”标志。 如果你能做一个像Flappy Fairy一样的游戏，你几乎可以做任何其他类型的2D动作游戏。除了使用你已经学过的所有技巧外，Flappy Fairy还引入了一些令人兴奋的新技巧: 以全屏模式启动游戏。 单击的按钮。 创建一个动画精灵。 使用tilingSprite来创建滚动背景。 使用粒子效果。 您将在教程文件夹中找到完整注释的Flappy Fairy源代码。请务必查看它，以便您能够在正确的上下文中看到所有这些代码。它的总体结构与本教程中的其他游戏相同，并添加了这些新技术。让我们看看它们是如何实现的。 制作按钮当你按下“Go”按钮时，游戏就开始了。“Go”按钮是一种叫做“button”的特殊精灵。按钮精灵有3个图像帧状态:上、下、下。您可以创建一个按钮，有以下三种状态: 12345goButton = g.button([ \"up.png\", \"over.png\", \"down.png\"]); up.png 是一个图像，它显示了当按钮不与指针交互时按钮应该是什么样子。over.png显示了指针在上面和向下时的按钮的样子。down.png是指针按下按钮时显示的图像。 (down.png图像被稍微向下偏移并向右偏移，因此它看起来像是被压下了。您可以将任何您喜欢的图像分配到这些状态，按钮将根据指针与这些状态的交互方式自动显示它们。(注意:如果你的游戏是触控的，你可能只有两个按钮状态:向上和向下。在这种情况下，只需分配两个图像帧，Hexi将假设它们是指上下状态) 按钮有可以定义的特殊方法:press, release, over, out, tap。您可以为这些方法指定任何代码。例如，当用户释放playButton时，如何更改游戏的状态: 123goButton.release = () =&gt; &#123; g.state = setupGame;&#125;; 按钮还有一个名为enabled的布尔(true/false)属性，如果想禁用按钮，可以将其设置为false。(设置为true以重新启用它。)您还可以使用按钮的state属性来确定按钮状态是否为“up”、“over”或“down”。(这些状态值是字符串。) 重要!只要将按钮的交互属性设置为true，就可以赋予任何精灵按钮的特性，如下所示: 1anySprite.interact = true; 这将使sprite press, release, over, out和tap方法以及与普通按钮相同的状态属性。这意味着你可以让所有的精灵都可以点击，这对于各种各样的互动游戏来说是非常有用的。 你也可以让舞台对象互动，把整个游戏画面变成一个互动按钮: 1g.stage.interact = true; 有关如何使用按钮的详细信息，请参见按钮。示例文件夹中的buttons.html文件。 动画精灵Flappy Fairy的一个奇妙特征是，当它飞起来的时候，精灵会拍打它的翅膀。这个动画是通过在连续循环中快速显示3个简单的图像而创建的。每个图像显示一个稍微不同的动画帧，如下图所示: 这三张图片只是游戏纹理地图集中三个普通的帧，叫做0.png, 1.png 和 2.png。但是你怎么能把像这样的一系列帧变成精灵动画呢? 首先，创建一个定义动画帧的数组，如下所示: 12345let fairyFrames = [ \"0.png\", \"1.png\", \"2.png\"]; 然后使用这些帧创建一个精灵，如下所示: 1let fairy = g.sprite(fairyFrames); 或者，如果你愿意的话，你可以把它合并成一个步骤: 12345let fairy = g.sprite([ \"0.png\", \"1.png\", \"2.png\"]); 任何具有多个图像帧的精灵都会自动成为一个动画精灵。如果你想要动画帧开始播放，只需调用sprite的playAnimation方法: 1fairy.playAnimation(); 帧将自动在一个连续循环中运行。如果不希望它们循环，则将loop设置为false。 1fairy.loop = false; 使用stopAnimation方法停止动画: 1fairy.stopAnimation(); 如果您想知道精灵的动画是否正在播放，请使用Boolean (true/false)的playing属性。 你希望动画播放的速度是快还是慢?你可以这样设置动画的帧/秒(fps): 1fairy.fps = 24; 精灵动画的帧速率与游戏的帧速率无关。这给你很大的灵活性来微调精灵动画。 如果您不想在动画中使用所有精灵的图像帧，只使用其中的一些帧，该怎么办?例如，假设您有一个带有30帧的精灵，但您只希望在动画的一部分中播放10到15帧。为playAnimation方法提供一个包含两个数字的数组:要播放的序列的第一帧和最后一帧。 1animatedSprite.playAnimation([10, 15]); 现在只有10到15之间的帧作为动画的一部分。为了使其更具可读性，您可以将序列定义为一个数组，该数组描述了这些动画帧的实际功能。例如，也许他们定义了一个角色的行走周期。你可以创建一个名为walkCycle的数组来定义这些帧: 1let walkCycle = [10, 15]; 然后使用playAnimation数组，如下所示: 1animatedSprite.playAnimation(walkCycle); 这需要编写更多的代码，但是可读性更好! 有关Hexi的精灵动画系统的更多细节以及你可以用它做什么，请参阅示例文件夹中的keyframeAnimation.html,textureAtlasAnimation.html和animationStates.html文件。 让仙女飞 既然你已经知道如何让精灵动起来，那么当你点击游戏屏幕时，Flappy Fairy的飞行动画是如何触发的呢? 在play函数的每一帧中，从仙女的y位置中减去表示重力的0.05。这就是把仙女拉到屏幕底部的重力效应。 12fairy.vy += -0.05;fairy.y -= fairy.vy; 但当你轻击屏幕时，仙女就会飞起来。这要感谢Hexi的内置指针对象。它有一个tap方法，您可以定义它来执行您喜欢的任何操作。在Flappy Fairy中，tap方法增加了精灵的垂直速度vy，每次点击都增加了1.5像素。 123g.pointer.tap = () =&gt; &#123; fairy.vy += 1.5;&#125;; Hexi的内置指针对象也有按下和释放的方法，你可以用同样的方法来定义。它还具有布尔(true/false) isUp、isDown和tap属性，如果需要，可以使用它来找到指针的状态。 但是你会注意到仙女只会在她开始飞起来的时候拍打她的翅膀，当她失去动力开始下降的时候停止拍打翅膀。要完成这项工作，您需要根据仙女垂直速度(vy)值的变化，知道仙女正在上升还是在下降。这个游戏采用了一种老掉牙的老把戏来帮助解决这个问题。play函数以一个名为oldVy的新值捕捉到当前帧中仙女的速度。但只有在仙女的位置发生变化后才会这样。 12345678910function play()&#123; //... //... all of the code that moves the fairy comes first... //... //Then, after the fairy's position has been changed, capture //her velocity for this current frame fairy.oldVy = fairy.vy;&#125; 这意味着，当下一个游戏帧在上下摆动时，oldVy仍然会存储前一帧中精灵的速度值。这意味着你可以用这个值计算出从前一帧到当前帧的速度变化量。如果她开始上升(如果vy比oldVy大)，播放仙女的动画: 12345if (fairy.vy &gt; fairy.oldVy) &#123; if(!fairy.playing) &#123; fairy.playAnimation(); &#125;&#125; 如果她开始下降，停止动画，只显示精灵的第一帧。 1234if (fairy.vy &lt; 0 &amp;&amp; fairy.oldVy &gt; 0) &#123; if (fairy.playing) fairy.stopAnimation(); fairy.show(0);&#125; 这就是仙女怎么飞的! 做一个滚动的背景 Flappy Fairy的一个有趣的新特性是，它有一个无限滚动的背景云从右向左移动。 背景的移动速度比绿色的柱子要慢，这给人一种云离得更远的错觉。(这是一种浅显的伪3D效果，叫做抛物线滚动。) 背景只是一个图像。 这张照片的设计使得云平铺无缝:顶部和左边的云与右下角的云相匹配。这意味着您可以连接同一映像的多个实例，它们将显示为创建单个、连续的映像。(图片来自OpenGameArt) 因为这对游戏非常有用，Hexi有一种精灵类型叫做tilingSprite，专为无限的滚动效果而设计。下面是如何创建tilingSprite: 12345sky = g.tilingSprite( \"sky.png\" //The image to use g.canvas.width, //The width g.canvas.height, //The height); 第一个参数是您想要使用的图像，最后两个参数是精灵的宽度和高度。 贴砖精灵与普通精灵具有相同的属性，增加了两个新属性:tileX和tileY。这两个属性允许您设置精灵左上角的图像偏移量。如果你想连续不断地制作一个平铺的精灵滚动条，只需在游戏循环的每一帧中增加少量的tileX值，如下所示: 1sky.tileX -= 1; 这就是你做无限滚动背景所需要做的。 粒子效果你如何创造像火，烟，魔法和爆炸这样的效果?你制造了很多小精灵;有几十个，成百上千个。然后对这些精灵施加一些物理或重力约束，使它们的行为类似于你要模拟的元素。您还需要给他们一些规则，关于他们应该如何出现和消失，以及他们应该形成什么样的模式。这些小精灵被称为粒子。你可以用它们为游戏制作各种各样的特效。 Hexi有一种多功能的内置方法叫做createParticles，它可以制造游戏所需的大多数粒子效果。下面是使用它的格式: 123456789101112131415createParticles( pointer.x, //The particle’s starting x position pointer.y, //The particle’s starting y position () =&gt; sprite(\"images/star.png\"), //Particle function g.stage, //The container to add the particles to 20, //Number of particles 0.1, //Gravity true, //Random spacing 0, 6.28, //Min/max angle 12, 24, //Min/max size 1, 2, //Min/max speed 0.005, 0.01, //Min/max scale speed 0.005, 0.01, //Min/max alpha speed 0.05, 0.1 //Min/max rotation speed); 您可以看到，大多数参数描述了最小值和最大值之间的范围，这些值应该用于更改精灵的速度、旋转、缩放或alpha。您还可以指定应该创建的粒子数，并添加可选的重力。通过定制第三个参数，您可以使用任何精灵生成粒子。只要提供一个函数，返回你想为每个粒子使用的精灵: 1() =&gt; (\"images/star.png\"), 如果你提供一个具有多个帧的精灵，createParticles方法会自动为每个粒子选择一个随机的帧。最小和最大角度值对于定义粒子从原点辐射出来时的圆形传播非常重要。对于完全圆形的爆炸效果，使用最小角度为0，最大角度为6.28。 10, 6.28, (这些值弧度;等于0和360。)0从3点钟方向开始，指向右边。3.14是9点的位置，6.28让你再次回到0点。如果你想把粒子范围限制在一个更窄的角度，只要提供描述这个范围的最小值和最大值。这里有一些值，你可以用来将角度限制在比萨斜面上，地壳指向左边。 12.4, 3.6, 你可以使用像这样的受限角度范围来创建粒子流，就像那些用来创建喷泉或火箭引擎火焰的粒子流。(你马上就会知道怎么做了。)随机间隔值(第六个参数)决定了粒子在这个范围内的间隔是均匀的(假)还是随机的(真)。通过仔细地为粒子选择精灵并精细地调整每个参数，您可以使用这个通用的createparticle方法来模拟从液体到火焰的一切。在Flappy Fairy中，它被用来创造仙尘。 仙女粉尘爆炸当Flappy Fairy撞上一块木头时，它就消失在一阵尘土中。 那效果如何呢? 在创建爆炸效果之前，我们必须定义一个数组，该数组列出了我们想要为每个粒子使用的图像。如前所述，如果精灵包含多个帧，那么createparticle方法将在精灵上随机显示一个帧。要完成这项工作，首先定义一组纹理图集框架，你想用它来应对仙女的尘埃爆炸: 123456dustFrames = [ \"pink.png\", \"yellow.png\", \"green.png\", \"violet.png\"]; 当仙女碰到一个绿色的方块时，爆炸就发生了。游戏循环在hitTestRectangle方法的帮助下实现了这一点。代码循环遍历这些块。对每个绿色块和精灵之间的冲突进行数组和测试。如果hitTestRectangle返回true，则循环退出，名为fairyVsBlock的冲突对象变为true。 123let fairyVsBlock = blocks.children.some(block =&gt; &#123; return g.hitTestRectangle(fairy, block, true); &#125;); hitTestRectangle的第三个参数需要是true，这样就可以使用sprite的全局坐标(gx和gy)来完成碰撞检测。这是因为仙女是舞台的子元素，但是每个块都是块组的子元素。这意味着它们不共享相同的局部坐标空间。使用块精灵的全局坐标迫使hitTestRectangle使用它们相对于画布的位置。 如果fairyVsBlock是正确的，并且精灵现在是可见的，那么冲突代码就会运行。它使精灵隐形，产生粒子爆炸，并在延迟3秒后调用游戏的复位功能。 123456789101112131415161718192021222324if (fairyVsBlock &amp;&amp; fairy.visible) &#123; //Make the fairy invisible fairy.visible = false; //Create a fairy dust explosion g.createParticles( fairy.centerX, fairy.centerY, //x and y position () =&gt; g.sprite(dustFrames), //Particle sprite g.stage, //The container to add the particles to 20, //Number of particles 0, //Gravity false, //Random spacing 0, 6.28, //Min/max angle 16, 32, //Min/max size 1, 3 //Min/max speed ); //Stop the dust emitter that's trailing the fairy dust.stop(); //Wait 3 seconds and then reset the game g.wait(3000, reset);&#125; 使用粒子发射器粒子发射器只是一个简单的计时器，以固定的间隔产生粒子。这意味着发送器不再只调用createParticles方法一次，而是周期性地调用它。Hexi有一个内置的粒子发射器方法让我们很容易做到这一点。下面是如何使用它的方法: 123456let particleStream = g.particleEmitter( 100, //The interval () =&gt; g.createParticles( //The `particleEffect` function //Assign particle parameters... )); 粒子发射器法只是围绕着创造粒子法。它的第一个参数是一个以毫秒为单位的数字，它决定了粒子产生的频率。第二个参数是createparticle方法，您可以随意定制它。粒子发射器方法返回一个带有播放和停止方法的对象，您可以使用它来控制粒子流。你可以使用它们就像你用来控制精灵动画的游戏和停止方法一样。 12particleStream.play();particleStream.stop(); 发射器对象还有一个playing属性，根据发射器的当前状态，该属性可以为真，也可以为假。(参见示例文件夹中的particleEmitter .html文件，了解如何创建和使用粒子发射器的更多细节。 Flappy Fairy中使用了一个粒子发射器，当仙女拍打翅膀时，它就会发出一串五颜六色的粒子。粒子的角度被限制在2.4到3.6弧度之间，所以它们以一个锥形的楔形向仙女的左边发射。 粒子流随机地发出粉色、黄色、绿色或紫色的粒子，每个粒子都是纹理图谱上的一个单独的框架。 以下是产生这种效果的代码: 12345678910111213141516171819202122232425262728dustFrames = [ \"pink.png\", \"yellow.png\", \"green.png\", \"violet.png\"];//Create the emitterdust = g.particleEmitter( 300, //The interval () =&gt; &#123; g.createParticles( //The function fairy.x + 8, //x position fairy.y + fairy.halfHeight + 8, //y position () =&gt; g.sprite(dustFrames), //Particle sprite g.stage, //The container to add the particles to 3, //Number of particles 0, //Gravity true, //Random spacing 2.4, 3.6, //Min/max angle 12, 18, //Min/max size 1, 2, //Min/max speed 0.005, 0.01, //Min/max scale speed 0.005, 0.01, //Min/max alpha speed 0.05, 0.1 //Min/max rotation speed ); &#125;); 您现在可以使用play和stop方法控制尘埃发射器。 创造和移动柱子你现在知道了Flappy Fairy如何实现了河西的一些特殊功能，以获得一些有趣和有用的效果。但是，如果你是游戏编程的新手，你可能也想知道，那个飘飘欲仙的世界是如何被创造出来的。让我们快速地看一下创建并移动精灵必须导航的绿色柱子的代码，以达到完成标记。 游戏中有15根绿色柱子。每隔5根柱子，顶部和底部之间的缝隙就会缩小。前五根柱子有四个街区的空隙，后五根柱子有三个街区的空隙，后五根柱子有两个街区的空隙。这使得这个游戏变得越来越困难，因为Flappy仙女飞得更远。每一根柱子上的空隙的确切位置都是随机的，每次游戏都是不同的。每根柱子的间距是384像素，这是它们相邻时的样子。 你可以看到这个缺口是如何从左到右逐渐缩小的。 构成柱子的所有砖块都属于一个叫做blocks的group。 1blocks = g.group(); 嵌套的for循环创建每个块并将其添加到blocks容器中。外环运行15次;一次创建每个支柱。内循环运行8次;在柱子上每隔一段。这些块只有在它们没有占据被随机选择的距离时才会被添加。每五次外环运行一次，间隙的大小就会缩小一倍。 123456789101112131415161718192021222324252627282930313233343536373839//What should the initial size of the gap be between the pillars?let gapSize = 4;//How many pillars?let numberOfPillars = 15;//Loop 15 times to make 15 pillarsfor (let i = 0; i &lt; numberOfPillars; i++) &#123; //Randomly place the gap somewhere inside the pillar let startGapNumber = g.randomInt(0, 8 - gapSize); //Reduce the `gapSize` by one after every fifth pillar. This is //what makes gaps gradually become narrower if (i &gt; 0 &amp;&amp; i % 5 === 0) gapSize -= 1; //Create a block if it's not within the range of numbers //occupied by the gap for (let j = 0; j &lt; 8; j++) &#123; if (j &lt; startGapNumber || j &gt; startGapNumber + gapSize - 1) &#123; let block = g.sprite(\"greenBlock.png\"); blocks.addChild(block); //Space each pillar 384 pixels apart. The first pillar will be //placed at an x position of 512 block.x = (i * 384) + 512; block.y = j * 64; &#125; &#125; //After the pillars have been created, add the finish image //right at the end if (i === numberOfPillars - 1) &#123; finish = g.sprite(\"finish.png\"); blocks.addChild(finish); finish.x = (i * 384) + 896; finish.y = 192; &#125;&#125; 代码的最后一部分向世界添加了一个大型的finish精灵，Flappy Fairy将会看到它是否能够一直运行到最后。 游戏循环在每一帧中向右移动2个像素块组，但只在结束精灵不在屏幕上时: 123if (finish.gx &gt; 256) &#123; blocks.x -= 2;&#125; 当完成的精灵滚动到画布的中心时，块容器将停止移动。注意，代码使用finish sprite的全局x位置(gx)来测试它是否在画布区域内。因为全局坐标是相对于画布的，而不是父容器的，所以对于这些需要在画布上找到嵌套精灵位置的情况，它们是非常有用的。 请确保在示例文件夹中检查完整的Flappy Fairy源代码，以便您能够在正确的上下文中看到所有这些代码。 与HTML和CSS的集成Hexi可以无缝地使用HTML和CSS。您可以自由地将Hexi精灵和代码与HTML元素混合，并使用Hexi的架构来构建一个基于HTML的应用程序。并且，您可以使用HTML为您的Hexi游戏构建一个丰富的用户界面。 它是如何工作的呢?河西采取了完全不干涉的方法。只需编写普通的旧HTML和CSS，然后在Hexi代码中引用HTML。这是所有!Hexi并没有重新发明轮子，所以你可以编写任何你喜欢的低水平的HTML/CSS代码，并将它混合到你的Hexi应用程序中。 您可以在这个代码存储库中的Hexi示例中找到一个html文件夹中的工作示例。这是一个简单的数字猜谜游戏: 包含按钮和文本输入字段的灰色框是HTML元素。这些HTML元素(包括按钮)完全是使用CSS样式的。动态文本和图像是六次精灵。 还有一个无形的&lt;div&gt;元素，它的大小和Hexi的画布一样，位置也一样。大的&lt;div&gt;元素浮在画布上，包含灰色框、按钮和输入字段。 让我们快速地看看这是如何工作的。主要的。html文件如下: 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Html integration&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"style.css\"&gt;&lt;body&gt;&lt;!-- UI --&gt;&lt;div id=\"ui\"&gt; &lt;div id=\"box\"&gt; &lt;button&gt;Guess!&lt;/button&gt; &lt;input id=\"input\" type=\"text\" placeholder=\"X...\" maxlength=\"10\" autofocus&gt; &lt;div&gt;&lt;/div&gt;&lt;!-- Hexi --&gt;&lt;script src=\"../../src/modules/pixi.js/bin/pixi.js\"&gt;&lt;/script&gt;&lt;script src=\"../../bin/modules.js\"&gt;&lt;/script&gt;&lt;script src=\"../../bin/core.js\"&gt;&lt;/script&gt;&lt;!-- Main application file --&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt; 重要的部分是UI部分，就在&lt;body&gt;标签下面。带有id ui的div用于封装框、按钮和输入。 魔术发生在style.css文件。以下是最重要的部分: 1234567891011121314canvas &#123; position : relative &#125;#ui &#123; position : absolute ; left : 0 ; top : 0 ; width : 512px ; height : 512px /*Important: set the z-index to 1 so that it appears above Hexi's canvas*/ ; z-index: 1 &#125; Hexi的画布被设置为相对，ui div被设置为绝对。ui也被设置为与Hexi的画布一样的宽度和高度512px。非常重要的是，ui的z-index为1，以迫使它在画布之上显示。其他HTML元素(框、按钮和输入字段)都是完全相对于ui div定位的——请检查完整的CSS代码以获得详细信息。 要访问你的Hexi代码中的按钮和输入字段，只需在河西的设置函数中创建对它们的引用: 12345678function setup() &#123; //Html elements var button = document.querySelector(\"button\"); button.addEventListener(\"click\", buttonClickHandler, false); var input = document.querySelector(\"#input\"); //...The rest of the setup code creates Hexi sprites... 然后创建一个普通的函数来处理按钮点击，像这样: 1234567function buttonClickHandler(event) &#123; //Capture the player's input from the HTML text input field if (input.value) playersGuess = parseInt(input.value); //...the rest of the code...&#125; input.value允许您访问用户在输入字段中输入的任何内容。这只是普通的Web API代码——没什么特别的!您可以使用该值来更改任何Hexi精灵属性。请查看源代码以获得详细信息，但这并不令人感到意外。 但是示例代码有一个诀窍，那就是它的袖子。整个Hexi应用程序在浏览器中进行扩展和对齐。这意味着，Hexi的画布和UI div的扩展和保持一致。如果用户改变浏览器窗口的大小，它们甚至会重新缩放和重新对齐。这是如何工作的呢?下面是实现此目的的JavaScript代码(在main.js文件中，就在Hexi的标准初始化代码之后): 12345678//Scale Hexi's canvasg.scaleToWindow();//Scale the html UI &lt;div&gt; containerscaleToWindow(document.querySelector(\"#ui\"));window.addEventListener(\"resize\", function(event)&#123; scaleToWindow(document.querySelector(\"#ui\"));&#125;); Hexi的canvas是由Hexi引擎在内部缩放的，但是UI层是使用全局scaleToWindow函数缩放的。(你可以在这里找到scaleToWindow函数。) HTML和Hexi之间的松散集成意味着您可以随意定制它。如果你想的话，你可以做一些疯狂的低级HTML/CSS编程，把逻辑和你的Hexi精灵混合在一起，设计任何你需要的自定义布局。它只是HTML !而且，是的，如果你想的话，你可以用Angular, React或Elm来编写你的HTML。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jigangduan.github.io/categories/JavaScript/"},{"name":"Pixi.js","slug":"JavaScript/Pixi-js","permalink":"https://jigangduan.github.io/categories/JavaScript/Pixi-js/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"pixijs","slug":"pixijs","permalink":"https://jigangduan.github.io/tags/pixijs/"},{"name":"游戏","slug":"游戏","permalink":"https://jigangduan.github.io/tags/游戏/"},{"name":"hexi","slug":"hexi","permalink":"https://jigangduan.github.io/tags/hexi/"}]},{"title":"WebApp(或HybridApp)和React-Native比较","slug":"WebApp或HybridApp和ReactNative","date":"2018-06-06T08:37:38.000Z","updated":"2020-07-25T02:57:18.171Z","comments":true,"path":"2018/06/06/WebApp或HybridApp和ReactNative/","link":"","permalink":"https://jigangduan.github.io/2018/06/06/WebApp或HybridApp和ReactNative/","excerpt":"","text":"web App(或Hybrid App)开发移动APP的弊端 用户体验，差强人意，流畅度差 需要原生接口，但调试原生时非常的不方便，没有工具的支持 各个机型内置的webview的差异性，带来的适配问题 难以支撑体量大的业务，只能做轻应用 没有优秀的技术框架支撑，单页面难以适应移动端的场景；多页面增加业务复杂度，技术落后 Dcloud等项目陈旧，没有开源，内部出现问题无法跟踪 选择React Native的优势和缺点 UI 原生渲染，对比H5体验更为高效 替代传统的WebView，打开效率更高，和原生之间的交互更方便 拥有了丰富第三方插件支持 热更新 React带来的先进理念 React 学习曲线高于H5 相对增大了app的体积 服务端渲染 对比 单页面优点 更好的SEO 更快的页面呈现速度 缺点 更复杂的开发，开发的代码需要兼容前后端的runtime 更复杂的构建和部署 加重服务器负载 React 和 Vue 比较Vue的优势 简单的语法和项目配置 更快的渲染速度和更小的体积 React的优势 更适合大型应用和更好的可测试性 更大的生态系统，更多的支持和好用的工具","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"WebAPP","slug":"前端/WebAPP","permalink":"https://jigangduan.github.io/categories/前端/WebAPP/"}],"tags":[{"name":"webapp","slug":"webapp","permalink":"https://jigangduan.github.io/tags/webapp/"}]},{"title":"前端框架选型","slug":"前端框架选型","date":"2018-05-22T08:48:41.000Z","updated":"2020-07-25T02:57:18.235Z","comments":true,"path":"2018/05/22/前端框架选型/","link":"","permalink":"https://jigangduan.github.io/2018/05/22/前端框架选型/","excerpt":"前端框架选型是件困难的事情，困难的原因是各个方面的权衡，包括 项目业务的适应性，前端开发人员的自身技术偏向，各个框架主张的思想，入门和后续的难易程度,性能情况,背后支持及生态系统是否丰富…..综合的考虑，但又没有一定的正确答案。","text":"前端框架选型是件困难的事情，困难的原因是各个方面的权衡，包括 项目业务的适应性，前端开发人员的自身技术偏向，各个框架主张的思想，入门和后续的难易程度,性能情况,背后支持及生态系统是否丰富…..综合的考虑，但又没有一定的正确答案。 框架需求 整合多项功能项目的能力，支撑业务的扩展 尽量兼容桌面端和移动端 具有技术先进性可持续发展 三大框架目前主流的前端框架是 Angular, React,Vue AngularAngular由Google进行维护，并用于Google 的Adwords 和Fiber项目。既然AdWords是Goolge重要的吸金利器，自然Angular不太可能突然夭折。 Angular自带很多的功能，更丰富的功能对于一个框架来说，是优点也有可能是缺点。 功能特性Angular除了提供一些需要最新浏览器支持的功能外，同时提供以下标准功能： 依赖注入 模板 路由（@angular/router） AJAX（@angular/http） 表单（@angular/forms） 组件化CSS封装 XSS保护 单元测试工具 功能丰富的好处就是你不需要额外费精力去挑选第三方的类库，然而，这也同样让你没得选择。 模式TypeScriptTypeScript是一种基于JavaScript开发并由Microsoft开发的新语言。其实TypeScript就是前端开发领域的“Java”，其特点（Type，Generics）天生契合以团队规模开发为目标的Angular。你可以使用它而不是Babel来编写最先进的JavaScript。它还可以通过使用注释和类型推断的组合来静态分析你的代码 RxJSRxJS是一个响应式编程库，可以灵活地处理异步操作和事件。它是将Observer和Iterator模式与功能编程相结合的组合。RxJS允许您将任何东西视为连续的流，并对其进行各种操作，例如映射，过滤，拆分或合并。 生态系统Angular CLICLI工具，可以帮助您引导项目，而无需自行配置构建。它允许您仅使用几个命令来生成和运行项目。负责构建应用程序的所有脚本，启动开发服务器和运行测试都会在node_modules中隐藏。您也可以在开发过程中使用它来生成新的代码。这使得新项目的设置变得轻而易举。 IonicIonic 开发混合移动应用程序。Angular集成的Cordova容器，以及一个漂亮的材料组件库。可以轻松地设置和构建移动应用程序。 Material design components如果您热衷于设计Material，Angular有一个Material组件库 更多更多的有关Angular相关类库和工具:Awesome Angular list 学习曲线Angular介绍了最多的新概念。首先，您需要使用TypeScript。对于具有静态类型语言（如Java或.NET）经验的开发人员，这可能比JavaScript更容易理解，但对于纯JavaScript开发人员，这可能需要一些额外的学习。 框架本身丰富的技术主题可以从诸如模块，依赖注入、装饰器、组件、服务、管道、模板和指令等基础开始，到更高级的主题，如更改检测，区域，AoT编译和RxJS。这些都在文档中。RxJS是一个很重的话题，在官方网站上有详细描述。虽然在基本功能层面上使用起来相对容易，但在转到高级应用时会变得更加复杂。 ReactReact由Facebook开发和维护，用于自己的产品，包括Instagram和WhatsApp。它也是GitHub 最受欢迎的项目之一。 功能特性React本身提供的功能就相对 简约： 无依赖注入 使用JSX代替传统的HTML Templates XSS保护 单元测试工具 自由度去挑选第三方的类库，比如： 路由（React-router） AJAX（Fetch or axios） 各种CSS封装（详见 更强大的单元测试（Enzyme） 模式JSXReact决定使用一种类似XML的语言在组件中把标记和代码结合起来，直接在JavaScript代码中编写HTML标记。 优点：静态分析。如果在JSX标记中发生错误，编译器会立即报错而不是留待运行时出现莫名其妙的问题。这有助于开发人员快速排查错误以及避免其它愚蠢的错误，比如拼写错误。 FlowFlow是由Facebook开发的JavaScript类型检查工具。它可以解析代码并检查常见的类型错误，如隐式转换或取消引用。 你的代码注释类型检查工作。在流程中，类型注释是可选的，可用于向分析器提供其他提示。如果你想使用静态代码分析，同时避免重写现有的代码，Flow是一个很好的选择。 ReduxRedux是一个可以以清晰的方式管理状态变化的库。它的灵感来自Flux，但是有一些简化。Redux的关键思想在于，应用程序的整个状态由单个对象表示，该对象由名为reducers的函数进行突变。Reducers本身是纯功能，与组件分开实现。这样可以更好地分离问题和测试。 如果你正在开展一个简单的项目，那么引入Redux可能有点得不偿失，但对于中等和大型项目来说，这是一个很好的选择。 生态系统Create React AppCreate-react-app 是一个CLI工具，用于快速创建新的React应用。可以生成一个新的工程，启动开发服务器并创建绑定。Jest（Facebook的一个单元测试工具）也同时集成在Create-react-app内部，更方便的让我们进行单元测试。 React NativeReact Native 是Facebook开发的基于React在移动端的开发平台，借助此平台，React可以创建真正的Native的UI。提供了一系列标准的React组件用于绑定。同时允许创建自己的组件并与Objective-C、Java或者Swift的代码进行绑定。 Material UI用于React的Material Design Component。与Angular的版本相比，比较成熟，可以使用更广泛的组件 Next.jsNext.js是一个基于React实现的服务端渲染框架，github地址为next.js。 更多可以从Awesome React list了解更多的工具和类库。 学习曲线JSX对于一些开发人员来说似乎刚开始会觉得很别扭，但它并没有增加复杂性; 只是表达式，实际上还是JavaScript，还有一个特殊的类似HTML的语法。您还需要学习如何编写组件，使用props进行配置和管理内部状态。不需要学习任何新的逻辑结构或循环，因为所有这些都是纯JavaScript。 官方教程是开始学习React的好地方。一旦完成了官方教程，接下来应该熟悉并掌握React的路由机制 。 使用Redux将需要一个范式的转变，免费入门Redux视频课程可以快速介绍核心概念。 根据项目的大小和复杂性，找到并学习一些额外的库。 VueVue.js 是一套构建用户界面的渐进式框架。尤雨溪个人创立的一个前端MVVM框架，Vue.js 是构建 Web 界面的 JavaScript 库，提供数据驱动的组件，还有简单灵活的 API，使得 MVVM 更简单。 功能特性Vue提供的功能就相对 简约： 轻量级的框架 双向数据绑定 指令 插件化 模式组件系统把UI结构映射到恰当的组件树。Vue的组件引入构建工具之后有一个单文件组件概念，就是这个Vue文件。在同一个Vue文件里，可以同时写 template, script 和 style，三个东西放在一个里面。同时，Vue的单文件组件和 Web Components 有一个本质不同，它是基于构建工具实现。 客户端路由 vue-router应用的URL和组件树的状态之间有一个映射关系，客户端路由的职责就是让这个映射关系声明式地对应起来。 状态管理 vuex它采用集中式存储管理应用的所有组件的状态. 生态系统vue-cliVue 提供了一个官方的 CLI，为单页面应用快速搭建 (SPA) 繁杂的脚手架。它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。 weexWeex 致力于使开发者能基于当代先进的 Web 开发技术，使用同一套代码来构建 Android、iOS 和 Web 应用。目前主要支持 Vue.js 和 Rax 这两个前端框架。 服务端渲染 Nuxt.jsNuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。 更多可以从Awesome vue list了解更多的工具和类库。 前人对比 React or VueReact or Vue: Which Javascript UI Library Should You Be Using? | Codementor 两个倡导者对比了React和Vue,得出了如下结论： 如果你喜欢用（或希望能够用）模板搭建应用，请使用Vue 如果你喜欢简单和“能用就行”的东西，请使用Vue 如果你的应用需要尽可能的小和快，请使用Vue 如果你计划构建一个大型应用程序，请使用React 如果你想要一个同时适用于Web端和原生App的框架，请选择React 如果你想要最大的生态圈，请使用React 如果你已经对其中一个用得满意了，就没有必要换了 UI组件库和最佳实践Material design componentsAnt Design Components基于 Ant Design 设计语言，我们提供了一套开箱即用的高质量 React 组件，用于开发和服务于企业级中后台产品。 Ant Design Pro 预览 优雅美观：基于 Ant Design 体系精心设计 常见设计模式：提炼自中后台应用的典型页面和场景 最新技术栈：使用 React/dva/antd 等前端前沿技术开发 响应式：针对不同屏幕大小设计 主题：可配置的主题满足多样化的品牌诉求 国际化：内建业界通用的国际化方案 最佳实践：良好的工程实践助您持续产出高质量代码 Mock 数据：实用的本地数据调试方案 UI 测试：自动化测试保障前端产品质量 Element一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 vuejs/vue-cli 3.x iview一套基于 Vue.js 的高质量 UI 组件库 iView adminiView admin是基于Vue.js，搭配使用iView UI组件库形成的一套后台集成解决方案 2.0版本预告 Feature 使用Vue-cli作为项目脚手架 使用Webpack4版本（待定） 重整项目结构，更好封装组件 新增更多组件 多级菜单 动态路由 重构权限控制体系 使用最新版iView以及iView-editor 加入大数据量表格vue-bigdata-table组件，几十万数据流畅渲染 移动端IonicIonic 开发混合移动应用程序。Angular集成的Cordova容器，以及一个漂亮的材料组件库。可以轻松地设置和构建移动应用程序。 编写一次运行到多个平台 Ionic3基于最新的angular4。Angular4和TypeScript以面向对象的开发方式，将成为网页开发的主流方式，而且在语法上与Java 8惊人的相似。 官方集成常见的120多种api功能，如蓝牙、HealthKit、指纹Auth，可以基于cordova扩展几乎原生能实现的所有功能。 性能而生-追求性能,运行非常流畅。 让您感觉到用html5开发的app也可以飞起来。 专注原生Native,基于cordova，官方提供了几百个调用原生的插件，可以快速的让我们完成调用摄像头、二维码、调用支付、调用定位等原生功能 强大的命令行,利用ionicframework只需要一个命令就可以创建，构建，测试，部署你的应用程序在任何平台上。 React Nativereact-native通过Components进行组件化。它把UI分割成独立的、可重用的部件 。 React通过虚拟DOM实现了对UI层的解耦（无论是android还是ios） 将浏览器的DOM树替换为Native的UI模块，使React在移动端进行渲染 采用Native的核心API完成react与native的通信 使用React Native一年后的感受 react-native技术的优劣 weexWeex 致力于使开发者能基于当代先进的 Web 开发技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。 weex只是提供了很好的多平台集成方式，但自身提供的组件很少，没有项目上的结构，这方面可以引用 WeexEros) WeexEroseros 是基于 weex 封装面向前端的 vue 写法的解决方案，由于 app 开发的特殊性，eros 则更偏重关心于整个 app 项目。 详细的文档来解决环境搭建过程中的坑。 一套代码编译成 ios，android 两端原生应用。 封装了大量 weex module，让前端开发方便进行原生的操作。 支持大量 echart 实例运行。 可以通过 appboard 机制来减少多页面项目中的代码冗余，减少包体积，并可以对其实时修改。 内置了一套完整的 JS 二次封装 module (widget) ，直接通过 vue 插件系统注入，直接在 this 上调用，可根据业务自行修改。 内置了中介者服务，来进行多个页面间的交互，并可以管理业务。 内置了服务器端增量发布更新逻辑，可以搭配着开源的简易增量发布系统一起使用。 支持真机和模拟器通过 weex debug 来断点调试，程序报错均会有报错日志弹窗提示。 Ionic vs React NativeIonic vs React Native: 前端框架之争，谁更胜一筹？ weex&amp;ReactNative对比weex&amp;ReactNative对比","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"}]},{"title":"Go微服务教程-第八部分","slug":"go-micro-tutorial-8","date":"2018-05-10T13:57:01.000Z","updated":"2020-07-25T02:57:18.206Z","comments":true,"path":"2018/05/10/go-micro-tutorial-8/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-8/","excerpt":"","text":"在之前的文章中，我们研究了用Terraform创建一个容器引擎集群。在本文中，我们将使用容器引擎和Kubernetes来研究如何将容器部署到我们的集群中。 Kubernetes首先,Kubernetes是什么?Kubernetes是一个开源的容器管理框架。它是平台无关的，这意味着您可以在本地机器、AWS、谷歌云或其他任何地方运行它。它允许您使用解密配置控制容器组和它们的网络规则。 您只需编写描述哪些容器应该运行的yaml/json文件，以及在何处运行。您可以定义您的网络规则，例如任何端口转发。它还为您处理服务发现。 Kubernetes是云场景中最重要的添加物之一，它正迅速成为云容器管理的实际选择。这是一个很好的理解。 所以让我们开始吧! 首先，确保您在本地安装了kubectl cli: 1$ gcloud components install kubectl 现在让我们确保您已经连接到您的集群并正确地进行了身份验证。首先，我们会登录并确认我们的身份。其次，我们将设置项目设置，以确保我们使用正确的项目ID和可用性区域。 12345678$ echo \"This command will open a web browser, and will ask you to login$ gcloud auth application-default login$ gcloud config set project shippy-freight$ gcloud config set compute/zone eu-west2-a$ echo \"Now generate a security token and access to your KB cluster\"$ gcloud container clusters get-credentials shippy-freight-cluster 在上面的命令中，您可能需要用所选择的区域替换计算/区域，您的项目id和集群名称也可能与我的不同。 这里有一个大纲……","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第七部分","slug":"go-micro-tutorial-7","date":"2018-05-10T13:56:56.000Z","updated":"2020-07-25T02:57:18.206Z","comments":true,"path":"2018/05/10/go-micro-tutorial-7/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-7/","excerpt":"在前一篇文章中，我们简要介绍了用户界面和web客户端，以及如何使用微工具包rpc代理与新创建的rpc服务进行交互。 这篇文章，我们将讨论如何创建一个云环境来承载我们的服务。我们将使用Terraform来架构我们的云集群在谷歌云平台上。这应该是一篇相当短的文章，但它很重要。","text":"在前一篇文章中，我们简要介绍了用户界面和web客户端，以及如何使用微工具包rpc代理与新创建的rpc服务进行交互。 这篇文章，我们将讨论如何创建一个云环境来承载我们的服务。我们将使用Terraform来架构我们的云集群在谷歌云平台上。这应该是一篇相当短的文章，但它很重要。 为什么Terraform","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第六部分","slug":"go-micro-tutorial-6","date":"2018-05-10T13:56:52.000Z","updated":"2020-07-25T02:57:18.205Z","comments":true,"path":"2018/05/10/go-micro-tutorial-6/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-6/","excerpt":"在上一篇文章中，我们讨论了一些在go-micro和go中事件驱动架构的各种方法。这一部分，我们将深入到客户端，看看如何创建与我们的平台交互的web客户端。 我们将研究微型工具包，使您能够将内部rpc方法从外部代理到web客户端。 我们将为我们的平台创建一个用户界面，一个登录界面，以及一个创建委托界面。这将把以前的一些帖子联系在一起。 所以让我们开始吧!","text":"在上一篇文章中，我们讨论了一些在go-micro和go中事件驱动架构的各种方法。这一部分，我们将深入到客户端，看看如何创建与我们的平台交互的web客户端。 我们将研究微型工具包，使您能够将内部rpc方法从外部代理到web客户端。 我们将为我们的平台创建一个用户界面，一个登录界面，以及一个创建委托界面。这将把以前的一些帖子联系在一起。 所以让我们开始吧! RPC复兴REST已经在web上运行多年了，它已经迅速成为管理客户端和服务器之间资源的goto方式。REST的出现，取代了RPC和SOAP实现的狂野西部，这种方式有时会让人觉得过时和痛苦。曾经需要编写wsdl文件吗? REST向我们承诺了一种实用的、简单的、统一的管理资源的方法。REST使用http谓词在执行的操作类型中更加显式。REST鼓励我们使用http错误代码来更好地描述服务器的响应。在很大程度上，这种方法运行良好，而且很好。但是像所有的好东西一样，休息也有很多抱怨和烦恼，我不打算在这里详细说明。但请务必阅读这篇文章。但随着微服务的出现，RPC正在卷土重来。 Rest对于管理不同的资源非常有用，但是微服务通常只处理单个资源的本质。因此，我们不需要在微服务上下文中使用RESTful术语。相反，我们可以专注于每个服务的具体操作和交互。 Micro在本教程中，我们已经广泛地使用了go-micro，现在我们将讨论microcli /toolkit。microtoolkit提供了一个API网关、一个sidecar、一个web代理以及其他一些很酷的特性。但我们将在这篇文章中看到的主要部分是API网关。 API网关将允许我们将rpc调用代理到web友好的JSON rpc调用，并将公开我们在客户端应用程序中可以使用的url。 那么这是如何运作的呢?你首先要确保安装了微型工具包: 1$ go get -u github.com/micro/micro 更好的是，既然我们使用Docker，让我们使用Docker映像: 1$ docker pull microhq/micro 现在让我们进入我们的用户服务，我做了一些更改，主要是错误处理和命名约定: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// shippy-user-service/main.gopackage mainimport ( \"log\" pb \"github.com/EwanValentine/shippy-user-service/proto/auth\" \"github.com/micro/go-micro\" _ \"github.com/micro/go-plugins/registry/mdns\")func main() &#123; // Creates a database connection and handles // closing it again before exit. db, err := CreateConnection() defer db.Close() if err != nil &#123; log.Fatalf(\"Could not connect to DB: %v\", err) &#125; // Automatically migrates the user struct // into database columns/types etc. This will // check for changes and migrate them each time // this service is restarted. db.AutoMigrate(&amp;pb.User&#123;&#125;) repo := &amp;UserRepository&#123;db&#125; tokenService := &amp;TokenService&#123;repo&#125; // Create a new service. Optionally include some options here. srv := micro.NewService( // This name must match the package name given in your protobuf definition micro.Name(\"shippy.auth\"), ) // Init will parse the command line flags. srv.Init() // Will comment this out for now to save having to run this locally... // publisher := micro.NewPublisher(\"user.created\", srv.Client()) // Register handler pb.RegisterAuthHandler(srv.Server(), &amp;service&#123;repo, tokenService, publisher&#125;) // Run the server if err := srv.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// shippy-user-service/proto/auth/auth.protosyntax = &quot;proto3&quot;;package auth;service Auth &#123; rpc Create(User) returns (Response) &#123;&#125; rpc Get(User) returns (Response) &#123;&#125; rpc GetAll(Request) returns (Response) &#123;&#125; rpc Auth(User) returns (Token) &#123;&#125; rpc ValidateToken(Token) returns (Token) &#123;&#125;&#125;message User &#123; string id = 1; string name = 2; string company = 3; string email = 4; string password = 5;&#125;message Request &#123;&#125;message Response &#123; User user = 1; repeated User users = 2; repeated Error errors = 3;&#125;message Token &#123; string token = 1; bool valid = 2; repeated Error errors = 3;&#125;message Error &#123; int32 code = 1; string description = 2;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// shippy-user-service/handler.gopackage mainimport ( \"errors\" \"fmt\" \"log\" pb \"github.com/EwanValentine/shippy-user-service/proto/auth\" micro \"github.com/micro/go-micro\" \"golang.org/x/crypto/bcrypt\" \"golang.org/x/net/context\")const topic = \"user.created\"type service struct &#123; repo Repository tokenService Authable Publisher micro.Publisher&#125;func (srv *service) Get(ctx context.Context, req *pb.User, res *pb.Response) error &#123; user, err := srv.repo.Get(req.Id) if err != nil &#123; return err &#125; res.User = user return nil&#125;func (srv *service) GetAll(ctx context.Context, req *pb.Request, res *pb.Response) error &#123; users, err := srv.repo.GetAll() if err != nil &#123; return err &#125; res.Users = users return nil&#125;func (srv *service) Auth(ctx context.Context, req *pb.User, res *pb.Token) error &#123; log.Println(\"Logging in with:\", req.Email, req.Password) user, err := srv.repo.GetByEmail(req.Email) log.Println(user, err) if err != nil &#123; return err &#125; // Compares our given password against the hashed password // stored in the database if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil &#123; return err &#125; token, err := srv.tokenService.Encode(user) if err != nil &#123; return err &#125; res.Token = token return nil&#125;func (srv *service) Create(ctx context.Context, req *pb.User, res *pb.Response) error &#123; log.Println(\"Creating user: \", req) // Generates a hashed version of our password hashedPass, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost) if err != nil &#123; return errors.New(fmt.Sprintf(\"error hashing password: %v\", err)) &#125; req.Password = string(hashedPass) if err := srv.repo.Create(req); err != nil &#123; return errors.New(fmt.Sprintf(\"error creating user: %v\", err)) &#125; res.User = req if err := srv.Publisher.Publish(ctx, req); err != nil &#123; return errors.New(fmt.Sprintf(\"error publishing event: %v\", err)) &#125; return nil&#125;func (srv *service) ValidateToken(ctx context.Context, req *pb.Token, res *pb.Token) error &#123; // Decode token claims, err := srv.tokenService.Decode(req.Token) if err != nil &#123; return err &#125; if claims.User.Id == \"\" &#123; return errors.New(\"invalid user\") &#125; res.Valid = true return nil&#125; 现在运行$ make build &amp;&amp; make run。然后前往您的shippy- emailservice服务并运行$ make build &amp;&amp; make run。一旦两者都运行，运行: 123456$ docker run -p 8080:8080 \\ -e MICRO_REGISTRY=mdns \\ microhq/micro api \\ --handler=rpc \\ --address=:8080 \\ --namespace=shippy 这在Docker容器中作为端口8080的rpc处理程序运行微api网关。我们告诉它在本地使用mdns作为注册表，与其他服务相同。最后，我们告诉它使用名称空间shippy，这是我们所有服务名称的第一部分shippy.auth或shippy.email。这很重要，因为它默认为go.micro.api，在这种情况下，它将无法找到我们的服务来代理它们。 我们的用户服务方法现在可以通过以下方式调用: 创建一个用户: 123curl -XPOST -H 'Content-Type: application/json' \\ -d '&#123; \"service\": \"shippy.auth\", \"method\": \"Auth.Create\", \"request\": &#123; \"user\": &#123; \"email\": \"ewan.valentine89@gmail.com\", \"password\": \"testing123\", \"name\": \"Ewan Valentine\", \"company\": \"BBC\" &#125; &#125; &#125;' \\ http://localhost:8080/rpc 如您所见，我们在请求中包括我们希望被路由的服务、我们想要使用的服务的方法，以及我们希望使用的数据。 验证一个用户: 123$ curl -XPOST -H 'Content-Type: application/json' \\ -d '&#123; \"service\": \"shippy.auth\", \"method\": \"Auth.Auth\", \"request\": &#123; \"email\": \"your@email.com\", \"password\": \"SomePass\" &#125; &#125;' \\ http://localhost:8080/rpc 寄售服务现在是时候重新启动我们的寄售服务了，$ make build &amp;&amp; make run。我们不需要在这里修改任何东西，但是，运行rpc代理，我们应该能够做到: 创建一个委托: 12345678910$ curl -XPOST -H 'Content-Type: application/json' \\ -d '&#123; \"service\": \"shippy.consignment\", \"method\": \"ConsignmentService.Create\", \"request\": &#123; \"description\": \"This is a test\", \"weight\": \"500\", \"containers\": [] &#125; &#125;' --url http://localhost:8080/rpc 船服务为了测试我们的用户界面，我们需要运行的最终服务是我们的船只服务，这里没有什么变化，所以只要运行$ make build &amp;&amp; make run。 用户界面让我们使用新的rpc端点，并创建一个UI。我们将使用React，但你可以随意使用任何你喜欢的。请求都是一样的。我将使用来自Facebook的react-create-app library。$ npm install -g react-create-app.一旦安装好，你就可以做$ react-create-app shippy-ui了。这将为您创建一个反应应用程序的框架。 所以让我们开始… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// shippy-ui/src/App.jsimport React, &#123; Component &#125; from 'react';import './App.css';import CreateConsignment from './CreateConsignment';import Authenticate from './Authenticate';class App extends Component &#123; state = &#123; err: null, authenticated: false, &#125; onAuth = (token) =&gt; &#123; this.setState(&#123; authenticated: true, &#125;); &#125; renderLogin = () =&gt; &#123; return ( &lt;Authenticate onAuth=&#123;this.onAuth&#125; /&gt; ); &#125; renderAuthenticated = () =&gt; &#123; return ( &lt;CreateConsignment /&gt; ); &#125; getToken = () =&gt; &#123; return localStorage.getItem('token') || false; &#125; isAuthenticated = () =&gt; &#123; return this.state.authenticated || this.getToken() || false; &#125; render() &#123; const authenticated = this.isAuthenticated(); return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;h2&gt;Shippy&lt;/h2&gt; &lt;/div&gt; &lt;div className='App-intro container'&gt; &#123;(authenticated ? this.renderAuthenticated() : this.renderLogin())&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 现在，让我们添加主要的两个组件，身份验证和createcon: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// shippy-ui/src/Authenticate.jsimport React from 'react';class Authenticate extends React.Component &#123; constructor(props) &#123; super(props); &#125; state = &#123; authenticated: false, email: '', password: '', err: '', &#125; login = () =&gt; &#123; fetch(`http://localhost:8080/rpc`, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; request: &#123; email: this.state.email, password: this.state.password, &#125;, service: 'shippy.auth', method: 'Auth.Auth', &#125;), &#125;) .then(res =&gt; res.json()) .then(res =&gt; &#123; this.props.onAuth(res.token); this.setState(&#123; token: res.token, authenticated: true, &#125;); &#125;) .catch(err =&gt; this.setState(&#123; err, authenticated: false, &#125;)); &#125; signup = () =&gt; &#123; fetch(`http://localhost:8080/rpc`, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; request: &#123; email: this.state.email, password: this.state.password, name: this.state.name, &#125;, method: 'Auth.Create', service: 'shippy.auth', &#125;), &#125;) .then((res) =&gt; res.json()) .then((res) =&gt; &#123; this.props.onAuth(res.token.token); this.setState(&#123; token: res.token.token, authenticated: true, &#125;); localStorage.setItem('token', res.token.token); &#125;) .catch(err =&gt; this.setState(&#123; err, authenticated: false, &#125;)); &#125; setEmail = e =&gt; &#123; this.setState(&#123; email: e.target.value, &#125;); &#125; setPassword = e =&gt; &#123; this.setState(&#123; password: e.target.value, &#125;); &#125; setName = e =&gt; &#123; this.setState(&#123; name: e.target.value, &#125;); &#125; render() &#123; return ( &lt;div className='Authenticate'&gt; &lt;div className='Login'&gt; &lt;div className='form-group'&gt; &lt;input type=\"email\" onChange=&#123;this.setEmail&#125; placeholder='E-Mail' className='form-control' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;input type=\"password\" onChange=&#123;this.setPassword&#125; placeholder='Password' className='form-control' /&gt; &lt;/div&gt; &lt;button className='btn btn-primary' onClick=&#123;this.login&#125;&gt;Login&lt;/button&gt; &lt;br /&gt;&lt;br /&gt; &lt;/div&gt; &lt;div className='Sign-up'&gt; &lt;div className='form-group'&gt; &lt;input type='input' onChange=&#123;this.setName&#125; placeholder='Name' className='form-control' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;input type='email' onChange=&#123;this.setEmail&#125; placeholder='E-Mail' className='form-control' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;input type='password' onChange=&#123;this.setPassword&#125; placeholder='Password' className='form-control' /&gt; &lt;/div&gt; &lt;button className='btn btn-primary' onClick=&#123;this.signup&#125;&gt;Sign-up&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Authenticate; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// shippy-ui/src/CreateConsignment.jsimport React from 'react';import _ from 'lodash';class CreateConsignment extends React.Component &#123; constructor(props) &#123; super(props); &#125; state = &#123; created: false, description: '', weight: 0, containers: [], consignments: [], &#125; componentWillMount() &#123; fetch(`http://localhost:8080/rpc`, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; service: 'shippy.consignment', method: 'ConsignmentService.Get', request: &#123;&#125;, &#125;) &#125;) .then(req =&gt; req.json()) .then((res) =&gt; &#123; this.setState(&#123; consignments: res.consignments, &#125;); &#125;); &#125; create = () =&gt; &#123; const consignment = this.state; fetch(`http://localhost:8080/rpc`, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; service: 'shippy.consignment', method: 'ConsignmentService.Create', request: _.omit(consignment, 'created', 'consignments'), &#125;), &#125;) .then((res) =&gt; res.json()) .then((res) =&gt; &#123; this.setState(&#123; created: res.created, consignments: [...this.state.consignments, consignment], &#125;); &#125;); &#125; addContainer = e =&gt; &#123; this.setState(&#123; containers: [...this.state.containers, e.target.value], &#125;); &#125; setDescription = e =&gt; &#123; this.setState(&#123; description: e.target.value, &#125;); &#125; setWeight = e =&gt; &#123; this.setState(&#123; weight: Number(e.target.value), &#125;); &#125; render() &#123; const &#123; consignments, &#125; = this.state; return ( &lt;div className='consignment-screen'&gt; &lt;div className='consignment-form container'&gt; &lt;br /&gt; &lt;div className='form-group'&gt; &lt;textarea onChange=&#123;this.setDescription&#125; className='form-control' placeholder='Description'&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;input onChange=&#123;this.setWeight&#125; type='number' placeholder='Weight' className='form-control' /&gt; &lt;/div&gt; &lt;div className='form-control'&gt; Add containers... &lt;/div&gt; &lt;br /&gt; &lt;button onClick=&#123;this.create&#125; className='btn btn-primary'&gt;Create&lt;/button&gt; &lt;br /&gt; &lt;hr /&gt; &lt;/div&gt; &#123;(consignments &amp;&amp; consignments.length &gt; 0 ? &lt;div className='consignment-list'&gt; &lt;h2&gt;Consignments&lt;/h2&gt; &#123;consignments.map((item) =&gt; ( &lt;div&gt; &lt;p&gt;Vessel id: &#123;item.vessel_id&#125;&lt;/p&gt; &lt;p&gt;Consignment id: &#123;item.id&#125;&lt;/p&gt; &lt;p&gt;Description: &#123;item.description&#125;&lt;/p&gt; &lt;p&gt;Weight: &#123;item.weight&#125;&lt;/p&gt; &lt;hr /&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; : false)&#125; &lt;/div&gt; ); &#125;&#125;export default CreateConsignment; 注意:我还添加了Twitter Bootstrap 到/public/index.html和修改了一些css。 现在运行用户界面$ npm start。这应该会在您的浏览器中自动打开。现在，您应该能够注册和登录，并查看托运表单，您可以在其中创建新的托运。在您的dev工具中查看网络选项卡，并查看从不同的微服务中触发和获取数据的rpc方法。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第五部分","slug":"go-micro-tutorial-5","date":"2018-05-10T13:56:48.000Z","updated":"2020-07-25T02:57:18.205Z","comments":true,"path":"2018/05/10/go-micro-tutorial-5/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-5/","excerpt":"在本系列的前一部分中，我们讨论了用户身份验证和JWT。在这节课中，我们将快速浏览一下go-micro的代理功能，甚至是代理。 正如前文所提到的，go-micro是一个可插拔的框架，它接口许多不同的常用技术。如果您查看一下plugins repo，您会看到它支持了多少个插件。 在我们的例子中，我们将使用NATS代理插件。","text":"在本系列的前一部分中，我们讨论了用户身份验证和JWT。在这节课中，我们将快速浏览一下go-micro的代理功能，甚至是代理。 正如前文所提到的，go-micro是一个可插拔的框架，它接口许多不同的常用技术。如果您查看一下plugins repo，您会看到它支持了多少个插件。 在我们的例子中，我们将使用NATS代理插件。 事件驱动架构事件驱动的体系结构是一个非常简单的概念。我们通常认为好的体系结构是可以解耦的;这些服务不应该与其他服务相耦合。当我们使用gRPC这样的协议时，这在某些情况下是正确的，因为我们说我想将这个请求发布到go.srv。例如用户服务。使用服务发现来查找该服务的实际位置。虽然这并不能直接将我们与实现结合起来，但它确实将服务连接到另一个名为go.srv的东西上。用户服务，所以它不是完全解耦的，因为它直接与其他东西对话。 那么，是什么使事件驱动架构真正地解耦了呢?为了理解这一点，让我们首先看一下发布和订阅事件的过程。服务a完成了任务x，然后对生态系统“x刚刚发生”表示。它不需要知道，或者关心是谁在听那个事件，或者是什么受到了那个事件的影响。这种责任留给了倾听的客户。 如果你期望在某一事件上有n个服务，这也会更容易。例如，如果您需要12个不同的服务来处理使用gRPC创建的新用户，那么您必须在您的用户服务中实例化12个客户端。使用pubsub或事件驱动架构，您的服务不需要关心这些。 现在，客户端服务将简单地侦听事件。这意味着您需要某种中间的中介来接受这些事件，并将其发布通知客户。 在本文中，我们将在每次创建用户时创建一个事件，我们将创建一个新服务来发送电子邮件。我们实际上不会写电子邮件的实现，只是暂时把它模拟出来。 代码首先，我们需要将NATS代理插件集成到我们的用户服务中: 12345678910111213// shippy-user-service/main.gofunc main() &#123; ... // Init will parse the command line flags. srv.Init() // Get instance of the broker using our defaults pubsub := srv.Server().Options().Broker // Register handler pb.RegisterUserServiceHandler(srv.Server(), &amp;service&#123;repo, tokenService, pubsub&#125;) ...&#125; 现在，让我们在创建新用户时发布事件(请参阅此处的完整更改): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// shippy-user-service/handler.goconst topic = \"user.created\"type service struct &#123; repo Repository tokenService Authable PubSub broker.Broker&#125;...func (srv *service) Create(ctx context.Context, req *pb.User, res *pb.Response) error &#123; // Generates a hashed version of our password hashedPass, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost) if err != nil &#123; return err &#125; req.Password = string(hashedPass) if err := srv.repo.Create(req); err != nil &#123; return err &#125; res.User = req if err := srv.publishEvent(req); err != nil &#123; return err &#125; return nil&#125;func (srv *service) publishEvent(user *pb.User) error &#123; // Marshal to JSON string body, err := json.Marshal(user) if err != nil &#123; return err &#125; // Create a broker message msg := &amp;broker.Message&#123; Header: map[string]string&#123; \"id\": user.Id, &#125;, Body: body, &#125; // Publish message to broker if err := srv.PubSub.Publish(topic, msg); err != nil &#123; log.Printf(\"[pub] failed: %v\", err) &#125; return nil&#125;... 确保你在运行Postgres，然后让我们运行这个服务: 123$ docker run -d -p 5432:5432 postgres$ make build$ make run 现在让我们创建我们的电子邮件服务。我创建了一个新的repo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// shippy-email-servicepackage mainimport ( \"encoding/json\" \"log\" pb \"github.com/EwanValentine/shippy-user-service/proto/user\" micro \"github.com/micro/go-micro\" \"github.com/micro/go-micro/broker\" _ \"github.com/micro/go-plugins/broker/nats\")const topic = \"user.created\"func main() &#123; srv := micro.NewService( micro.Name(\"go.micro.srv.email\"), micro.Version(\"latest\"), ) srv.Init() // Get the broker instance using our environment variables pubsub := srv.Server().Options().Broker if err := pubsub.Connect(); err != nil &#123; log.Fatal(err) &#125; // Subscribe to messages on the broker _, err := pubsub.Subscribe(topic, func(p broker.Publication) error &#123; var user *pb.User if err := json.Unmarshal(p.Message().Body, &amp;user); err != nil &#123; return err &#125; log.Println(user) go sendEmail(user) return nil &#125;) if err != nil &#123; log.Println(err) &#125; // Run the server if err := srv.Run(); err != nil &#123; log.Println(err) &#125;&#125;func sendEmail(user *pb.User) error &#123; log.Println(\"Sending email to:\", user.Name) return nil&#125; 在运行这个之前，我们需要运行NATS… 1$ docker run -d -p 4222:4222 nats 另外，我想快速地解释一下我觉得在理解它是如何作为一个框架的过程中，我觉得很重要的一部分。你会注意到: 12srv.Init()pubsub := srv.Server().Options().Broker 让我们快速看一看。当我们在go-micro中创建服务时，后台的srv.Init()将查找任何配置，如任何插件和环境变量，或命令行选项。然后它将实例化这些集成作为服务的一部分。为了使用这些实例，我们需要将它们从服务实例中取出。在srv.Server().options()中，您还将找到传输和注册表。 在这里，它将找到我们的GO_MICRO_BROKER环境变量，它将找到NATS代理插件，并创建一个实例。准备好让我们连接和使用。 如果您正在创建一个命令行工具，那么您将使用cmd.Init()，确保您导入的是github.com/micro/go-micro/cmd。这将产生同样的影响。 现在构建并运行这个服务:$ make build &amp;&amp; make run，确保您也运行了用户服务。然后转到我们的shippy-user-cli repo，运行$ make run，查看我们的电子邮件服务输出。你应该看看……2017/12/26 23:57:23发邮件至:Ewan Valentine。 这是它!这是一个有点牵强的例子，因为我们的电子邮件服务隐式地监听单个用户。创建的事件。但是希望您能看到这种方法是如何允许您编写解耦的服务的。 值得一提的是，如果我们回到序列化JSON字符串的领域，在NATS上使用JSON将会有性能开销vs gRPC。但是，对于某些用例来说，这是完全可以接受的。NATS是非常高效的，对火灾和遗忘事件来说是非常棒的。 Go-micro还支持一些最广泛使用的queue/pubsub技术，供您使用。您可以在这里看到它们的列表。你不需要改变你的实现，因为你可以把它抽象出来。您只需要将环境变量从MICRO_BROKER=nats更改为MICRO_BROKER=googlepubsub，然后更改main中的导入。例如，从 _ &quot;github.com/micro/go-plugins/broker/nats&quot;到_ &quot;github.com/micro/go-plugins/broker/googlepubsub&quot;。 如果你不使用go-micro，那就会有一个NATS go库(NATS本身是写在go上的，所以自然地支持go是相当可靠的)。 发布一个事件: 1234nc, _ := nats.Connect(nats.DefaultURL)// Simple Publishernc.Publish(\"user.created\", userJsonString) 订阅一个事件: 12345// Simple Async Subscribernc.Subscribe(\"user.created\", func(m *nats.Msg) &#123; user := convertUserString(m.Data) go sendEmail(user)&#125;) 我之前提到过，当使用第三方message broker(比如NATS)时，您就会失去对protobuf的使用。这是一个遗憾，因为我们失去了使用二进制流进行通信的能力，当然这比序列化的JSON字符串的开销要低得多。但与大多数担忧一样，go-micro也能解决这个问题。 内置到go-micro是一个pubsub层，它位于代理层之上，但不需要第三方代理，如NATS。但是这个特性的可怕之处在于，它使用了你的protobuf定义。我们回到了低延迟的二进制流领域。因此，让我们更新我们的用户服务以替换现有的NATS代理，使用go-micro的pubsub: 123456789// shippy-user-service/main.gofunc main() &#123; ... publisher := micro.NewPublisher(\"user.created\", srv.Client()) // Register handler pb.RegisterUserServiceHandler(srv.Server(), &amp;service&#123;repo, tokenService, publisher&#125;) ...&#125; 1234567891011121314151617181920// shippy-user-service/handler.gofunc (srv *service) Create(ctx context.Context, req *pb.User, res *pb.Response) error &#123; // Generates a hashed version of our password hashedPass, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost) if err != nil &#123; return err &#125; req.Password = string(hashedPass) // Here's our new publisher code, much simpler if err := srv.repo.Create(req); err != nil &#123; return err &#125; res.User = req if err := srv.Publisher.Publish(ctx, req); err != nil &#123; return err &#125; return nil&#125; 现在我们的电子邮件服务: 12345678910111213141516// shippy-email-serviceconst topic = \"user.created\"type Subscriber struct&#123;&#125;func (sub *Subscriber) Process(ctx context.Context, user *pb.User) error &#123; log.Println(\"Picked up a new message\") log.Println(\"Sending email to:\", user.Name) return nil&#125;func main() &#123; ... micro.RegisterSubscriber(topic, srv.Server(), new(Subscriber)) ...&#125; 现在，我们在服务中使用底层用户原型，而不是使用gRPC，也不使用第三方代理。太棒了! 这是一个包装!下一个教程，我们将介绍如何为我们的服务创建一个用户界面，并查看web客户端如何开始与我们的服务交互。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第四部分","slug":"go-micro-tutorial-4","date":"2018-05-10T13:56:32.000Z","updated":"2020-07-25T02:57:18.205Z","comments":true,"path":"2018/05/10/go-micro-tutorial-4/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-4/","excerpt":"在本系列的前一部分中，我们研究了创建用户服务并开始存储一些用户。现在我们需要考虑使我们的用户服务存储用户密码安全，并创建一些功能来验证用户，并在我们的微服务中发布安全令牌。","text":"在本系列的前一部分中，我们研究了创建用户服务并开始存储一些用户。现在我们需要考虑使我们的用户服务存储用户密码安全，并创建一些功能来验证用户，并在我们的微服务中发布安全令牌。 注意，我现在已经将我们的服务分离到单独的存储库中。我发现这更容易部署。最初，我打算尝试做一个monorepo，但是我发现用Go的dep管理来设置它太麻烦了，不会有各种冲突。我还将开始演示如何独立运行和测试微服务。 不幸的是，使用这种方法，我们将会失去docker。但现在还好。 现在需要手动运行数据库: 12$ docker run -d -p 5432:5432 postgres$ docker run -d -p 27017:27017 mongo 新的存储库可以在这里找到: https://github.com/EwanValentine/shippy-consignment-service https://github.com/EwanValentine/shippy-user-service https://github.com/EwanValentine/shippy-vessel-service https://github.com/EwanValentine/shippy-user-cli https://github.com/EwanValentine/shippy-consignment-cli 首先，让我们更新我们的用户处理程序来哈希我们的密码，这是绝对必须的。永远不要存储明文密码。你们中的很多人会认为“duh很明显”，但不幸的是，它还在继续! 1234567891011121314151617181920212223242526272829303132333435363738// shippy-user-service/handler.go...func (srv *service) Auth(ctx context.Context, req *pb.User, res *pb.Token) error &#123; log.Println(\"Logging in with:\", req.Email, req.Password) user, err := srv.repo.GetByEmail(req.Email) log.Println(user) if err != nil &#123; return err &#125; // Compares our given password against the hashed password // stored in the database if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil &#123; return err &#125; token, err := srv.tokenService.Encode(user) if err != nil &#123; return err &#125; res.Token = token return nil&#125;func (srv *service) Create(ctx context.Context, req *pb.User, res *pb.Response) error &#123; // Generates a hashed version of our password hashedPass, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost) if err != nil &#123; return err &#125; req.Password = string(hashedPass) if err := srv.repo.Create(req); err != nil &#123; return err &#125; res.User = req return nil&#125; 这里并没有发生很大的变化，只是我们添加了密码散列功能，然后在保存新用户之前将其设置为密码。此外，在身份验证方面，我们还检查了哈希密码。 现在我们可以安全地对数据库进行身份验证，我们需要一种机制，在这个机制中，我们可以跨用户界面和分布式服务来实现这一点。有很多方法可以做到这一点，但是我遇到的最简单的解决方案是JWT，我们可以在服务和web上使用它。 但是在我们打开之前，请检查一下我对Dockerfiles和每个服务的makefile所做的更改。我还更新了导入来匹配新的git存储库。 JWTJWT代表JSON web令牌，是一种分布式安全协议。OAuth相似。这个概念很简单，您可以使用一个算法为用户生成一个唯一的散列，可以对其进行比较和验证。但不仅如此，令牌本身可以包含并由我们的用户元数据组成。换句话说，它们的数据本身可以成为令牌的一部分。让我们看一个JWT的例子: 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 这个令牌被分成三部分。每一段都有重要意义。第一部分是关于令牌本身的一些元数据。例如令牌的类型和用于创建令牌的算法。这使客户能够理解如何解码令牌。第二部分由用户定义的元数据组成。这可以是您的用户详细信息，一个过期时间，任何您想要的。最后一个部分是验证签名，它是关于如何散列标记和使用什么数据的信息。 当然，使用JWT也有缺点和风险，本文概述了这些优点。另外，我建议您阅读本文以了解安全最佳实践。 我建议您特别关注的是，获取用户的IP，并将其作为标记声明的一部分。这确保了某人不能窃取您的令牌，并在另一个设备上充当您的角色。确保您使用https有助于减轻这种攻击类型，因为它模糊了您在中间风格攻击中的标记。 有许多不同的散列算法，可以使用到散列JWT，通常分为两类。对称和非对称。对称就像我们使用的方法，使用共享的盐。不对称利用客户端和服务器之间的公钥和私钥。这对于跨服务的身份验证非常有用。 更多资源: Auth0 RFC算法 现在我们已经讨论了JWT是什么，让我们更新token_service。执行这些操作。我们将会使用一个非常棒的Go库:github.com/dgrijalva/jwt-go，其中包含一些很好的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// shippy-user-service/token_service.gopackage mainimport ( \"time\" pb \"github.com/EwanValentine/shippy-user-service/proto/user\" \"github.com/dgrijalva/jwt-go\")var ( // Define a secure key string used // as a salt when hashing our tokens. // Please make your own way more secure than this, // use a randomly generated md5 hash or something. key = []byte(\"mySuperSecretKeyLol\"))// CustomClaims is our custom metadata, which will be hashed// and sent as the second segment in our JWTtype CustomClaims struct &#123; User *pb.User jwt.StandardClaims&#125;type Authable interface &#123; Decode(token string) (*CustomClaims, error) Encode(user *pb.User) (string, error)&#125;type TokenService struct &#123; repo Repository&#125;// Decode a token string into a token objectfunc (srv *TokenService) Decode(tokenString string) (*CustomClaims, error) &#123; // Parse the token token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; return key, nil &#125;) // Validate the token and return the custom claims if claims, ok := token.Claims.(*CustomClaims); ok &amp;&amp; token.Valid &#123; return claims, nil &#125; else &#123; return nil, err &#125;&#125;// Encode a claim into a JWTfunc (srv *TokenService) Encode(user *pb.User) (string, error) &#123; expireToken := time.Now().Add(time.Hour * 72).Unix() // Create the Claims claims := CustomClaims&#123; user, jwt.StandardClaims&#123; ExpiresAt: expireToken, Issuer: \"go.micro.srv.user\", &#125;, &#125; // Create token token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) // Sign token and return return token.SignedString(key)&#125; 根据我的观点，我留下了一些注释，解释了一些更详细的细节，但是这里的前提非常简单。Decode接受一个字符串令牌，将其解析为一个令牌对象，并验证它，并在有效的情况下返回断言。这将允许我们从索赔中获取用户元数据以验证该用户。 编码方法做相反的事情，它将您的自定义元数据散入一个新的JWT并返回它。 注意，我们还在顶部设置了一个“关键”变量，这是一个安全的盐，请使用比这个更安全的产品。 现在我们有了一个验证令牌服务。让我们更新我们的用户cli，我已经简化了这只是一个脚本，因为我在之前的cli代码中有问题，我会回到这个，但是这个工具只是用于测试: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// shippy-user-cli/cli.gopackage mainimport ( \"log\" \"os\" pb \"github.com/EwanValentine/shippy-user-service/proto/user\" micro \"github.com/micro/go-micro\" microclient \"github.com/micro/go-micro/client\" \"golang.org/x/net/context\")func main() &#123; srv := micro.NewService( micro.Name(\"go.micro.srv.user-cli\"), micro.Version(\"latest\"), ) // Init will parse the command line flags. srv.Init() client := pb.NewUserService(\"go.micro.srv.user\", microclient.DefaultClient) name := \"Ewan Valentine\" email := \"ewan.valentine89@gmail.com\" password := \"test123\" company := \"BBC\" r, err := client.Create(context.TODO(), &amp;pb.User&#123; Name: name, Email: email, Password: password, Company: company, &#125;) if err != nil &#123; log.Fatalf(\"Could not create: %v\", err) &#125; log.Printf(\"Created: %s\", r.User.Id) getAll, err := client.GetAll(context.Background(), &amp;pb.Request&#123;&#125;) if err != nil &#123; log.Fatalf(\"Could not list users: %v\", err) &#125; for _, v := range getAll.Users &#123; log.Println(v) &#125; authResponse, err := client.Auth(context.TODO(), &amp;pb.User&#123; Email: email, Password: password, &#125;) if err != nil &#123; log.Fatalf(\"Could not authenticate user: %s error: %v\\n\", email, err) &#125; log.Printf(\"Your access token is: %s \\n\", authResponse.Token) // let's just exit because os.Exit(0)&#125; 我们现在只需要一些硬编码的值，替换那些并使用$ make build &amp;&amp; make run运行脚本。您应该看到返回一个令牌。复制并粘贴这个长标记字符串，您很快就需要它! 现在我们需要更新我们的consign-cli以获取一个令牌字符串，并将其传递到我们的consignment-service: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// shippy-consignment-cli/cli.go...func main() &#123; cmd.Init() // Create new greeter client client := pb.NewShippingService(\"go.micro.srv.consignment\", microclient.DefaultClient) // Contact the server and print out its response. file := defaultFilename var token string log.Println(os.Args) if len(os.Args) &lt; 3 &#123; log.Fatal(errors.New(\"Not enough arguments, expecing file and token.\")) &#125; file = os.Args[1] token = os.Args[2] consignment, err := parseFile(file) if err != nil &#123; log.Fatalf(\"Could not parse file: %v\", err) &#125; // Create a new context which contains our given token. // This same context will be passed into both the calls we make // to our consignment-service. ctx := metadata.NewContext(context.Background(), map[string]string&#123; \"token\": token, &#125;) // First call using our tokenised context r, err := client.CreateConsignment(ctx, consignment) if err != nil &#123; log.Fatalf(\"Could not create: %v\", err) &#125; log.Printf(\"Created: %t\", r.Created) // Second call getAll, err := client.GetConsignments(ctx, &amp;pb.GetRequest&#123;&#125;) if err != nil &#123; log.Fatalf(\"Could not list consignments: %v\", err) &#125; for _, v := range getAll.Consignments &#123; log.Println(v) &#125;&#125; 现在我们需要更新我们的委托服务来检查令牌的请求，并将其传递给我们的用户服务: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// shippy-consignment-service/main.gofunc main() &#123; ... // Create a new service. Optionally include some options here. srv := micro.NewService( // This name must match the package name given in your protobuf definition micro.Name(\"go.micro.srv.consignment\"), micro.Version(\"latest\"), // Our auth middleware micro.WrapHandler(AuthWrapper), ) ...&#125;...// AuthWrapper is a high-order function which takes a HandlerFunc// and returns a function, which takes a context, request and response interface.// The token is extracted from the context set in our consignment-cli, that// token is then sent over to the user service to be validated.// If valid, the call is passed along to the handler. If not,// an error is returned.func AuthWrapper(fn server.HandlerFunc) server.HandlerFunc &#123; return func(ctx context.Context, req server.Request, resp interface&#123;&#125;) error &#123; meta, ok := metadata.FromContext(ctx) if !ok &#123; return errors.New(\"no auth meta-data found in request\") &#125; // Note this is now uppercase (not entirely sure why this is...) token := meta[\"Token\"] log.Println(\"Authenticating with token: \", token) // Auth here authClient := userService.NewUserService(\"go.micro.srv.user\", client.DefaultClient) _, err := authClient.ValidateToken(context.Background(), &amp;userService.Token&#123; Token: token, &#125;) if err != nil &#123; return err &#125; err = fn(ctx, req, resp) return err &#125;&#125; 现在，让我们运行我们的consign-cli工具，cd进入我们新的shippy-consignment-cli repo并运行$ make build来构建我们的新docker映像，现在运行: 12345$ make build$ docker run --net=\"host\" \\ -e MICRO_REGISTRY=mdns \\ consignment-cli consignment.json \\ &lt;TOKEN_HERE&gt; 注意，在运行docker容器时，我们使用的是-net=”host”标志。这告诉Docker在我们的主机网络上运行我们的容器。e 127.0.0.1或localhost，而不是内部Docker网络。注意，您不需要使用此方法进行任何端口转发。而不是-p 8080:8080你可以只做- p8080。阅读更多关于Docker网络。 现在，当您运行这个程序时，您应该看到已经创建了一个新的委托。尝试从令牌中删除几个字符，这样它就无效了。您应该会看到一个错误。 因此，我们已经创建了JWT令牌服务和一个用于验证JWT令牌的中间件来验证用户。 如果你不想使用go-micro，而你使用的是vanilla grpc，你会希望你的中间件看起来像: 12345678910111213141516171819202122232425func main() &#123; ... myServer := grpc.NewServer( grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(AuthInterceptor), ) ...&#125;func AuthInterceptor(ctx context.Context, req interface&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface&#123;&#125;, error) &#123; // Set up a connection to the server. conn, err := grpc.Dial(authAddress, grpc.WithInsecure()) if err != nil &#123; log.Fatalf(\"did not connect: %v\", err) &#125; defer conn.Close() c := pb.NewAuthClient(conn) r, err := c.ValidateToken(ctx, &amp;pb.ValidateToken&#123;Token: token&#125;) if err != nil &#123; log.Fatalf(\"could not authenticate: %v\", err) &#125; return handler(ctx, req)&#125; 这种设置在本地运行有点笨拙。但我们并不总是需要在本地运行每个服务。我们应该能够创建独立的、可以独立测试的服务。在我们的例子中，如果我们想测试我们的委托服务，我们可能并不一定要运行我们的authservice。我使用的一个技巧是切换到其他服务的调用。 我已经更新了我们的寄售服务auth包装: 1234567891011// shippy-user-service/main.go...func AuthWrapper(fn server.HandlerFunc) server.HandlerFunc &#123; return func(ctx context.Context, req server.Request, resp interface&#123;&#125;) error &#123; // This skips our auth check if DISABLE_AUTH is set to true if os.Getenv(\"DISABLE_AUTH\") == \"true\" &#123; return fn(ctx, req, resp) &#125; ... &#125;&#125; 然后在Makefile中添加新的toggle: 123456789// shippy-user-service/Makefile...run: docker run -d --net=\"host\" \\ -p 50052 \\ -e MICRO_SERVER_ADDRESS=:50052 \\ -e MICRO_REGISTRY=mdns \\ -e DISABLE_AUTH=true \\ consignment-service 这种方法使得在本地运行您的微服务的某些子部分变得更容易，对于这个问题有几种不同的方法，但我发现这是最简单的方法。我希望你已经发现这个有用，尽管方向有微小的改变。而且，任何关于运行微服务的建议都是非常受欢迎的，因为它将使这个系列变得更容易!","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第三部分","slug":"go-micro-tutorial-3","date":"2018-05-10T13:56:27.000Z","updated":"2020-07-25T02:57:18.204Z","comments":true,"path":"2018/05/10/go-micro-tutorial-3/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-3/","excerpt":"在之前的文章中，我们介绍了go-micro和Docker的一些基础知识。我们还介绍了第二种服务。在这篇文章中，我们将讨论docker-compose，以及如何在本地更轻松地运行我们的服务。我们将介绍一些不同的数据库，最后我们将介绍第三种服务。","text":"在之前的文章中，我们介绍了go-micro和Docker的一些基础知识。我们还介绍了第二种服务。在这篇文章中，我们将讨论docker-compose，以及如何在本地更轻松地运行我们的服务。我们将介绍一些不同的数据库，最后我们将介绍第三种服务。 先决条件安装docker-compose:https://docs.docker.com/compose/install/ 但是首先，让我们看看数据库。 选择数据库到目前为止，我们的数据实际上并没有存储在任何地方，而是存储在我们的服务中，当我们的容器重新启动时，它就会丢失。当然，我们需要一种持久化、存储和查询数据的方法。 微服务的好处在于，每个服务可以使用不同的数据库。当然你不需要这么做，很多人都不需要。事实上，我很少为小团队做这样的事情，因为维护几个不同的数据库是一种精神上的飞跃，而不仅仅是一个。但是在某些情况下，一个服务数据可能不适合您为其他服务使用的数据库。所以用别的东西是有意义的。由于您的关注是完全独立的，微服务使这个简单的简单。 为您的服务选择“正确”的数据库是一篇完全不同的文章，例如这篇文章，所以我们不会对这个subect做太多的细节。但是，如果您有相当松散或不一致的数据集，那么NoSQL文档存储解决方案是完美的。它们更灵活，可以存储和使用json。我们将为NoSQL数据库使用MongoDB。没有什么特别的原因，除了它表现良好，它被广泛使用和支持，并且有一个伟大的在线社区。 如果您的数据更严格地定义和关系，那么使用传统的rdbms或关系数据库是有意义的。但实际上并没有硬性规定，一般情况下，任何人都可以胜任这份工作。但是一定要查看您的数据结构，考虑您的服务是否正在进行更多的阅读或更多的写作，查询的复杂程度如何，并尝试将这些作为选择数据库的起点。对于我们的关系数据库，我们将使用Postgres。再一次，没有什么特别的原因，除了它做的很好，我很熟悉它。你可以用MySQL, MariaDB，或者别的什么。 Amazon和谷歌对于这两种数据库类型的前提解决方案都有一些出色的解决方案，如果您想避免管理自己的数据库(通常是明智的)。另一个不错的选择是编写，它将使用相同的云提供程序作为您的服务，以避免连接延迟，从而实现各种数据库技术的完全管理、可伸缩的实例。 亚马逊:RDBMS: https://aws.amazon.com/rds/ NoSQL: https://aws.amazon.com/dynamodb/。 RDBMS: https://cloud.google.com/spanner/ NoSQL: https://cloud.google.com/datastore/。 现在我们已经讨论了一些数据库，让我们来做一些编码! docker-compose在本系列的最后一部分中，我们研究了Docker，它让我们在轻量级容器中运行我们的服务，并使用它们自己的运行时和依赖项。但是，必须使用单独的Makefile来运行和管理每个服务，这有点麻烦。让我们来看看docker-compose。Docker-compose 允许您在yaml文件中定义docker容器的列表，并指定关于其运行时的元数据。Docker-compose服务或多或少地映射到我们已经使用的docker命令。例如: 1$ docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 -e MICRO_REGISTRY=mdns vessel-service 就变成了: 12345678910version: '3.1'services: vessel-service: build: ./vessel-service ports: - 50052:50051 environment: MICRO_REGISTRY: \"mdns\" MICRO_SERVER_ADDRESS: \":50051\" 简单! 因此，让我们在我们的目录$ touch docker-compose.yml中创建一个docker- compile文件。现在加入我们的服务: 1234567891011121314151617181920212223242526# docker-compose.ymlversion: '3.1'services: consignment-cli: build: ./consignment-cli environment: MICRO_REGISTRY: \"mdns\" consignment-service: build: ./consignment-service ports: - 50051:50051 environment: MICRO_ADDRESS: \":50051\" MICRO_REGISTRY: \"mdns\" DB_HOST: \"datastore:27017\" vessel-service: build: ./vessel-service ports: - 50052:50051 environment: MICRO_ADDRESS: \":50051\" MICRO_REGISTRY: \"mdns\" 首先，我们定义了我们想要使用的docker-compose的版本，然后是服务列表。还有其他根级定义，如网络和卷，但我们现在只关注服务。 每个服务由它的名称定义，然后我们包括一个构建路径，它是指向一个位置的引用，该位置应该包含一个Dockerfile。这告诉docker-compose 使用这个Dockerfile来构建它的映像。您还可以在这里使用图像来使用预构建映像。我们以后会讲到。然后定义端口映射，最后定义环境变量。 要构建docker-compose栈，只需运行$ docker-compose build，并运行它，$ docker-compose run。要在后台运行栈，请使用$ docker-compose up -d。您还可以使用$ docker ps查看当前正在运行的容器的列表。最后，您可以通过运行$ docker stop $(docker ps -qa)来停止所有当前的容器。 我们来运行栈。您应该会看到大量的输出和dockerfile正在构建。您可能也会从我们的CLI工具中看到错误，但是不要担心，这很可能是因为它是在我们的其他服务之前运行的。它只是说它还找不到它们。 让我们通过运行CLI工具进行测试。要通过docker-组合运行它，只需运行$ docker-compose run consignment-cli，一旦所有其他容器都在运行。您应该看到它像以前一样成功运行。 实体和protobufs在本系列中，我们谈到了protobufs是我们数据模型的中心。我们使用它来定义我们的服务结构和功能。由于protobuf以或多或少的所有正确的数据类型生成结构，我们也可以重用这些结构作为我们的底层数据库模型。这实际上相当令人兴奋。它与原型保持一致，成为真理的唯一来源。 然而，这种方法确实有缺点。有时，将protobuf生成的代码编组到一个有效的数据库实体中是很困难的。有时，数据库技术使用自定义类型，这些类型很难从protobuf生成的原生类型转换。我花了很多时间思考的一个问题是如何将Id字符串转换为Id bson。ObjectId Mongodb的实体。结果是bson。ObjectId，实际上只是一个字符串，所以你可以把它们组合在一起。另外，mongodb的id索引在内部存储为_id，因此您需要一种方法将其绑定到id字符串字段，因为您不能真正执行_id字符串。这意味着要找到一种方法来为您的原buf文件定义自定义标记。但我们以后会讲到。 此外，许多人经常反对使用protobuf定义作为数据库实体，因为您将通信技术与数据库代码紧密耦合。这也是一个有效的点。 一般情况下，建议在protobuf定义代码和数据库实体之间进行转换。但是，您最终会得到许多转换代码，用于转换两个几乎相同的类型，例如: 123456789func (service *Service) (ctx context.Context, req *proto.User, res *proto.Response) error &#123; entity := &amp;models.User&#123; Name: req.Name. Email: req.Email, Password: req.Password, &#125; err := service.repo.Create(entity) ...&#125; 表面上看起来并不是那么糟糕，但是当你有几个嵌套结构和几种类型时。它可能非常繁琐，而且可能需要大量的迭代来转换嵌套结构等等。 不过,这种方法真的到你喜欢很多东西在编程,这并不归结为对或错。所以无论感觉最合适的方法。但是,我自己的个人意见是,两个几乎相同的类型之间的转换,尤其是考虑到我们对待protobuf代码作为我们的基础数据,感觉自己像一个减损从我们获得的利益使用protobufs作为你的核心定义。所以我将使用我们的protobuf代码数据库。顺便说一句,我不是说我是对的,我想听到你的意见。 让我们开始我们的第一个服务，我们的寄售服务。我觉得我们应该先整理一下。我们把所有东西都集中到main_go文件中。我知道这些都是微服务，但这并不是混乱的借口!因此，让我们在consignationservice、handler.go、datastore.go和repository.go中创建两个更多的文件。我在服务的根目录中创建这些，而不是创建它们作为新的包和目录。这对于小型的微服务来说是完全足够的。对于开发人员来说，创建这样的结构是一种常见的诱惑: 12345678main.gomodels/ user.gohandlers/ auth.go user.goservices/ auth.go 这又回到了MVC时代，在Golang中并没有得到真正的建议。当然不是小项目。如果你有一个更大的项目，有多个关注点，你可以按照下面的方式组织它: 1234567891011121314main.gousers/ services/ auth.go handlers/ auth.go user.go users/ user.gocontainers/ services/ manage.go models/ container.go 在这里，您是按域对代码进行分组，而不是按其所做的任意分组代码。 然而，由于我们正在处理一个微服务，它应该只处理一个单一的问题，我们不需要采取上述任何一种方法。事实上，Go的宗旨是鼓励简单。因此，我们将从简单的开始，并将所有内容都放在服务的根目录中，并使用一些明确定义的文件名。 作为附带说明，我们需要更新Dockerfile的文件，因为我们不需要将新的分离的代码导入到包中，我们需要告诉go编译器将这些新文件拖入其中。因此，更新构建函数如下所示: 1RUN CGO_ENABLED=0 GOOS=linux go build -o consignment-service -a -installsuffix cgo main.go repository.go handler.go datastore.go 这将包括我们将要创建的新文件。 MongoDB Golang lib是这个简单的一个很好的例子，最后，这里有一篇关于组织Go codebase的好文章。 让我们首先从main.go中删除所有的存储库代码，并重新使用它来使用mongodb库，mgo。再一次，我试着注释代码来解释每个部分的功能，所以请仔细阅读代码和注释。特别是关于mgo如何处理会话的部分: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// consignment-service/repository.gopackage mainimport ( pb \"github.com/EwanValentine/shippy/consignment-service/proto/consignment\" \"gopkg.in/mgo.v2\")const ( dbName = \"shippy\" consignmentCollection = \"consignments\")type Repository interface &#123; Create(*pb.Consignment) error GetAll() ([]*pb.Consignment, error) Close()&#125;type ConsignmentRepository struct &#123; session *mgo.Session&#125;// Create a new consignmentfunc (repo *ConsignmentRepository) Create(consignment *pb.Consignment) error &#123; return repo.collection().Insert(consignment)&#125;// GetAll consignmentsfunc (repo *ConsignmentRepository) GetAll() ([]*pb.Consignment, error) &#123; var consignments []*pb.Consignment // Find normally takes a query, but as we want everything, we can nil this. // We then bind our consignments variable by passing it as an argument to .All(). // That sets consignments to the result of the find query. // There's also a `One()` function for single results. err := repo.collection().Find(nil).All(&amp;consignments) return consignments, err&#125;// Close closes the database session after each query has ran.// Mgo creates a 'master' session on start-up, it's then good practice// to copy a new session for each request that's made. This means that// each request has its own database session. This is safer and more efficient,// as under the hood each session has its own database socket and error handling.// Using one main database socket means requests having to wait for that session.// I.e this approach avoids locking and allows for requests to be processed concurrently. Nice!// But... it does mean we need to ensure each session is closed on completion. Otherwise// you'll likely build up loads of dud connections and hit a connection limit. Not nice!func (repo *ConsignmentRepository) Close() &#123; repo.session.Close()&#125;func (repo *ConsignmentRepository) collection() *mgo.Collection &#123; return repo.session.DB(dbName).C(consignmentCollection)&#125; 因此，我们的代码负责与Mongodb数据库进行交互。我们需要创建创建主session/connection.的代码。更新consignment-service/datastore.go。用以下: 123456789101112131415161718// consignment-service/datastore.gopackage mainimport ( \"gopkg.in/mgo.v2\")// CreateSession creates the main session to our mongodb instancefunc CreateSession(host string) (*mgo.Session, error) &#123; session, err := mgo.Dial(host) if err != nil &#123; return nil, err &#125; session.SetMode(mgo.Monotonic, true) return session, nil&#125; 就是这样，非常直接。它以一个主机字符串作为参数，将会话返回给我们的数据存储，当然还有一个潜在的错误，因此我们可以在启动时处理它。让我们修改我们的主。将此文件连接到我们的存储库: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// consignment-service/main.gopackage mainimport ( // Import the generated protobuf code \"fmt\" \"log\" pb \"github.com/EwanValentine/shippy/consignment-service/proto/consignment\" vesselProto \"github.com/EwanValentine/shippy/vessel-service/proto/vessel\" \"github.com/micro/go-micro\" \"os\")const ( defaultHost = \"localhost:27017\")func main() &#123; // Database host from the environment variables host := os.Getenv(\"DB_HOST\") if host == \"\" &#123; host = defaultHost &#125; session, err := CreateSession(host) // Mgo creates a 'master' session, we need to end that session // before the main function closes. defer session.Close() if err != nil &#123; // We're wrapping the error returned from our CreateSession // here to add some context to the error. log.Panicf(\"Could not connect to datastore with host %s - %v\", host, err) &#125; // Create a new service. Optionally include some options here. srv := micro.NewService( // This name must match the package name given in your protobuf definition micro.Name(\"go.micro.srv.consignment\"), micro.Version(\"latest\"), ) vesselClient := vesselProto.NewVesselService(\"go.micro.srv.vessel\", srv.Client()) // Init will parse the command line flags. srv.Init() // Register handler pb.RegisterShippingServiceHandler(srv.Server(), &amp;service&#123;session, vesselClient&#125;) // Run the server if err := srv.Run(); err != nil &#123; fmt.Println(err) &#125;&#125; 复制和克隆您可能已经注意到，在使用mgo Mongodb库时。我们创建一个数据库会话，它被传递到我们的处理程序中，但是在每个请求中，我们调用一个方法来克隆该会话并将其传递到存储库代码中。 实际上，除了生成与数据库的第一个连接之外，我们从未接触过“主会话”，我们每次都要对数据存储进行调用时，我们调用了session.clone()。正如我在代码注释中简要提到的，但是我认为值得重新迭代一些细节，如果您使用主会话，您将重用相同的套接字。这意味着您的查询可能会被其他查询阻塞，并且必须等待操作在这个套接字上完成。这在支持并发性的语言中是没有意义的。 因此，为了避免阻塞请求，mgo允许您Copy() 或 Clone()一个会话，以便您对每个请求都有一个并发连接。您会注意到，我提到过复制和克隆方法，它们非常相似，但是有一个细微但重要的区别。克隆重新使用与master相同的套接字。这减少了生成一个全新套接字的开销。这是快速写性能的最佳选择。然而，更长的操作，例如更复杂的查询或大数据作业等，可能会导致其他的go例程阻塞，试图使用这个套接字。 一般来说，你最好是像我们这样的克隆。 我们需要做的最后一点整理是将gRPC处理程序代码移到新的handler.go文件。让我们这样做。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// consignment-service.gopackage mainimport ( \"log\" \"golang.org/x/net/context\" pb \"github.com/EwanValentine/shippy/consignment-service/proto/consignment\" vesselProto \"github.com/EwanValentine/shippy/vessel-service/proto/vessel\")// Service should implement all of the methods to satisfy the service// we defined in our protobuf definition. You can check the interface// in the generated code itself for the exact method signatures etc// to give you a better idea.type service struct &#123; vesselClient vesselProto.NewVesselService&#125;func (s *service) GetRepo() Repository &#123; return &amp;ConsignmentRepository&#123;s.session.Clone()&#125;&#125;// CreateConsignment - we created just one method on our service,// which is a create method, which takes a context and a request as an// argument, these are handled by the gRPC server.func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error &#123; repo := s.GetRepo() defer repo.Close() // Here we call a client instance of our vessel service with our consignment weight, // and the amount of containers as the capacity value vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification&#123; MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), &#125;) log.Printf(\"Found vessel: %s \\n\", vesselResponse.Vessel.Name) if err != nil &#123; return err &#125; // We set the VesselId as the vessel we got back from our // vessel service req.VesselId = vesselResponse.Vessel.Id // Save our consignment err = repo.Create(req) if err != nil &#123; return err &#125; // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = req return nil&#125;func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error &#123; repo := s.GetRepo() defer repo.Close() consignments, err := repo.GetAll() if err != nil &#123; return err &#125; res.Consignments = consignments return nil&#125; 我们已经更新了我们的repo中的一些返回参数，这些参数来自于上一个教程:Old: 1234type Repository interface &#123; Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment&#125; New: 12345type Repository interface &#123; Create(*pb.Consignment) error GetAll() ([]*pb.Consignment, error) Close()&#125; 这只是因为我觉得我们不需要在创建后返回相同的货物。现在，我们从mgo返回一个适当的错误，以获取我们的get查询。否则代码或多或少是相同的。当然，我们将我们的封闭方法添加到接口中。 现在让我们对您的vessel-service做同样的操作。我不打算在这篇文章中演示，你应该在这一点上有一个好的感觉。记住，您可以使用我的存储库作为参考。 不过，我们将为我们的vesselservice添加一个新方法，它将允许我们创建新的容器。与以往一样，让我们从更新我们的protobuf定义开始: 12345678910111213141516171819202122232425262728syntax = \"proto3\";package vessel;service VesselService &#123; rpc FindAvailable(Specification) returns (Response) &#123;&#125; rpc Create(Vessel) returns (Response) &#123;&#125;&#125;message Vessel &#123; string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6;&#125;message Specification &#123; int32 capacity = 1; int32 max_weight = 2;&#125;message Response &#123; Vessel vessel = 1; repeated Vessel vessels = 2; bool created = 3;&#125; 我们在gRPC服务下创建了一个新创建方法，它接收一个容器并返回我们的一般响应。我们还为响应消息添加了一个新字段，仅仅是一个创建的bool。运行$ make构建以更新此服务。现在我们将在vessel-service/handler.go中添加一个新的处理程序和一个新的存储库方法: 12345678910111213141516// vessel-service/handler.gofunc (s *service) GetRepo() Repository &#123; return &amp;VesselRepository&#123;s.session.Clone()&#125;&#125;func (s *service) Create(ctx context.Context, req *pb.Vessel, res *pb.Response) error &#123; repo := s.GetRepo() defer repo.Close() if err := repo.Create(req); err != nil &#123; return err &#125; res.Vessel = req res.Created = true return nil&#125; 1234// vessel-service/repository.gofunc (repo *VesselRepository) Create(vessel *pb.Vessel) error &#123; return repo.collection().Insert(vessel)&#125; 所以在这之后。我们已经更新了我们的服务以使用Mongodb。在尝试运行此操作之前，我们需要更新docker-compose文件，以包含Mongodb容器: 123456services: ... datastore: image: mongo ports: - 27017:27017 在您的两个服务中更新环境变量，包括:DB_HOST:“datastore:27017”。注意，我们将数据存储称为主机名，而不是本地主机。这是因为docker-组合为我们处理了一些聪明的内部DNS。 所以你应该: 12345678910111213141516171819202122232425262728293031version: '3.1'services: consignment-cli: build: ./consignment-cli environment: MICRO_REGISTRY: \"mdns\" consignment-service: build: ./consignment-service ports: - 50051:50051 environment: MICRO_ADDRESS: \":50051\" MICRO_REGISTRY: \"mdns\" DB_HOST: \"datastore:27017\" vessel-service: build: ./vessel-service ports: - 50052:50051 environment: MICRO_ADDRESS: \":50051\" MICRO_REGISTRY: \"mdns\" DB_HOST: \"datastore:27017\" datastore: image: mongo ports: - 27017:27017 重新构建您的堆栈$ docker-compose build并重新运行它$ docker-compose up。注意，有时由于Dockers缓存，您可能需要运行一个cacheless构建来获取某些更改。要在docker-compose中执行此操作，只需在运行$ docker-compose build时使用-no-cache标志。 用户服务现在，让我们创建第三个服务。我们将从更新docker-compose.yml文件开始。此外，为了将内容混合起来，我们将为我们的用户服务在docker堆栈中添加Postgres: 1234567891011121314... user-service: build: ./user-service ports: - 50053:50051 environment: MICRO_ADDRESS: \":50051\" MICRO_REGISTRY: \"mdns\" ... database: image: postgres ports: - 5432:5432 现在在根目录中创建一个用户服务目录。和之前的服务一样。创建下列文件:handler.go, main.go, repository.go, database.go, Dockerfile, Makefile，我们的proto文件的子目录，最后是proto文件本身:proto/user/user.proto。 将以下内容添加到user.proto: 1234567891011121314151617181920212223242526272829303132333435363738syntax = &quot;proto3&quot;;package go.micro.srv.user;service UserService &#123; rpc Create(User) returns (Response) &#123;&#125; rpc Get(User) returns (Response) &#123;&#125; rpc GetAll(Request) returns (Response) &#123;&#125; rpc Auth(User) returns (Token) &#123;&#125; rpc ValidateToken(Token) returns (Token) &#123;&#125;&#125;message User &#123; string id = 1; string name = 2; string company = 3; string email = 4; string password = 5;&#125;message Request &#123;&#125;message Response &#123; User user = 1; repeated User users = 2; repeated Error errors = 3;&#125;message Token &#123; string token = 1; bool valid = 2; repeated Error errors = 3;&#125;message Error &#123; int32 code = 1; string description = 2;&#125; 现在，确保您已经创建了一个类似于我们以前的服务的Makefile，您应该能够运行$ make构建来生成我们的gRPC代码。根据我们以前的服务，我们已经创建了一些代码来接口我们的gRPC方法。我们只会让其中的一部分在这个系列的这一部分中工作。我们只是希望能够创建和获取一个用户。在本系列的下一部分中，我们将讨论身份验证和JWT。所以我们将会留下任何与现在有关的标记。您的处理程序应该是这样的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// user-service/handler.gopackage mainimport ( \"golang.org/x/net/context\" pb \"github.com/EwanValentine/shippy/user-service/proto/user\")type service struct &#123; repo Repository tokenService Authable&#125;func (srv *service) Get(ctx context.Context, req *pb.User, res *pb.Response) error &#123; user, err := srv.repo.Get(req.Id) if err != nil &#123; return err &#125; res.User = user return nil&#125;func (srv *service) GetAll(ctx context.Context, req *pb.Request, res *pb.Response) error &#123; users, err := srv.repo.GetAll() if err != nil &#123; return err &#125; res.Users = users return nil&#125;func (srv *service) Auth(ctx context.Context, req *pb.User, res *pb.Token) error &#123; user, err := srv.repo.GetByEmailAndPassword(req) if err != nil &#123; return err &#125; res.Token = \"testingabc\" return nil&#125;func (srv *service) Create(ctx context.Context, req *pb.User, res *pb.Response) error &#123; if err := srv.repo.Create(req); err != nil &#123; return err &#125; res.User = req return nil&#125;func (srv *service) ValidateToken(ctx context.Context, req *pb.Token, res *pb.Token) error &#123; return nil&#125; 现在让我们添加我们的存储库代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// user-service/repository.gopackage mainimport ( pb \"github.com/EwanValentine/shippy/user-service/proto/user\" \"github.com/jinzhu/gorm\")type Repository interface &#123; GetAll() ([]*pb.User, error) Get(id string) (*pb.User, error) Create(user *pb.User) error GetByEmailAndPassword(user *pb.User) (*pb.User, error)&#125;type UserRepository struct &#123; db *gorm.DB&#125;func (repo *UserRepository) GetAll() ([]*pb.User, error) &#123; var users []*pb.User if err := repo.db.Find(&amp;users).Error; err != nil &#123; return nil, err &#125; return users, nil&#125;func (repo *UserRepository) Get(id string) (*pb.User, error) &#123; var user *pb.User user.Id = id if err := repo.db.First(&amp;user).Error; err != nil &#123; return nil, err &#125; return user, nil&#125;func (repo *UserRepository) GetByEmailAndPassword(user *pb.User) (*pb.User, error) &#123; if err := repo.db.First(&amp;user).Error; err != nil &#123; return nil, err &#125; return user, nil&#125;func (repo *UserRepository) Create(user *pb.User) error &#123; if err := repo.db.Create(user).Error; err != nil &#123; return err &#125;&#125; 我们还需要改变ORM的行为来生成一个UUID，而不是试图生成一个整数ID，如果你不知道，UUID是一个随机生成的连字符字符串，用作ID或主键。这比使用自动递增的ID更安全，因为它阻止人们猜测或遍历API端点。MongoDB已经使用了这种变体，但是我们需要告诉我们的Postgres模型使用UUID。因此，在user-service/proto/user中创建一个名为extensions.go的新文件。在这个文件中，添加: 1234567891011package go_micro_srv_userimport ( \"github.com/jinzhu/gorm\" \"github.com/satori/go.uuid\")func (model *User) BeforeCreate(scope *gorm.Scope) error &#123; uuid := uuid.NewV4() return scope.SetColumn(\"Id\", uuid.String())&#125; 这个钩子进入GORM的事件生命周期，以便在实体被保存之前为Id列生成UUID。 您会注意到，与我们的Mongodb服务不同，我们没有进行任何连接处理。本机、SQL/postgres驱动程序的工作方式略有不同，所以这次我们不需要担心这个问题。我们正在使用一个名为“gorm”的软件包，让我们简单地讨论一下这个问题。 Gorm - Go + ORMGorm是一个合理的轻量级对象关系映射器，它与Postgres、MySQL、Sqlite等很好地工作，它很容易设置、使用和管理数据库模式自动更改。 也就是说，使用微服务，您的数据结构要小得多，包含更少的连接和整体的复杂性。所以，不要觉得你应该使用任何类型的ORM。 我们需要能够测试创建用户，所以让我们创建另一个cli工具。这一次用户cli在我们的项目根中。类似于我们的consignment-cli，但这次: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( \"log\" \"os\" pb \"github.com/EwanValentine/shippy/user-service/proto/user\" microclient \"github.com/micro/go-micro/client\" \"github.com/micro/go-micro/cmd\" \"golang.org/x/net/context\" \"github.com/micro/cli\" \"github.com/micro/go-micro\")func main() &#123; cmd.Init() // Create new greeter client client := pb.NewUserService(\"go.micro.srv.user\", microclient.DefaultClient) // Define our flags service := micro.NewService( micro.Flags( cli.StringFlag&#123; Name: \"name\", Usage: \"You full name\", &#125;, cli.StringFlag&#123; Name: \"email\", Usage: \"Your email\", &#125;, cli.StringFlag&#123; Name: \"password\", Usage: \"Your password\", &#125;, cli.StringFlag&#123; Name: \"company\", Usage: \"Your company\", &#125;, ), ) // Start as service service.Init( micro.Action(func(c *cli.Context) &#123; name := c.String(\"name\") email := c.String(\"email\") password := c.String(\"password\") company := c.String(\"company\") // Call our user service r, err := client.Create(context.TODO(), &amp;pb.User&#123; Name: name, Email: email, Password: password, Company: company, &#125;) if err != nil &#123; log.Fatalf(\"Could not create: %v\", err) &#125; log.Printf(\"Created: %s\", r.User.Id) getAll, err := client.GetAll(context.Background(), &amp;pb.Request&#123;&#125;) if err != nil &#123; log.Fatalf(\"Could not list users: %v\", err) &#125; for _, v := range getAll.Users &#123; log.Println(v) &#125; os.Exit(0) &#125;), ) // Run the server if err := service.Run(); err != nil &#123; log.Println(err) &#125;&#125; 这里我们使用了go-micro的命令行帮助器，非常简洁。 我们可以运行这个并创建一个用户: 12345$ docker-compose run user-cli command \\ --name=\"Ewan Valentine\" \\ --email=\"ewan.valentine89@gmail.com\" \\ --password=\"Testing123\" \\ --company=\"BBC\" 您应该在列表中看到创建的用户! 这不是很安全，因为目前我们存储的是明文密码，但是在本系列的下一部分中，我们将在我们的服务中查看身份验证和JWT标记。 我们已经创建了一个额外的服务，一个额外的命令行工具，我们开始使用两种不同的数据库技术来保存数据。在这篇文章中，我们已经讨论了很多问题，如果我们过于迅速地讨论任何事情，涉及太多或假设太多的知识，我们就会道歉。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第二部分(Docker和go-micro)","slug":"go-micro-tutorial-2","date":"2018-05-10T13:56:23.000Z","updated":"2020-07-25T02:57:18.204Z","comments":true,"path":"2018/05/10/go-micro-tutorial-2/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-2/","excerpt":"介绍在之前的文章中，我们介绍了编写基于gRPC的微服务的基础知识。在这一部分;我们将介绍dockeringa服务的基本内容，我们还将更新我们的服务以使用go-micro，最后，引入第二个服务。","text":"介绍在之前的文章中，我们介绍了编写基于gRPC的微服务的基础知识。在这一部分;我们将介绍dockeringa服务的基本内容，我们还将更新我们的服务以使用go-micro，最后，引入第二个服务。 介绍 Docker随着云计算的出现和微服务的诞生。部署更多、但更小的代码块的压力导致了一些有趣的新想法和技术。其中之一是容器的概念。 传统上，团队会将一个整体系统部署到静态服务器上，运行一个操作系统，并使用预定义的依赖集来跟踪。或者可能是由Chef或Puppet提供的虚拟机。扩大规模是很昂贵的，但并不是那么有效。最常见的选项是垂直缩放。在静态服务器上抛出越来越多的资源。 像vagrant这样的工具出现了，使得供应VM变得相当琐碎。但是，运行VM仍然是一个相当重要的操作。您正在运行一个完整的操作系统，它的所有荣誉，内核和所有，在您的主机。在资源方面，这是相当昂贵的。因此，当microservices出现时，在它们自己的环境中运行这么多单独的代码库是不可能的。 随之而来的容器容器是操作系统的简化版本。容器不包含内核、客户操作系统或任何较低级别的组件，这些组件通常组成一个操作系统。 容器只包含顶级库及其运行时组件。内核在主机上共享。因此，主机运行一个单一的Unix内核，然后由n个容器共享，运行非常不同的运行时集。 在引擎盖下，容器使用各种内核实用程序，以便在容器空间之间共享资源和网络功能。 进一步的阅读 这意味着您可以运行运行时和代码需要的依赖项，而不需要启动几个完整的操作系统。这是一个游戏规则的改变者，因为一个容器的整体大小与虚拟机相比，是更小的。例如，Ubuntu的尺寸通常小于1GB。而它的Docker映像副本仅为188mb。 您会注意到，我在介绍中使用了更广泛的容器，而不是“Docker容器”。通常认为Docker和容器是一回事。然而，容器是Linux中更多的概念或功能集合。Docker只是一种容器的味道，因为它的易用性而变得流行起来。也有其它的。但是，我们将继续坚持Docker，因为它在我看来是最受支持的，也是新来者最简单的。 所以现在希望你能看到集装箱化的价值，我们可以开始为我们的第一个服务进行dockering。让我们创建一个Dockerfile $ touch consignment-service/Dockerfile。 在该文件中，添加以下内容: 1234567FROM alpine:latestRUN mkdir /appWORKDIR /appADD consignment-service /app/consignment-serviceCMD [\"./consignment-service\"] 如果你在 Linux 上运行，你可能会遇到使用 Alpine 的问题。所以，如果你在 Linux 机器上关注这篇文章，只需用 debian 替换 alpine 即可，你应该能够正常运行。 稍后我们将会介绍一个更好的方法来构建我们的二进制文件。 首先，我们下载最新的 Linux Alpine 镜像。Linux Alpine 是一个轻量级 Linux 发行版，为运行 Dockerised Web 应用程序而开发和优化。换一种说法，Linux Alpine 具有足够的依赖和运行时功能来运行大多数应用程序。这意味着它的镜像大小只有 8M 左右。与之相比，大约 1GB 的 Ubuntu 虚拟机，你可以开始看到为什么 Docker 镜像更适合微服务和云计算。 接下来我们创建一个新的目录来存放我们的应用程序，并将上下文目录设置到我们的新目录中。这时我们的应用程序目录是默认的目录。然后，我们将编译后的二进制文件添加到我们的 Docker 容器中，并运行它。 现在我们来更新 Makefile 文件来构建我们的 Docker 镜像。 1234build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment-service . 我们在这里增加了两个步骤，我想详细解释一下。首先，我们正在构建我们的二进制文件。你会注意到在运行命令 $ go build 之前，设置了两个环境变量。GOOS 和 GOARCH 允许您为另一个操作系统交叉编译您的二进制文件，由于我在 Macbook上开发，所以无法编译出二进制文件，让它在 Docker 容器中运行它，而该容器使用的是 Linux。这个二进制在你的 Docker 容器中将是完全没有意义的，它会抛出一个错误。第二步是添加 Docker 构建过程。这将读取你的 Dockerfile 文件，并通过一个名称 consignment-service 构建镜像。句号表示一个目录路径，在这里我们只是希望构建过程在当前目录中查找。 我将在我们的 Makefile 中添加一个新条目： 12run: docker run -p 50051:50051 consignment-service 在这里，我们运行 consignment-service Docker 镜像，并暴露 50051 端口。由于 Docker 在单独的网络层上运行，因此您需要将 Docker 容器中使用的端口转发给主机。您可以通过更改第一个段将内部端口转发到主机上的新端口。例如，如果要在端口 8080 上运行此服务，则需要将 -p 参数更改为 8080:50051。您也可以通过包含 -d 标志在后台运行容器。例如，docker run -d -p 50051:50051 consignment-service。 您可以阅读更多关于 Docker 网络如何工作的信息 当您运行 $ docker build 时，您正在将代码和运行时环境构建到镜像中。Docker 镜像是您的环境及其依赖关系的可移植快照。你可以将它分享到 Docker Hub 来共享你的 Docker 镜像。Docker 镜像就像一个 npm 或 yum repo。当你在你的 Dockerfile 里面定义了 FROM，你就告诉了 docker 从 docker hub 下载哪个镜像来作为运行环境。然后，您可以扩展并覆盖该基本文件的某些部分，方法是自行重新定义它们。我们不会公开我们的 Docker 镜像，但是可以随时仔细阅读 Docker hub，并且注意到有多少功能被容器化。一些非常显著的事情已经被 Docker 化了。 Dockerfile 中的每个声明在第一次构建时都被缓存。这样可以节省每次更改时重新构建整个运行时的时间。 Docker 非常聪明，可以确定哪些部分发生了变化，哪些部分需要重新构建。这使得构建过程非常快速。 我们已经介绍了很多容器的部分了。让我们回到我们的代码。 在创建 gRPC 服务时，创建连接的代码有很多，并且必须将服务地址的位置硬编码到客户端或其他服务中，以便连接到它。这很棘手，因为当您在云中运行服务时，它们可能不共享相同的主机，或者重新部署服务后地址或 IP 可能会更改。 这是服务发现的起点。服务发现保持所有服务及其位置的最新目录。每个服务在运行时注册自己，并在关闭时自行注销。 每个服务都有一个名字或编号分配给它。 因此，即使可能有新的 IP 地址或主机地址，只要服务名称保持不变，您就不需要从其他服务更新对此服务的调用。 通常情况下，解决这个问题的方法有很多，但是像编程中的大多数情况一样，如果已经有人解决了这个问题，那么重新发明轮子就没有意义了。 Go-micro 的创始人是 @chuhnk（Asim Aslam），他以一种非常清晰和易用的方式解决了这些问题。 Go-microGo-micro 是一个用 Go 编写的强大的微服务框架，大部分用于 Go。但是，您也可以使用 Sidecar 以便与其他语言进行交互。 Go-micro 有一些有用的功能，可以用来制作微型服务。但是，我们将从可能解决的最常见问题开始，那就是服务发现。 我们需要对我们的服务进行一些更新，让它与 go-micro 一起工作。Go-micro 作为 protoc 插件集成，在这种情况下，替换我们当前使用的标准 gRPC 插件。所以让我们开始在我们的 Makefile 中替换它。 确保安装 go-micro 依赖: 1go get -u github.com/micro/protobuf/&#123;proto,protoc-gen-go&#125; 123456build: protoc -I. --go_out=plugins=micro:$(GOPATH)/src/github.com/EwanValentine/shippy/consignment-service \\ proto/consignment/consignment.proto ...... 我们已经更新了我们的 Makefile 来使用 go-micro 插件，而不是 gRPC 插件。现在需要更新我们的 consignment-service/main.go 文件来使用 go-micro。这将抽象我们以前的 gRPC 代码，它将处理注册和轻松启动我们的服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// consignment-service/main.gopackage mainimport ( // Import the generated protobuf code \"fmt\" pb \"github.com/EwanValentine/shippy/consignment-service/proto/consignment\" micro \"github.com/micro/go-micro\" \"golang.org/x/net/context\")type IRepository interface &#123; Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment&#125;// Repository - Dummy repository, this simulates the use of a datastore// of some kind. We'll replace this with a real implementation later on.type Repository struct &#123; consignments []*pb.Consignment&#125;func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) &#123; updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil&#125;func (repo *Repository) GetAll() []*pb.Consignment &#123; return repo.consignments&#125;// Service should implement all of the methods to satisfy the service// we defined in our protobuf definition. You can check the interface// in the generated code itself for the exact method signatures etc// to give you a better idea.type service struct &#123; repo IRepository&#125;// CreateConsignment - we created just one method on our service,// which is a create method, which takes a context and a request as an// argument, these are handled by the gRPC server.func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error &#123; // Save our consignment consignment, err := s.repo.Create(req) if err != nil &#123; return err &#125; // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil&#125;func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error &#123; consignments := s.repo.GetAll() res.Consignments = consignments return nil&#125;func main() &#123; repo := &amp;Repository&#123;&#125; // Create a new service. Optionally include some options here. srv := micro.NewService( // This name must match the package name given in your protobuf definition micro.Name(\"go.micro.srv.consignment\"), micro.Version(\"latest\"), ) // Init will parse the command line flags. srv.Init() // Register handler pb.RegisterShippingServiceHandler(srv.Server(), &amp;service&#123;repo&#125;) // Run the server if err := srv.Run(); err != nil &#123; fmt.Println(err) &#125;&#125; 这里的主要变化是我们实例化我们的 gRPC 服务器的方式，它处理注册我们的服务，已经被整齐地抽象到一个 mico.NewService() 方法中。最后，处理连接本身的 service.Run() 函数。和以前一样，我们注册了我们的实现，但这次使用了一个稍微不同的方法。第二个最大的变化是服务方法本身，参数和响应类型略有变化，把请求和响应结构作为参数，现在只返回一个错误。在我们的方法中，设置了由 go-micro 处理响应。 最后，我们不再对端口进行硬编码。go-micro 应该使用环境变量或命令行参数进行配置。设置地址, 使用 MICRO_SERVER_ADDRESS=:50051。我们还需要告诉我们的服务使用 mdns（多播DNS）作为我们本地使用的服务代理。 您通常不会在生产环境中使用 mdns 进行服务发现，但我们希望避免在本地运行诸如 Consul 或 etcd 这样的测试。更多我们将在后面介绍。 让我们更新我们的 Makefile 来实现这一点。 1234run: docker run -p 50051:50051 \\ -e MICRO_SERVER_ADDRESS=:50051 \\ -e MICRO_REGISTRY=mdns consignment-service -e 是一个环境变量标志，它允许你将环境变量传递到你的 Docker 容器中。 每个变量必须有一个标志，例如 -e ENV=staging -e DB_HOST=localhost 等。 现在如果你运行 make run，您将拥有一个 Dockerised 服务，并具有服务发现功能。所以让我们更新我们的 cli 工具来利用它。 1234567891011121314import ( ... \"github.com/micro/go-micro/cmd\" microclient \"github.com/micro/go-micro/client\")func main() &#123; cmd.Init() // Create new greeter client client := pb.NewShippingServiceClient(\"go.micro.srv.consignment\", microclient.DefaultClient) ...&#125; 完整文件看这里 在这里，我们导入了用于创建客户端的 go-micro 库，并用 go-micro 客户端代码取代了现有的连接代码，该客户端代码使用服务解析而不是直接连接到地址。 但是，如果你运行它，这是行不通的。这是因为我们现在正在 Docker 容器中运行我们的服务，它有自己的 mdns，独立于我们使用中的主机 mdns 。解决这个问题的最简单的方法是确保服务和客户端都在 “dockerland” 中运行，以便它们都在相同的主机上运行，并使用相同的网络层。让我们创建一个 Makefile consignment-cli/Makefile，并创建一些条目。 123456build: GOOS=linux GOARCH=amd64 go build docker build -t consignment-cli .run: docker run -e MICRO_REGISTRY=mdns consignment-cli 与之前类似，我们要为 Linux 构建我们的二进制文件。 当我们运行我们的 docker 镜像时，我们想传递一个环境变量来指示 go-micro 使用 mdns。 现在让我们为我们的 CLI 工具创建一个 Dockerfile ： 123456789FROM alpine:latestRUN mkdir -p /app WORKDIR /appADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cliCMD [\"./consignment-cli\"] 它除了引入了我们的 json 数据文件，其余与之前服务的 Dockerfile 非常相似。如果你在你的 consignment-cli 目录，运行 $ make run 命令，你应该和以前一样，看见 Created: true。 之前，我提到那些使用 Linux 的人应该切换到使用 Debian 作为基础映像。现在看起来是一个很好的时机来看看 Docker 的一个新功能：多阶段构建。这使我们可以在一个 Dockerfile 中使用多个 Docker 镜像。 这在我们的例子中尤其有用，因为我们可以使用一个镜像来构建我们的二进制文件，具有所有正确的依赖关系等，然后使用第二个镜像来运行它。让我们试试看，我会在代码中留下详细的注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# consignment-service/Dockerfile# We use the official golang image, which contains all the # correct build tools and libraries. Notice `as builder`,# this gives this container a name that we can reference later on. FROM golang:1.9.0 as builder# Set our workdir to our current service in the gopathWORKDIR /go/src/github.com/EwanValentine/shippy/consignment-service# Copy the current code into our workdirCOPY . .# Here we're pulling in godep, which is a dependency manager tool,# we're going to use dep instead of go get, to get around a few# quirks in how go get works with sub-packages.RUN go get -u github.com/golang/dep/cmd/dep# Create a dep project, and run `ensure`, which will pull in all # of the dependencies within this directory.RUN dep init &amp;&amp; dep ensure# Build the binary, with a few flags which will allow# us to run this binary in Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo .# Here we're using a second FROM statement, which is strange,# but this tells Docker to start a new build process with this# image.FROM alpine:latest# Security related package, good to have.RUN apk --no-cache add ca-certificates# Same as before, create a directory for our app.RUN mkdir /app WORKDIR /app# Here, instead of copying the binary from our host machine,# we pull the binary from the container named `builder`, within# this build context. This reaches into our previous image, finds# the binary we built, and pulls it into this container. Amazing!COPY --from=builder /go/src/github.com/EwanValentine/shippy/consignment-service/consignment-service .# Run the binary as per usual! This time with a binary build in a# separate container, with all of the correct dependencies and# run time libraries.CMD [\"./consignment-service\"] 这种方法的唯一问题，我想回来并在某些时候改善这一点，是 Docker 不能从父目录中读取文件。它只能读取 Dockerfile 所在目录或子目录中的文件。 这意味着为了运行 $ dep ensure 或 $ go get，你需要确保你的代码被推到 Git 上，这样它就可以提取 vessel-service。就像其他 Go 包一样。这种方法不理想，但足够满足我们现在的需求。 现在我将会在其他 Docker 文件中应用这种新方法。 噢，记住要记得从 Makefiles 中删除 $ go build。 更多的多阶段编译在这里 船只服务让我们创建第二个服务。我们有一个代销服务，这将处理将一批货物与一批最适合该批货物的 vessel 进行匹配。为了配合我们的货物，我们需要将集装箱的重量和数量发送到我们的新 vessel 服务，然后将找到一个能够处理该货物的船只。 在您的根目录$ mkdir vessel-service中创建一个新目录，现在为我们的新服务protobuf定义创建了一个子目录，$ mkdir -p vessel-service/proto/vessel。现在，让我们创建一个新的protobuf文件，$ touch vessel-service/proto/vessel/vessel.proto。 由于 protobuf 的定义确实是我们领域设计的核心，所以我们从这里开始 123456789101112131415161718192021222324252627// vessel-service/proto/vessel/vessel.protosyntax = \"proto3\";package go.micro.srv.vessel;service VesselService &#123; rpc FindAvailable(Specification) returns (Response) &#123;&#125;&#125;message Vessel &#123; string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6;&#125;message Specification &#123; int32 capacity = 1; int32 max_weight = 2;&#125;message Response &#123; Vessel vessel = 1; repeated Vessel vessels = 2;&#125; 正如你所看到的，这和我们的第一个服务非常相似。我们用一个 rpc 方法 FindAvailable 创建了一个服务。。这需要一个 Specification 类型并返回一个 Response 类型。Response 类型使用重复字段返回 Vessel 类型或多个 Vesse。 现在我们需要创建一个 Makefile 来处理我们的构建逻辑和运行脚本。 $ touch vessel-service/Makefile。打开该文件并添加以下内容： 12345678// vessel-service/Makefilebuild: protoc -I. --go_out=plugins=micro:$(GOPATH)/src/github.com/EwanValentine/shippy/vessel-service \\ proto/vessel/vessel.proto docker build -t vessel-service .run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 -e MICRO_REGISTRY=mdns vessel-service 这与我们为托管服务创建的第一个 Makefile 几乎相同，但注意服务名称和端口已经改变了一点。我们不能在同一个端口上运行两个 Docker 容器，所以我们在这里利用 Docker 端口转发来确保服务上的 50051 端口映射到主机网络上的 50052 端口。 现在我们需要一个 Dockerfile，使用我们新的多阶段格式： 123456789101112131415161718192021# vessel-service/DockerfileFROM golang:1.9.0 as builderWORKDIR /go/src/github.com/EwanValentine/shippy/vessel-serviceCOPY . .RUN go get -u github.com/golang/dep/cmd/depRUN dep init &amp;&amp; dep ensureRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo .FROM alpine:latestRUN apk --no-cache add ca-certificatesRUN mkdir /appWORKDIR /appCOPY --from=builder /go/src/github.com/EwanValentine/shippy/vessel-service/vessel-service .CMD [\"./vessel-service\"] 最后，我们可以开始我们的实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// vessel-service/main.gopackage mainimport ( \"context\" \"errors\" \"fmt\" pb \"github.com/EwanValentine/shippy/vessel-service/proto/vessel\" \"github.com/micro/go-micro\")type Repository interface &#123; FindAvailable(*pb.Specification) (*pb.Vessel, error)&#125;type VesselRepository struct &#123; vessels []*pb.Vessel&#125;// FindAvailable - checks a specification against a map of vessels,// if capacity and max weight are below a vessels capacity and max weight,// then return that vessel.func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) &#123; for _, vessel := range repo.vessels &#123; if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight &#123; return vessel, nil &#125; &#125; return nil, errors.New(\"No vessel found by that spec\")&#125;// Our grpc service handlertype service struct &#123; repo Repository&#125;func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error &#123; // Find the next available vessel vessel, err := s.repo.FindAvailable(req) if err != nil &#123; return err &#125; // Set the vessel as part of the response message type res.Vessel = vessel return nil&#125;func main() &#123; vessels := []*pb.Vessel&#123; &amp;pb.Vessel&#123;Id: \"vessel001\", Name: \"Boaty McBoatface\", MaxWeight: 200000, Capacity: 500&#125;, &#125; repo := &amp;VesselRepository&#123;vessels&#125; srv := micro.NewService( micro.Name(\"go.micro.srv.vessel\"), micro.Version(\"latest\"), ) srv.Init() // Register our implementation with pb.RegisterVesselServiceHandler(srv.Server(), &amp;service&#123;repo&#125;) if err := srv.Run(); err != nil &#123; fmt.Println(err) &#125;&#125; 我留下了一些注释，但是非常简单。另外，我想提下，一个 Reddit 用户 /r/jerky_lodash46 指出，我曾经使用 IRepository 作为我的接口名称。我想在这里纠正一下，在我的接口名前面加上 Java 和 C＃ 等语言的约定，但 Go 并没有真正鼓励这一点，因为 Go 把接口当作一等公民。所以我把 IRepository 更名为 Repository ，并且把我的具体结构重命名为 ConsignmentRepository。 这个系列中，我会留下任何错误，并在以后的文章中予以纠正，以便我能够解释这些改进。我们可以更多地学习。 现在让我们来看看有趣的部分。当我们创建一个托运货物时，我们需要改变我们的托运服务来呼叫我们的新 vessel 服务，找到一艘船，并更新创建的托运中的 vessel_id： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// consignment-service/main.gopackage mainimport ( // Import the generated protobuf code \"fmt\" \"log\" pb \"github.com/EwanValentine/shippy/consignment-service/proto/consignment\" vesselProto \"github.com/EwanValentine/shippy/vessel-service/proto/vessel\" micro \"github.com/micro/go-micro\" \"golang.org/x/net/context\")type Repository interface &#123; Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment&#125;// Repository - Dummy repository, this simulates the use of a datastore// of some kind. We'll replace this with a real implementation later on.type ConsignmentRepository struct &#123; consignments []*pb.Consignment&#125;func (repo *ConsignmentRepository) Create(consignment *pb.Consignment) (*pb.Consignment, error) &#123; updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil&#125;func (repo *ConsignmentRepository) GetAll() []*pb.Consignment &#123; return repo.consignments&#125;// Service should implement all of the methods to satisfy the service// we defined in our protobuf definition. You can check the interface// in the generated code itself for the exact method signatures etc// to give you a better idea.type service struct &#123; repo Repository vesselClient vesselProto.NewVesselService&#125;// CreateConsignment - we created just one method on our service,// which is a create method, which takes a context and a request as an// argument, these are handled by the gRPC server.func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error &#123; // Here we call a client instance of our vessel service with our consignment weight, // and the amount of containers as the capacity value vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification&#123; MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), &#125;) log.Printf(\"Found vessel: %s \\n\", vesselResponse.Vessel.Name) if err != nil &#123; return err &#125; // We set the VesselId as the vessel we got back from our // vessel service req.VesselId = vesselResponse.Vessel.Id // Save our consignment consignment, err := s.repo.Create(req) if err != nil &#123; return err &#125; // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil&#125;func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error &#123; consignments := s.repo.GetAll() res.Consignments = consignments return nil&#125;func main() &#123; repo := &amp;ConsignmentRepository&#123;&#125; // Create a new service. Optionally include some options here. srv := micro.NewService( // This name must match the package name given in your protobuf definition micro.Name(\"consignment\"), micro.Version(\"latest\"), ) vesselClient := vesselProto.NewVesselService(\"go.micro.srv.vessel\", srv.Client()) // Init will parse the command line flags. srv.Init() // Register handler pb.RegisterShippingServiceHandler(srv.Server(), &amp;service&#123;repo, vesselClient&#125;) // Run the server if err := srv.Run(); err != nil &#123; fmt.Println(err) &#125;&#125; 在这里，我们为我们的 vessel 服务创建了一个客户端实例，这允许我们使用服务名称，即 go.micro.srv.vessel 将船舶服务作为客户端调用，并与其方法交互。在这种情况下，只有一个方法 (FindAvailable)。我们把我们的寄售重量，以及我们想要作为规格的集装箱的数量发送到 vessel 服务。然后返回一个适当的 vessel。 更新 consignment-cli/consignment.json 文件，删除硬编码的 vessel_id ，我们要确认我们自己正在工作。让我们再添加一些容器，增加权重。例如 123456789&#123; \"description\": \"This is a test consignment\", \"weight\": 55000, \"containers\": [ &#123; \"customer_id\": \"cust001\", \"user_id\": \"user001\", \"origin\": \"Manchester, United Kingdom\" &#125;, &#123; \"customer_id\": \"cust002\", \"user_id\": \"user001\", \"origin\": \"Derby, United Kingdom\" &#125;, &#123; \"customer_id\": \"cust005\", \"user_id\": \"user001\", \"origin\": \"Sheffield, United Kingdom\" &#125; ]&#125; 现在在 consignment-cli 中运行 $ make build &amp;&amp; make。您应该看到一个响应​​，并创建货物清单。在您的货物中，您现在应该看到 vessel_id 已经设置好了。所以现在有了我们两个互联的微服务和一个命令行界面！在这个系列的下一部分，我们将看看使用 MongoDB 来保存这些数据。我们还将添加第三个服务，并使用 docker-compose 来管理我们在本地不断增长的容器生态系统。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程-第一部分","slug":"go-micro-tutorial-1","date":"2018-05-10T13:56:15.000Z","updated":"2020-07-25T02:57:18.203Z","comments":true,"path":"2018/05/10/go-micro-tutorial-1/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-1/","excerpt":"介绍这是一个十节Golang的微服务的系列。利用protobuf和gRPC作为底层传输协议。为什么?因为我花了很长时间才弄明白并解决了一个清晰而简洁的解决方案，我想要分享我在创建、测试和部署微服务的过程中所了解到的东西，这些服务是与其他新出现的用户端到一起的。 在本教程中，我们将介绍一些基本概念、术语，并以最原始的形式创建我们的第一个微服务。","text":"介绍这是一个十节Golang的微服务的系列。利用protobuf和gRPC作为底层传输协议。为什么?因为我花了很长时间才弄明白并解决了一个清晰而简洁的解决方案，我想要分享我在创建、测试和部署微服务的过程中所了解到的东西，这些服务是与其他新出现的用户端到一起的。 在本教程中，我们将介绍一些基本概念、术语，并以最原始的形式创建我们的第一个微服务。 我们将在整个系列中创建以下服务: 货物 库存 用户 身份验证 角色 船只 我们最终将会用到:golang, mongodb, grpc, docker，谷歌云，Kubernetes, NATS, CircleCI, Terraform和go-micro。 接下来，您可以按照我所包含的步骤进行操作，但是一定要使用git repo(每一篇文章都有自己的分支)作为参考，将GOPATH更改为您自己的步骤。 同时注意，我正在使用Macbook，所以您可能需要修改makefile以使用$GOPATH而不是$(GOPATH)，操作系统之间可能还有其他一些不一致的地方。 先决条件 对Golang及其生态系统的理解 安装gRPC / protobuf - 看这里 安装Golang - 看这里 安装以下的go库: 12go get -u google.golang.org/grpcgo get -u github.com/golang/protobuf/protoc-gen-go 我们构建什么我们将构建一个您能想到的最通用的微服务示例，一个集装箱管理平台!一个博客对微服务的用例太过简单，我想要一些能真正展示复杂性分离的东西。所以这是一个很好的挑战! 让我们从基础开始: 什么是微服务在传统的庞大应用程序中，所有的组织特性都被写入到一个应用程序中。有时，它们被它们的类型分组，比如控制器、实体、工厂等等。其他时候，可能在更大的应用程序中，特性会被关注点或特性分隔开来。因此，您可能会有一个auth包、一个朋友包和一个文章包。它们可能包含自己的工厂、服务、存储库、模型等，但最终它们都被组合在一个代码库中。 微服务是将第二种方法稍作进一步的概念，并将这些关注点分离为独立的可运行的代码库。 为什么微服务复杂性——将特性拆分为微服务，可以将代码分割成更小的块。这让人想起了古老的unix格言:“做好一件事”。有一种趋势是，单分子允许域彼此紧密耦合，而关注点变得模糊。这将导致更危险、更复杂的更新、潜在的更多bug和更复杂的集成。 规模——在一个整体中，某些代码领域可能比其他领域更频繁地使用。用一个整体，你只能缩放整个代码库。因此，如果您的auth服务经常受到攻击，您需要扩展整个代码库来处理您的第auth服务的负载。 有了微服务，这种分离就可以让您单独地扩展单个服务。这意味着更有效的水平扩展。它与多核、多区域的云计算非常有效。 Nginx写了一个关于微服务的各种概念的奇妙系列，请阅读。 为什么Golang毕竟，微服务是由所有语言支持的，毕竟，微服务是一个概念，而不是一个特定的框架或工具。也就是说，有些语言更适合，或者比其他语言更好地支持微服务。有一种非常支持的语言是Golang。 Golang非常轻，非常快，并且对并发有非常好的支持，在运行多个机器和内核时，它是一个强大的功能。 Go还包含一个非常强大的用于编写web服务的标准库。 最后，还有一个很棒的微服务框架，叫做Go-micro。我们将在本系列中使用。 引入protobuf/gRPC由于微服务被拆分为单独的代码库，而微服务的一个重要问题就是通信。在一个单一的通信中不是一个问题，因为你直接从代码库的其他地方调用代码。然而，微服务没有这种能力，因为它们生活在不同的地方。因此，你需要一种方式，让这些独立的服务能够以尽可能少的延迟进行对话。 在这里，您可以使用传统的REST，例如http上的JSON或XML。但是，这种方法的问题在于，服务A必须将其数据编码成JSON/XML，将一个大字符串发送到网络上，然后服务于B，然后将该消息从JSON解码为代码。这在规模上有潜在的开销问题。当您被迫采用这种形式的web浏览器通信时，服务可以以任何他们希望的格式进行对话。 gRPC是由谷歌提出的基于轻量级二进制文件的RPC通信协议。这是很多单词，我们来仔细分析一下。gRPC使用二进制作为其核心数据格式。在我们的RESTful示例中，使用JSON，您将通过http发送一个字符串。字符串包含关于其编码格式的大量元数据;关于它的长度，它的内容格式和各种其他零零碎碎。这是为了让服务器能够通知传统的基于浏览器的客户端。在两个服务之间进行通信时，我们并不需要所有这些。所以我们可以使用冷硬二进制，它的重量要轻得多。gRPC使用了新的HTTP 2.0规范，它允许使用二进制数据。它甚至允许双向流，这很酷!HTTP 2对于gRPC的工作方式非常重要。有关HTTP 2的更多信息，请查看谷歌的这篇精彩文章。 但是对于二进制数据我们怎么做呢?gRPC有一个叫做protobuf的互换DSL。Protobuf允许您使用开发人员友好的格式定义服务的接口。 让我们从创建第一个服务定义开始。从我们的repo的根目录创建以下文件:consignment-service/proto/consignment/consignment.proto。就目前而言，我把我们所有的服务都安排在一个单一的回购协议里。这就是所谓的mono-repo。这主要是为了让本教程保持简单。有很多反对使用单引号的理由，我不会在这里讨论。您可以将所有这些服务和组件放在单独的repos中，也有许多很好的理由支持这种方法。 这里有一篇很棒的关于gRPC的文章，我强烈推荐你读一读。 在您刚刚创建的consignment.proto文件中，添加以下内容: 12345678910111213141516171819202122232425262728// consignment-service/proto/consignment/consignment.protosyntax = &quot;proto3&quot;;package go.micro.srv.consignment;service ShippingService &#123; rpc CreateConsignment(Consignment) returns (Response) &#123;&#125;&#125;message Consignment &#123; string id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5;&#125;message Container &#123; string id = 1; string customer_id = 2; string origin = 3; string user_id = 4;&#125;message Response &#123; bool created = 1; Consignment consignment = 2;&#125; 这是一个非常基本的例子，但是这里有一些事情。首先，定义您的服务，这应该包含您希望向其他服务公开的方法。然后定义消息类型，这些是有效的数据结构。Protobuf是静态类型的，您可以定义自定义类型，就像我们在容器中所做的那样。消息本身就是自定义类型。 这里有两个库，消息由protobuf处理，我们定义的服务由gRPC protobuf插件处理，它编译代码来与这些类型交互。我们的proto文件的服务部分。 然后，通过一个CLI来生成这个protobuf定义，生成代码来接口这个二进制数据和您的功能。 说到这里，让我们为我们的第一个服务$ touch consignment-service/Makefile创建一个Makefile。 注意:在复制Makefile代码时要注意格式，它们必须是制表符间距，否则就会中断。请确保您的编辑器已经对makefile进行了linting或适当的设置。 123build: protoc -I. --go_out=plugins=grpc:$(GOPATH)/src/github.com/ewanvalentine/shipper/consignment-service \\ proto/consignment/consignment.proto 这将调用protoc库，该库负责将您的protobuf定义编译成代码。我们还指定了grpc插件的使用，以及构建上下文和输出路径。 现在，当您从这个服务目录运行$ make build时，查看proto/consignment/您应该看到一个新的Go文件，叫做consignment.pb.go。这是gRPC/protobuf库自动生成的代码，允许您将protobuf定义与您自己的代码进行接口。 我们现在来创建main.go文件在项目根$ touch consignment-service/main.go。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// consignment-service/main.gopackage mainimport ( \"log\" \"net\" // Import the generated protobuf code pb \"github.com/ewanvalentine/shipper/consignment-service/proto/consignment\" \"golang.org/x/net/context\" \"google.golang.org/grpc\" \"google.golang.org/grpc/reflection\")const ( port = \":50051\")type IRepository interface &#123; Create(*pb.Consignment) (*pb.Consignment, error)&#125;// Repository - Dummy repository, this simulates the use of a datastore// of some kind. We'll replace this with a real implementation later on.type Repository struct &#123; consignments []*pb.Consignment&#125;func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) &#123; updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil&#125;// Service should implement all of the methods to satisfy the service// we defined in our protobuf definition. You can check the interface// in the generated code itself for the exact method signatures etc// to give you a better idea.type service struct &#123; repo IRepository&#125;// CreateConsignment - we created just one method on our service,// which is a create method, which takes a context and a request as an// argument, these are handled by the gRPC server.func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment) (*pb.Response, error) &#123; // Save our consignment consignment, err := s.repo.Create(req) if err != nil &#123; return nil, err &#125; // Return matching the `Response` message we created in our // protobuf definition. return &amp;pb.Response&#123;Created: true, Consignment: consignment&#125;, nil&#125;func main() &#123; repo := &amp;Repository&#123;&#125; // Set-up our gRPC server. lis, err := net.Listen(\"tcp\", port) if err != nil &#123; log.Fatalf(\"failed to listen: %v\", err) &#125; s := grpc.NewServer() // Register our service with the gRPC server, this will tie our // implementation into the auto-generated interface code for our // protobuf definition. pb.RegisterShippingServiceServer(s, &amp;service&#123;repo&#125;) // Register reflection service on gRPC server. reflection.Register(s) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"failed to serve: %v\", err) &#125;&#125; 请仔细阅读代码中的注释。但总的来说，我们在这里创建了实现逻辑，我们的gRPC方法接口使用生成的格式，在端口50051上创建一个新的gRPC服务器。有你有它!一个功能齐全的gRPC服务。你可以用$ go main来运行这个。去吧，但是你什么都看不到，你还不能用它……因此，让我们创建一个客户端来查看它的实际操作。 让我们创建一个命令行接口，它将使用一个JSON委托文件，并与我们的gRPC服务交互。 在根目录中，创建一个新的子目录$ mkdir consignment-cli。在该目录中，创建一个名为cli.go的文件。以下内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// consignment-cli/cli.gopackage mainimport ( \"encoding/json\" \"io/ioutil\" \"log\" \"os\" pb \"github.com/ewanvalentine/shipper/consignment-service/proto/consignment\" \"golang.org/x/net/context\" \"google.golang.org/grpc\")const ( address = \"localhost:50051\" defaultFilename = \"consignment.json\")func parseFile(file string) (*pb.Consignment, error) &#123; var consignment *pb.Consignment data, err := ioutil.ReadFile(file) if err != nil &#123; return nil, err &#125; json.Unmarshal(data, &amp;consignment) return consignment, err&#125;func main() &#123; // Set up a connection to the server. conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil &#123; log.Fatalf(\"Did not connect: %v\", err) &#125; defer conn.Close() client := pb.NewShippingService(conn) // Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 &#123; file = os.Args[1] &#125; consignment, err := parseFile(file) if err != nil &#123; log.Fatalf(\"Could not parse file: %v\", err) &#125; r, err := client.CreateConsignment(context.Background(), consignment) if err != nil &#123; log.Fatalf(\"Could not greet: %v\", err) &#125; log.Printf(\"Created: %t\", r.Created)&#125; 现在创建一个委托(consignment-cli/consignment.json): 12345678&#123; \"description\": \"This is a test consignment\", \"weight\": 550, \"containers\": [ &#123; \"customer_id\": \"cust001\", \"user_id\": \"user001\", \"origin\": \"Manchester, United Kingdom\" &#125; ], \"vessel_id\": \"vessel001\"&#125; 现在，如果你在consignment-service运行$ go run main.go，然后在一个单独的终端面板中运行$ go run cli.go。您应该看到一条消息说Created: true。但是，我们如何才能真正检验它创造了什么呢?让我们用GetConsignments方法来更新我们的服务，这样我们就可以查看所有创建的委托。 首先让我们更新我们的proto定义(我留下注释来表示所做的更改): 12345678910111213141516171819202122232425262728293031323334353637// consignment-service/proto/consignment/consignment.protosyntax = \"proto3\";package go.micro.srv.consignment;service ShippingService &#123; rpc CreateConsignment(Consignment) returns (Response) &#123;&#125; // Created a new method rpc GetConsignments(GetRequest) returns (Response) &#123;&#125;&#125;message Consignment &#123; string id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5;&#125;message Container &#123; string id = 1; string customer_id = 2; string origin = 3; string user_id = 4;&#125;// Created a blank get requestmessage GetRequest &#123;&#125;message Response &#123; bool created = 1; Consignment consignment = 2; // Added a pluralised consignment to our generic response message repeated Consignment consignments = 3;&#125; 因此，我们在我们的服务上创建了一个名为GetConsignments的新方法，我们还创建了一个新的GetRequest，它暂时不包含任何东西。我们还在响应消息中添加了一个consignments字段。您将注意到这里的类型在实际类型之前重复了关键字。正如您可能已经猜到的那样，这意味着将这个字段作为这些类型的数组来处理。 现在再次运行$ make build。现在，再次尝试运行您的服务，您应该会看到类似于:*. service没有实现go_micro_srv_consignment.ShippingServiceServer(丢失GetConsignments方法)的错误。 由于我们的gRPC方法的实现，是基于与protobuf库生成的接口相匹配的，所以我们需要确保我们的实现符合我们的proto定义。 所以，让我们更新一下我们的consignment-service/main.go文件: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport ( \"log\" \"net\" // Import the generated protobuf code pb \"github.com/ewanvalentine/shipper/consignment-service/proto/consignment\" \"golang.org/x/net/context\" \"google.golang.org/grpc\" \"google.golang.org/grpc/reflection\")const ( port = \":50051\")type IRepository interface &#123; Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment&#125;// Repository - Dummy repository, this simulates the use of a datastore// of some kind. We'll replace this with a real implementation later on.type Repository struct &#123; consignments []*pb.Consignment&#125;func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) &#123; updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil&#125;func (repo *Repository) GetAll() []*pb.Consignment &#123; return repo.consignments&#125;// Service should implement all of the methods to satisfy the service// we defined in our protobuf definition. You can check the interface// in the generated code itself for the exact method signatures etc// to give you a better idea.type service struct &#123; repo IRepository&#125;// CreateConsignment - we created just one method on our service,// which is a create method, which takes a context and a request as an// argument, these are handled by the gRPC server.func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment) (*pb.Response, error) &#123; // Save our consignment consignment, err := s.repo.Create(req) if err != nil &#123; return nil, err &#125; // Return matching the `Response` message we created in our // protobuf definition. return &amp;pb.Response&#123;Created: true, Consignment: consignment&#125;, nil&#125;func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest) (*pb.Response, error) &#123; consignments := s.repo.GetAll() return &amp;pb.Response&#123;Consignments: consignments&#125;, nil&#125;func main() &#123; repo := &amp;Repository&#123;&#125; // Set-up our gRPC server. lis, err := net.Listen(\"tcp\", port) if err != nil &#123; log.Fatalf(\"failed to listen: %v\", err) &#125; s := grpc.NewServer() // Register our service with the gRPC server, this will tie our // implementation into the auto-generated interface code for our // protobuf definition. pb.RegisterShippingServiceServer(s, &amp;service&#123;repo&#125;) // Register reflection service on gRPC server. reflection.Register(s) if err := s.Serve(lis); err != nil &#123; log.Fatalf(\"failed to serve: %v\", err) &#125;&#125; 这里，我们已经包含了新的GetConsignments方法，更新了我们的存储库和接口，并满足了proto定义生成的接口。如果你运行$ go run main.go。再来一遍，这又管用了。 让我们更新cli工具，以包括调用此方法和列出我们的委托的能力: 1234567891011func main() &#123; ... getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest&#123;&#125;) if err != nil &#123; log.Fatalf(\"Could not list consignments: %v\", err) &#125; for _, v := range getAll.Consignments &#123; log.Println(v) &#125;&#125; 在我们的main函数的最下面，在下面我们记录我们的”Created: success”消息，附加上面的代码，并重新运行 $ go run cli.go。这将创建一个委托，然后调用GetConsignments。您应该看到这个列表在运行的次数越多。 注意:为了简洁起见，我有时可能会修订之前用一个…表示没有对前面的代码做任何更改，但是添加了附加的行或附加的行。 因此，我们已经成功地创建了一个微服务和一个客户端来与它交互，使用protobuf和gRPC。 本系列的下一篇文章将围绕如何集成go-micro，这是一个强大的框架，用于创建基于gRPC的微服务。我们还将创建第二个服务，即容器服务。说到容器，只是为了混淆问题，我们还将在本系列的下一部分中查看Docker容器中的服务。 进一步的阅读 文章和通讯https://www.nginx.com/blog/introduction-to-microservices/https://martinfowler.com/articles/microservices.htmlhttps://www.microservices.com/talks/ https://medium.facilelogin.com/ten-talks-on-microservices-you-cannot-miss-at-any-cost-7bbe5ab7f43f#.ui0748oat https://microserviceweekly.com/ 书https://www.amazon.co.uk/Building-Microservices-Sam-Newman/dp/1491950358 https://www.amazon.co.uk/Devops-Handbook-World-Class-Reliability-Organizations/dp/1942788002 https://www.amazon.co.uk/Phoenix-Project-DevOps-Helping-Business/dp/0988262509 播客https://softwareengineeringdaily.com/tag/microservices/https://martinfowler.com/tags/podcast.htmlhttps://www.infoq.com/microservices/podcasts/","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Go微服务教程","slug":"go-micro-tutorial-readme","date":"2018-05-10T13:33:53.000Z","updated":"2020-07-25T02:57:18.206Z","comments":true,"path":"2018/05/10/go-micro-tutorial-readme/","link":"","permalink":"https://jigangduan.github.io/2018/05/10/go-micro-tutorial-readme/","excerpt":"","text":"这是一个十节Golang的微服务的系列。利用protobuf和gRPC作为底层传输协议。为什么?因为我花了很长时间才弄明白并解决了一个清晰而简洁的解决方案，我想要分享我在创建、测试和部署微服务的过程中所了解到的东西，这些服务是与其他新出现的用户端到一起的。 目录第一部分第二部分第三部分第四部分第五部分第六部分第七部分第八部分","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Redis开发和运维 (4) - 其它功能","slug":"redis-devops-4","date":"2018-04-20T03:55:11.000Z","updated":"2020-07-25T02:57:18.227Z","comments":true,"path":"2018/04/20/redis-devops-4/","link":"","permalink":"https://jigangduan.github.io/2018/04/20/redis-devops-4/","excerpt":"","text":"慢查询客户端生命周期 两点说明： 慢查询发生在第3阶段 客户端超时不一定是慢查询，但是慢查询是客户端超时的一个可能的原因 慢查询的两个配置slowlog-max-len 它决定 slow log 最多能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 slowlog-max-len 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log。 先进先出队列 固定长度，队列满后，第一个进入队列的将会被踢出 保存在内存中 slowlog-log-slower-than 它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。 慢查询阈值（单位：微秒） slowlog-log-slower-than=0，记录所有命令 slowlog-log-slower-than&lt;0，不记录任何命令 配置方法 默认值 12config get slowlog-max-len = 128config get slowlog-log-slower-than = 10000 修改配置文件重启 动态配置 慢查询命令 slowlog get [n]：获取慢查询队列 slowlog len：获取慢查询队列长度 slowlog reset：清空慢查询队列 运维经验 slowlog-max-len 不要设置过大，默认10ms，通常设置1ms slowlog-log-slower-than 不要设置过小，通常设置1000左右 理解命令的生命周期 定期持久化慢查询 pipeline发布订阅BitmapHyperLogLogGEO","categories":[{"name":"Redis","slug":"Redis","permalink":"https://jigangduan.github.io/categories/Redis/"},{"name":"数据库","slug":"Redis/数据库","permalink":"https://jigangduan.github.io/categories/Redis/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://jigangduan.github.io/tags/redis/"}]},{"title":"Redis开发和运维 (3) - 客户端使用","slug":"redis-devops-3","date":"2018-04-20T02:07:56.000Z","updated":"2020-07-25T02:57:18.227Z","comments":true,"path":"2018/04/20/redis-devops-3/","link":"","permalink":"https://jigangduan.github.io/2018/04/20/redis-devops-3/","excerpt":"","text":"Redis支持的客户端，查看这里 Java客户端Jedis Maven依赖： 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Jedis直连： 生成Jedis对象(连接) Jedis执行命令 返回执行结果 关闭Jedis连接 123Jedis jedis = new Jedis(\"127.0.0.1\", 6379);jedis.set(\"hello\", \"world\");String value = jedis.get(\"hello\"); 1Jedis(String host, int port, int connectionTimeout, int soTimeout) host: Redis节点所在机器的IP port：Redis节点的端口 connectionTimeout: 客户端连接超时 soTimeout：客户端读写超时 Jedis连接池 从资源池借Jedis对象 Jedis执行命令 返回执行结果 归还Jedis对象给连接池 方案对比： - 优点 缺点 直连&nbsp;&nbsp; 简单方便适用于少量长期连接的场景 存在每次新键/关闭TCP开销资源无法控制，存在连接泄露的可能Jedis对象线程不安全 连接池&nbsp;&nbsp; Jedis预先生成，降低开销连接池的形式保护和控制资源使用 相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题 简单使用1234// 1. stringjedis.set(\"hello\", \"world\");jedis.get(\"hello\");jedis.incr(\"counter\"); 1234// 2. hashjedis.hset(\"myhash\", \"f1\", \"v1\");jedis.hset(\"myhash\", \"f2\", \"v2\");jedis.hgetAll(\"myhash\"); 12345// 3. listjedis.hset(\"mylist\", \"1\");jedis.hset(\"mylist\", \"2\");jedis.hset(\"mylist\", \"3\");jedis.lrange(\"mylist\", 0, -1); 12345// 4. setjedis.sadd(\"myset\", \"a\");jedis.sadd(\"myset\", \"b\");jedis.sadd(\"myset\", \"c\");jedis.smembers(\"myset\"); 12345// 5. zsetjedis.zadd(\"myzset\", 99, \"tom\");jedis.zadd(\"myzset\", 66, \"pete\");jedis.zadd(\"myzset\", 33, \"jam\");jedis.zrangeWithScores(\"myset\", 0, -1); Jedis连接池使用Jedis操作步骤如下： 获取Jedis实例需要从JedisPool中获取 用完Jedis实例需要返还给JedisPool 如果Jedis在使用过程中出错，则也需要还给JedisPool 1234567891011121314151617181920212223242526272829303132333435package cn.crxy.redis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class RedisUtils &#123; private RedisUtils()&#123; &#125; private static JedisPool jedisPool = null; //获取链接 public static synchronized Jedis getJedis()&#123; if(jedisPool==null)&#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); //指定连接池中最大空闲连接数 jedisPoolConfig.setMaxIdle(10); //链接池中创建的最大连接数 jedisPoolConfig.setMaxTotal(100); //设置创建链接的超时时间 jedisPoolConfig.setMaxWaitMillis(2000); //表示连接池在创建链接的时候会先测试一下链接是否可用，这样可以保证连接池中的链接都可用的。 jedisPoolConfig.setTestOnBorrow(true); jedisPool = new JedisPool(jedisPoolConfig, \"192.168.1.170\", 6379); &#125; return jedisPool.getResource(); &#125; //返回链接 public static void returnResource(Jedis jedis)&#123; jedisPool.returnResourceObject(jedis); &#125;&#125; python客户端redis-py 安装redis-pyGitHub 要安装redis-py，只需:: 1pip install redis 或从源代码: 1python setup.py install 123456import redis&gt;&gt;&gt; r = redis.Redis(host='localhost', port=6379, db=0)&gt;&gt;&gt; r.set('foo', 'bar')True&gt;&gt;&gt; r.get('foo')'bar' golang客户端redigo GitHub 安装: 1go get github.com/gomodule/redigo/redis API文档","categories":[{"name":"Redis","slug":"Redis","permalink":"https://jigangduan.github.io/categories/Redis/"},{"name":"数据库","slug":"Redis/数据库","permalink":"https://jigangduan.github.io/categories/Redis/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://jigangduan.github.io/tags/redis/"}]},{"title":"Redis开发和运维 (2) - Redis API","slug":"redis-devops-2","date":"2018-04-19T14:46:25.000Z","updated":"2020-07-25T02:57:18.227Z","comments":true,"path":"2018/04/19/redis-devops-2/","link":"","permalink":"https://jigangduan.github.io/2018/04/19/redis-devops-2/","excerpt":"","text":"通用命令 遍历所有key 123keys *keys [pattern] 一般不在生产环境使用，单线程列出耗时 可以在热备节点上用 计算key的总数 1dbsize 检查key是否存在 1exists key 删除指定key-value 1del key [keys...] key在seconds秒后过期 1expire key seconds type key 数据结构和内部编码### 字符串类型哈希类型列表类型集合类型有序集合类型查缺补漏zrevankzrevrang","categories":[{"name":"Redis","slug":"Redis","permalink":"https://jigangduan.github.io/categories/Redis/"},{"name":"数据库","slug":"Redis/数据库","permalink":"https://jigangduan.github.io/categories/Redis/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://jigangduan.github.io/tags/redis/"}]},{"title":"Redis开发和运维 (1) - 初识","slug":"redis-devops-1","date":"2018-04-19T12:41:55.000Z","updated":"2020-07-25T02:57:18.227Z","comments":true,"path":"2018/04/19/redis-devops-1/","link":"","permalink":"https://jigangduan.github.io/2018/04/19/redis-devops-1/","excerpt":"","text":"导学盛赞Redis 高性能 Key-Value服务器 支持多种数据结构 丰富的功能 高可用分布式支持 介绍Redis是什么 开源 基于键值的存储服务系统 多种数据结构 高性能，功能丰富 Redis的前世今生 作者：Salvaore Sanfilippo（antirez） 脱胎于项目LLOOGG.com 支持的数据结构： Strings/Blobs/Bitmaps Hash Tables(objects) Linked Lists Sets Sorted Sets 谁再使用Redis? GitHub twitter stackoverflow Alibba Baidu 微博 … 特性 速度快 10w OPS 数据存储在内存中 使用C语言 单线程 类型 每秒读写次数 随机读写延迟 访问带宽 内存 千万级 80ns 5GB SSD盘 35000 1~0.2ms 100~300MB 机械盘 100左右 10ms 100MB左右 持久性 Redis所有数据保存在内存中，对数据的更新将异步地保存到磁盘中 多种数据结构 Strings/Blobs Hash Tables(objects) Linked Lists Sets Sorted Sets Bitmaps(位图) HyperLogLog（超小内存唯一值计数） GEO(地理信息定位) 支持多种编辑语言java php python ruby lua node … 功能丰富 发布订阅 Lub脚本 事务 pipeline 简单 23,000行C代码 主从复制 高可用，分布式 高可用 =&gt; Redis-Sentinel(v2.8)支持高可用 分布式 =&gt; Redis-Cluster(v3.0)支持分布式 典型应用场景 缓存系统 计数器 消息队列系统 排行榜 社交网络 实时系统 安装和配置安装 Linux 12345wget http://download.redis.io/releases/redis-3.0.7.tar.gztar -xzf redis-3.0.7.tar.gzln -s redis-3.0.7 rediscd redismake &amp;&amp; make install Redis可执行文件： redis-serer Redis服务器 redis-cli Redis命令行客户端 redis-benchmark Redis性能测试工具 redis-check-aof AOF文件修复工具 redis-check-dump RDB文件修复工具 redis-sentinel Sentinel服务器(2.8以后) 三种启动方式： 最简启动 1redis-server 配置文件启动 1redis-server --port 6380 动态参数启动 1redis-server configPath 验证： 123ps -ef | grep redisnetstat -antpl | grep redisredis-cli -h ip port ping 生产环境选择配置启动 单机多实例配置文件可以用端口区分开 Redis客户端连接 1234567# redis-cli -h 10.10.79.150 -p 638410.10.79.150:6380&gt; pingPONG10.10.79.150:6380&gt; set hello worldOK10.10.79.150:6380&gt; get hello\"world\" 常用配置： daemonize 是否是守护进程(no|yes) port 对外端口(默认6379) logfile 日志名 dir 工作目录…","categories":[{"name":"Redis","slug":"Redis","permalink":"https://jigangduan.github.io/categories/Redis/"},{"name":"数据库","slug":"Redis/数据库","permalink":"https://jigangduan.github.io/categories/Redis/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://jigangduan.github.io/tags/redis/"}]},{"title":"WebAPP升级方案(iOS版)","slug":"webapp-update-ios","date":"2018-04-19T03:33:51.000Z","updated":"2020-07-25T02:57:18.232Z","comments":true,"path":"2018/04/19/webapp-update-ios/","link":"","permalink":"https://jigangduan.github.io/2018/04/19/webapp-update-ios/","excerpt":"","text":"服务器部分服务端提供: 版本检测接口e.g. http://192.168.11.1:3000/version H5+包下载地址e.g. http://192.168.11.1:3000/download/HelloH5.wgtu H5+包命名： Supervisor.wgtu格式： package_name.wgtu H5+包使用zip压缩 JS部分执行步骤: 版本检测 下载wgtu包 安装wgtu包 重启 版本检测123456789101112131415161718192021222324252627282930313233343536function checkVersion() &#123; var wgtVer = null; plus.runtime.getProperty( plus.runtime.appid, function ( wgtinfo ) &#123; //version属性 wgtVer = wgtinfo.version; outSet( wgtStr ); &#125; ); var url = \"http://192.168.11.1:3000/version\"; var xhr = new plus.net.XMLHttpRequest(); xhr.onreadystatechange = function () &#123; switch ( xhr.readyState ) &#123; case 4: if ( xhr.status == 200 ) &#123; outSet(\"检测更新 版本：\" + xhr.responseText); var newVer = xhr.responseText; if (wgtVer &amp;&amp; newVer &amp;&amp; (wgtVer != newVer)) &#123; outSet(\"有新版本:，可更新！！, 旧版本:\"); alert(\"有新版本:\" + newVer + \"，可更新！！, 旧版本:\" + wgtVer); &#125; else &#123; outSet(\"无新版本可更新！\"); alert(\"无新版本可更新！\"); &#125; &#125; else &#123; outSet(\"检测更新失败！\"); alert(\"检测更新失败！\"); &#125; break; default : break; &#125; &#125; xhr.open( \"GET\", url ); xhr.send();&#125; H5包升级1234567891011121314151617181920212223242526function updateApp()&#123; var url='http://192.168.11.1:3000/download/HelloH5.wgtu'; plus.nativeUI.showWaiting(\"升级中...\"); var dtask = plus.downloader.createDownload( url, &#123;method:\"GET\"&#125;, function(d,status)&#123; if ( status == 200 ) &#123; plus.console.log( \"Download wgtu success: \" + d.filename ); outSet( \"Download wgtu success: \" + d.filename ); plus.runtime.install(d.filename,&#123;&#125;,function()&#123; plus.nativeUI.closeWaiting(); plus.nativeUI.alert(\"Update wgtu success, restart now!\",function()&#123; plus.runtime.restart(); &#125;); &#125;,function(e)&#123; plus.nativeUI.closeWaiting(); alert(\"Update wgtu failed: \"+e.message); &#125;); &#125; else &#123; plus.nativeUI.closeWaiting(); alert( \"Download wgtu failed: \" + status ); &#125; &#125; ); dtask.addEventListener('statechanged',function(d,status)&#123; console.log(\"statechanged: \"+d.state); &#125;); dtask.start();&#125; iOS部分 H5包从Build位置向沙盒位置迁移依赖plus.runtime.install寻找迁移位置 动态加载H5+包","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"WebAPP","slug":"前端/WebAPP","permalink":"https://jigangduan.github.io/categories/前端/WebAPP/"}],"tags":[{"name":"webapp","slug":"webapp","permalink":"https://jigangduan.github.io/tags/webapp/"}]},{"title":"micro-heartbeat","slug":"micro-heartbeat","date":"2018-03-24T13:36:35.000Z","updated":"2020-07-25T02:57:18.213Z","comments":true,"path":"2018/03/24/micro-heartbeat/","link":"","permalink":"https://jigangduan.github.io/2018/03/24/micro-heartbeat/","excerpt":"演示服务发现使用心跳。","text":"演示服务发现使用心跳。 依据服务发现在启动和注销时提供服务发现。有时，这些服务可能会意外地死亡或被强行杀死或面临暂时的网络问题。在这些情况下，将在服务发现中保留陈旧的节点。如果自动删除服务，那将是理想的。 解决方案Micro支持一个注册器TTL的选项，并为这个确切的原因注册间隔。TTL指定一个注册在发现之后应该存在多长时间，它会过期并被删除。间隔是服务重新注册以保存其在服务发现中的注册的时间。 这些选项都可以在go-micro和micro Toolkit中使用。 Toolkit使用像这样的标志运行工具箱中的任何组件 1micro --register_ttl=30 --register_interval=15 api 这个示例显示，我们设置一个30秒的ttl，重新注册间隔为15秒。 Go Micro在宣布micro服务时，您可以将选项作为time.Duration传递 12345service := micro.NewService( micro.Name(\"com.example.srv.foo\"), micro.RegisterTTL(time.Second*30), micro.RegisterInterval(time.Second*15),)","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"micro new [service]","slug":"micro-new","date":"2018-03-23T13:21:14.000Z","updated":"2020-07-25T02:57:18.213Z","comments":true,"path":"2018/03/23/micro-new/","link":"","permalink":"https://jigangduan.github.io/2018/03/23/micro-new/","excerpt":"micro new命令是为micro服务生成样板模板的快捷方式。","text":"micro new命令是为micro服务生成样板模板的快捷方式。 使用通过指定相对于$GOPATH的目录路径来创建新服务。 1micro new github.com/micro/foo 将运行： 1234567891011121314151617181920212223micro new github.com/micro/foocreating service go.micro.srv.foocreating /Users/asim/checkouts/src/github.com/micro/foocreating /Users/asim/checkouts/src/github.com/micro/foo/main.gocreating /Users/asim/checkouts/src/github.com/micro/foo/handlercreating /Users/asim/checkouts/src/github.com/micro/foo/handler/example.gocreating /Users/asim/checkouts/src/github.com/micro/foo/subscribercreating /Users/asim/checkouts/src/github.com/micro/foo/subscriber/example.gocreating /Users/asim/checkouts/src/github.com/micro/foo/proto/examplecreating /Users/asim/checkouts/src/github.com/micro/foo/proto/example/example.protocreating /Users/asim/checkouts/src/github.com/micro/foo/Dockerfilecreating /Users/asim/checkouts/src/github.com/micro/foo/README.mddownload protobuf for micro:go get github.com/micro/protobuf/&#123;proto,protoc-gen-go&#125;compile the proto file example.proto:protoc -I/Users/asim/checkouts/src \\ --go_out=plugins=micro:/Users/asim/checkouts/src \\ /Users/asim/checkouts/src/github.com/micro/foo/proto/example/example.proto 选项指定更多的选项，如名称空间、类型、fqdn和别名 1micro new --fqdn com.example.srv.foo github.com/micro/foo 帮助1234567891011NAME: micro new - Create a new micro serviceUSAGE: micro new [command options] [arguments...]OPTIONS: --namespace \"go.micro\" Namespace for the service e.g com.example --type \"srv\" Type of service e.g api, srv, web --fqdn FQDN of service e.g com.example.srv.service (defaults to namespace.type.alias) --alias Alias is the short name used as part of combined name if specified","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"micro web","slug":"micro-web","date":"2018-03-21T23:09:09.000Z","updated":"2020-07-25T02:57:18.214Z","comments":true,"path":"2018/03/22/micro-web/","link":"","permalink":"https://jigangduan.github.io/2018/03/22/micro-web/","excerpt":"micro web提供了查看和查询服务的仪表板。","text":"micro web提供了查看和查询服务的仪表板。 入门指南安装1go get -u github.com/micro/micro 运行1micro web ACME默认使用ACME安全服务 1MICRO_ENABLE_ACME=true micro web 可以选择指定一个主机白名单 123MICRO_ENABLE_ACME=true \\MICRO_ACME_HOSTS=example.com,api.example.com \\micro web TLS证书API支持安全地使用TLS证书 1234MICRO_ENABLE_TLS=true \\MICRO_TLS_CERT_FILE=/path/to/cert \\MICRO_TLS_KEY_FILE=/path/to/key \\micro web 截图","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"micro api","slug":"micro-api","date":"2018-03-20T12:57:18.000Z","updated":"2020-07-25T02:57:18.212Z","comments":true,"path":"2018/03/20/micro-api/","link":"","permalink":"https://jigangduan.github.io/2018/03/20/micro-api/","excerpt":"micro api是微服务的api网关。使用API网关模式为您的服务提供一个单一入口点。micro api使用服务发现服务HTTP和动态路由到适当的后端。","text":"micro api是微服务的api网关。使用API网关模式为您的服务提供一个单一入口点。micro api使用服务发现服务HTTP和动态路由到适当的后端。 概述micro api是一个HTTP api。对API的请求通过HTTP提供，并通过RPC在内部路由。它建立在go-micro的基础上，利用它进行服务发现、负载平衡、编码和基于RPC的通信。 因为micro api在内部使用了micro，这也使得它成为可插拔的。参见go-plugins支持gRPC、kubernetes、etcd、nats、rabbitmq等。 入门指南安装1go get -u github.com/micro/micro 运行1micro api ACME默认使用ACME安全服务 1MICRO_ENABLE_ACME=true micro api 可以选择指定一个主机白名单 123MICRO_ENABLE_ACME=true \\MICRO_ACME_HOSTS=example.com,api.example.com \\micro api TLS证书API支持安全地使用TLS证书 1234MICRO_ENABLE_TLS=true \\MICRO_TLS_CERT_FILE=/path/to/cert \\MICRO_TLS_KEY_FILE=/path/to/key \\micro api 设置名称空间API利用名称空间来逻辑地分离后端和面向公众的服务。名称空间和http路径用于解析服务name/method。默认的名称空间是go.micro.api。 1MICRO_NAMESPACE=com.example.api micro api 例子这里我们有一个3层架构的例子 micro api: (localhost:8080) - 作为http入口点。 api服务:提供面向公众的api服务。 后端服务:(go.micro.srv.greeter) - 内部范围服务。 完整的例子是examples/greeter 运行示例 确保您正在运行服务发现 e.g consul agent -dev 得到例子 1git clone https://github.com/micro/examples 启动该服务 1go run examples/greeter/srv/main.go 启动API 1go run examples/greeter/api/api.go 启动 micro api 1micro api 查询通过micro api进行HTTP调用 1curl \"http://localhost:8080/greeter/say/hello?name=John\" HTTP路径/greeter/say/hello映射到服务go.micro.api.greeter Say.Hello方法 绕过api服务，直接通过/rpc调用后 1234curl -d 'service=go.micro.srv.greeter' \\ -d 'method=Say.Hello' \\ -d 'request=&#123;\"name\": \"John\"&#125;' \\ http://localhost:8080/rpc 完全相同地调用JSON 123curl -H 'Content-Type: application/json' \\ -d '&#123;\"service\": \"go.micro.srv.greeter\", \"method\": \"Say.Hello\", \"request\": &#123;\"name\": \"John\"&#125;&#125;' \\ http://localhost:8080/rpc APImicro api提供了以下HTTP api 12- /[service]/[method] # HTTP路径被动态映射到服务- /rpc # 通过名称和方法显式地调用后端服务 参见下面的例子 HandlersHandlers是管理请求路由的HTTP处理程序。 默认handler使用注册中心的端点元数据来确定服务路由。如果没有找到匹配的路由，它将返回到API handler。您可以使用go-api配置注册路由。 API具有以下可配置的请求handler api -处理任何HTTP请求。通过RPC完全控制http请求/响应。 event-处理任何HTTP请求并发布到消息总线。 http -处理任何http请求和转发作为反向代理。 rpc -处理json和protobuf POST请求。向前 RPC。 web -包含web套接字支持的HTTP handler。 可以选择使用/rpc端点绕过handlers API Handler Content-Type: Any Body: Any Forward Format: api.Request/api.Response 路径: /[service]/[method] 解析器:路径用于解析服务和方法。 Configure: Flag --handler=api或MICRO_API_HANDLER=api。 没有指定handler时的默认handler。 Event Handler事件handler服务于HTTP，并将请求转发给使用go-micro代理的消息总线上的消息。 Content-Type: Any Body: Any Forward Format:请求被格式化为go-api/proto.Event Path: /[topic]/[event] 解析器:路径用于解析主题和事件名称。 Configure: Flag --handler=event或 MICRO_API_HANDLER=event HTTP Handlerhttp handler是一个基于服务发现的http备用代理。 Content-Type: Any Body: Any Forward Format: HTTP反向代理 Path: /[service] 解析器:路径用于解析服务名称 配置:Flag —handler=http或MICRO_API_HANDLER=http REST可以作为微服务在API后面实现 RPC HandlerRPC handler以RPC请求的形式提供json或protobuf HTTP POST请求和转发。 Content-Type: application/json 或 application/protobuf Body: JSON 或 Protobuf 正向格式:基于内容的json-rpc或proto-rpc。 Path: / [service] / [method] 解析器:路径用于解析服务和方法。 配置:Flag —handler=rpc或MICRO_API_HANDLER=rpc Web Handlerweb handler是一个基于服务发现和web socket支持的http反向代理。 Content-Type: Any Body: Any 正向格式:HTTP反向代理，包括web sockets。 Path: /[service] 解析器:路径用于解析服务名称。 配置:Flag —handler=web 或 MICRO_API_HANDLER=web RPC端点/rpc端点让我们绕过主handler直接与任何服务对话 请求参数 service - 设置服务名称 method - 设置服务方法 request - 请求体 address - 可选地指定主机地址到目标 示例调用: 1234curl -d 'service=go.micro.srv.greeter' \\ -d 'method=Say.Hello' \\ -d 'request=&#123;\"name\": \"Bob\"&#125;' \\ http://localhost:8080/rpc 在github.com/micro/examples/api找到工作的例子 解析器使用名称空间值和HTTP路径到服务的Micro动态路由。 默认的名称空间是go.micro.api。通过--namespace或MICRO_NAMESPACE=设置名称空间 使用的解析器如下所示。 RPC解析器RPC服务有一个名称(go.micro.api.greeter)和一个方法(Greeter.Hello)。 URLs的解析如下: Path Service Method /foo/bar go.micro.api.foo Foo.Bar /foo/bar/baz go.micro.api.foo Bar.Baz /foo/bar/baz/cat go.micro.api.foo.bar Baz.Cat 可以很容易地将版本化的API URLs映射到服务名称: Path Service Method /foo/bar go.micro.api.foo Foo.Bar /v1/foo/bar go.micro.api.v1.foo Foo.Bar /v1/foo/bar/baz go.micro.api.v1.foo Bar.Baz /v2/foo/bar go.micro.api.v2.foo Foo.Bar /v2/foo/bar/baz go.micro.api.v2.foo Bar.Baz HTTP解析器对于http handler，我们只需要处理服务名称的解析。所以分辨率与RPC解析器略有不同。 URLs的解析如下: Path Service Service Path /foo go.micro.api.foo /foo /foo/bar go.micro.api.foo /foo/bar /greeter go.micro.api.greeter /greeter /greeter/:name go.micro.api.greeter /greeter/:name Go Restful API的例子这里是如何使用go-restful在API后面服务REST的一个示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"log\" \"github.com/emicklei/go-restful\" hello \"github.com/micro/examples/greeter/srv/proto/hello\" \"github.com/micro/go-micro/client\" \"github.com/micro/go-web\" \"context\")type Say struct&#123;&#125;var ( cl hello.SayClient)func (s *Say) Anything(req *restful.Request, rsp *restful.Response) &#123; log.Print(\"Received Say.Anything API request\") rsp.WriteEntity(map[string]string&#123; \"message\": \"Hi, this is the Greeter API\", &#125;)&#125;func (s *Say) Hello(req *restful.Request, rsp *restful.Response) &#123; log.Print(\"Received Say.Hello API request\") name := req.PathParameter(\"name\") response, err := cl.Hello(context.TODO(), &amp;hello.Request&#123; Name: name, &#125;) if err != nil &#123; rsp.WriteError(500, err) &#125; rsp.WriteEntity(response)&#125;func main() &#123; // Create service service := web.NewService( web.Name(\"go.micro.api.greeter\"), ) service.Init() // setup Greeter Server Client cl = hello.NewSayClient(\"go.micro.srv.greeter\", client.DefaultClient) // Create RESTful handler say := new(Say) ws := new(restful.WebService) wc := restful.NewContainer() ws.Consumes(restful.MIME_XML, restful.MIME_JSON) ws.Produces(restful.MIME_JSON, restful.MIME_XML) ws.Path(\"/greeter\") ws.Route(ws.GET(\"/\").To(say.Anything)) ws.Route(ws.GET(\"/&#123;name&#125;\").To(say.Hello)) wc.Add(ws) // Register Handler service.Handle(\"/\", wc) // Run server if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 运行 Micro API1$ micro api --handler=proxy 运行 Greeter Service1$ go run greeter/server/main.go 运行 Greeter API12$ go run go-restful.goListening on [::]:64738 Curl API测试index 1234curl http://localhost:8080/greeter&#123; \"message\": \"Hi, this is the Greeter API\"&#125; 测试资源 1234curl http://localhost:8080/greeter/asim&#123; \"msg\": \"Hello asim\"&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"用Micro构建有弹性和容错的应用程序","slug":"micro-resiliency","date":"2018-03-18T15:44:26.000Z","updated":"2020-07-25T02:57:18.214Z","comments":true,"path":"2018/03/18/micro-resiliency/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/micro-resiliency/","excerpt":"构建分布式系统是很有挑战性的，这已经不是什么秘密了。虽然我们已经解决了很多问题，作为一个行业，我们仍然经历了重建许多建筑街区的周期。是否因为迁移到下一个抽象级别，虚拟机到容器，采用新的语言，利用基于云的服务，甚至是这种向微服务的转变。总有一些东西似乎需要我们重新学习如何为下一波技术构建性能和容错系统。 这是一次迭代和创新之间的无休止的战斗，但是我们需要做一些事情来帮助减轻很多痛苦，因为向云、容器和微服务的转移仍在继续。","text":"构建分布式系统是很有挑战性的，这已经不是什么秘密了。虽然我们已经解决了很多问题，作为一个行业，我们仍然经历了重建许多建筑街区的周期。是否因为迁移到下一个抽象级别，虚拟机到容器，采用新的语言，利用基于云的服务，甚至是这种向微服务的转变。总有一些东西似乎需要我们重新学习如何为下一波技术构建性能和容错系统。 这是一次迭代和创新之间的无休止的战斗，但是我们需要做一些事情来帮助减轻很多痛苦，因为向云、容器和微服务的转移仍在继续。 动机我们为什么要这么做?为什么我们要不断地重建构建块，为什么还要继续尝试解决相同的规模、容错和分布式系统问题? “更大、更强、更快”，甚至可能是“速度、规模、敏捷”。你会从c级高管那里听到很多，但关键的结论是，我们总是需要建立更多的业绩和弹性系统。 在互联网的早期，只有成千上万的人上网。随着时间的推移，我们看到了加速，我们现在进入了数十亿的数量级。数十亿人，数十亿的设备。我们必须学习如何建立这样的系统。 对于老一代，你可能还记得C10K问题。我不确定我们现在在哪里，但我认为我们讨论的是解决数百万并发连接的问题，如果不是更多的话。世界上最大的科技公司在十年前就真正解决了这个问题，并且在规模上有了构建系统的模式，但是我们其余的人仍然在学习。 亚马逊(Amazon)、谷歌和微软(Microsoft)等公司现在为我们提供了大规模的云计算平台，但我们仍在努力研究如何编写能够有效利用它的应用程序。您现在听到的术语是容器编排、微服务和云本地。这项工作正在进行中，将会有一段时间，在我们作为一个行业真正敲定需要向前发展的模式和解决方案之前。 许多公司现在都在帮助解决“如何以可扩展和容错的方式运行我的应用程序”的问题。”,但仍然有很少的帮助更为重要的问题… 如何以可伸缩和容错的方式编写应用程序? 通过关注微服务的关键软件开发需求来解决这些问题。现在，我们将介绍一些可以帮助您构建弹性和容错应用程序的方法，从客户端开始。 Client客户端是在go-micro中提出请求的构建块。如果您之前已经构建了微服务或SOA架构，那么您就会知道，大部分时间和执行都花费在调用其他服务来获取相关信息上。 而在一个单一的应用程序中，主要关注的是服务内容，在一个微服务的世界中，它更多的是检索或发布内容。 这里有一个精简版的go-micro客户端接口，有三个最重要的方法; Call, Publish和Stream。 12345678910111213type Client interface &#123; Call(ctx context.Context, req Request, rsp interface&#123;&#125;, opts ...CallOption) error Publish(ctx context.Context, p Publication, opts ...PublishOption) error Stream(ctx context.Context, req Request, opts ...CallOption) (Streamer, error)&#125;type Request interface &#123; Service() string Method() string ContentType() string Request() interface&#123;&#125; Stream() bool&#125; Call和Stream用于同步请求。Call返回一个单独的结果，而Stream则是与另一个服务保持的双向流连接，可以来回发送消息。发布用于通过代理发布异步消息，但我们今天不打算讨论这个问题。 客户端是如何在幕后工作的，在前几篇博客文章中，你可以在这里和这里找到。如果你想了解细节，可以去看看。 我们将简要地介绍一些重要的内部细节。 客户端处理RPC层，同时利用代理、编解码器、注册表、选择器和传输包进行各种功能。分层架构很重要，因为我们分离了每个组件的关注点，降低了复杂性并提供了可插拔性。 为什么Client很重要?客户端本质上是抽象了提供服务之间的弹性和容错通信的细节。call给另一个服务似乎是相当直接的，但有可能会失败的各种方法。 让我们开始了解其中的一些功能以及它的帮助。 服务发现在分布式系统中，服务的实例可以根据各种原因来进行。网络分区，机器故障，重新调度等等，我们并不是真的想要关心它。 在对另一个服务进行调用时，我们按名称进行操作，并允许客户端使用服务发现来将名称解析为包含其地址和端口的实例列表。在关闭的启动和注销上有发现的服务注册。 正如我们所提到的，任何数量的问题都可能出现在分布式系统中，服务发现也不例外。因此，我们依靠作战测试分布式服务发现系统，如consul、etcd和zookeeper来存储有关服务的信息。 每一种方法都使用Paxos网络一致性算法，这使我们能够从CAP定理得到一致性和分区的容忍度。通过运行一个3或5个节点的集群，我们可以容忍大多数系统故障，并为客户机提供可靠的服务发现。 节点选择因此，现在我们可以可靠地将服务名称解析为地址列表。我们如何选择调用哪一个呢?这就是go-micro选择器发挥作用的地方。它构建在注册表上，并提供负载平衡策略，如轮询或随机散列，同时提供过滤、缓存和黑名单失败节点的方法。 这是一个裁剪的接口。 123456789type Selector interface &#123; Select(service string, opts ...SelectOption) (Next, error) Mark(service string, node *registry.Node, err error) Reset(service string)&#125;type Next func() (*registry.Node, error)type Filter func([]*registry.Service) []*registry.Servicetype Strategy func([]*registry.Service) Next 平衡策略目前的策略相当直截了当。当选择被调用时，选择器将从注册表中检索服务，并创建一个下一个函数，该函数使用默认策略封装节点池，或者在被重写时作为一个选项传入。 客户端将根据负载均衡策略调用下一个函数来检索列表中的下一个节点，并提出请求。如果请求失败并且重试设置在1之上，它将经历相同的过程，检索下一个要调用的节点。 在这里可以使用多种策略，例如轮询、随机散列、最小conn、加权等。负载均衡策略对于在服务中均匀分布请求至关重要。 选择缓存虽然有一个健壮的服务发现系统很好，但是对每个请求进行查找都是低效和昂贵的。如果您想象一个大型的系统，每个服务都在这样做，那么就很容易使发现系统过载。可能会出现完全不可用的情况。 为了避免这种情况，我们可以使用缓存。大多数发现系统提供了一种监听更新的方法，通常被称为观察者。而不是轮询发现，我们等待事件被发送给我们。go-micro注册表为这个提供了一个表抽象。 我们编写了一个缓存选择器，它在服务的内存缓存中维护一个。在缓存缺失时，它会查找信息的发现，缓存它，然后在随后的请求中使用它。如果接收到我们所知道的服务的监视事件，那么缓存将相应地更新。 首先，通过删除服务查找，极大地提高了性能。它还提供了在服务发现失败的情况下的一些容错。虽然我们有点偏执，但由于一些失败的场景，缓存可能会变得陈旧，因此节点会被适当地处理。 黑名单的节点接下来是黑名单。注意选择器接口有标记和复位方法。我们永远不能真正保证健康的节点是通过发现注册的，所以我们需要做些什么。 无论何时提出请求，我们都会跟踪结果。如果一个服务实例多次失败，我们基本上可以将该节点列入黑名单，并在下一次选择请求时将其过滤掉。 在将节点放到池中之前，该节点将被列入一段时间的黑名单。如果服务的某个节点失败了，我们将它从列表中删除，这样我们就可以继续为成功的请求提供服务，这一点非常重要。 超时和重试Adrian Cockroft最近开始讨论微服务架构中缺少的组件。其中一个非常有趣的事情是经典的超时和重试策略导致级联失败。我恳求你去看看他的幻灯片。我直接链接到它开始覆盖超时和重试的地方。感谢艾德里安让我用幻灯片。 这张幻灯片确实很好地概括了这个问题。 Adrian所描述的是一种常见的情况，在这种情况下，缓慢的响应会导致超时，然后导致客户机重试。由于请求实际上是下游的请求链，因此通过系统创建了一整套新的请求，而旧的工作可能仍在进行。错误配置可能导致在调用链中超载服务，并导致难以恢复的失败场景。 在微服务领域，我们需要重新考虑处理超时和重试的策略。Adrian接着讨论了这个问题的潜在解决方案。其中一个是超时预算和对新节点的重试。 在重试方面，我们已经在Micro上做了一段时间了。可以将重试的数量配置为客户机的选项。如果调用失败，客户端将检索一个新节点并尝试再次发出请求。 超时是一些经过深思熟虑的事情，但实际上是从经典的静态超时设置开始的。直到艾德里安提出他的想法后，才明白该策略应该是什么。 预算的暂停现在被建立在Micro上。让我们来看看它是如何工作的。 第一个调用者设置超时，这通常发生在边缘。在链上的每个请求中，超时都被减少，以解释已经通过的时间量。当零时间结束时，我们停止处理任何进一步的请求或重试并返回调用堆栈。 正如Adrian所提到的，这是一种提供动态超时预算并删除在下游发生的不必要工作的好方法。 进一步来说，下一步应该是删除任何类型的静态超时。服务响应的方式会因环境、请求负载等而有所不同。这应该是一个动态的SLA，它会根据当前的状态而变化，但又会有一些东西需要保留一天。 连接池呢?连接池是构建可伸缩系统的重要组成部分。我们很快就看到了没有它的局限性。通常会导致文件描述符限制和端口耗尽。 目前正在进行的一项工作是将连接池添加到go-micro。考虑到微的可插拔性，在传输层上处理这一层非常重要，因此任何实现(无论是HTTP、NATS、RabbitMQ等)都将受益。 你可能会想，这是具体的实现，有些传输可能已经支持了。虽然这是事实，但并不总是保证在每个传输过程中都使用相同的方法。通过解决这个特定的问题，我们降低了传输本身的复杂性和需求。 还有什么?这些都是一些非常有用的东西，可以用来做go-micro，但还有什么呢? 我很高兴你问我…或者,假设你问…。 服务版本Canarying我们有它!它实际上是在之前的一篇关于微服务的架构和设计模式的博客文章中讨论过的，您可以在这里查看。 服务包含名称和版本作为服务发现中的一对。当从注册中心检索服务时，它的节点按版本分组。然后，可以利用各种负载均衡策略，利用选择器来在每个版本的节点之间分配流量。 Canarying为什么重要?在发布新版本的服务并确保所有的功能都能正常运行之前，这是非常有用的。新版本可以部署到一个小的节点池中，客户端会自动分配一定比例的流量给新服务。结合像Kubernetes这样的业务流程系统，如果有任何问题，您可以使用信任和回滚来增强部署。 过滤呢?我们有它!选择器非常强大，它包括在选择时通过过滤器来过滤节点的能力。在发出请求时，这些可以作为调用选项传递给客户端。一些现有的过滤器可以在这里找到元数据、端点或版本过滤。 过滤为什么重要?您可能有一些仅在服务版本中存在的功能。将请求流固定到这些特定的版本之间，确保您总是能够找到正确的服务。在系统中同时运行多个版本的情况非常好。 另一个有用的用例是您希望基于位置的服务路由。通过在每个服务上设置一个数据中心标签，您可以应用一个只返回本地节点的过滤器。基于元数据的过滤功能非常强大，并且有更广泛的应用程序，我们希望能在野外听到更多的应用。 可插拔的体系结构你会不断听到的一件事是Micro的可插拔性。这是从第一天开始设计的。与一个完整的系统相比，Micro提供构建块非常重要。可以在盒子里工作但可以增强的东西。 为什么是可插入的问题?每个人对于构建分布式系统都有不同的想法，我们真的想提供一种方式让人们设计他们想要使用的解决方案。不仅如此，还有强大的战斗测试工具，我们可以利用这些工具，而不是从头开始编写任何东西。 技术总是在进化，新的和更好的工具每天都在出现。如何避免锁定?一个可插拔的架构意味着我们可以在今天使用组件，并在明天用最少的努力将它们转换出来。 插件Go -micro的每个特性都被创建为Go接口。通过这样做并且只引用接口，我们实际上可以将底层实现用最少的代码替换为零。在大多数情况下，在命令行上指定一个简单的import语句和标志。 在GitHub上的go-plugin repo中有许多插件。 虽然go-micro提供了一些默认值，比如发现和http的传输，但是您可能希望在您的体系结构中使用一些不同的东西，甚至可以实现自己的插件。我们现在已经在公共关系模式中使用了Kubernetes注册插件和Zookeeper注册表。 如何使用插件?大多数时候都是这么简单。 12# Import the pluginimport _ \"github.com/micro/go-plugins/registry/etcd\" 1go run main.go --registry=etcd --registry_address=10.0.0.1:2379 包装器更重要的是，客户端和服务器支持中间件的概念，即所谓的包装器。通过支持中间件，我们可以在请求-响应处理周围添加附加功能的pre和post挂钩。 中间件是一个很好理解的概念，并且在数千个库中使用。您可以立即看到在用例中所带来的好处，如电路中断、速率限制、身份验证、日志记录、跟踪等。 12345678# Client Wrapperstype Wrapper func(Client) Clienttype StreamWrapper func(Streamer) Streamer# Server Wrapperstype HandlerWrapper func(HandlerFunc) HandlerFunctype SubscriberWrapper func(SubscriberFunc) SubscriberFunctype StreamerWrapper func(Streamer) Streamer 我如何使用包装器?这和插件一样直接。 1234567891011import ( \"github.com/micro/go-micro\" \"github.com/micro/go-plugins/wrapper/breaker/hystrix\")func main() &#123; service := micro.NewService( micro.Name(\"myservice\"), micro.WrapClient(hystrix.NewClientWrapper()), )&#125; 简单的对吧?我们发现，许多公司在微观上创建自己的层，以初始化他们正在寻找的大多数默认包装器，因此，如果需要添加新的包装器，那么它们都可以在一个地方完成。 现在让我们来看看一些弹性和容错的包装器。 断路器在SOA或微服务世界中，单个请求实际上可以导致对多个服务的调用，在许多情况下，可能会导致数十个或更多的请求收集必要的信息，以返回给调用者。在成功的情况下，这很好，但是如果出现问题，它会很快下降到级联故障，这很难在不重置整个系统的情况下恢复。 我们在客户端部分解决了这些问题，请求重试，并将多次失败的黑名单节点解决，但在某个时刻，可能需要阻止客户端尝试发出请求。 这就是断路器发挥作用的地方。 断路器的概念是直接的。函数的执行被包装或与跟踪故障的某种监视器关联。当故障数量超过某个阈值时，断路器就会被绊倒，任何进一步的调用尝试都会返回一个错误，而不执行包装的函数。在超时时间后，电路被放入半开放状态。如果在这个状态下一个调用失败，那么这个断路器就会再次被绊倒，但是如果它成功了，我们就会恢复到一个闭合电路的正常状态。 虽然Micro客户机的内部结构具有一些内置的容错功能，但我们不应该期望能够解决所有问题。在现有的断路器实现中使用包装器可以大大受益。 速度限制如果我们能毫不费力地满足世界上所有的要求，那不是很好吗?啊梦。现实世界并不是这样的。处理一个查询需要一定的时间，并且由于资源的限制，我们实际上可以提供很多请求。 在某种程度上，我们需要考虑限制我们可以并行地创建或服务的请求的数量。这就是速率限制发挥作用的地方。如果没有速率限制，就很容易导致资源耗尽或完全瘫痪系统，并阻止它继续提供任何进一步的请求。这通常是DDOS攻击的基础。 每个人都听说过，使用过或者甚至可能实施过某种形式的限速。有很多不同的速率限制算法，其中之一是漏桶算法。我们不打算讨论算法的细节，但值得一读。 再一次，我们可以利用微包装器和现有的库来执行这个功能。在这里可以找到一个现有的实现。 我们真正感兴趣的一个系统是YouTube的门卫，一个全球分布式客户端速率限制器。我们正在寻找一个社区的贡献，所以请联系! 服务器端所有这些都涉及到很多客户端特性或用例。服务器端呢?首先要注意的是，Micro杠杆利用了API、CLI、Sidecar等的go-micro客户端。这些好处将整个体系结构从边缘转化为最后的后端服务。不过，我们仍然需要为服务器解决一些基本问题。 在客户端，注册中心用于查找服务，而服务器端则是注册实际发生的地方。当一个服务的一个实例出现时，当它优雅地退出时，它会使用服务发现机制和注销器注册自己。关键词是优雅地。 处理失败在分布式系统中，我们必须处理故障，我们需要容错。注册表支持TTLs过期或标记节点为不健康的，基于任何基础的服务发现机制是e.g consul,etcd。而服务本身也支持重新注册。这两种方法的组合意味着服务节点将在一个集合间隔上重新注册，而它是健康的，并且注册中心将在没有刷新的情况下终止该节点。如果节点因任何原因失败，且不重新注册，则将从注册表中删除该节点。 这种容错行为最初并不是作为go-micro的一部分，但是我们很快从现实世界中看到，由于恐慌和其他导致服务不优雅地退出的故障，很容易在注册表中填充陈旧的节点。 这样做的效果是，如果没有几百个不新鲜的条目，客户就会被留下来处理几十个。虽然客户端也需要容错，但我们认为这种功能可以避免很多问题。 添加更多的功能另外要注意的一点是，正如上面提到的，服务器还提供了使用包装器或中间件的能力，因为它更广为人知。这意味着我们可以在这一层使用电路中断、速率限制和其他特性来控制请求流、并发性等。 服务器的功能是故意保持简单但可插入的，这样功能就可以按要求分层排列。 Clients vs Sidecars这里讨论的大部分内容都存在于核心的go-micro库中。虽然这对所有的程序员来说都很好，但其他人可能会想，我该如何获得这些好处呢? 从一开始，Micro就包含了Sidecar的概念，它是一个HTTP代理，它包含了go-micro内置的所有功能。因此，无论您使用哪种语言构建应用程序，您都可以通过使用Micro Sidecar从以上讨论中获益。 sidecar模式并不是什么新鲜事。NetflixOSS有一个名为Prana的系统，它利用基于JVM的NetflixOSS栈。最近，有一个叫Linkerd的功能丰富的系统，它是一个在Twitter的Finagle库之上的RPC代理。 Micro Sidecar使用默认的go-micro客户端。所以如果你想添加其他功能，你可以很容易地增加它和重建。我们将在将来进一步简化这个过程，并提供一个具有所有漂亮容错功能的版本。 等等,还有更多这篇博客文章涵盖了许多核心的go-micro库和周围的工具包。这些工具是一个很好的开始，但它们还不够。当你想要大规模运行时，当你想要数百个服务数以百万计的微服务时，还有很多需要解决的问题。 Platform这就是go-platform和platform发挥作用的地方。在micro基础构建块的地方，platform更进一步地解决了在规模上运行的需求。认证、分布式跟踪、同步、健康检查监控等。 分布式系统需要一套不同的工具来观察、协商一致和协调容错，微平台可以帮助满足这些需求。通过提供分层架构，我们可以在核心工具定义的原语基础上构建，并在需要时增强其功能。 现在还为时尚早，但人们希望micro platform能解决许多组织在构建分布式系统平台时遇到的问题。 我如何使用所有这些工具?正如您可以从博客文章中收集到的，这些特性中的大部分都是内置在Micro工具包中。您可以在GitHub上查看项目，并且几乎可以立即开始编写容错Micro服务。 如果你需要帮助或有问题，请加入我们的社区。它非常活跃，而且发展迅速，用户广泛，从黑客的侧面项目到现在已经在使用Micro生产的公司。 总结技术正在迅速发展，云计算现在给我们提供了几乎无限的规模。试图跟上变革的步伐是困难的，构建可伸缩的新世界的容错系统仍然具有挑战性。 但不一定非要这样。作为一个社区，我们可以互相帮助，以适应新的环境，并建立符合我们日益增长的需求的产品。 通过提供简化构建和管理分布式系统的工具，Micro可以帮助您实现这一过程。希望这篇博客能帮助我们展示一些我们正在寻找的方法。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Micro Bot - 微服务聊天工具","slug":"the-micro-bot","date":"2018-03-18T15:27:02.000Z","updated":"2020-07-25T02:57:18.229Z","comments":true,"path":"2018/03/18/the-micro-bot/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/the-micro-bot/","excerpt":"今天我想和你们谈谈机器人。","text":"今天我想和你们谈谈机器人。 机器人吗?真的…现在我知道你在想什么了。现在有很多关于机器人的炒作。如果你对聊天机器人很熟悉，你就会知道这不是一个新的概念，事实上，它可以追溯到伊丽莎时代。对机器人的重新迷恋真的出现了，因为我们发现了更多有用的功能，而不仅仅是娱乐。他们还对可能成为下一个超越应用的交互界面，即会话用户界面进行了研究。 在工程领域，机器人不仅是用于会话目的，它们对于操作任务来说也非常有用。所以，我们大多数的技术人员都已经熟悉了“ChatOps”这个词。GitHub从这个词的起源开始就被认为是这个术语的起源，因为它是一个用于管理技术和业务操作任务的聊天机器人Hubot的创建和使用。 请看看杰西·纽兰在GitHub上对ChatOpts的演讲，以了解更多。 像它一样的Hubot和机器人已经被证明在技术组织中非常有用，并且成为ops和自动化领域的主要工具。通过HipChat或Slack来指导机器人执行任务的能力是相当强大的。它对整个团队的可见性有直接的价值。每个人都能看到你在做什么，影响是什么。 这与micro服务有什么关系?Micro ,microservice toolkit包括许多提供进入运行系统的入口点的服务。API、Web仪表板、CLI等都是用于交互和观察您的微服务环境的所有固定的入口点。在过去的几个月里，很明显，Bot是另一种形式的入口点，以互动和观察，并且它应该是在Micro观世界的一等公民。 所以,… 让我先说一下，Micro Bot是一个非常早期的原型，目前专注于提供与CLI相同的特性。我们不是拥有人工智能基于ChatOps…但也许有一天… Micro Bot包括hubot类似于脚本的语义，以及一种实现新输入的方式，如Slack和Hipchat。这是一个粗略的版本1，但我相信，只要有什么东西能起作用，我就会相信，通过这样做，我们就能更快地提高机器人的速度。希望与社区的贡献! 该Bot包括所有的CLI命令和对Slack和HipChat的输入。我们的社区机器人目前在演示环境中运行，现在处于微松弛状态!如果你想看的话，请加入我们。 在短期内，我们将考虑添加更多的输入插件，如IRC、XMPP和命令，这些插件可以简化管理运行环境中的微服务。如果你对其他的输入或命令有想法，或者想要提交一份关于某件事的公关，那么你的贡献就不受欢迎了。更多的插件可以在github.com/micro/go-plugins/bot中找到。 这是Micro生态系统可编程机器人的基本框架。考虑到整个工具包的可插入性，在bot形式中提供类似的东西是很有意义的。 让我们继续讨论输入和命令是如何工作的。 InputsInputs是micro bot如何连接到hipchat, slack, irc, xmpp等等。我们现在已经有了hipchat和slack的实现，这似乎涵盖了大量的用户。 这是Input接口。 1234567891011121314type Input interface &#123; // Provide cli flags Flags() []cli.Flag // Initialise input using cli context Init(*cli.Context) error // Stream events from the input Stream() (Conn, error) // Start the input Start() error // Stop the input Stop() error // name of the input String() string&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Micro架构和微服务的设计模式","slug":"micro-architecture","date":"2018-03-18T13:58:35.000Z","updated":"2020-07-25T02:57:18.213Z","comments":true,"path":"2018/03/18/micro-architecture/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/micro-architecture/","excerpt":"在过去的几个月里，我们对微服务的micro架构和设计模式有很多疑问。所以今天我们将尝试把两者都包括进去。","text":"在过去的几个月里，我们对微服务的micro架构和设计模式有很多疑问。所以今天我们将尝试把两者都包括进去。 关于MicroMicro是一个微型服务工具包。它被构建为在它的特性和接口上的观点，同时提供一个强大的可插入架构，允许将底层的依赖项交换出去。 Micro专注于满足构建微服务的基本需求，并通过采用深思熟虑和慎重的方法来实现它的设计。 如果你想在microtoolkit上阅读，看看之前的博客文章，或者你想了解更多关于微服务的概念。 在深入讨论进一步的架构讨论之前，我们将快速回顾一下Micro的特性。 ToolkitGo Micro是一种可插入的RPC框架，用于在Go中编写微服务。它为服务发现、客户端负载平衡、编码、同步和异步通信提供了库。 Micro API是一个API网关，它服务于HTTP，并将请求路由到适当的微服务。它作为一个入口点，可以作为反向代理，也可以将HTTP请求转换为RPC。 Micro Web是一个Web仪表盘，是Micro Web应用程序的反向代理。我们认为，网络应用应该作为微服务构建，因此在微服务领域被视为一等公民。它的行为类似于API反向代理，但也包括对web sockets的支持。 Micro Sidecar提供了go-micro作为HTTP服务的所有功能。虽然我们热爱Go，相信它是构建微服务的伟大语言，但您可能也想使用其他语言，因此Sidecar提供了一种将其他应用集成到Micro世界的方法。 Micro CLI是一个直接与您的微服务交互的命令行界面。它还允许您利用Sidecar作为代理，您可能不希望直接连接到服务注册中心。 这是快速的回顾。现在让我们更深。 RPC, REST, Proto…首先你可能会想到为什么RPC，为什么不休息?我们的信念是，RPC是跨服务通信的一个更合适的选择。或者使用protobuf IDL定义的protobuf编码和api更具体地说RPC。这种组合允许创建强定义的API接口和有效的消息编码格式。RPC是一种直接的、无附加的、用于通信的协议。 我们并不孤单。 谷歌是创建protobuf，在内部使用RPC，以及最近开源的gRPC，一个RPC框架。Hailo同时也是RPC/Protobuf的有力倡导者，并且在跨团队开发中比系统性能更有优势。优步选择了自己的路径，开发了一个名为TChannel的RPC框架协议。 就个人而言，我们认为未来的api将会使用RPC来构建，因为它们的结构格式很好，使用高效的编码协议(如protobuf)，并提供了强定义的api和性能通信。 HTTP 到 RPC, API…但实际上，我们在网络上的RPC还有很长的路要走。虽然它在数据中心内是完美的，但却为公众服务如网站和移动api，是另一个交互。让我们面对它，在我们离开HTTP之前会有一段时间。这是micro包含API网关、服务和传输 HTTP请求的原因之一。 API网关是用于微服务体系结构的模式。它充当外部世界的单一入口点，并根据请求提供适当的服务。这使得HTTP API本身可以由不同的微服务组成。 这是一个强大的架构模式。在过去的日子里，你的API的某个部分可能会毁掉整个整体。 micro API使用路径到服务的解析，这样每个独特的请求路径都可以由不同的API微服务来服务，例如:/user =&gt; user api, /order =&gt; order api。 这是一个例子。对/customer/orders的请求将通过Customer.Orders方法发送到API服务go.micro.api.customer。 您可能想知道什么是API服务。现在是讨论不同类型服务的合适时机。 服务类型微服务的概念是关于关注点分离的，并且从unix的哲学中借鉴了很多，并且做得很好。部分出于这个原因，我们认为需要在不同职责的服务之间进行逻辑和架构的分离。 我现在要承认，这些概念并不是什么新鲜事物，但它们是令人信服的，因为它们已经在非常成功的科技公司中得到证明。我们的目标是通过工具传播这些开发理念和指导设计决策。 这是我们目前定义的服务类型。 API - 由micro api服务，API服务位于您的基础设施的边缘，最有可能服务于公共交通和您的移动或web应用程序。您可以使用HTTP处理程序构建它，并以反向代理模式运行micro api，或者默认地处理在这里可以找到的特定RPC api请求响应格式。 Web - 由**micro web服务，Web服务侧重于服务html内容和指示板。micro web反向代理HTTP和WebSockets。这是目前支持的唯一协议，但将来可能会扩展。如前所述，我们认为web应用程序是微服务。 SRV - 这些是基于后端RPC的服务。他们主要集中于为您的系统提供核心功能，而且很可能不是面向公众的。如果您愿意，您仍然可以通过micro api或web使用/rpc端点访问它们，但更有可能的是，api、web和其他SRV服务使用go-micro客户机直接调用它们。 根据以往的经验，我们发现这种类型的体系结构模式非常强大，它可以扩展到数百种服务。通过将其构建到微架构中，我们觉得它为微服务开发提供了一个良好的基础。 命名空间因此，你可能会想，是什么阻止了micro api与web服务或micro web对话的api服务。我们使用逻辑命名空间来分隔这些。通过将名称空间预先设置为服务名称，我们清楚地确定了它在系统中的用途和位置。这是一种简单而有效的模式，对我们有好处。 micro api和web将为请求路径的命名空间和第一个路径组成一个服务名称，例如请求api /customer成为go.micro.api.customer。 默认名称空间: API - go.micro.api Web - go.micro.web SRV - go.micro.srv 你应该把这些设置成你的域名，比如com.example.{api, web, srv}。micro api和micro web可以在运行时配置，以路由到您的名称空间。 同步/异步你会经常听到与响应模式相同的微服务。对于许多人来说，微服务是关于创建事件驱动的架构和设计服务，这些服务主要通过异步通信进行交互。 Micro将异步通信作为一个一流的公民，是微服务的基本构建块。通过异步消息传递传递事件允许任何人消费并对其进行操作。可以构建新的独立服务，而不需要对系统的其他方面进行任何修改。这是一个强大的设计模式，因此我们已经将Broker接口包含在了go-micro中。 同步和异步通信是在Micro中作为单独的需求处理的。传输接口用于创建服务之间的点连接。go-micro客户机和服务器构建在传输上，以执行请求-响应RPC，并提供双向流的功能。 在构建系统时，应该使用这两种通信模式，但关键是要了解何时何地都合适。在很多情况下，没有对错之分，而是会做出某些权衡。 在跟踪客户事件历史的审计跟踪系统中，可能会使用代理和异步通信的示例。 在这个示例中，每个API或服务都发布一个事件，当某些操作发生时，比如客户登录、更新他们的配置文件或下订单。审计服务将订阅这些事件并将它们存储在某个时间序列数据库中。管理员或其他人可以查看系统中为任何用户所发生的事件的历史。 如果这是一个同步调用，那么当出现高流量或定制服务的数量增加时，我们可以很容易地淹没审计服务。如果由于某些原因而关闭了审计服务，或者调用失败，我们将失去这段历史。通过将这些事件发布给代理，我们可以异步地持久化它们。这是事件驱动架构和微服务的常见模式。 好的，稍等一下，但什么定义了微服务呢?我们涵盖了许多微型工具提供的微服务，我们已经定义了服务的类型(API, WEB, SRV)，但实际上并没有什么真正的微服务。 它与其他类型的应用有何不同?是什么赋予了它一个“微服务”的特殊名称。 这里有不同的定义和解释，但这里有一对在微观世界中最适合的说明。 松散耦合的面向服务的体系结构，具有有界的上下文。Adrian Cockcroft 将单个应用程序开发为一套小型服务的方法，每个应用程序都在自己的进程中运行，并与轻量级机制进行通信。马丁 因为我们热爱unix哲学，并且觉得它与微服务理念完美契合。 做一件事，做得好吗?Doug McIlroy 我们的信念和我们构建的理念是，一个微服务是一个应用程序，专注于单一类型的实体或领域，它通过一个强大的定义的API提供访问。 让我们使用一个真实的例子，比如社交网络。 随着Ruby on Rails的兴起，一个定义良好的软件架构模式是MVC -模型-视图-控制器。 在MVC世界中，每个实体或域将被表示为一个模型，该模型依次抽象出数据库。该模型可能与其他模型有关系，例如对许多或多个模型。控制器处理即将到来的请求，从模型中检索数据并将其传递给用户。 现在，以一个微型服务架构为例。每一个模型都是一个服务，通过一个API来传递数据。用户请求、数据收集和呈现由许多不同的web服务处理。 每个服务都有一个焦点。当我们想要添加新的特性或实体时，我们可以简单地改变一个与该特性相关的服务或编写一个新服务。这种关注点分离为可伸缩的软件开发提供了一种模式。 现在回到我们的定期计划。 版本控制 版本控制是开发现实世界软件的一个重要部分。在微服务领域，考虑到API和业务逻辑在许多不同的服务中被分割，这是至关重要的。出于这个原因，服务版本控制是核心工具的一部分，允许对更新和流量形成进行更细粒度的控制。 在go-micro服务中，定义了一个名称和版本。注册表将服务作为列表返回，将节点按其注册的版本进行拆分。 这是基于版本的路由的构建块。 1234567type Service struct &#123; Name string Version string Metadata map[string]string Endpoints []*Endpoint Nodes []*Node&#125; 这与选择器(客户端负载均衡器)相结合，在go-micro中确保请求在不同版本之间分布。 选择器是一个功能强大的接口，我们正在构建它来提供不同类型的路由算法;随机(默认)、轮询、基于标签、延迟等。 通过使用默认的随机散列负载平衡算法，并逐步添加新服务版本的实例，您可以执行蓝绿色部署和做canary测试。 在将来，我们将考虑实现一个全局服务负载均衡器，它连接到选择器，允许基于运行系统中的历史趋势进行路由决策。它还能够在运行时调整发送到服务的每个版本的流量的百分比，并动态地将元数据或标签添加到服务中，基于标签的路由决策可以在此基础上进行。 扩展以上对版本控制的评论开始暗示了扩展服务的基本模式。虽然注册表用作存储有关服务的信息的机制，但我们使用选择器来分离路由和负载平衡的关注。 把关注点分离和做好一件事的概念。扩展基础结构和代码非常简单，定义了api和分层架构。通过创建这些构建块，我们允许自己构建更可伸缩的软件，并解决其他地方更高层次的关注。 这是Micro写作的基础，也是我们希望在微服务领域指导软件开发的方式。 我们在之前的文章中简要讨论了云架构模式，并将在这里重新讨论一些想法。 当在生产环境中部署服务时，您将考虑构建可伸缩、容错和性能的东西。云计算现在让我们获得了几乎无限的规模，但没有什么是不受失败影响的。事实上，在构建分布式系统时，我们希望解决的关键问题之一是失败，在构建基础设施时应该考虑到这一点。 在云的世界中，我们希望能够容忍可用性区域(datacenter)故障，甚至是整个区域(多DC)宕机。在过去的日子里，我们常常谈论温暖和冷备用系统或灾难恢复计划。如今，最先进的技术公司以一种全球化的方式运作，每个应用程序的多个副本都在世界各地的数字数据中心运行。 我们需要向谷歌、Facebook、Netflix和Twitter等公司学习。我们必须构建能够容忍AZ失败的系统，而不影响用户，并且在大多数情况下，在几分钟或更短时间内处理区域故障。 Micro使您能够构建这种架构。通过提供可插入的接口，我们可以利用最合适的分布式系统来满足微型工具包的每个需求。 服务发现和注册表是Micro的构建块。它可以用于分离和发现在AZ或区域内的一组服务或您所选择的任何配置。然后，Micro API可以用于路由和平衡多个服务及其在该拓扑中的实例。 总结希望这篇博文能够清晰地描述微处理器的架构，以及它如何为微服务提供可伸缩的设计模式。 微服务首先是关于软件设计模式的。我们可以通过工具启用某些基本模式，同时为其他模式的出现或使用提供灵活性。 因为Micro是可插拔的架构，它是多种设计模式的强大推动者，可以在许多场景中得到适当的应用。例如，如果您正在构建视频流基础设施，您可以选择HTTP传输以点到点通信。如果您没有延迟敏感，那么您可以选择一个传输插件，比如NATS或RabbitMQ。 未来的软件开发工具如Micro，是非常令人兴奋的。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Micro在NATS - 微服务与消息","slug":"micro-on-nats","date":"2018-03-18T12:41:09.000Z","updated":"2020-07-25T02:57:18.214Z","comments":true,"path":"2018/03/18/micro-on-nats/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/micro-on-nats/","excerpt":"在这篇文章中，我们将讨论在NATS上使用Micro。它包括关于服务发现的讨论、对微服务的同步和异步通信。 让我们开始谈正事吧。","text":"在这篇文章中，我们将讨论在NATS上使用Micro。它包括关于服务发现的讨论、对微服务的同步和异步通信。 让我们开始谈正事吧。 NATS是什么?NATS是一个开源的云本地消息传递系统或更简单的消息总线。NATS是由Apcera的创始人Derek Collison创立的。它起源于VMWare，并开始以ruby为基础的系统。它早就被重写了，并且在那些寻找高度可伸缩和高性能的消息传递系统的用户中稳步获得采用。 如果你想更多地了解NATS本身，请访问nats.io或加入这里的社区。 为什么NATS ?为什么不NATS呢?在过去处理过许多消息总线后，很明显，NATS是分开的。多年来，信息传递被认为是企业的救星，导致系统试图成为所有人的一切。它导致了很多错误的承诺，显著的特征膨胀和高成本技术，造成了比他们解决的更多的问题。 相比之下，NATS则采取了非常专注的方式，解决了性能和可用性方面的问题，同时保持了不可思议的精益。它说的是“随时待命”，并使用“fire and forget”消息模式。它的简单性、焦点和轻量级特性使它成为微服务生态系统的主要候选对象。我们相信，它将很快成为主要的候选服务，作为消息传递的服务之间的通信传输。 NATS提供: 较高的性能和可伸缩性 高可用性 非常轻量级的 最多一次交付 NATS所不提供的: 持久性 传输 增强的交付模式 企业排队 简单介绍一下什么是NATS，为什么是NATS。那么它是如何与Micro相适应的呢?让我们讨论一下。 Micro在NATSMicro是一个使用可插入架构构建的微服务工具箱，它允许将底层的依赖项以最小的变化交换出来。Go-Micro框架的每个接口都为微服务提供了一个构建块;用于服务发现的注册、同步通信的传输、异步消息传递代理等。 为每个组件创建一个插件就像实现接口一样简单。我们将花更多的时间详细介绍如何在以后的博客文章中编写插件。如果您想要查看NATS或其他系统(如etcd发现、kafka broker、rabbitmq传输)的插件，您可以在这里找到github.com/micro/go-plugins。 Micro on NATS本质上是一组可用于与NATS消息系统集成的微型插件。通过为go-micro的各种接口提供插件，我们创建了许多集成点，允许选择架构模式。 在我们的经验中，一种尺寸并不适合所有的，而微操作系统的灵活性允许您定义为您和您的团队工作的模型。 下面我们将讨论用于传输、代理和注册的NATS插件的实现。 传输 传输是同步通信的微型接口。它使用相当通用的Socket语义，类似于其他的Go代码，使用Listen、Dial和Accept。这些概念和模式对于使用tcp、http等的同步通信非常了解，但是适应消息总线可能会有些困难。与消息总线建立连接，而不是使用服务本身。为了解决这个问题，我们使用了与主题和通道有关的伪连接的概念。 这是它是如何工作的。 服务使用transport.Listen侦听消息。这将创建与NATS的连接。当transport.Accept被调用时，一个独特的主题被创建并订阅。这个独特的主题将被用作go-micro注册表中的服务地址。每个接收到的消息将被用作pseudo套接字/连接的基础。如果现有的连接存在相同的应答地址，我们将简单地将该消息放入到该连接的backlog中。 希望与此服务通信的客户端将使用transport.Dial来创建与服务的连接。这将连接到NATS，创建它自己独特的主题并订阅它。主题用于服务的响应。当客户端向服务发送消息时，它将为这个主题设置应答地址。 当任何一方想要关闭连接时，他们简单地调用transport.Close来终止与NATS的连接。 使用传输插件导入传输插件 1import _ \"github.com/micro/go-plugins/transport/nats\" 从transport标志开始 1go run main.go --transport=nats --transport_address=127.0.0.1:4222 或者直接使用transport 1transport := nats.NewTransport() go-micro传输接口: 12345type Transport interface &#123; Dial(addr string, opts ...DialOption) (Client, error) Listen(addr string, opts ...ListenOption) (Listener, error) String() string&#125; 代理 代理是异步消息传递的go-micro接口。它提供了适用于大多数消息代理的高级通用实现。NATS本质上是一个异步消息传递系统，它被用作消息代理。只有一个警告，NATS不保存消息。虽然这对一些人来说可能不是理想的，但我们仍然相信NATS可以并且应该作为一个中间人使用。在不需要持久性的情况下，它允许具有高度可伸缩的pub子架构。 NATS提供了一个非常直接的发布和订阅机制，其中包含了主题、通道等概念。消息可以以异步的方式发布并忘记方式。使用相同通道名称的订阅者在NATS中形成一个队列组，然后允许消息自动均匀地分布在订阅者之间。 使用代理插件导入代理插件 1import _ \"github.com/micro/go-plugins/broker/nats\" 从broker标志开始 1go run main.go --broker=nats --broker_address=127.0.0.1:4222 或者直接使用broker 1broker := nats.NewBroker() go-micro代理接口: 12345678910type Broker interface &#123; Options() Options Address() string Connect() error Disconnect() error Init(...Option) error Publish(string, *Message, ...PublishOption) error Subscribe(string, Handler, ...SubscribeOption) (Subscriber, error) String() string&#125; 注册 注册是服务发现的go-micro接口。你可能会思考。使用消息总线的服务发现?,即使是工作吗?确实如此，而且相当不错。许多使用消息总线的人将避免使用任何类型的独立发现机制。这是因为消息总线本身可以通过主题和通道来处理路由。定义为服务名称的主题可以用作路由键，自动在订阅该主题的服务实例之间进行负载平衡。 Go-micro将服务发现和传输机制视为两个不同的关注点。当客户端向另一个服务发出请求时，在覆盖层之下，它会根据名称查找注册表中的服务，选择一个节点的地址，然后通过传输与它通信。 通常，存储服务发现信息的最常用方法是通过一个分布式的键值存储库，如zookeeper, etcd或类似的东西。您可能已经意识到,NATS分布式键值存储不是一个,所以我们要做一些有点不同… 广播查询!广播查询就像你想象的那样。服务侦听我们认为用于广播查询的特定主题。任何想要服务发现信息的人首先会创建一个它订阅的回复主题，然后用他们的回复地址对广播主题进行查询。 因为我们实际上不知道一个服务运行的实例有多少，或者返回的响应有多少，所以我们在等待响应的时候设置了一个上限。这是一种分散收集的粗糙机制，但由于NATs的可扩展性和性能，它实际上工作得非常好。它还间接提供了一种非常简单的过滤服务的方式，响应时间也更高。在将来，我们将考虑改进底层实现。 总结一下它是如何工作的: 创建应答主题并订阅 以回复地址发送广播主题查询 在一个时间限制后，倾听回应和取消订阅 聚合响应和返回结果 使用注册中心插件导入registry插件 1import _ \"github.com/micro/go-plugins/registry/nats\" 从registry标志开始 1go run main.go --registry=nats --registry_address=127.0.0.1:4222 或者直接使用registry 1registry := nats.NewRegistry() go-micro registry接口: 12345678type Registry interface &#123; Register(*Service, ...RegisterOption) error Deregister(*Service) error GetService(string) ([]*Service, error) ListServices() ([]*Service, error) Watch() (Watcher, error) String() string&#125; NATS上加强Micro在上面的示例中，我们只在localhost上指定一个单独的NATS服务器，但是我们推荐的实际应用程序是为高可用性和容错性设置一个NATS集群。要了解更多关于NATs集群检查的NATs文档。 Micro接受一个逗号分隔的地址列表，就像上面提到的标记或者可以选择使用环境变量。如果您直接使用客户端库，那么它也允许作为初始化注册、传输和代理的一种可变的主机集。 在一个云原生世界的架构方面，我们过去的经验表明，每个AZ或每个区域的集群是理想的。大多数云提供商在AZs之间有相对较低的(3-5ms)延迟，这使得区域集群没有问题。当运行一个高度可用的配置时，重要的是确保您的系统能够容忍AZ的失败，并且在更成熟的配置中能够容忍整个区域的失败。我们不建议跨区域进行集群。理想情况下，应该使用更高级别的工具来管理多集群和多区域系统。 Micro是一个非常灵活的运行时不可知的微服务系统。它可以在任何地方和任何配置中运行。它的世界观是由服务注册中心指导的。服务集群可以在一组机器、AZs或区域中进行本地化和命名空间，这完全基于您提供服务访问的注册中心。结合NATS集群，它允许您构建一个高度可用的体系结构来满足您的需求。 总结NATS是一个可扩展和性能的消息传递系统，我们认为它非常适合于微服务生态系统。它与Micro的关系非常好，正如我们所演示的，它可以作为注册表、传输或代理的插件。我们已经实现了这三种功能，以强调NATS的灵活性。 微观上的NATS是微观强大的可插入架构的一个例子。每一个微型软件包都可以实现并以最小的变化交换出去。在未来，我们将会看到更多关于微观的例子。 希望这能激励你在NATS上试用Micro，甚至为其他系统编写一些插件，并回馈社区。 在github.com/micro/go-plugins中找到NATS插件的源代码。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"用Go Micro编写微服务","slug":"go-micro","date":"2018-03-18T11:30:53.000Z","updated":"2020-07-25T02:57:18.206Z","comments":true,"path":"2018/03/18/go-micro/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/go-micro/","excerpt":"这是一个高水平的指导，用go-micro来编写微服务。 如果你想了解更多有关微服务的内容，请点击这里的入门博客文章，如果你想了解更多关于Micro的信息，请点击这里。 让我们开始吧。","text":"这是一个高水平的指导，用go-micro来编写微服务。 如果你想了解更多有关微服务的内容，请点击这里的入门博客文章，如果你想了解更多关于Micro的信息，请点击这里。 让我们开始吧。 Go Micro是什么?Go Micro是一个可插入的RPC库，它提供了用于编写微服务的基本构件。微哲学是用可插拔的体系结构设计的“电池”。从这个框中，它实现了使用代理的服务发现，通过http和使用proto-rpc或json-rpc进行编码 Go Micro是: Go写的库 一组可插入的接口 基于RPC Go Micro提供了接口: 服务发现 编码 客户端/服务端 发布/订阅 这里可以找到更详细的分类。 为什么要Go Micro?一年前就开始做Go Micro，最初是为个人服务。不久之后，很明显，它对更广泛的受众来说也很有价值，他们也希望编写微服务。这是基于在谷歌和Hailo等规模经营微服务平台的各种科技公司的经验。 正如前面提到的，Go Micro是一个可插入的体系结构，它侧重于提供基于Go的接口，这些接口在一起使用时提供了用于编写微服务的构件。这些接口可以通过具体的实现来满足。例如，服务发现的注册接口有一个默认的Consul实现，但是可以用etcd、zookeeper或其他任何能够满足接口的功能交换。 如果您想要交换底层技术，可插拔的体系结构意味着零代码重写。 让我们开始写一个服务吧。 写一个服务如果您想直接阅读代码，请查看examples/service。 顶层服务接口是构建服务的主要组件。它将所有的底层Go Micro包封装到一个方便的接口中。 12345678type Service interface &#123; Init(...Option) Options() Options Client() client.Client Server() server.Server Run() error String() string&#125; 1. 初始化服务是用micro.NewService创建的。 123import \"github.com/micro/go-micro\"service := micro.NewService() 选项可以在创建期间传入。 1234service := micro.NewService( micro.Name(\"greeter\"), micro.Version(\"latest\"),) 这里可以找到所有可用的选项。 Go Micro还提供了一种使用micro.Flags设置命令行标志的方法。 12345678910111213import ( \"github.com/micro/cli\" \"github.com/micro/go-micro\")service := micro.NewService( micro.Flags( cli.StringFlag&#123; Name: \"environment\", Usage: \"The environment\", &#125;, )) 要解析标记使用service.Init。另外，访问标志使用micro.Action 选项。 12345678service.Init( micro.Action(func(c *cli.Context) &#123; env := c.StringFlag(\"environment\") if len(env) &gt; 0 &#123; fmt.Println(\"Environment set to\", env) &#125; &#125;),) Go Micro提供预定义的标志，如果调用了service.Init，就会设置和解析这些标志。看这里所有的flags。 2. 定义API我们使用protobuf文件来定义服务API接口。这是严格定义API并为服务器和客户机提供具体类型的非常方便的方法。 这里有一个例子定义。 greeter.proto 12345678910111213syntax = &quot;proto3&quot;;service Greeter &#123; rpc Hello(HelloRequest) returns (HelloResponse) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloResponse &#123; string greeting = 2;&#125; 在这里，我们定义了一个服务处理程序，叫做Greeter，方法是Hello，它使用参数HelloRequest类型并返回HelloResponse。 3. 生成的API接口我们使用protoc和protoc-gen-go为这个定义生成具体的go实现。 Go-micro使用代码生成来提供客户端存根方法来减少板代码，就像gRPC一样。它是通过一个protobuf插件需要golang/protobuf,可以在这里找到github.com/micro/protobuf。 12go get github.com/micro/protobuf/&#123;proto,protoc-gen-go&#125;protoc --go_out=plugins=micro:. greeter.proto 生成的类型现在可以导入，并在请求时在服务器或客户机的处理程序中使用。 这是生成代码的一部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type HelloRequest struct &#123; Name string `protobuf:\"bytes,1,opt,name=name\" json:\"name,omitempty\"`&#125;type HelloResponse struct &#123; Greeting string `protobuf:\"bytes,2,opt,name=greeting\" json:\"greeting,omitempty\"`&#125;// Client API for Greeter servicetype GreeterClient interface &#123; Hello(ctx context.Context, in *HelloRequest, opts ...client.CallOption) (*HelloResponse, error)&#125;type greeterClient struct &#123; c client.Client serviceName string&#125;func NewGreeterClient(serviceName string, c client.Client) GreeterClient &#123; if c == nil &#123; c = client.NewClient() &#125; if len(serviceName) == 0 &#123; serviceName = \"greeter\" &#125; return &amp;greeterClient&#123; c: c, serviceName: serviceName, &#125;&#125;func (c *greeterClient) Hello(ctx context.Context, in *HelloRequest, opts ...client.CallOption) (*HelloResponse, error) &#123; req := c.c.NewRequest(c.serviceName, \"Greeter.Hello\", in) out := new(HelloResponse) err := c.c.Call(ctx, req, out, opts...) if err != nil &#123; return nil, err &#125; return out, nil&#125;// Server API for Greeter servicetype GreeterHandler interface &#123; Hello(context.Context, *HelloRequest, *HelloResponse) error&#125;func RegisterGreeterHandler(s server.Server, hdlr GreeterHandler) &#123; s.Handle(s.NewHandler(&amp;Greeter&#123;hdlr&#125;))&#125; 4. 实现处理程序服务器需要为服务请求注册** handlers。handler是一种public类型，其public方法符合签名func(ctx context.Context, req interface{}, rsp interface{}) error。 正如您在上面看到的，一个用于Greeter接口的处理程序签名看起来是这样的。 123type GreeterHandler interface &#123; Hello(context.Context, *HelloRequest, *HelloResponse) error&#125; 下面是Greeter handler的一个实现 12345678import proto \"github.com/micro/examples/service/proto\"type Greeter struct&#123;&#125;func (g *Greeter) Hello(ctx context.Context, req *proto.HelloRequest, rsp *proto.HelloResponse) error &#123; rsp.Greeting = \"Hello \" + req.Name return nil&#125; handler在您的服务中注册的很像http.Handler。 12345service := micro.NewService( micro.Name(\"greeter\"),)proto.RegisterGreeterHandler(service.Server(), new(Greeter)) 您还可以创建双向流handler，但我们将把它留到以后的一天。 5. 运行服务greeter.go 该服务可以通过调用server.Run来运行。这会导致服务绑定到config中的地址(默认设置为找到的第一个RFC1918接口和一个随机端口)并侦听请求。 这将在发出一个kill信号时，在开始时和注销时对服务进行注册。 123if err := service.Run(); err != nil &#123; log.Fatal(err)&#125; 6. 完整的服务greeter.go 1234567891011121314151617181920212223242526272829303132package mainimport ( \"log\" \"github.com/micro/go-micro\" proto \"github.com/micro/examples/service/proto\" \"golang.org/x/net/context\")type Greeter struct&#123;&#125;func (g *Greeter) Hello(ctx context.Context, req *proto.HelloRequest, rsp *proto.HelloResponse) error &#123; rsp.Greeting = \"Hello \" + req.Name return nil&#125;func main() &#123; service := micro.NewService( micro.Name(\"greeter\"), micro.Version(\"latest\"), ) service.Init() proto.RegisterGreeterHandler(service.Server(), new(Greeter)) if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 请注意。服务发现机制需要运行，因此服务可以注册为客户机和其他服务发现。这里有一个快速入门。 编写一个客户端客户端包用于查询服务。当您创建服务时，将包含一个与服务器使用的初始包相匹配的客户端。 查询上述服务如下所示。 12345678910111213// create the greeter client using the service name and clientgreeter := proto.NewGreeterClient(\"greeter\", service.Client())// request the Hello method on the Greeter handlerrsp, err := greeter.Hello(context.TODO(), &amp;proto.HelloRequest&#123; Name: \"John\",&#125;)if err != nil &#123; fmt.Println(err) return&#125;fmt.Println(rsp.Greeter) proto.NewGreeterClient使用服务名称和用于发出请求的客户端。 完整的例子可以在go-micro/example/service中找到。 总结希望这篇博文是一个有用的高级指南，可以用Go Micro来编写微服务。您可以在repo github.com/micro中找到更多的示例服务，以帮助您进一步了解更真实的世界解决方案。 如果你想了解更多关于我们提供的服务或微服务，请检查micro.mu。或者是github repo。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"Micro - 微服务工具包","slug":"micro","date":"2018-03-18T10:15:47.000Z","updated":"2020-07-25T02:57:18.215Z","comments":true,"path":"2018/03/18/micro/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/micro/","excerpt":"到现在为止，你可能已经听说过这种新的现象，微服务。如果你还不熟悉，而且对学习感兴趣，请在查看这里。 在这篇博文中，我们将讨论Micro，一个开源的微服务工具包。Micro提供了构建和管理微服务的核心需求。它由一系列的库和工具组成，这些库和工具主要面向Go语言的编程开发，但是通过使用Sidecar来解决其他语言的问题。 在我们了解微观的细节之前，让我们来谈谈为什么我们决定把时间花在这上面。","text":"到现在为止，你可能已经听说过这种新的现象，微服务。如果你还不熟悉，而且对学习感兴趣，请在查看这里。 在这篇博文中，我们将讨论Micro，一个开源的微服务工具包。Micro提供了构建和管理微服务的核心需求。它由一系列的库和工具组成，这些库和工具主要面向Go语言的编程开发，但是通过使用Sidecar来解决其他语言的问题。 在我们了解微观的细节之前，让我们来谈谈为什么我们决定把时间花在这上面。 开发或部署从我们过去的经验和我们在业界所看到的情况来看，我们需要关注开发而不是部署。PaaS解决方案是现成的。AWS、谷歌和微软等公司都提供了功能丰富的平台，而且如果不这样做的话，它们也会迅速转向支持容器编排。所有这一切使我们可以通过点击几个按钮来访问大规模的计算。 这个新世界听起来不错。你可能会说这解决了你所有的问题，对吧?虽然我们现在可以使用大规模的计算能力，但是我们仍然缺乏能够使我们编写能够利用它的软件的工具。不仅如此，在这个新的世界中，容器可能会更加短暂，随着运行时重新安排它们或它们正在运行的机器的失败，容器会变得更加短暂。 扩展的挑战我们经常看到的另一个问题是，组织是如何成为其整体架构的牺牲品的。由于需要以极快的速度增长，有一种趋势是将功能塞进现有系统，并导致技术债务，使雪球陷入无法控制的局面。除此之外，当组织试图增加工程团队的时候，开发人员在单个代码基础上进行协作，或者并行地进行特性开发，而不在发布时被阻塞，这将变得更加困难。 对于SOA或基于微服务的架构来说，重构和最终路径是不可避免的。公司最终会在房子里进行研发工作，通过尝试和错误来学习。如果有一些工具可以帮助创建可伸缩的系统，减少研发的可能性，并从过去的经验中提供专业知识。 进入Micro在Micro方面，我们正在构建一个微服务生态系统，其中包括用于微服务开发的工具、服务和解决方案。我们用一个同名的工具来构建这个生态系统的基础。Micro是一个微型服务工具包，它可以创建可伸缩的体系结构，并提高执行速度。 让我们深入了解一下Micro的特征。 Go MicroGo Micro是一个可插入的RPC框架，用于在Go中构建微服务。它提供了创建、发现和与服务通信所需的基本特性。任何优秀的微服务体系结构的核心都始于服务发现、同步和异步通信。 包括包装和特点: Registry - 客户端服务发现 Transport - 同步通信 Broker - 异步通信 Selector - 节点过滤和负载平衡 Codec - 消息编码/解码 Server - 构建在上面的RPC服务器 Client - 构建在上面的RPC客户端 与大多数库不同的是，它是可插拔的体系结构。这允许将每个包的实现和后端系统交换出去。例如;注册表的默认服务发现机制是Consul，但这可以很容易地与etcd、zookeeper或其他您选择实现的插件交换。我们正在实现的插件可以在github.com/micro/go-plugins上找到。 可插拔系统的价值在于能够选择用于支持微服务的平台，而无需重写任何代码。Go Micro要求零代码更改，只需导入一个插件就可以了。 Go Micro是写微服务的起点。readme提供了如何编写、运行和查询服务的概述。这里有一个类似的例子，在repo github.com/micro中提供了micro/example/greeter和更多的示例服务。 SidecarGo Micro提供了一种方式Go来编写服务，但是其他语言呢?我们如何创建一个polygot生态系统，让任何人都能利用Micro的优势?虽然Micro是写在Go上的，但是我们想让一个快速简单的方法来集成用任何语言编写的应用程序。 进入Sidecar，这是一种轻量级的伙伴服务，它在概念上“附加”到主(即父级)应用程序，并通过提供Micro系统的特性来补充它。sidecar是一个与您的应用程序并行运行的进程，它通过一个HTTP接口实现了Go Micro的特性。 sidecar的特点: 注册与发现系统 主机发现其他服务 主应用程序的健康检查 用于发出RPC请求的代理 通过WebSockets的PubSub 可以在这里找到使用带有ruby或python的Sidecar的例子。我们将在不久的将来添加更多的示例代码，以帮助理解如何集成sidecar。 API将RPC请求从一个服务发送到另一个服务非常简单，但对于外部访问并不理想。服务的实例可能会失败，它们可能被重新安排到其他地方，或者最终绑定到任意的端口。该API为查询微服务提供了一个单一入口点，并应作为外部访问的网关。 该API提供了一些不同类型的请求处理程序。 /rpc可以使用/rpc端点通过RPC查询单个服务。例子: 1234567curl \\ -d \"service=go.micro.srv.greeter\" \\ -d \"method=Say.Hello\" \\ -d \"request=&#123;\\\"name\\\": \\\"John\\\"&#125;\" \\ http://localhost:8080/rpc&#123;\"msg\":\"Hello John\"&#125; api.Request该API可用于分解由单个微服务提供的url。这是一种强大的API组合方法。在这里，API使用请求路径的第一部分以及名称空间组件来确定要路由请求的服务。然后，HTTP请求被转换为一个api.Request，并适当地转发。 在Micro上，我们使用创建API微服务的模式来服务于边缘的请求。分离后端和前端服务的职责。 API请求处理的一个例子: 请求 1GET /greeter/say/hello?name=John 变成 123456789service: go.micro.api.greeter (default namespace go.micro.api is applied)method: Say.Hellorequest &#123; &quot;method&quot;: &quot;GET&quot;, &quot;path&quot;: &quot;/greeter/say/hello&quot;, &quot;get&quot;: &#123; &quot;name&quot;: &quot;John&quot; &#125;&#125; api.Request 和 api.Response的结构: 123456789101112131415161718192021syntax = &quot;proto3&quot;;message Pair &#123; optional string key = 1; repeated string values = 2;&#125;message Request &#123; optional string method = 1; // GET, POST, etc optional string path = 2; // e.g /greeter/say/hello map&lt;string, Pair&gt; header = 3; map&lt;string, Pair&gt; get = 4; // The URI query params map&lt;string, Pair&gt; post = 5; // The post body params optional string body = 6; // raw request body; if not application/x-www-form-urlencoded&#125;message Response &#123; optional int32 statusCode = 1; map&lt;string, Pair&gt; header = 2; optional string body = 3;&#125; 可以在这里找到如何创建API服务的示例。 Greeter API proxyAPI的请求处理的最终方法是反向代理。正如上面所述，API使用请求路径和名称空间组件来确定要路由请求的服务。通过提供反向代理和微服务请求路由，我们能够支持REST，这是一种广泛追求的需求。 通过传递–api_handler=proxy标志，可以启用代理。 如何构建一个RESTful API的一个例子可以在这里找到micro/examples/greeter/api。 Web UIweb UI提供了一个简单的指示板，用于观察和与运行的系统交互。不仅如此，它还提供了与API非常相似的反向代理。我们的“web代理”的目标是使web应用程序的开发成为微服务。同样，就像API一样，请求路径与名称空间一起使用，以确定要路由请求的服务。web代理还支持web sockets，因为我们认为实时是交付web应用程序的核心部分。 CLICLI是一个命令行工具，它提供了在运行环境中观察、交互和管理服务的方法。当前的特性集允许您检查注册表、检查服务的基本健康状况并对服务本身执行查询。 另一个很好的特性是使用Sidecar作为CLI的代理的能力。这就像在执行CLI时指定sidecar的地址作为标志一样简单–proxy_address=example.proxy.com。 把它放在一起我们已经通过使用简单的greeter服务编写了一个完整的端到端流程示例。 流程如下: HTTP GET请求name=John被发送到/greeter/say/hello的micro API API将这个使用默认名称空间转换为API服务go.micro.api.greeter和方法Say.Hello。请求的结构是一个api.Request。 使用Go Micro的API，查询注册表以查找服务go.micro.api的所有节点。将请求转发给节点。 greeter api解析请求，生成hello。请求并请求rpc服务go.micro.srv.greeter。同样，使用相同的注册表/发现机制来查找服务的节点。 greeter rpc服务使用hello.Response响应。 greeter api将响应转换为api.Response并将其传回API。 micro API解析响应并响应客户机的HTTP请求。 在一个更复杂的示例中，API服务可以调用许多其他RPC服务，聚合和转换数据，然后将最终的汇总结果传递给客户机。这允许您在不了解客户机的情况下，在后台维护一致的外部入口点和更改服务。 Dome如果你想在运行的系统上，请在web.micro.pm处查看我们的演示。 我们正在使用谷歌集装箱引擎在Kubernetes上运行Micro。演示是开源的，如果您想自己运行它。你可以在这里github.com/micro/kubernetes找到k8s配置。 总结Micro为编写和管理微服务提供了基本的构建模块。微观包括核心需求;发现、客户机/服务器和发布/订阅。CLI让您与环境和服务交互。sidecar可以集成任何非微应用程序。该API是rpc请求的单一入口点，可以创建REST端点。有了可插入的接口，您可以选择并选择您想要利用的系统来构建您的体系结构。 我们在Micro上的目标是在规模上实现开发，提高执行速度，并从开发人员生命周期的最初阶段开始提供价值。我们觉得Micro是做所有这些事情的最好方法。随着时间的推移，工具的生态系统将会发展到包含更多的功能丰富的服务，用于发现、路由和可转换性。 如果你想了解更多关于我们提供的服务或微服务，请检查micro.mu。或者是github repo。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"介绍Micro - 微服务系统","slug":"micro-introduction","date":"2018-03-18T09:38:06.000Z","updated":"2020-07-25T02:57:18.213Z","comments":true,"path":"2018/03/18/micro-introduction/","link":"","permalink":"https://jigangduan.github.io/2018/03/18/micro-introduction/","excerpt":"Hello World! 让我们来谈谈软件开发的未来。 改变正在进行之中。我们正越来越多地走向一个以科技为核心的世界。在当今时代，保持竞争优势正变得越来越困难。组织的执行能力会随着他们试图扩展低效的平台、过程和结构而陷入停顿。十年前，科技公司经历了这些规模的阵痛，大多数公司都采用了同样的方法来克服这些挑战。 是时候把世界上最成功的公司的竞争优势带给其他人了。因此，让我们谈谈微服务，一种创造竞争优势的方法。","text":"Hello World! 让我们来谈谈软件开发的未来。 改变正在进行之中。我们正越来越多地走向一个以科技为核心的世界。在当今时代，保持竞争优势正变得越来越困难。组织的执行能力会随着他们试图扩展低效的平台、过程和结构而陷入停顿。十年前，科技公司经历了这些规模的阵痛，大多数公司都采用了同样的方法来克服这些挑战。 是时候把世界上最成功的公司的竞争优势带给其他人了。因此，让我们谈谈微服务，一种创造竞争优势的方法。 什么是微服务？微服务是一种软件体系结构模式，用于将大型单块应用程序分解为更小的可管理的独立服务，这些服务通过语言无关协议进行通信，并且每一项都专注于做好一件事。 行业专家对微服务的定义： 松散耦合的面向服务的体系结构，具有有界的上下文。Adrian Cockcroft - 将单个应用程序开发为一套小型服务的方法，每个应用程序都在自己的进程中运行，并使用轻量级机制进行通信。马丁 微服务的概念并不新鲜，这是对服务定向架构的重新设想，但采用的方法更符合unix进程和管道。 微服务架构的理念: 服务是小粒度的，作为一个单一的业务用途，类似于unix的“做一件事，做好它”的哲学 组织文化应该拥抱部署和测试的自动化。这减轻了管理和操作的负担。 文化和设计原则应该包含失败和错误，类似于反脆弱系统。 为什么使用微服务？随着组织规模的扩大，技术和人员数量的增加，管理单一的代码库变得更加困难。我们都习惯了推特失败的鲸鱼一段时间，因为他们试图扩大他们的用户基础和产品特性集与一个整体系统。微服务使Twitter能够将应用程序分解为更小的服务，这些服务可以由许多不同的团队单独管理。每个团队负责由许多微服务组成的业务功能，这些服务可以独立于其他团队部署。 我们通过第一手的经验了解到，微服务系统支持更快的开发周期、改进的生产力和卓越的可伸缩系统。 让我们来谈谈其中的一些好处: 更容易扩展开发 —— 团队围绕不同的业务需求进行组织，并管理他们自己的服务。 更容易理解 —— 微服务要小得多，通常是1000 LOC或更少。 更容易部署新版本的服务 ——服务可以独立部署、扩展和管理。 改进的容错和隔离 ——关注的分离最小化了从另一个服务中产生的问题的影响。 改进的执行速度 ——团队独立地开发、部署和管理微服务，从而更快地交付业务需求。 可重用的服务和快速的原型 ——在microservices中根深蒂固的unix哲学允许您重用现有的服务，并在上面更快地构建全新的功能。 什么是Micro?Micro是一个微服务生态系统，致力于为现代软件驱动企业提供产品、服务和解决方案。我们计划成为任何与微服务相关的实际资源，并将使公司能够利用这项技术为自己的企业服务。从早期的原型开发一直到大规模的生产部署。 我们看到了行业的根本性转变。摩尔定律是有效的，我们每天都能获得越来越多的计算能力。然而，我们无法充分认识到这种新的能力。在这个新时代，现有的工具和开发实践没有规模。开发人员没有提供从单片代码基转移到更有效的设计模式的工具。大多数公司都不可避免地要达到一个以整体设计来减少回报的程度，并且必须进行大规模的研发再造工作。Netfix、Twitter、Gilt和Hailo都是这方面的主要例子。最终，他们都建立了自己的微服务平台。 我们的愿景是提供基本的构建模块，让任何人都更容易采用微服务。 我们用一个开源的微服务工具包(也叫做Micro)来解决这个问题。期待一个后续的博客详细介绍这个工具包。 现在该做什么?当你听到“微服务”这个词时，我们希望你能想到微服务生态系统。 如果你想了解更多关于我们提供的服务或微服务，请检查micro.mu。或者是github repo。","categories":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"}]},{"title":"WebAPP 框架方案讨论","slug":"WebApp","date":"2018-03-01T15:54:43.000Z","updated":"2020-07-25T02:57:18.171Z","comments":true,"path":"2018/03/01/WebApp/","link":"","permalink":"https://jigangduan.github.io/2018/03/01/WebApp/","excerpt":"框架需求 H5\b应用开发\b\b\b\b响应快速开发 \b多\b客户的定制化 \b\b不同\b项目呈现不同的\b功能模块 移动端\b\b原生功能的支持 升级\b迭代的便利性","text":"框架需求 H5\b应用开发\b\b\b\b响应快速开发 \b多\b客户的定制化 \b\b不同\b项目呈现不同的\b功能模块 移动端\b\b原生功能的支持 升级\b迭代的便利性 目前WebAPP方案对比 React Native Ionic H5+ 微信小程序 框架方案思路 APP： \b原生APP，MA容器功能和\b\b\b\b管理功能。 MA: 微应用，H5+\b\b\b实现的微小应用。\b尽量功能单一，体量小。 WebView: \b\b经过\b封装原生WebView,\b\b\b封装后\b\b经过\b\b\b\b桥接\b\b\b插件支持H5+ plug: 插件，\b\b桥接JS和原生API S： 服务端微\b服务 ACS: MA\b\b注册\b服务，\b记录列表-服务端\b\b\b\b包含的微\b应用 UCS：用户配置\b\b\b服务，\b记录列表-用户\b需要的微应用 \b思路\b简介 移动端APP\b\b\b\b不包括\b\b任何\b\b业务逻辑，\b业务\b功能只按模块\b分布于各个微应用MA中。 MA通过H5+实现\b单一/简单的\b功能，被\b打包成资源包，\b存储\b\b在服务器\b\b\b\b\b\b\b\b\b微应用仓库中。 ACS/UCS 记录/管理微应用\b仓库和用户\b微应用需求 APP\b通过ACS/UCS， 发现/加载/升级 微应用 APP通过WebView启动\b微应用，运行\b\b业务功能 主要\b涉及的功能 WebView\b加载\b\b本地MA资源 H5+ 插件开发\b调用\b原生API MA资源\b管理 MA资源配置获取 \bMA资源\b网络加载 MA资源\b本地管理 \b\b移动端权限获取 \b壳APP的\b其它功能 需要考虑的问题 \b配置信息\b\b\b规范 移动端权限管理 插件开发 微\b应用之间需要\b通信吗？如何\b通信？ \b\b性能要求 H5的流畅\b度 MA资源包的加载速度 H5在各个Android系统中的适配问题 \b\b后期，每添加一个插件\b都需要\bAPP的打包上架，\b建议\b\b\b\b\b\b\b\b\b减少上架次数 \b可能存在问题/\b风险 iOS上架\b风险，H5 APP上架的不确定性 适配问题的各种\b坑（WebApp的坑） H5+ Engine的封闭性，没有开源，太依赖5+SDK 后续任务 \b方案的\b可行性\b \b\b\b研究插件开发的实现方式","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"WebAPP","slug":"前端/WebAPP","permalink":"https://jigangduan.github.io/categories/前端/WebAPP/"}],"tags":[{"name":"webapp","slug":"webapp","permalink":"https://jigangduan.github.io/tags/webapp/"}]},{"title":"使用Expo工作","slug":"expo-working-with-expo","date":"2018-02-08T04:15:06.000Z","updated":"2020-07-25T02:57:18.201Z","comments":true,"path":"2018/02/08/expo-working-with-expo/","link":"","permalink":"https://jigangduan.github.io/2018/02/08/expo-working-with-expo/","excerpt":"","text":"启动和运行创建一个帐户打开XDE后，将提示输入用户名和密码。填入你想要的用户名和密码，然后点击继续-如果用户名还没有被使用，我们会自动为你创建帐户。 创建项目按下Project并选择New Project，然后选择选项Tab Navigation选项，这将为我们提供一个良好的起点，然后在弹出的对话框中输入项目名称。我将调用我的first-project，并按下创建。 接下来，选择保存项目的位置。我把所有有趣的项目都保存在~/coding中，所以我导航到那个目录并按下打开。 XDE现在在选择的目录中初始化一个新项目:它复制一个基本的模板，并安装react、react-native和expo。 当项目初始化并准备好时，您将在XDE日志中看到&quot;React packager ready&quot;的消息。 “React packager”是一个简单的HTTP服务器，它使用Babel编译我们的应用JavaScript代码，并将其应用到世博会应用程序中。 注意:如果你在MacOS上，XDE被困在“Waiting for packager and tunnel to start”的时候，你可能需要在你的机器上安装watchman。最简单的方法是使用Homebrew，brew install watchman。 在你的手机或模拟器上打开应用你会发现XDE显示你一个URL http://4v-9wa.notbrent.mynewproject.exp.direct:80-可以在浏览器中打开它，你会看到它提供了一些JSON。这个JSON是Expo的清单。我们可以在我们的手机上打开应用程序，把这个URL输入地址栏。或者，按下分享，输入你的电话号码，然后按发送链接。打开你的手机上的信息，点击链接，在Expo上打开它。你可以和任何安装了Expo app的人分享这个链接，但是只要你在XDE中打开这个项目，它就会被使用。 要在iOS模拟器中打开应用，你可以按下Device按钮，选择Open on iOS Simulator(macOS)。要在Android模拟器中打开应用程序，首先要启动它，然后按下Device，然后在Open on Android。 第一次修改在您的新项目中打开screens/HomeScreen.js，并更改render()函数中的任何文本。你应该看到你的应用重新载入你的改变。 看不出你的变化吗?Live重载是默认启用的，但是让我们确保我们可以通过这些步骤来启用它，以防止在某种情况下无法正常工作。 首先，确保在XDE中启用了开发模式。 接下来，关闭应用程序并重新打开它。 一旦应用再次打开，你就可以摇晃你的设备来显示开发者菜单。如果你使用的是模拟器，请按下⌘+d在iOS或ctrl+m在Android。 如果你看到Enable Live Reload，按下它，你的应用就会重新加载。如果您看到了Disable Live Reload，那么退出开发人员菜单并尝试进行另一个更改。 手动重新加载应用程序 如果您已经按照上面的步骤进行了重新加载，仍然没有工作，请按下XDE右下角的按钮来发送一个支持请求。在我们解决这个问题之前，您可以摇动设备并按下Reload，或者使用以下工具之一，它可以同时使用没有开发模式的工具。 祝贺你您已经创建了一个新的Expo项目，进行了更改，并看到了它的更新。 术语表app.jsonapp.json是一个为每个Expo项目而存在的文件，它被用来配置你的项目，例如名字、图标和splash screen。更多信息请阅读“app.json的配置” create-react-native-appReact Native与create-react-app是一样的。您可以设置并创建一个无需构建配置的React Native app，并使用Expo来完成这一任务。请阅读更多的“Expo和创造React Native App”。 分离“分离”一词在Expo上被用于描述离开舒适的标准Expo开发环境，在这里你不必处理构建配置或本地代码。当你从Expo“分离”的时候，你会得到ExpoKit的原生项目，所以你可以继续使用Expo的api来建造你的项目，但是你的工作流程和你在没有Expo的情况下建立一个反应的本地应用是一样的。详情请阅读“分离ExpoKit”。 eject“eject”这个词是由create-react-app推广的，它被用于create-react-native-app。当你“eject”你的项目时，你会采取更极端的步骤，而不仅仅是分离——你失去了对Expo APIs的访问，完全离开了Expo的环境。阅读更多关于ejecting。 EmulatorEmulator用于描述您的计算机上的Android设备的软件仿真器。通常，iOS模拟器被称为Simulators。 exp用于与Expo合作的命令行工具。阅读更多。 体验应用程序的同义词通常意味着更单一的用途和更小的范围，有时是艺术的和异想天开的 Expo ClientExpo SDKExpoKitExpoKit是一个Objective-C和Java库，它允许你使用Expo SDK和平台以及你现有的Expo项目，作为一个更大的标准原生项目的一部分——你通常会用Xcode、Android Studio或者react-native init来创建这个项目。阅读更多。 iOS在iPhone、iPad和苹果电视上使用的操作系统。Expo目前在iOS版iPhone和iPad上运行。 链接Manifest本地目录npmOver the Air updates包管理器发布React NativeShell appSimulatorSlug我们在app.json中使用“slug”这个词，指的是它的url中应用程序的名称。例如，Native Component列表应用程序就生活在https://expo.io/@community/native-component-list和slug是native-component-list。 SnackSnack是一种浏览器开发环境，你可以在你的手机或电脑上不安装任何工具，就可以在这里建立Expo体验。 独立app一个可以提交到iOS应用商店或Android Play商店的应用程序二进制文件。更多地阅读“构建独立应用”。 XDE一个带有图形用户界面(GUI)的桌面工具，用于与Expo项目合作。它与exp CLI工具的功能基本相同，但适用于更熟悉GUI的人。 yarn一个用于JavaScript的包管理器。更多 使用app.json配置app.json是你用来配置不属于代码的部分应用程序的首选之地。它位于您的项目的根目录下，紧邻您的package.json。它看起来是这样的: 12345678&#123; \"expo\": &#123; \"name\": \"My app\", \"slug\": \"my-app\", \"sdkVersion\": \"25.0.0\", \"privacy\": \"public\" &#125;&#125; app.json之前被称为exp.json，但是为了保持与 Create React Native App的一致性，它已经被合并到一个文件中。如果您正在将您的应用程序从使用exp.json转换为app.json，那么您所需要做的就是在app.json的根上添加一个“expo”键，作为所有其他键的父元素。 大多数来自app.json的配置在运行时都可以通过Expo.Constants.manifest的JavaScript代码访问。诸如密匙之类的敏感信息被删除。有关如何将任意配置数据传递给应用程序的信息，请参阅下面的&quot;extra&quot;键。 下面是在app.json的&quot;extra&quot;关键字下面提供的属性列表: name 必需。你的app的名字在Expo上和你的home屏幕上都是一个独立app。 description 简短地描述一下你的应用是什么，以及它为什么很棒。 slug 必需。用于发布的友好url名称。例如:expo.io/@your-username/slug。 privacy public或unlisted。如果没有提供，则默认为unlisted。在未来，private将得到支持。unlisted隐藏了搜索结果的经验。有效值:public、unlisted sdkVersion 必需。运行项目的Expo sdkVersion。这应该与您的package.json中指定的版本一致。 version 你的app版本，使用你喜欢的任何版本控制方案。 platforms 您的项目明确支持的平台。如果没有指定，它会默认为[&quot;ios&quot;, &quot;android&quot;]。 githubUrl 如果你想在Github上分享你的应用程序的源代码，那么在这里输入存储库的URL，它将链接到你的Expo项目页面。 orientation 把你的应用程序锁定在一个特定的方向上，用portrait或landscape。默认为没有锁。有效值:‘default’, ‘portrait’, ‘landscape’ primaryColor 在Android上，这将决定你的应用在多任务的颜色。目前这款应用还没有在iOS上使用，但将来可能会用于其他用途。6个字符长的十六进制颜色字符串，如:&#39;#000000&#39; icon 本地路径或远程url到应用程序图标的图像。我们建议您使用1024x1024 png文件。这个图标将会出现在主屏和Expo应用程序中。 notification 远程(推送)通知的配置 icon本地路径或远程url到一个图像，用作推送通知的图标。透明的48x48 png灰度图。 color当它出现在通知托盘中时，为推送通知图像着色。6个字符长的十六进制颜色字符串，如:&#39;#000000&#39; androidMode分别显示每个推送通知(default)或collapse为一个(collapse)。有效值:‘default’, ‘collapse’ androidCollapsedTitle如果androidMode被设置为collapse，这个标题将被用于崩溃的通知消息。例如:’#{unread_notifications} new interactions’ loading 弃用:使用splash代替。用户在打开应用程序时看到的加载屏幕的配置，同时获取和缓存捆绑包和资产。 icon在启动应用程序时，本地路径或远程url显示的图像。图像大小和纵横比取决于你。必须是一个.png。 exponentIconColor如果没有提供icon，我们将展示Expo标志。你可以在white和blue之间选择。有效值:‘white’, ‘blue’ exponentIconGrayscale类似于exponentIconColor，但表示它应该是灰度(1)还是不(0)。 backgroundImage本地路径或远程url到图像以填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 backgroundColor颜色填充加载屏幕背景6字符长的十六进制颜色字符串， eg: &#39;#000000&#39; hideExponentText在默认情况下，Expo在加载屏幕的底部显示了一些文本。设置为true，禁用 appKey 在默认情况下，世博会将作为main的注册地申请注册。如果您想要更改这个属性，您可以在该属性中指定名称。 androidStatusBarColor 弃用。使用androidStatusBar代替。6个字符长的十六进制颜色字符串，如:’#000000’ androidStatusBar 配置android状态栏。 barStyle配置状态栏图标，以有亮或暗颜色。有效值:‘light-content’, ‘dark-content’ backgroundColor配置android状态栏。6字符长十六进制颜色字符串，eg: ‘#000000’ androidShowExponentNotificationInShellApp 使用refresh按钮和调试信息向您的独立应用程序添加一个通知。 scheme 独立的应用程序。链接到你的应用程序的URL方案。例如，如果我们把它设置为’demo’，那么demo:// URLs会在点击时打开你的应用。字符串以字母开头，然后是字母、数字、”+”, ”.” or ”-” 的组合。 entryPoint 相对路径到您的主JavaScript文件。 extra 你想要传递给你的经验的任何额外的领域。值可以通过Expo.Constants.manifest.extra。(了解更多) rnCliPath packagerOpts ignoreNodeModulesValidation nodeModulesPath ios 独立的应用程序。iOS独立应用特定配置 bundleIdentifier这是你的iOS独立应用的bundle id，你可以在app Store中使用它，但它必须是独一无二的。看到这个StackOverflow问题。iOS绑定标识符标记为您的应用程序的唯一名称。例如，exp.host。我们的Expo是我们的域名，而Expo就是我们的应用。 buildNumber为你的iOS独立应用构建数字，必须是一个匹配苹果格式的CFBundleVersion格式的字符串 icon本地路径或远程URL到你的应用在iOS上的图标。如果指定了，这将覆盖顶级的图标键。使用一个1024x1024的图标，遵循苹果的图标的界面指南，包括颜色配置和透明度。世博会将产生其他所需的规模。这个图标将会出现在主屏和Expo应用程序中。 merchantId在你的独立应用中使用Apple Pay的商家ID。 appStoreUrl如果你已经把它部署到苹果应用商店，你可以在苹果app Store上使用它。如果你的应用是公开的，你可以在你的世博会项目页面上链接到你的商店页面。 config branch分支键连接分支连接服务。 apiKey你的分支API Key usesNonExemptEncryption设置独立ipa’s Info.plist ITSAppUsesNonExemptEncryption,给定的布尔值。 googleMapsApiKey为你的独立应用提供的Google Maps iOS SDK key。 googleSignIn为你的独立应用提供的Google Sign-In iOS SDK reservedClientId保留的客户端ID URL方案。可以在GoogeService-Info.plist中找到 isRemoteJSEnabled如果设置为false，您的独立应用程序将永远不会下载任何代码，并且只会使用在设备上本地绑定的代码。在这种情况下，你的应用的所有更新都必须通过苹果审核提交。默认值为true。(请注意，这将无法通过ExpoKit项目来实现) loadJSInBackgroundExperimental如果是这样的话，你的独立应用程序会立即运行它的缓存JS包，如果存在的话，并在后台请求一个新的。 supportsTablet你的独立iOS应用是否支持平板电脑的尺寸。默认值为false。 isTabletOnly如果这是true，说明你的独立iOS应用不支持手机，只支持平板电脑。 infoPlist任意配置的字典，添加到您的独立应用程序的本地Info.plist。适用于所有其他特定于Expo配置。没有执行其他验证，所以在应用程序商店的拒绝中使用它。 associatedDomains一个包含独立应用程序的相关域的数组。 usesIcloudStorage一个布尔值，指示该应用是否使用用于DocumentPicker的iCloud存储。有关详细信息，请参阅DocumentPicker文档。 splash为独立的iOS应用提供加载和启动屏幕的配置。 backgroundColor颜色填充屏幕背景6个字符的长十六进制颜色字符串，如:’#000000’ resizeMode确定图像将如何显示在弹出的加载屏幕中。必须是一个包含或包含的默认值。有效值:‘cover’, ‘contain’ image本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 tabletImage本地路径或远程url到图像以填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 android独立的应用程序。Android独立应用程序特定配置 package的Android独立应用程序的包名，你可以做，但它需要在Play Store中是独一无二的。看到这个StackOverflow问题。反向DNS标记为您的应用程序的唯一名称。例如，host.exp.exponent。我们的域名是我们的域名，而Expo就是我们的应用。 versionCodeGoogle Play需要的版本号。每个版本增加一个。必须是一个整数。https://developer.android.com/studio/publish/versioning.html icon本地路径或远程url到你的应用程序在Android上的图标。如果指定了，这将覆盖顶级的图标键。我们建议您使用1024x1024 png文件(Google Play商店推荐使用透明度)。这个图标将会出现在主屏和世博会应用程序中。 playStoreUrl如果你已经部署在Google Play Store，那么你的应用程序的URL。如果你的应用程序是公开的，这是用来链接到你的商店页面的。 permissions独立应用程序使用的权限列表。删除该字段以使用默认的权限列表。示例: [ &quot;CAMERA&quot;, &quot;ACCESS_FINE_LOCATION&quot; ].您可以根据需要指定以下权限: ACCESS_COARSE_LOCATION ACCESS_FINE_LOCATION CAMERA MANAGE_DOCUMENTS READ_CONTACTS READ_CALENDAR WRITE_CALENDAR READ_EXTERNAL_STORAGE READ_INTERNAL_STORAGE READ_PHONE_STATE RECORD_AUDIO USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_EXTERNAL_STORAGE com.anddoes.launcher.permission.UPDATE_COUNT com.android.launcher.permission.INSTALL_SHORTCUT com.google.android.c2dm.permission.RECEIVE com.google.android.gms.permission.ACTIVITY_RECOGNITION com.google.android.providers.gsf.permission.READ_GSERVICES com.htc.launcher.permission.READ_SETTINGS com.htc.launcher.permission.UPDATE_SHORTCUT com.majeur.launcher.permission.UPDATE_BADGE com.sec.android.provider.badge.permission.READ com.sec.android.provider.badge.permission.WRITE com.sonyericsson.home.permission.BROADCAST_BADGE config branch分支键连接分支链接服务。 apiKey你分支API key fabricGoogle Developers Fabric keys连接Crashlytics和其他服务。 apiKey你Fabric API key buildSecretFabric build secret googleMaps你的独立app的Google Maps Android SDK key。 apiKeyGoogle Maps Android SDK API key googleSignIn为你的独立应用提供的Google Sign-In iOS SDK apiKeyAndroid API key。可以在开发人员控制台的凭据部分或在google-services.json中找到。 certificateHash用于构建apk的签名证书的SHA-1哈希，没有任何分隔符:。可以在google-service.json中找到。https://developers.google.com/android/guides/client-auth splash为独立的Android应用程序加载和启动屏幕的配置。 backgroundColor颜色填充屏幕背景6个字符的长十六进制颜色字符串，如: ‘#000000’ resizeMode确定图像将如何显示在弹出的加载屏幕中。必须是一个cover或contain,默认值contain。有效值:‘cover’, ‘contain’ ldpi本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 mdpi本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 hdpi本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 xhdpi本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 xxhdpi本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 xxxhdpi本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 facebookAppId 用于所有的Facebook库。在https://developers.facebook.com上设置你的Facebook应用程序ID。 facebookDisplayName 用于原生的Facebook登录。 facebookScheme 用于Facebook本地登录。从“fb”开始，接着是一系列的数字，比如“fb1234567890”。你可以在https://developers.facebook.com/docs/facebook-login/ios找到你的方案的配置信息。plist”部分。 splash 为独立应用程序加载和启动屏幕的配置。 backgroundColor颜色填充屏幕背景6个字符的长十六进制颜色字符串，如:’#000000’ resizeMode确定图像将如何显示在弹出的加载屏幕中。必须是一个包含或包含的默认值。有效值:‘cover’, ‘contain’ image本地路径或远程url到一个图像来填充加载屏幕的背景。图像大小和纵横比取决于你。必须是一个.png。 hooks 对脚本的配置，以将其连接到发布过程中 postPublish assetBundlePatterns 一组文件glob字符串，它指向的资产将被绑定到独立的应用程序二进制文件中。在离线支持指南中阅读更多信息 开发模式React Native包括一些非常有用的开发工具:在Chrome中进行远程JavaScript调试、实时重载、热重加载，以及一个类似于您在Chrome中使用的受欢迎的检查器的元素检查器。它还执行一些验证，当您的应用程序正在运行时，如果您使用的是不赞成的属性，或者您忘记将必需的属性传递到组件中，那么它将给您发出警告。 这是有代价的:你的应用在开发模式下运行得比较慢。你可以在XDE上来回切换。当你打开它时，关闭并重新打开你的应用程序，让它生效。在测试应用程序的性能时，一定要禁用开发模式。 在XDE中切换开发模式 exp命令行接口除了XDE之外，我们还有一个CLI exp，如果您喜欢在命令行上工作，或者想要在测试或持续集成(CI)中使用Expo。 安装运行 npm install -g exp 安装全局exp. 如果您以前没有使用过exp或XDE，那么您需要做的第一件事就是使用exp login登录您的Expo帐户。 命令查看使用exp --help的命令列表: 1234567891011121314151617181920212223242526272829303132333435363738394041Usage: exp [options] [command]Options: -V, --version output the version number -o, --output [format] Output format. pretty (default), raw -h, --help output usage informationCommands: android [options] [project-dir] Opens your app in Expo on a connected Android device build:ios|bi [options] [project-dir] Build a standalone IPA for your project, signed and ready for submission to the Apple App Store. build:android|ba [options] [project-dir] Build a standalone APK for your project, signed and ready for submission to the Google Play Store. build:status|bs [options] [project-dir] Gets the status of a current (or most recently finished) build for your project. convert|onentize [options] [project-dir] Initialize Expo project files within an existing React Native project detach [options] [project-dir] Creates Xcode and Android Studio projects for your app. Use this if you need to add custom native functionality. diagnostics [options] [project-dir] Uploads diagnostics information and returns a url to share with the Expo team. doctor [options] [project-dir] Diagnoses issues with your Expo project. fetch:ios:certs [options] [project-dir] Fetch this project&apos; iOS certificates. Writes to PROJECT_DIR/PROJECT_NAME_(dist|push).p12 and prints passwords to stdout. fetch:android:keystore [options] [project-dir] Fetch this project&apos;s Android keystore. Writes keystore to PROJECT_DIR/PROJECT_NAME.jks and prints passwords to stdout. init|i [options] [project-dir] Initializes a directory with an example project. Run it without any options and you will be prompted for the name and type. install:ios [options] Install the latest version of Expo Client for iOS on the simulator install:android [options] Install the latest version of Expo Client for Android on a connected device or emulator ios [options] [project-dir] Opens your app in Expo in an iOS simulator on your computer login|signin [options] Login to Expo logout [options] Logout from exp.host path [options] Sets PATH for XDE prepare-detached-build [options] [project-dir] Prepares a detached project for building publish:history|ph [options] [project-dir] View a log of your published releases. publish:details|pd [options] [project-dir] View the details of a published release. publish:set|ps [options] [project-dir] Set a published release to be served from a specified channel. publish:rollback|pr [options] [project-dir] Rollback an update to a channel. publish|p [options] [project-dir] Publishes your project to exp.host register [options] Sign up for a new Expo account send [options] [project-dir] Sends a link to your project to a phone number or e-mail address start|r [options] [project-dir] Starts or restarts a local server for your app and gives you a URL to it url|u [options] [project-dir] Displays the URL you can use to view your project in Expo whoami|w [options] Checks with the server and then says who you are logged in as 通过传递–help标志查看关于特定命令的其他信息。例如，exp start --help输出: 12345678910111213141516171819202122232425262728Usage: start|r [options] [project-dir]Starts or restarts a local server for your app and gives you a URL to itOptions: -s, --send-to [dest] A phone number or e-mail address to send a link to -c, --clear Clear the React Native packager cache -a, --android Opens your app in Expo on a connected Android device -i, --ios Opens your app in Expo in a currently running iOS simulator on your computer -m, --host [mode] tunnel (default), lan, localhost. Type of host to use. &quot;tunnel&quot; allows you to view your link on other networks -p, --protocol [mode] exp (default), http, redirect. Type of protocol. &quot;exp&quot; is recommended right now --tunnel Same as --host tunnel --lan Same as --host lan --localhost Same as --host localhost --dev Turns dev flag on --no-dev Turns dev flag off --strict Turns strict flag on --no-strict Turns strict flag off --minify Turns minify flag on --no-minify Turns minify flag off --exp Same as --protocol exp --http Same as --protocol http --redirect Same as --protocol redirect --non-interactive Fails if an interactive prompt would be required to continue. --offline Allows this command to run while offline -h, --help output usage information 另外，你可以在离线模式下运行，将离线标志传递给android、ios或启动命令。 查看日志在Expo应用程序中写入日志就像在浏览器中一样:使用console.log, console.warn, console.error。注意:我们目前不支持远程调试模式之外的console.table。 推荐:使用Expo工具查看日志当你打开一个从XDE或exp中服务的应用程序时，该应用会将日志发送到服务器，并让它们方便地提供给你。这意味着你甚至不需要把你的设备连接到你的电脑上查看日志——事实上，如果有人打开了世界另一端的应用，你仍然可以从他们的设备上看到你的应用的日志。 XDE日志面板当您在XDE中打开一个项目时，日志窗口将被一分为二。您的应用程序日志显示在右边，而packager日志显示在左边。 XDE还允许您在任何打开应用程序的设备之间切换日志。 使用exp查看日志如果您使用我们的命令行工具exp，那么当您的项目运行时，packager日志和应用日志都将自动地流。为了停止您的项目(并结束日志流)，使用ctrl+c终止进程。 可选:手动访问设备日志虽然这通常是不必要的，但是如果你想看到你的设备上发生的所有事情，甚至是来自其他应用和操作系统本身的日志，你可以使用以下方法之一 查看iOS模拟器的日志选项1:使用GUI日志 在模拟器中，按⌘ + /或进入Debug -&gt; Open System Log-这两个打开一个日志窗口，显示设备上的所有日志，包括Expo应用程序的日志。 选项2:在终端打开它 运行instruments -s devices 找到你正在使用的模拟器的设备/操作系统版本，eg: iPhone 6s (9.2) [5083E2F9-29B4-421C-BDB5-893952F2B780] 括号中的部分结束时设备代码,因此您现在可以这样做: tail -f ~/Library/Logs/CoreSimulator/DEVICE_CODE/system.log, 如: tail -f ~/Library/Logs/CoreSimulator/5083E2F9-29B4-421C-BDB5-893952F2B780/system.log 查看iPhone的日志 brew install libimobiledevice 代入你的手机 idevicepair pair 在你的设备上按下 accept 运行 idevicesyslog 从Android设备或模拟器查看日志 确保安装了Android SDK 确保在您的设备上启用了USB调试(对于仿真器来说没有必要)。 运行adb logcat 调试使用 Simulator / Emulator在一个实际的设备上测试你的应用程序的性能和感觉是没有任何替代的，但是在调试过程中，你可能会更容易使用模拟器。 苹果将他们的模拟器称为“Simulator”，而谷歌将他们的模拟器称为“Emulator”。 iOS确保你有最新的Xcode(比如Mac App Store)。这包括iOS模拟器，以及其他一些工具。 Android在Android上，我们推荐使用标准模拟器的Genymotion模拟器——我们发现它更完整、更快、更容易使用。 下载Genymotion(免费版本)并遵循Genymotion安装指南。一旦你安装了Genymotion，创建一个虚拟设备——我们推荐一个Nexus 5, Android版本由你决定。启动虚拟设备时，它已经准备好了。如果你遇到任何问题，请遵循我们的Genymotion指南。 开发者菜单这个菜单使您能够访问几个对调试有用的函数。它也被称为调试菜单。调用它取决于您正在运行应用程序的设备。 iOS设备上摇一下这个装置。 在iOS模拟器在模拟器上的Mac上按Ctrl-Cmd-Z来模拟握手动作，或者按下Cmd+D。 在Genymotion在Genymotion的工具栏中按下“菜单”按钮，或者直接点击Cmd-m。 调试Javascript你可以使用Chrome调试器工具来调试Expo应用程序。与其在你的手机上运行你的应用程序的JavaScript，不如将它运行在Chrome浏览器的一个webworker中。然后，您可以设置断点、检查变量、执行代码等等，就像调试web应用程序时所做的那样。 为了确保最佳调试体验，首先将您的主机类型更改为LAN或localhost。如果你使用了启用调试的隧道，那么你很可能会经历太多的延迟，以至于你的应用无法使用。在这里，也确保检查开发模式。 如果你正在使用局域网，请确保你的设备与你的开发机器在同一个wifi网络上。这可能不会在某些公共网络上奏效。除非你在模拟器中，否则本地主机将无法工作，而且只有在你的设备通过usb连接到你的机器时，它才会在Android上运行。 在你的设备上打开这个应用，打开开发者菜单，然后点击Debug JS Remotely。这将打开一个浏览器选项卡URL http://localhost:19001/debugger-ui。从那里，您可以设置断点，并通过JavaScript控制台进行交互。当你完成的时候，摇动这个设备，停止Chrome的调试。 当使用Chrome调试时，console.log语句的行号在默认情况下不会起作用。要获得正确的行号，打开Chrome开发工具设置，进入“black装箱”选项卡，确保选中“Blackbox内容脚本”，并将expo/src/Logs.js添加为带有“Blackbox”选项的模式。 故障主机调试当您在XDE中打开一个项目时，当您在Android上打开时，XDE将自动告诉您的设备转发localhost:19000和19001到您的开发机器，只要您的设备被插入或模拟器正在运行。如果您正在使用localhost进行调试，并且它没有工作，关闭应用程序并在Android上再次打开它。或者，如果您安装了Android开发工具，您可以使用以下命令手动转发端口:adb reverse tcp:19000 tcp:19000 - adb reverse tcp:19001 tcp:19001 源码映射和异步函数源码映射和异步函数不是100%可靠的。在每种情况下，本地的响应都不能很好地使用Chrome的源代码映射，所以如果你想要确保你在正确的地方使用了断点，你应该直接从你的代码中使用调试器调用。 HTTP调试要调试应用程序的HTTP请求，您应该使用代理。以下的选项将全部奏效: Charles Proxy mitmproxy Fiddler 在Android上，代理设置应用程序有助于在调试和非调试模式之间切换。不幸的是，它还不能与Android M兼容。 未来的工作是在Chrome DevTools中显示网络请求。 热加载和重新加载热模块重载是一种快速重载更改的方法，不会在屏幕或导航堆栈中丢失状态。要启用，请调用开发人员菜单并点击“启用热重加载”项。而Live Reload将重新加载整个JS上下文，热模块重载将使您的调试周期更快。但是，确保您没有打开两个选项，因为这是不支持的行为。 其他调试技巧Dotan Nahum在他的“Debugging React Native Applications”中概述了其他有用的工具，比如监视桥梁信息和JSEventLoopWatchdog。 Genymotion 发布当您在开发项目时，您正在计算机上编写代码，当您使用XDE或exp时，服务器和本地包装器会在您的机器上运行，并将所有的源代码打包，并使其从URL中获得。您正在处理的项目的URL可能是这样的:exp://i3-kvb.ccheever.an-example.exp.direct:80。 exp.direct是我们用来进行隧道挖掘的领域，所以即使你在VPN或防火墙后面，任何有你的URL的设备都应该能够访问你的项目。这使得在你的手机上打开你的项目或发送给你正在和谁不在同一局域网的其他人更容易。 但是由于包装器和服务器在您的计算机上运行，如果您关闭了您的笔记本或关闭XDE，您将无法从该URL加载您的项目。“发布”是我们用来部署您的项目的术语。它使您的项目可以在一个持久的URL中使用，例如https://expo.io/@community/native-component-list。它还会将你的所有应用图片、字体和视频上传至CDN(在这里阅读更多)。 如何发布要发布项目，请单击XDE中的发布按钮。(在窗户的右上角。)如果您正在使用exp cli工具，则运行exp publish。不需要设置，继续创建一个新项目，并在不发生任何更改的情况下发布它，您将看到它是有效的。 当你这么做的时候，packager会将你所有的代码都缩小，并生成两个版本的代码(一个用于iOS，一个用于Android)，然后将这些代码上传到CDN上。您将获得一个链接，如https://exp.host/@ccheever/an-example，任何人都可以从这个项目中加载您的项目。 任何时候您想要部署一个更新，再次点击发布，新的版本将会在用户下一次打开它的时候立即可用。 部署到App Store和Play Store当你准备好将你的应用分发给最终用户时，你可以创建一个独立的应用程序二进制文件(ipa或apk文件)，然后将它放到iOS应用商店和Google Play商店中。看到分发应用程序。 这个独立的应用程序知道在你的应用发布的url中寻找更新，如果你发布了一个更新，那么下次用户打开你的应用时，他们会自动下载这个新版本。这些通常被称为“空中”(OTA)更新，其功能类似于CodePush，但它是内置在Expo上的，所以你不需要安装任何东西。 要配置你的应用程序处理JS更新的方式，请参见离线支持。 限制如果您在app.json中做出以下任何更改，您将需要重新构建应用程序的二进制文件，以便更改生效: 增加Expo SDK版本 在ios或安卓系统下修改任何东西 改变你的应用程序启动 改变你的应用程序图标 改变你的应用程序的名字 改变你的应用方案 改变你的facebookScheme 在assetBundlePatterns下改变你的捆绑资产 隐私您可以将项目的隐私设置在您的app.json配置文件中，将关键的“privacy”设置为“public”或“unlisted”。 这些选项的工作方式与YouTube上类似。未列出的项目url将是秘密的，除非您告诉人们关于它们或共享它们。公共项目可能会出现在其他开发人员身上。 链接介绍每个好的网站都有https://，https就是所谓的URL方案。不安全的网站使用http://，http是URL方案。我们把它叫做短期计划。 要从一个网站导航到另一个网站，你可以在网络上使用一个锚标签(&lt;a&gt;)。您还可以使用像窗口这样的JavaScript APIs window.history和window.location。 除了https之外，您可能还熟悉mailto scheme。当您打开mailto scheme的链接时，您的操作系统将打开一个已安装的邮件应用程序。如果您安装了多个邮件应用程序，那么您的操作系统可能会提示您选择一个。类似地，也有打电话和发短信的计划。请阅读下面关于内置URL方案的更多信息。 https和http是由您的浏览器处理的，但是可以通过使用不同的url方案链接到其他应用程序。例如，当你从Slack获得一个“神奇链接”的电子邮件时，“启动Slack”按钮是一个带有href的锚标签，它看起来像是:slack://secret/magic-login/other-secret。就像Slack一样，你可以告诉操作系统你想要处理一个定制的方案。请阅读有关配置方案的更多信息。当Slack应用打开时，它会收到用于打开它的URL，然后可以对通过URL提供的数据进行操作——在这种情况下，是一个将用户登录到特定服务器的秘密字符串。这通常被称为深度链接。阅读更多关于如何处理你的应用的深度链接。 深度链接与scheme并不是唯一可用的链接工具——我们正在努力为iOS上的通用链接添加支持，我们还支持与分支的延迟深度链接。我们将在未来的sdk中更新更多的信息。 从你的应用程序到其他应用程序内置的URL方案正如在简介中提到的，在每个平台上都存在一些核心功能的URL方案。下面是一个不完整的列表，但是涵盖了最常用的方案。 Scheme 描述 iOS Android mailto 打开邮件应用，如:mailto: support@expo.io ✅ ✅ tel 打开phone app, eg: tel:+123456789 ✅ ✅ sms 打开SMS app, eg: sms:+123456789 ✅ ✅ https / http 打开web浏览器app, eg: https://expo.io ✅ ✅ 打开你的应用程序的链接React Native中没有锚标记，所以我们不能写&lt;a href=&quot;https://expo.io&quot;&gt;。相反，我们必须使用Linking.openURL。 123import &#123; Linking &#125; from 'react-native';Linking.openURL('https://expo.io'); 通常，如果没有用户的请求，您就不会打开URL，这是一个简单的Anchor组件示例，当它被按下时，它将打开一个URL。 12345678910111213141516171819import &#123; Linking, Text &#125; from 'react-native';export default class Anchor extends React.Component &#123; _handlePress = () =&gt; &#123; Linking.openURL(this.props.href); this.props.onPress &amp;&amp; this.props.onPress(); &#125;; render() &#123; return ( &lt;Text &#123;...this.props&#125; onPress=&#123;this._handlePress&#125;&gt; &#123;this.props.children&#125; &lt;/Text&gt; ); &#125;&#125;// &lt;Anchor href=\"https://google.com\"&gt;Go to Google&lt;/Anchor&gt;// &lt;Anchor href=\"mailto://support@expo.io\"&gt;Go to Google&lt;/Anchor&gt; 使用Expo.WebBrowser，而不是链接打开web链接下面的例子说明了打开一个web链接使用Expo.WebBrowser.openBrowserAsync和React Native’s Linking.openURL的的区别。通常，WebBrowser是一个更好的选择，因为它是你的应用中的一个模式，用户可以很容易地关闭它并返回到你的应用。 123456789101112131415161718192021import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Button, Linking, View, StyleSheet &#125; from &apos;react-native&apos;;import &#123; Constants, WebBrowser &#125; from &apos;expo&apos;;export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Button title=&quot;Open URL with ReactNative.Linking&quot; onPress=&#123;this._handleOpenWithLinking&#125; style=&#123;styles.button&#125; /&gt; &lt;Button title=&quot;Open URL with Expo.WebBrowser&quot; onPress=&#123;this._handleOpenWithWebBrowser&#125; style=&#123;styles.button&#125; /&gt; &lt;/View&gt; ); &#125; 打开其他应用程序的链接如果你知道另一款应用的定制方案，你可以链接到它。一些服务提供了深度链接的文档，例如Lyft深度链接文档描述了如何直接链接到特定的位置和目的地: 1lyft://ridetype?id=lyft&amp;pickup[latitude]=37.764728&amp;pickup[longitude]=-122.422999&amp;destination[latitude]=37.7763592&amp;destination[longitude]=-122.4242038 用户可能没有安装Lyft应用，在这种情况下，你可能想打开应用/Play商店，或者让他们知道他们需要先安装。我们建议在这些情况下使用库react-native-app-link。 在iOS上，Linking.canOpenUrl需要额外的配置来查询其他应用的链接方案。你可以在你的app.json中使用ios.infoPlist键来指定应用程序需要查询的方案列表。例如: 123\"infoPlist\": &#123; \"LSApplicationQueriesSchemes\": [\"lyft\"]&#125; 如果你没有指定这个列表，不管设备是否安装了这个应用，Linking.canOpenUrl可能会返回false。注意，这种配置只能在独立的应用程序中进行测试，因为它需要在Expo客户端测试时不应用的本地更改。 链接到你的应用在Expo客户端在继续之前，花点时间学习如何在Expo客户端链接到你的应用程序是值得的。Expo客户端使用exp:// scheme，但如果我们链接到exp://没有任何地址，它将会打开应用到主界面。 在开发中,应用程序将会住在一个url像exp://wg-qka.community.app.exp.direct:80。当它被部署时，它将会出现在一个URL中，比如exp://exp.host/@community/with-webbrowser-redirect。如果你创建了一个网站，其中有一个链接，比如&lt;a href=&quot;exp://expo.io/@community/with-webbrowser-redirect&quot;&gt;Open my project&lt;/a&gt;。打开我的项目，然后在你的设备上打开这个网站，点击这个链接，它就会在Expo客户端打开你的应用程序。你可以通过使用Linking.openURL从另一个应用中链接到它。 在一个独立的应用程序要链接到你的独立应用，你需要为你的应用程序指定一个方案，你可以在你的app.json中注册一个方案，通过在scheme key下面添加一个字符串: 12345&#123; \"expo\": &#123; \"scheme\": \"myapp\" &#125;&#125; 一旦你建立了独立的应用，并将其安装到你的设备上，你就可以用myapp://的链接打开它。 Expo.Constants.linkingUri为了省去插入大量条件的麻烦，基于您所在的环境和硬编码url，我们提供了linkingUri常量。当您想要提供一个需要重定向到应用程序的url的服务时，您可以使用它，它将解决以下问题: 在Expo客户端发布的应用:exp://exp.host/@community/with-webbrowser-redirect/+ 独立出版的应用:myapp://+ 开发: exp://wg-qka.community.app.exp.direct:80/+ 您将注意到，在每个URL的末尾有一个/+ — 任何在/+之后被应用程序用来接收数据的东西，我们将在下一节中讨论。 注意:目前有一个已知的问题，在Android独立版本中没有出现+。我们希望在不久的版本中解决这个问题！ 在你的应用中处理链接有两种方法可以处理打开应用程序的url。 如果应用已经打开，应用就会被启动，链接事件就会被触发 您可以使用Linking.addEventListener(‘url’, callback)来处理这些事件。 如果这个应用程序还没有打开，它就会打开，url会作为initialURL传递 您可以使用Linking.getInitialURL来处理这些事件——如果有的话，它返回一个解析到url的Promise。 请参见下面的示例，以查看这些示例。 通过URL将数据传递给应用程序如果我想将一些数据传递到我的应用程序中，我可以在常量Constants.linkingUri的末尾添加一个查询字符串。然后，您可以使用类似于qs的东西来解析查询字符串。 当处理用于打开/前景应用的URL时，它看起来是这样的: 12345678_handleUrl = (url) =&gt; &#123; this.setState(&#123; url &#125;); let queryString = url.replace(Constants.linkingUri, ''); if (queryString) &#123; let data = qs.parse(queryString); alert(`Linked to app with data: $&#123;JSON.stringify(data)&#125;`); &#125;&#125; 如果你打开一个URL，像${Constants.linkingUri}?hello=world&amp;goodbye=now，这将会alert {hello: &#39;world&#39;, goodbye: &#39;now&#39;}。 例子:从网页浏览器链接到你的应用示例项目examples/with-webbrowser-redirect演示了如何从WebBrowser重定向并从查询字符串中获取数据。在Expo上试试吧。 示例:使用链接进行身份验证链接到你的应用的一个常见的用例是在打开一个网页浏览器后重定向回你的应用。例如，您可以在屏幕上打开一个web浏览器会话，当用户成功登录时，您可以使用该方案将您的网站重定向到您的应用程序，并将身份验证令牌和其他数据附加到URL。 注意:如果尝试使用链接。openURL打开web浏览器进行身份验证，然后你的应用可能会被苹果拒绝，原因是糟糕或令人困惑的用户体验。WebBrowser.openBrowserAsync打开了一个模态的浏览器窗口，外观和感觉都很好，苹果公司也批准了。 要查看使用web浏览器进行身份验证的完整示例，请参见examples/with-facebook-auth。目前，Facebook认证要求你部署一个小的webserver来重定向到你的应用程序(正如在这个例子中所描述的那样)，因为Facebook不允许你重定向到自定义的方案，而Expo正在为解决这个问题而努力。在Expo上试一试。 另一个使用WebBrowser进行身份验证的例子可以在expo/auth0-example中找到。 当不使用深层链接时这是在你的应用中建立深度链接的最简单方法，因为它只需要很少的配置。 主要的问题是，如果用户没有安装你的应用，并按照它的自定义模式链接到你的应用程序，那么他们的操作系统将会显示页面不能打开，但不能提供更多的信息。这不是一次伟大的经历。在浏览器中没有办法解决这个问题。 此外，许多消息应用程序不使用自定义方案自动生成url——例如，exp://exp.host/@community/native-component-list可能只是在浏览器中显示为纯文本，而不是作为链接(exp://exp.host/@community/native- componentlist)。 Expo &amp; “Create React Native App”Create React Native App允许您构建一个没有任何构建配置的React Native app。这对您来说可能听起来很熟悉，因为世博会也会这样做——当您用XDE或exp创建一个项目时，您不必处理Xcode或Android Studio配置文件，它只是工作。本指南旨在概述博览会与CRNA (create-react-native-app)之间的一些关键区别。 Expo是如何工作的 升级 Expo","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"React Native","slug":"React/React-Native","permalink":"https://jigangduan.github.io/categories/React/React-Native/"},{"name":"Expo","slug":"React/React-Native/Expo","permalink":"https://jigangduan.github.io/categories/React/React-Native/Expo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"react-native","slug":"react-native","permalink":"https://jigangduan.github.io/tags/react-native/"},{"name":"expo","slug":"expo","permalink":"https://jigangduan.github.io/tags/expo/"}]},{"title":"Expo 介绍","slug":"expo-introduce","date":"2018-02-08T03:38:08.000Z","updated":"2020-07-25T02:57:18.200Z","comments":true,"path":"2018/02/08/expo-introduce/","link":"","permalink":"https://jigangduan.github.io/2018/02/08/expo-introduce/","excerpt":"how-to-become-a-react-native-developer 介绍Expo是一套工具、库和服务，让你可以通过编写JavaScript来构建本地的iOS和Android应用程序。 使用Expo工作详细介绍如何使用Expo开发环境和工具的各个方面。如果你对Expo完全陌生，一定要确保你已经安装好了工具并四处看看。在此之后，您可能想要阅读并运行以创建您的第一个项目。","text":"how-to-become-a-react-native-developer 介绍Expo是一套工具、库和服务，让你可以通过编写JavaScript来构建本地的iOS和Android应用程序。 使用Expo工作详细介绍如何使用Expo开发环境和工具的各个方面。如果你对Expo完全陌生，一定要确保你已经安装好了工具并四处看看。在此之后，您可能想要阅读并运行以创建您的第一个项目。 快速入门介绍Expo应用程序是带有Expo SDK的本地应用程序。SDK是一个native-and-JS库，它提供了对设备的系统功能的访问(像照相机、联系人、本地存储和其他硬件)。这意味着您不需要使用Xcode或Android Studio，也不需要编写任何本地代码，而且它也使您的纯js项目非常便于移植，因为它可以在包含世博会SDK的任何本地环境中运行。 Expo还提供了UI组件来处理各种各样的用例，这些用例几乎所有的应用都能覆盖，但没有被融入到React Native中，比如图标、模糊视图等等。 最后，Expo SDK提供了对服务的访问，这些服务通常是一种很难管理的服务，但几乎每个应用都需要它。其中最受欢迎的是:Expo可以为你管理你的资产，它可以帮你处理推送通知，它还可以构建原生二进制文件，这些二进制文件已经准备好部署到app store中。 考虑使用Expo吗? 如果你想了解一下Expo提供了什么，你可能想要熟悉一下Expo项目的生命周期，它描述了你是如何进入一个产品的iOS和Android应用的场景。 为了进一步解释，检查经常被问到的问题也很好。 准备好开始了吗? 首先安装工具，看看周围的情况。 通过跟踪和运行指南来完成你的第一个项目。 如果您还不熟悉React和React Native，那么您可以使用React Native Express来引导您的知识。 安装开发应用程序你需要有两种工具——一个桌面开发工具和一个移动客户端来打开你的应用程序。 桌面开发工具:XDEXDE代表Expo开发环境。它是一个独立的桌面应用程序，包含了所有需要启动的依赖项。 为macOS、Windows(64位)或Linux下载最新版本的XDE。 在Linux上，打开chmod a+x xde.AppImage 和 ./xde.AppImage。 移动客户端:iOS和Android ExpoExpo客户端就像一个用Expo搭建的应用的浏览器。当你在你的项目上启动XDE时，它会为你生成一个独特的开发URL，你可以从iOS或Android的世博会客户端访问它，无论是在真实的设备上，还是在模拟器上。 在你的设备下载Android从Play Store 或 iOS从App Store 所需的Android和iOS版本:最低的Android版本支持是Android 4.4，最小的iOS版本是iOS 9.0。 您不需要在模拟器上手动安装世博会客户端，因为XDE会自动完成这个操作。请参阅本指南的下一部分。 iOS模拟器通过苹果App Store安装Xcode。需要一段时间，去打个盹。接下来，打开Xcode，进入首选项并单击组件选项卡，从列表中安装模拟器。 一旦模拟器打开，你在XDE中打开了一个项目，你可以在XDE上打开iOS模拟器，它会将Expo客户端安装到模拟器上，并在里面打开你的应用。 不工作吗? 有时XDE会自动安装世博客户端，通常是由于你的环境或Xcode工具链上的小差异造成的。如果您需要手动在模拟器上安装世博会客户端，您可以遵循以下步骤: 下载最新的模拟器构建。 提取存档的内容。你应该得到一个像指数.x.xxx这样的目录。 确保模拟器正在运行。 在终端中，运行 xcrun simctl install booted [path to extracted directory] Android模拟器下载Genymotion(免费版)，并遵循Genymotion安装指南。一旦你安装了Genymotion，创建了一个虚拟设备——我们推荐Nexus 5，Android版本就会由你来决定。在准备好时启动虚拟设备。 一旦模拟器打开，你在XDE中打开了一个项目，你就可以在XDE的Android平台上发布开放项目，它会将Expo客户端安装到模拟器上，并在里面打开你的应用程序。如果你遇到任何问题，请遵循我们的Genymotion指南。 Node.js要想开始Expo，你不一定需要安装了Node.js，但一旦你开始构建东西，你就会想要拥有它。下载最新版本的Node.js。 Watchman一些macOS用户会遇到问题，如果他们没有安装在他们的机器上，那么我们建议您安装Watchman。当用户改变时，他们会观察文件和记录，然后触发相应的动作，并在内部进行反应。下载并安装Watchman。 XDE之旅登录屏幕当你第一次打开XDE时，你会在屏幕上看到这个标志。如果你已经有了一个账户，请继续登录。如果你不这样做，要么和Github签约，要么注册一个账户。 主屏幕成功,你签署!在这个屏幕上，您可能想要创建一个新项目，或者打开一个现有的项目。为了方便，我们列出了一些最近开放的项目。 项目对话框点击项目，你就会看到你能做的一切。当然，你不能关闭一个项目或者在finder中显示它，因为你还没有打开一个项目。 退出,如果你想要在任何时候，你都可以点击右上方的用户名并退出。或注销。谁能真正同意这一看法呢? 项目屏幕所以我们已经开放了一个新项目。左边的窗格是React包装器，您可以在它的启动和运行中了解更多关于Expo的工作。右边的面板是用于设备日志的，您可以在查看日志中看到更多的内容。 分享向任何有互联网连接的人发送你的应用程序的链接。如果你的设备没有连接到你的电脑上，这也很有用。 设备上打开设备按钮可以让你在设备或模拟器上快速打开你的应用。更多的阅读启动和运行。 开发模式您通常希望在开发模式中使用您的项目。这使它运行得稍微慢一些，因为它增加了很多运行时验证的代码来警告您潜在的问题，但是它也提供了实时重载、热重载、远程调试和元素检查器的访问权。如果你想测试与性能相关的任何东西，禁用开发模式并重新加载你的应用。 项目对话框(与项目打开)除了主屏幕提供的选项外，我们还提供了一些快捷方式，比如在finder中显示项目目录。 发布当你在你的项目上工作的时候，它会得到一个临时的URL，从你的电脑上提供。当你准备好与他人分享这个项目时，你可以 发布 这个项目来获得一个永久的URL(类似expo.io/@your-username/your-app-slug)，任何人都可以和Expo的客户一起开放。 当您点击XDE中的Publish按钮时，您将被要求确认您希望您的项目对公众开放。XDE需要花一些时间来生成你的迷你JS包，并将你的资产上传到我们的服务器上，一旦完成，打印出你的应用发布的URL。你可以读到更多的细节，关于在Expo如何运作和发布指南方面，发布是如何运作的。 项目生命周期Expo让你很容易开始编写应用程序，但Expo也可以将你的项目带向生产。以下是您可能在此过程中使用的工具和服务的概述。 本指南旨在对Expo提供的内容进行高层次的解释。出于好奇，这些主题的技术实现将在这里更详细地介绍。 创建一个世博会项目您可以使用我们的桌面工具和文本编辑器创建一个新的Expo项目。查看启动并运行一个快速指南来创建一个项目，在一个设备上运行它，并进行更改。 Expo应用程序是本地应用程序。最快的方法是使用启动并运行指南，但是你也可以转换一个已有的React Native应用，或者使用一个由create-react-native-app生成的项目。 本地开发当你在一个Expo项目上工作时，我们会从你的本地电脑上为你的项目提供一个实例。如果你关闭了这个项目或者关闭了你的电脑，你的开发项目就会停止。 在这段时间里，你可以使用一个叫做Expo Client的预构建的iOS/Android应用来测试你的项目。它要求您的计算机为您的项目的本地副本(通过localhost、LAN或隧道)，下载它，并运行它。您可以利用各种开发工具，如调试、流设备日志、检查元素、热模块重新加载等等。 发布您的项目如果你点击XDE的 发布 按钮，我们就会将你的应用的一个迷你版复制到我们的CDN上，并给你一个可分享的网址，你的地址，expo.io/@your-username/your-app-slug。 你可以立即与任何拥有Expo Client应用程序的人分享这个链接，阅读更多关于这里的发布。 更新应用程序您可以在不影响用户的情况下继续在本地进行更改。任何时候你发布应用程序的修改，你的新版本就会立即被任何有链接的人使用。 我们经常发布对Expo SDK的更新。每次更新包括说明如何升级你的项目。如果您决定更新我们的SDK的更新版本，那么旧版本的副本将继续正常工作。用户将下载他们的客户端支持的最新版本。 部署到苹果应用商店和Google Play商店当你准备在苹果应用商店和Google Play商店正式发布你的应用时，世博会就可以为你带来部署了.ipa和.apk，准备提交给苹果和谷歌。我们在我们的服务器上生成它们，所以你仍然不需要任何苹果或谷歌软件。参见关于分发应用程序的文档。 更改本地代码你可以在app Store和Play商店中使用你的应用程序，同时只编写JS。然而，如果你遇到了Expo所没有的特殊的高级需求，我们就提供了分离到ExpoKit的能力，这是你的Expo项目的本地Xcode和Android工作室的代表。 ⚠️:如果您选择与Expo分开，一些Expo服务将不复存在。例如，我们不能再为您生成独立的构建。您需要自己管理本机构建。 额外的资源以下资源对于学习Expo和它所依赖的一些项目是非常有用的。 Expo 博客 Exposition——官方博客，每个月我们都会发布新闻稿和其他与Expo相关的内容。 课程 使用Expo repl.it - React Native - 在接下来的5分钟内构建你的第一个应用程序 (免费) React Europe - React Native工作室视频在YouTube的介绍 (免费) RMOTR - React Native &amp; Expo 移动开发 (付费) Udemy - React Native: Stephen Grider的高级概念 (付费) Udacity - React Nanodegree (付费) React Native React Native Express - React Native最佳实践入门! 这是对 React 和 React Native的构建块的一次演练. 官方 React Native 文档 React Native 基本原理 (egadad.io视频课程) 动态 React Native UI 元素 (egadad.io的视频课程) 学习 React Native (书) Jani Eväkallio的聊天教程 会谈 React Native Europe - Snack的建立 React Europe - Expo Snack React Conf - 创建 React Native App Reactive - 从React web 到本地移动 React Europe - 建造 Android的 li.st以 Expo 和 React Native 哈佛大学CS50课程 - 很容易就能建立React Native应用 Apollo Day - GraphQL at Expo React React Express React 课程 Egghead.io - 几个播放列表，包括React和Redux基本原理. 官方 React 文档 JavaScript ES6 Katas - 为了让自己熟悉新JavaScript特性，可以让自己熟悉使用React Native的新JavaScript特性","categories":[{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"React Native","slug":"React/React-Native","permalink":"https://jigangduan.github.io/categories/React/React-Native/"},{"name":"Expo","slug":"React/React-Native/Expo","permalink":"https://jigangduan.github.io/categories/React/React-Native/Expo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"react-native","slug":"react-native","permalink":"https://jigangduan.github.io/tags/react-native/"},{"name":"expo","slug":"expo","permalink":"https://jigangduan.github.io/tags/expo/"}]},{"title":"猫的JavaScript","slug":"jsforcats","date":"2018-02-06T04:24:23.000Z","updated":"2020-07-25T02:57:18.210Z","comments":true,"path":"2018/02/06/jsforcats/","link":"","permalink":"https://jigangduan.github.io/2018/02/06/jsforcats/","excerpt":"新程序员简介你的人类伙伴也可以轻易的做到！ JavaScript是一种编程语言，或者，换句话说，是一种计算机被指令去做事情的方式。就像一个人用“口哨”和“猫叫”控制人类一样，一个人控制着用编程语言编写的语句。所有的web浏览器都能理解JavaScript，您可以利用它来让web页面做一些疯狂的事情！ JavaScript是一种使web页面更具交互性的方法。如今，JavaScript在很多地方运行，而不仅仅是web浏览器——它运行在web服务器、手机甚至是机器人上。这篇文章将会教你一些JavaScript基础知识，这样你就可以随时启动和运行。 实际时间:没有的很多。大概一两个小时吧。因为你是一只猫你不太可能跑，更有可能在太阳下躺着","text":"新程序员简介你的人类伙伴也可以轻易的做到！ JavaScript是一种编程语言，或者，换句话说，是一种计算机被指令去做事情的方式。就像一个人用“口哨”和“猫叫”控制人类一样，一个人控制着用编程语言编写的语句。所有的web浏览器都能理解JavaScript，您可以利用它来让web页面做一些疯狂的事情！ JavaScript是一种使web页面更具交互性的方法。如今，JavaScript在很多地方运行，而不仅仅是web浏览器——它运行在web服务器、手机甚至是机器人上。这篇文章将会教你一些JavaScript基础知识，这样你就可以随时启动和运行。 实际时间:没有的很多。大概一两个小时吧。因为你是一只猫你不太可能跑，更有可能在太阳下躺着 不要做一只胆小的猫即使是编程，你也会永远地站在你的脚上。与在笔记本电脑上的一杯水不同，这些教程中的任何东西都不会对你的电脑造成任何损害，即使你键入命令或者点击错误的按钮。像猫一样，计算机程序员总是犯错误:拼写错误，忘记引号或括弧，忘记基本的功能(和yarn，lasers)的工作。程序员更关心的是让它最终工作，而不是让它第一次工作。学习的最好方法就是犯错误！ 所以，不要成为一只胆小的猫！最糟糕的情况是，如果您陷入困境，您可能不得不在web浏览器中刷新这一页面。不过，不要担心，这种情况很少发生。 基础知识现在这个页面上有JavaScript运行。让我们稍微玩一下。为了简单起见，我假设您使用Google Chrome来阅读这一页(如果您不使用Chrome的话，这对我们两个人来说可能更容易些)。 首先，右键单击屏幕上的任何地方，然后单击检查元素，然后单击控制台选项卡。你应该看到这样的东西: 这是一个控制台，也称为“命令行”或“终端”。基本上，这是一种将一件事一件一件地输入到电脑里的方法，然后立即让电脑回复。它们作为一种学习工具非常有用(我几乎每天都在使用控制台)。 控制台有一些很酷的东西。在这里，我开始输入一些东西，控制台正在帮助我，给我一个列表，让我可以继续输入所有可能的东西！另一件你可以做的事情是在控制台中输入1+1，然后点击Enter键，看看会发生什么。 使用控制台是学习JavaScript的一个非常重要的部分。如果你不知道某件事是否有效，或者你的命令是什么，那就去控制台，把它弄清楚！这里有一个例子: Strings因为我是一只猫，所以我想用那些该死的狗,把狗狗的每一个单词都替换掉。首先进入你的控制台，输入几句包含狗至少一次的句子。在JavaScript中，一串字母、数字、单词或其他任何东西都被称为字符串(如字符串中的字符串)。字符串必须以引号开始和结束。单&#39;或双&quot;，只是确保你在开始时使用的是一样的。 看到令人讨厌的错误消息了吗?别担心，你没有违反任何法律。当机器人告诉你你的程序有问题时，同步错误就是它听起来的样子。头两个句子在开头和结尾都有匹配的引号，但是当我把单引号和双引号混合在一起时，我就感到害怕了 好，为了修复其中的一个句子(用我们的增强版本替换dog)，我们必须先保存原来的句子，这样当我们替换魔法的时候，我们可以把它叫起来。注意，当我们将字符串输入到控制台时，该字符串是如何以红色重复的?这是因为我们没有告诉它要在任何地方保存这个句子，所以它才会返回(或者如果我们把事情搞砸了，它会给我们一个错误)。 值和变量值是JavaScript中最简单的组件。1是一个值，true是一个值，”hello”是一个值，function() {}是一个值，list会继续下去！JavaScript中有几种不同类型的值，但我们不需要马上处理它们——您将会自然地了解到它们的代码！ 为了存储值，我们使用变量。“变量”这个词的意思是“可以改变”，因为变量可以存储许多不同类型的值，并且可以多次更改它们的值。它们很像邮箱。我们把一些东西放在一个变量里，比如我们的句子，然后给这个变量一个地址，我们可以用它来查找这个句子。在现实生活中，邮箱必须有PO Box号码，但在JavaScript中，通常只使用小写字母或数字，而不需要任何空格。 var是变量的简写，而等号的意思是把右边的东西放在左边的东西上。正如你所看到的，既然我们将句子存储在一个变量中，控制台不会立即返回我们的句子，而是给我们未定义的意思，这意味着没有任何东西可以返回。 如果您简单地将一个变量名输入到控制台，它将输出该变量中存储的值。关于变量的一个注释是，默认情况下，当切换到另一个页面时，它们会消失。例如，如果我在Chrome中点击Refresh按钮，我的dogSentence变量就会被抹去，就像它从来没有存在过一样。但现在不要太担心这一点——你可以在键盘上敲击键盘上的上或下箭头，来完成你最近输入的所有东西。 函数既然我们已经将语句存储在一个变量中，那么让我们更改一个存储在其中的单词！我们可以通过执行一个函数来做到这一点。函数是一种类型的值，它为我们提供一个特定的功能(也就是目的或行为)。我认为，把它们称为“行动”听起来很奇怪，所以他们用“函数”一词来代替。 JavaScript有一个名为replace的函数，它完全符合我们的要求！函数在括号中(0、1或多个)中接受任意数量的值，并返回任何值(未定义的)或更改的字符串。替换函数可用于任何字符串，并具有两个值:要取出的字符和要交换的字符。描述这些东西会让你感到困惑所以这里是一个视觉上的例子: 请注意，即使在我们运行替换之后，它的值是一样的吗?这是因为replace函数(以及大多数JavaScript函数)接受我们赋予它的值，并返回一个新的值，而不需要修改传入的值。因为我们没有存储结果(在替换函数的左边没有=)，它只是在我们的控制台中打印了返回值。 标准库您可能想知道在JavaScript中还有哪些函数可用。答案:一吨。在MDN(一个由Mozilla运行的站点拥有许多关于web技术的漂亮信息)，您可以在MDN中了解到许多 构建的标准库 。例如，这里是关于JavaScript的数学对象的MDN页面。 第三方JavaScript还有很多JavaScript代码都 没有内置。来自第三方的JavaScript通常被称为“库”或“插件”。我最喜欢的一个叫做 Underscore.js 。让我们去抓取它并载入到我们的页面！第一次去Underscore网站,http://underscorejs.org/,点击下载链接(我通常使用开发版本,因为他们更容易读但都将给你相同的基本功能),然后复制到您的剪贴板的所有代码(你可以使用从编辑菜单中选择所有选择的一切)。然后把它粘贴到你的控制台，点击回车。现在，您的浏览器中有一个新的变量:_。Underscore给你提供了很多有用的功能。稍后我们将学习更多关于如何使用它们的知识。 制作新函数你并不局限于使用他人的函数——你也可以自己写。这很简单!让我们创建一个名为makeMoreExciting的函数，它在字符串的末尾添加了一些感叹号。 123function makeMoreExciting(string) &#123; return string + '!!!!'&#125; 在我的脑海里，我这样大声地读出来:“有一个函数叫做 make more exciting，它接收一个字符串，然后返回一个新的字符串，这个字符串的末尾有很多感叹号。如果我们不使用函数，我们将如何在控制台中手动写入。 表达式string + &#39;!!!!&#39;返回一个新的字符串，我们的变量名为string的变量保持不变(因为我们从未将它更新为=)。 让我们使用我们的函数，而不是手动操作。首先，将该函数粘贴到控制台，然后通过传入字符串来调用函数: 您也可以通过传递指向一个字符串的变量来调用同一个函数(在上面的例子中，我们只是将字符串直接输入为一个值，而不是先将其保存到一个变量中): MakeMoreExciting (sentence)的相当于sentence + ‘!!!!’。如果我们想要修改in-place(更新)sentence的值呢?简单地将函数的返回值保存回我们的sentence变量: 12var sentence = \"time for a nap\"sentence = makeMoreExciting(sentence) 现在sentence里有了感叹号！注意，当您初始化一个变量时，您只需要使用var，这是您第一次使用它。在此之后，您不应该使用var，除非您想要重新初始化(重新设置/清除/清空)变量。 如果我们在函数中取出return statement会发生什么? 为什么sentence是空的吗?因为函数在默认情况下返回undefined！您可以通过返回某个值来返回一个值。函数应该具有一个值，如果它们改变了值或者创建了一个新的值，这个值应该在以后被使用，返回一个值(有趣的事实:这个样式的一个奇特的术语是函数式编程)。这是另一个函数，它不返回任何东西，而是使用另一种方法来显示输出: 12345function yellIt(string) &#123; string = string.toUpperCase() string = makeMoreExciting(string) console.log(string)&#125; 这个函数，yellIt，使用我们之前的函数makeMoreExciting，以及内置的字符串方法toUpperCase。方法只是一个函数的名字，当它属于某个东西的时候——在这个例子中，toUpperCase是一个属于字符串的函数，所以我们可以把它称为一个方法或者一个函数。另一方面，makeMoreExciting不属于任何人，因此将其称为一种方法是不正确的(我知道这是一种混淆)。 该函数的最后一行是另一个内置函数，它只接受您提供的任何值，并将其输出到控制台 那么上面的yellIt函数有什么问题吗?视情况而定!以下是两种主要的功能: 修改或创建值并返回它们的函数 函数接受值并执行一些无法返回的操作 console.log是第二种功能的例子:它把东西打印到你的控制台——你可以用眼睛看到的动作，但这不能用JavaScript的值来表示。我自己的经验法则是，把这两种函数分开，这是我重写yellIt函数的方式: 123456function yellIt(string) &#123; string = string.toUpperCase() return makeMoreExciting(string)&#125;console.log(yellIt(\"i fear no human\")) yellIt变得更通用，这意味着它只做一两个简单的小事情，不知道如何将自己打印到控制台——在函数定义之外，该部分总是可以编程的。 循环现在我们已经有了一些基本的技能我们可以开始变得懒惰。什么? !是的，这是对的:编程就是懒惰。Perl编程语言的发明者拉里沃尔称，懒惰是优秀程序员最重要的美德。如果电脑不存在，你将不得不手工做各种繁琐的工作，但如果你学会编程，你就可以整天躺在太阳底下，而电脑则可以为你运行程序。这是一种充满了放松的光荣的生活方式！ 循环是利用计算机的力量的最重要的方法之一。还记得早些时候Underscore.js吗?确保你在页面上加载了它(记住:你可以在你的键盘上敲上几下箭头，然后按下回车键，如果你需要的话)，然后在你的控制台中复制/粘贴这个。 1234function logANumber(someNumber) &#123; console.log(someNumber)&#125;_.times(10, logANumber) 这段代码使用的是Underscore的times方法，它包含1个数字和1个函数，然后从0开始，10个步骤是1，用每个步骤的数字来调用这个函数。 如果我们要手动写出上面的代码，它会是这样的: 12345678910logANumber(0)logANumber(1)logANumber(2)logANumber(3)logANumber(4)logANumber(5)logANumber(6)logANumber(7)logANumber(8)logANumber(9) 但是猫拒绝做这样的不必要的手工工作，所以我们必须总是问自己:“我是不是用最懒的方式做这件事?” 那么为什么这个叫做循环呢?可以这样想:如果我们要用JavaScript数组写出10个数字(从0到9)，它会是这样的: 1var zeroThroughTen = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 真正的times是访问每个数字并重复一个任务:在上面的例子中，任务是用当前的数字调用logANumber函数。以这种方式重复任务被称为循环遍历数组。 Arrays我已经提过几次了，但让我们花一分钟时间来了解它们。想象一下，你需要跟踪所有的朋友。好吧，数组会做得很好。想象一个数组，就像一个排序列表，你可以保存大量的东西。 这就是你的制作方法: 1var myCatFriends = [\"bill\", \"tabby\", \"ceiling\"] 甜蜜的!现在你有了一份你的猫友的名单。 元素(也就是数组中的单一项)存储在数组中，从0开始，从那里开始计数。myCatFriends[0]返回bill和myCatFriends[1]返回tabby。等等。 为了让你的好友离开你的全新的数组，你可以直接访问一个元素: 1console.log(myCatFriends[0]) 如果你在另一个晚上在最时髦的猫咪俱乐部里做了一个全新的猫咪朋友，你想把它们加到你的名单上，那就太简单了:myCatFriends.push(&quot;super hip cat&quot;)。 为了检查新猫是否能进入你的数组，你可以使用.length: 注意到push是如何返回长度的?方便的!还需要注意的是，数组将始终保持顺序，这意味着它们将记住您添加或定义的顺序的顺序。并不是所有的JavaScript都保存了排序，所以要记住数组的特殊属性！ Objects数组对列表很好，但是对于其他任务，它们可能很难处理。想想我们的猫朋友圈吧。如果您还想存储更多的名称，又该如何呢? 123var myCatFriends = [\"bill\", \"tabby\", \"ceiling\"]var lastNames = [\"the cat\", \"cat\", \"cat\"]var addresses = [\"The Alley\", \"Grandmas House\", \"Attic\"] 有时在一个变量中包含所有的地址或名称是很好的。但有时你有一只猫，让我们说bill，你只是想查一下那只猫的地址。使用数组需要大量的工作，因为你不能只说“嗨，数组，给我Bill的地址”因为“Bill”在一个数组中，他的地址是完全不同的数组。 这可能是很脆弱的，因为如果我们的数组改变了，并且我们在开始的时候添加了一个新的cat，那么我们就必须更新我们的账单变量，以指向在数组中新的Bill信息的位置！这里有一个更容易维护的方式来存储这样的信息:使用对象: 123var firstCat = &#123; name: \"bill\", lastName: \"the cat\", address: \"The Alley\" &#125;var secondCat = &#123; name: \"tabby\", lastName: \"cat\", address: \"Grandmas House\" &#125;var thirdCat = &#123; name: \"ceiling\", lastName: \"cat\", address: \"Attic\" &#125; 我们为什么要这样做呢?因为现在我们为每只猫都有一个变量，我们可以用它来让猫的值更方便、更容易读懂。 你可以把钥匙放在钥匙圈上。每一个都是针对特定的门，如果你的钥匙上有漂亮的标签，你就能快速打开门。事实上，左边的东西被称为键(也称为属性)，右边的东西是值。 你可以把对象想象为钥匙环上的钥匙。每一个都是针对特定的门，如果你的钥匙上有漂亮的标签，你就能快速打开门。事实上，左边的东西被称为键(也称为属性)，右边的东西是值。 12// an object with a single key 'name' and single value 'bill'&#123; name: 'bill' &#125; 如果你能把数据放到对象中，你为什么要使用数组呢?因为对象不记得你设置的键的顺序，你可能会进入这样一个对象: 1&#123; date: \"10/20/2012\", diary: \"slept a bit today\", name: \"Charles\" &#125; 但是电脑可以把它还给你: 1&#123; diary: \"slept a bit today\", name: \"Charles\", date: \"10/20/2012\" &#125; 还是这样! 1&#123; name: \"Charles\", diary: \"slept a bit today\", date: \"10/20/2012\" &#125; 所以你不能相信对象中键的顺序。如果你想要变得非常漂亮，你可以做一个充满了对象的数组，或者一个充满数组的对象！ 1234567891011121314151617181920var moodLog = [ &#123; date: \"10/20/2012\", mood: \"catnipped\" &#125;, &#123; date: \"10/21/2012\", mood: \"nonplussed\" &#125;, &#123; date: \"10/22/2012\", mood: \"purring\" &#125;]// ordered from least to most favoritevar favorites = &#123; treats: [\"bird sighting\", \"belly rub\", \"catnip\"], napSpots: [\"couch\", \"planter box\", \"human face\"]&#125; 当你把不同的东西组合在一起时，你就在制造数据结构体，就像乐高积木一样！ CallbacksCallbacks并不是JavaScript像对象或数组那样的特性，而是使用函数的一种特定方式。要理解Callbacks为什么是有用的，您首先必须了解异步(通常简称为异步)编程。根据定义，异步代码是以一种非同步的方式编写的。同步代码易于理解和编写。这里有一个例子来说明: 12var photo = download('http://foo-chan.com/images/sp.jpg')uploadPhotoTweet(photo, '@maxogden') 这段同步的伪代码下载了一张可爱的猫照片，然后将照片上传到twitter，并在@maxogden上推文。很简单的! 这段代码是同步的，因为为了将照片上传至推文，照片下载必须完成。这意味着第2行不能运行，直到第1行中的任务完全完成。如果我们要实现这个伪代码下载我们想要确保“阻塞”执行,直到下载完成了,这意味着它将防止其他JavaScript执行,直到完成,当下载完成后,将un-block JavaScript执行和2号线将执行。 同步代码对于快速发生的事情很好，但是对于那些需要保存、加载、下载或上传的东西来说是很可怕的。如果你正在下载照片的服务器很慢，或者你正在使用的网络连接很慢，或者你正在运行的电脑上运行的电脑上有太多的youtube视频标签，运行速度很慢，怎么办?这意味着，在第2行开始运行之前，它可能需要等待几分钟的等待。同时，由于页面上的所有JavaScript都在下载过程中被阻止运行，网页会完全冻结，直到下载完成后才会出现响应。 应该不惜一切代价避免阻塞的执行，尤其是这样做会使程序冻结或变得无响应。让我们假设上面的照片需要一秒钟的时间下载。为了说明一秒钟对一台现代计算机有多长的时间，这里有一个程序来测试JavaScript在一秒内可以处理多少任务。 1234567891011121314151617function measureLoopSpeed() &#123; var count = 0 function addOne() &#123; count = count + 1 &#125; // Date.now() returns a big number representing the number of // milliseconds that have elapsed since Jan 01 1970 var now = Date.now() // Loop until Date.now() is 1000 milliseconds (1 second) or more into // the future from when we started looping. On each loop, call addOne while (Date.now() - now &lt; 1000) addOne() // Finally it has been &gt;= 1000ms, so let's print out our total count console.log(count)&#125;measureLoopSpeed() 将上面的代码复制到你的JavaScript控制台，一秒钟后它就会打印出一个数字。在我的电脑上，我得到了8527360，大约850万。在一秒内，JavaScript可以调用addOne函数850万次！因此，如果您有同步代码下载照片，而照片下载需要一秒，这意味着您可能会阻止850万操作的发生，而JavaScript执行被阻塞。 有些语言有一个名为sleep的函数，它可以阻塞执行数秒。例如，在使用sleep的Mac OS上运行Terminal.app的bash代码。当您运行命令sleep 3 &amp;&amp; echo &#39;done sleeping now时。在打印出来之前，它会阻塞3秒。 JavaScript没有sleep函数。既然你是一只猫，你可能会问自己:“我为什么要学习一门不涉及睡眠的编程语言?”但留在我身边。与其依赖睡眠等待事情的发生，JavaScript的设计还鼓励使用函数。如果在执行任务B之前必须等待任务A完成，则将任务B的所有代码都放到一个函数中，在完成任务时只调用该函数。 例如，这是一种封闭风格的代码: 12a()b() 这是一种非阻塞的风格: 1a(b) 在非阻塞版本中b是一个callback。在阻塞版本中a和b都是called/invoked(它们都有()后立即执行函数)。在非阻塞版本中，您将注意到只有a被调用，而b只是作为一个参数传递给a。 在阻塞版本中，a和b之间没有明确的关系，在非阻塞版本中，它变成了一项工作，做它需要做的事情，然后在完成时调用b。以这种方式使用函数称为回调函数，因为在这种情况下，回调函数在a完成后会被调用。 下面是一个伪代码的实现，它可能是这样的: 123456789function a(done) &#123; download('https://pbs.twimg.com/media/B4DDWBrCEAA8u4O.jpg:large', function doneDownloading(error, png) &#123; // handle error if there was one if (err) console.log('uh-oh!', error) // call done when you are all done done() &#125;)&#125; 回想一下我们的非阻塞例子a(b)，我们把a和b作为第一个参数。在上面的函数定义中，done参数是我们传入的b函数。这种行为一开始很难让你的头脑有个头绪。当你调用一个函数时，传入的参数在函数中不会有相同的变量名。在这种情况下，我们称之为b的函数是在函数内部完成的。但b和done只是变量名，指向相同的底层函数。通常回调函数被标记为done或回调，以明确它们是在当前函数为done时应该调用的函数。 所以，只要a和b在完成时，a和b都被调用在非阻塞和阻塞的两个版本中。不同之处在于，在非阻塞版本中，我们不需要停止JavaScript的执行。一般来说，非阻塞样式是指您编写每个函数的地方，以便它能够尽快返回，而不会阻塞。 为了进一步说明这个问题，如果你需要一秒钟的时间来完成，并且你使用了阻塞版本，那意味着你只能做一件事。如果你使用非阻塞版本(又称使用回调)，你可以在同一秒内完成数百万件其他事情，这意味着你可以更快地完成你的工作，并在剩下的时间里睡觉。 记住:编程完全是关于懒惰的，你应该是一个睡觉的人，而不是你的电脑。 希望您现在可以看到，回调函数只是在一些异步任务之后调用其他函数的函数。异步任务的常见例子有:读取照片、下载歌曲、上传图片、与数据库对话、等待用户按下键或点击某人等，任何需要时间的事情。JavaScript非常擅长处理像这样的异步任务，只要您花时间学习如何使用回调，并防止JavaScript被阻塞。 结束!这只是您与JavaScript的关系的开始！你不可能一下子就学会所有的东西，但是你应该找到适合你的东西，并尝试在这里学习所有的概念。 我建议明天再来一遍，从一开始就把整件事再做一遍！在你得到所有东西之前，可能需要几次(编程是困难的)。试着避免在任何包含闪亮对象的房间里阅读这一页。它们会让人难以置信的分心。 你还想知道另一个话题吗?在github上为它打开一个问题。 推荐阅读对于猫来说，JavaScript跳过了很多不重要的细节，这些细节并不重要(猫的注意力不集中)，但如果你觉得你需要深入研究一下，就可以查看以下内容: NodeSchool.io是一种社区驱动的、开源的教育软件，它以一种交互的、自导向的方式教授各种web开发技能。我帮助NodeSchool !可悲的是，它比这一页更少的猫。 Eloquent Javascript是一本免费的书，教你Javascript！很好!特别是关于值、变量和控制流的章节 Mozilla的JavaScript指南也有一个很可爱的入门章节叫做值，变量和文字 标准JS风格指南是我使用的JS风格的“零配置”linter 让我们来写@shama的代码这是我的一个朋友制作的很棒的YouTube编码教程","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jigangduan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"}]},{"title":"Hyperoslo Cache介绍","slug":"hyperoslo-cache","date":"2018-01-26T01:20:34.000Z","updated":"2020-07-25T02:57:18.207Z","comments":true,"path":"2018/01/26/hyperoslo-cache/","link":"","permalink":"https://jigangduan.github.io/2018/01/26/hyperoslo-cache/","excerpt":"描述在这个领域里，Cache并不是独一无二的，但它并不是另一个让你拥有上帝力量的怪物库。除了缓存，它什么都不做，但它做得很好。它提供了一个良好的公共API，它有开箱即用的实现和巨大的自定义可能性。高速缓存在Swift 4中使用Codable来执行序列化。","text":"描述在这个领域里，Cache并不是独一无二的，但它并不是另一个让你拥有上帝力量的怪物库。除了缓存，它什么都不做，但它做得很好。它提供了一个良好的公共API，它有开箱即用的实现和巨大的自定义可能性。高速缓存在Swift 4中使用Codable来执行序列化。 关键特性 与Swift 4 Codable合作。任何符合Codable的东西都将被Storage轻松地保存和加载。 [X] 默认磁盘存储。可选地使用内存存储来启用混合. [X] 选项通过DiskConfig和MemoryConfig. 支持过期和清除过期的对象. 线程安全的。可以从任何队列访问操作. 默认情况下同步。还支持异步APIs. [X] 存储图像通过ImageWrapper. 广泛的单元测试覆盖面和文档. 支持iOS, tvOS 和 macOS. 使用StorageCache是建立基于责任链模式,在其中有许多处理对象，每个处理对象都知道如何执行1个任务，并委托给下一个任务。但这只是实现细节。您需要知道的是Storage，它保存并加载Codable对象。 Storage有磁盘存储和可选的内存存储。内存存储应该更少时间和内存消耗，而磁盘存储用于满足应用程序生命周期的内容，更像一种存储用户信息的方便方式，这些信息应该在应用程序启动时持久化。 DiskConfig是必需的，设置磁盘存储。您可以选择通过MemoryConfig来将内存作为前端存储。 1234let diskConfig = DiskConfig(name: \"Floppy\")let memoryConfig = MemoryConfig(expiry: .never, countLimit: 10, totalCostLimit: 10)let storage = try? Storage(diskConfig: diskConfig, memoryConfig: memoryConfig) Codable 类型Storage支持任何符合Codable协议对象。你可以做你自己的事情符合Codable,这样可以保存和加载Storage。 支持的类型: 原语如 Int, Float, String, Bool, … 数组的元素如 [Int], [Float], [Double], … 基本类型的Set如 Set&lt;String&gt;, Set&lt;Int&gt;, … 简单的字典 [String: Int], [String: String], … Date URL Data 错误处理错误处理是通过try catch完成的。Storage在StorageError方面抛出错误。 1234567891011121314public enum StorageError: Error &#123; /// 不能找到对象 case notFound /// 对象被找到，但是被请求的类型失败了 case typeNotMatch /// 文件属性是畸形的 case malformedFileAttributes /// 不能执行解码 case decodingFailed /// 不能执行编码 case encodingFailed /// 存储已经被释放了 case deallocated&#125; 在从存储中加载时，可能会出现磁盘问题或类型不匹配的错误，因此，如果要处理错误，则需要try catch 12345do &#123; let storage = try Storage(diskConfig: diskConfig, memoryConfig: memoryConfig)&#125; catch &#123; print(error)&#125; 配置下面是如何使用多种配置选项 12345678910111213let diskConfig = DiskConfig( //磁盘存储的名称，这将用作目录中的文件夹名称 name: \"Floppy\", //在默认情况下，每个添加的对象都将使用该过期日期 //如果它没有在`setObject(forKey:expiry:)`方法中被覆盖 expiry: .date(Date().addingTimeInterval(2*3600)), maxSize: 10000, // 存储磁盘缓存的位置。如果nil，它被放置在cachesDirectory目录中. directory: try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true).appendingPathComponent(\"MyPreferences\"), // 数据保护用于在磁盘上以加密格式存储文件，并根据需要对其进行解密 protectionType: .complete) 123456789let memoryConfig = MemoryConfig( //在默认情况下，每个添加的对象都将使用该过期日期 //如果它没有在`setObject(forKey:expiry:)`方法中被覆盖 expiry: .date(Date().addingTimeInterval(2*60)), /// 内存中的对象的最大数量应该保持在内存中 countLimit: 50, /// 缓存在开始清除对象之前所能容纳的最大总成本 totalCostLimit: 0) 在iOS平台上，tvOS还可以在DiskConfig上指定protectionType，在应用程序的容器中为存储在磁盘上的文件添加安全级别。有关更多信息,请参见FileProtectionType 同步 APIs缺省情况下，Storage是同步的，是线程安全的，您可以从任何队列访问它。所有同步功能都受到StorageAware协议的约束。 12345678910111213141516171819202122// 保存到storagetry? storage.setObject(10, forKey: \"score\")try? storage.setObject(\"Oslo\", forKey: \"my favorite city\", expiry: .never)try? storage.setObject([\"alert\", \"sounds\", \"badge\"], forKey: \"notifications\")try? storage.setObject(data, forKey: \"a bunch of bytes\")try? storage.setObject(authorizeURL, forKey: \"authorization URL\")// 从storage加载let score = try? storage.object(ofType: Int.self, forKey: \"score\")let favoriteCharacter = try? storage.object(ofType: String.self, forKey: \"my favorite city\")// 检查对象是否存在let hasFavoriteCharacter = try? storage.existsObject(ofType: String.self, forKey: \"my favorite city\")// 删除存储中的对象try? storage.removeObject(forKey: \"my favorite city\")// 删除所有对象try? storage.removeAll()// 删除过期的对象try? storage.removeExpiredObjects() Entry您可以使用它的过期信息和元数据来获取对象。您可以使用 Entry 1234let entry = try? storage.entry(ofType: String.self, forKey: \"my favorite city\")print(entry?.object)print(entry?.expiry)print(entry?.meta) 如果从磁盘存储器中取出对象，meta可能包含文件信息。 自定义 CodableCodable适用于像[String: Int], [String: String], … 这样的简单字典它并不适用于[String: Any]，因为Any不符合Codable的一致性，它将在运行时引发致命错误。因此，当您从后端响应中获得json时，您需要将其转换为您的自定义Codable对象，并将其保存为存储。 1234567struct User: Codable &#123; let firstName: String let lastName: String&#125;let user = User(fistName: \"John\", lastName: \"Snow\")try? storage.setObject(user, forKey: \"character\") 异步 APIs在async方式中，您处理Result而不是try catch，因为result是在稍后的时间交付的，以避免阻塞当前的调用队列。在完成块中，您要么有value，要么有error。 您可以通过storage.async访问异步APIs，它也是线程安全的，您可以按照您想要的任何顺序使用同步和异步APIs。所有的异步函数都受到AsyncStorageAware协议的约束。 123456789101112131415161718192021222324252627282930313233storage.async.setObject(\"Oslo\", forKey: \"my favorite city\") &#123; result in switch result &#123; case .value: print(\"saved successfully\") case .error(let error): print(error) &#125; &#125;&#125;storage.async.object(ofType: String.self, forKey: \"my favorite city\") &#123; result in switch result &#123; case .value(let city): print(\"my favorite city is \\(city)\") case .error(let error): print(error) &#125; &#125;&#125;storage.async.existsObject(ofType: String.self, forKey: \"my favorite city\") &#123; result in if case .value(let exists) = result, exists &#123; print(\"I have a favorite city\") &#125;&#125;storage.async.removeAll() &#123; result in print(\"removal completes\")&#125;storage.async.removeExpiredObjects() &#123; result in print(\"removal completes\")&#125; 到期日期默认情况下，所有保存的对象与您在DiskConfig或MemoryConfig中指定的到期时间具有相同的过期时间。可以通过指定setObject的expiry来覆盖特定对象 123456789101112// 配置的默认过期日期将被应用到项目中try? storage.setObject(\"This is a string\", forKey: \"string\")// 给定的过期日期try? storage.setObject( \"This is a string\", forKey: \"string\" expiry: .date(Date().addingTimeInterval(2 * 3600)))// 清除过期的对象storage.removeExpiredObjects() 关于图片？如您所知，NSImage和UIImage在默认情况下不符合Codable。为了使它在可编程序中运行良好，我们引入了ImageWrapper，这样您就可以保存和加载图像 1234let wrapper = ImageWrapper(image: starIconImage)try? storage.setObject(wrapper, forKey: \"star\")let icon = try? storage.object(ofType: ImageWrapper.self, forKey: \"star\").image 如果你想把图像载入UIImageView或NSImageView，那么我们也有一个很好的礼物给你。叫做Imaginary,并使用Cache下罩时,让你的生活更容易处理远程图像。 处理JSON响应大多数情况下，我们的用例是从后端获取json，并将json存储到存储中，以便将来使用。如果你使用库Alamofire或Malibu,你是得到json形式的字典,字符串,或数据。 Storage可以持久存储字符串或数据。您甚至可以使用JSONArrayWrapper和JSONDictionaryWrapper将json保存到Storage中，但是我们更喜欢持久化强类型的对象，因为这些对象是您将在UI中显示的对象。此外，如果json数据不能转换为强类型的对象，那么保存它的意义是什么呢?😉 您可以在JSONDecoder上使用这些扩展来解码json字典、字符串或数据到对象。 123let user = JSONDecoder.decode(jsonString, to: User.self)let cities = JSONDecoder.decode(jsonDictionary, to: [City].self)let dragons = JSONDecoder.decode(jsonData, to: [Dragon].self) 这就是如何使用Alamofire执行对象转换和保存 12345678Alamofire.request(\"https://gameofthrones.org/mostFavoriteCharacter\").responseString &#123; response in do &#123; let user = try JSONDecoder.decode(response.result.value, to: User.self) try storage.setObject(user, forKey: \"most favorite character\") &#125; catch &#123; print(error) &#125;&#125; 安装CocoapodsCache 是通过CocoaPods提供的。安装它简单地将以下行添加到您的Podfile: 1pod 'Cache' CarthageCache 是通过 Carthage提供的.安装它简单地将以下行添加到您的Cartfile: 1github \"hyperoslo/Cache\" 你还需要添加 SwiftHash.framework 在你的 copy-frameworks 脚本.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"iOS第三方库","slug":"iOS/iOS第三方库","permalink":"https://jigangduan.github.io/categories/iOS/iOS第三方库/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"}]},{"title":"基于Sylius搭建电商平台","slug":"sylius-set-up","date":"2018-01-03T04:53:57.000Z","updated":"2020-07-25T02:57:18.229Z","comments":true,"path":"2018/01/03/sylius-set-up/","link":"","permalink":"https://jigangduan.github.io/2018/01/03/sylius-set-up/","excerpt":"Sylius是一种电子商务技术，它能让你完全自由地创造一种独特的客户体验。它与您现有的系统集成在一起，并保证快速上市。 Sylius使用PHP编程语言和Symfony框架。像Drupal或eZ这样的大型的开源项目也是如此。它使用doctrine作为ORM、数据库抽象和TWIG(PHP的安全模板引擎)。 Sylius不是一个单一的解决方案——您可以随时更改或开发它。它可以作为你的自定义电子商务平台的基础，也可以作为你自己系统的核心。 这篇文章将介绍如何搭建Sylius框架和添加ShopAPI插件，以适应移动APP的电商客户端API。","text":"Sylius是一种电子商务技术，它能让你完全自由地创造一种独特的客户体验。它与您现有的系统集成在一起，并保证快速上市。 Sylius使用PHP编程语言和Symfony框架。像Drupal或eZ这样的大型的开源项目也是如此。它使用doctrine作为ORM、数据库抽象和TWIG(PHP的安全模板引擎)。 Sylius不是一个单一的解决方案——您可以随时更改或开发它。它可以作为你的自定义电子商务平台的基础，也可以作为你自己系统的核心。 这篇文章将介绍如何搭建Sylius框架和添加ShopAPI插件，以适应移动APP的电商客户端API。 系统需求首先，看一下运行Symfony的需求。 推荐操作系统是Unix系统 —— Linux，MacOS Web服务器和配置 Apache web server ≥ 2.2 开发过程中，推荐方法是使用PHP内置的web服务器 PHP需要模块和配置PHP版本:PHP ^7.1 PHP扩展: gd 没有具体的配置 exif 没有具体的配置 fileinfo 没有具体的配置 intl 没有具体的配置 PHP配置设置: memory_limit ≥1024M date.timezone Europe/Warsaw 数据库 MySQL 5.x 当然，您可以使用任何其他RDBMS，例如PostgreSQL。 访问权限大多数应用程序文件夹和文件只需要读取访问权限，但是一些文件夹也需要对Apache/Nginx用户的写访问权限: var/cache ar/logs web/media 环境搭建为了方便，环境在macOS上选择使用MAMP Pro。 开发过程中的Web服务器使用PHP内置的web服务器，所以主要的配置是PHP和数据库的环境。MAMP Pro上自带MySQL和phpMyAdmin. 双击phpMyAdmin图标： PHP配置使能相关扩展： 内存限制： 创建数据库用户和库 安装本文假设您熟悉PHP的依赖管理器Composer。 创建Sylius项目要使用Sylius标准版创建一个新项目，请运行以下命令: 1composer create-project sylius/sylius-standard sylius composer开始安装： 1234567891011Installing sylius/sylius-standard (v1.0.7) - Installing sylius/sylius-standard (v1.0.7): Downloading (100%) Created project in syliusLoading composer repositories with package informationInstalling dependencies (including require-dev) from lock fileWarning: The lock file is not up to date with the latest changes in composer.json. You may be getting outdated dependencies. Run update to update them.Package operations: 151 installs, 0 updates, 0 removals - Installing ocramius/package-versions (1.2.0): Downloading (100%) - Installing behat/transliterator (v1.2.0): Loading from cache - Installing doctrine/lexer (v1.0.1): Loading from cache... ... 如果是第一次安装可以下载需要一段时间，依赖了很多的库。 依赖下载完成之后，安装过程会构建参数，需要填写信息： 1234567891011121314&gt; Incenteev\\ParameterHandler\\ScriptHandler::buildParametersCreating the \"app/config/parameters.yml\" fileSome parameters are missing. Please provide them.database_driver (pdo_mysql):database_host (127.0.0.1):database_port (null): 8889database_name (sylius): syliusdatabase_user (root): syliusdatabase_password (null): syliusmailer_transport (smtp):mailer_host (127.0.0.1):mailer_user (null): syliusmailer_password (null): syliussecret (EDITME): 以上信息可以看出，创建了一个app/config/parameters.yml文件。设置了一些配置参数，这些参数也可以在文件中更改。 最后会清除缓存和安装资源： Sylius项目新建成功！！ 新建完成Sylius项目后，会出现一个sylius文件夹，里面是整个项目工程。 123456789101112131415161718$ tree -L 1.├── Gulpfile.js├── LICENSE├── README.md├── app├── behat.yml.dist├── bin├── composer.json├── composer.lock├── etc├── features├── package.json├── src├── var├── vendor├── web└── yarn.lock 标准的Symfony项目目录结构。Symfony和Sylius的源码都在vendor目录级下。 安装Sylius12$ cd sylius # Move to the newly created directory$ php bin/console sylius:install 安装过程主要是: 检查系统需求 建立数据库。创建Sylius相关的数据表和一些测试的资源数据(比如产品/顾客用户等)。 所以安装过程请确保数据库能正常连接。 创建媒体文件夹 ‘web/media’,’web/media/image’ 选择货币 添加语言环境en_US 创建您的管理员帐户 安装assets为了看到一个功能齐全的前端，您需要安装它的assets. Yarn安装到您的项目目录并运行: 1$ yarn install 现在您可以使用gulp来安装views，只需运行一个简单的命令: 1$ yarn run gulp 访问商店建议使用Symfony内置web服务器运行php bin/console server:start 127.0.0.1:8000命令，然后在web浏览器中访问http://127.0.0.1:8000，以查看该商店。 访问管理面板查看/admin url，您将在其中找到管理面板。 请记住，您必须使用安装Sylius时提供的凭证作为管理员登录。 修改管理面板为中文 项目结构简介在项目的根目录中，您将找到这些重要的子目录: app/config/ - 添加yaml配置文件，包括路由、安全、状态机配置等 var/logs/ - 应用程序的日志 var/cache/ - 项目的缓存 src/ - AppBundle中添加所有自定义逻辑的地方 web/ - 放置你的项目的资产 bin/console 命令列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124$ php bin/console listSymfony 3.4.2 (kernel: app, env: dev, debug: true)Usage: command [options] [arguments]Options: -h, --help 显示帮助信息 -q, --quiet 不要输出任何消息 -V, --version 显示这个应用程序版本 --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction 不要问任何互动的问题 -e, --env=ENV 环境名称[默认:“dev”] --no-debug 关闭调试模式 -v|vv|vvv, --verbose 增加消息的冗余:1用于正常输出，2用于更详细的输出，3用于调试。Available commands: about 显示当前项目的信息 help 显示命令的帮助 list 命令列表 assets assets:install 在公共目录下安装bundle web资产 cache cache:clear 清空缓存 cache:pool:clear 清除缓存池 cache:pool:prune 修剪缓存池 cache:warmup 预热空缓存 config config:dump-reference 为扩展转储默认配置 debug debug:autowiring 列出可以用于自动装配的类/接口 debug:config 转储当前配置 debug:container 显示应用程序的当前服务 debug:event-dispatcher 为应用程序显示已配置的侦听器 debug:form 显示表单类型信息 debug:payum:gateway [payum:gateway:debug] debug:router 显示应用程序的当前路由 debug:swiftmailer 显示应用程序的当前邮件 debug:translation 显示消息翻译信息 debug:twig 显示一组分支函数、筛选器、全局变量和测试 debug:winzou:state-machine doctrine doctrine:cache:clear-collection-region 清除二级缓存收集区域. doctrine:cache:clear-entity-region 清除二级缓存实体区域. doctrine:cache:clear-metadata 为一个实体管理器清除所有的元数据缓存 doctrine:cache:clear-query 为一个实体管理器清除所有的查询缓存 doctrine:cache:clear-query-region 清除二级缓存查询区域. doctrine:cache:clear-result 为实体管理器清除结果缓存 doctrine:cache:contains 检查是否存在一个高速缓存条目 doctrine:cache:delete 删除缓存条目 doctrine:cache:flush [doctrine:cache:clear] 刷新一个给定的缓存 doctrine:cache:stats 获取给定缓存提供者的统计信息 doctrine:database:create 创建配置的数据库 doctrine:database:drop Drops the configured database doctrine:database:import 将SQL文件直接导入数据库. doctrine:ensure-production-settings 验证该原则是否为生产环境配置了适当的配置. doctrine:fixtures:load 将数据固定到数据库中. doctrine:generate:entities [generate:doctrine:entities] 从映射信息中生成实体类和方法存根 doctrine:mapping:convert [orm:convert:mapping] 转换支持格式之间的映射信息. doctrine:mapping:import 从现有数据库导入映射信息 doctrine:mapping:info doctrine:migrations:diff 通过将当前数据库与映射信息进行比较，生成迁移. doctrine:migrations:execute 手动执行单个迁移版本. doctrine:migrations:generate 生成一个空白的迁移类. doctrine:migrations:latest 输出最新版本号 doctrine:migrations:migrate 执行迁移到指定的版本或最新的可用版本. doctrine:migrations:status 查看一组迁移的状态. doctrine:migrations:version 手动添加和删除版本表中的迁移版本. doctrine:query:dql 从命令行直接执行任意DQL. doctrine:schema:create 执行(或转储)生成数据库模式所需的SQL doctrine:schema:drop 执行(或转储)删除当前数据库模式所需的SQL doctrine:schema:update 执行(或转储)更新数据库模式所需的SQL，以匹配当前的映射元数据. doctrine:schema:validate 验证映射文件. fos fos:oauth-server:clean 清除到期的令牌 gaufrette gaufrette:filesystem:keys 列出文件系统的所有文件键 liip liip:imagine:cache:remove 删除用于传递的资产路径和过滤器名称的资产缓存 liip:imagine:cache:resolve 为已传递的资产路径和过滤集名称解析资产缓存 lint lint:twig Lints a template and outputs encountered errors lint:xliff Lints a XLIFF file and outputs encountered errors lint:yaml Lints a file and outputs encountered errors payum payum:security:create-capture-token payum:security:create-notify-token payum:status 允许获得付款状态. router router:match 通过模拟路径信息匹配来帮助调试路由 security security:check 检查项目依赖项中的安全性问题 security:encode-password 编码一个密码. server server:run 运行一个本地web服务器 server:start 在后台启动一个本地web服务器 server:status 为给定地址输出本地web服务器的状态 server:stop 停止使用`server:start` 命令启动的本地web服务器 sonata sonata:block:debug 调试所有可用的块，显示每个块的默认设置 sonata:core:dump-doctrine-metadata 获取当前教条模式的信息 swiftmailer swiftmailer:email:send 发送简单的电子邮件消息 swiftmailer:spool:send 从线轴发送电子邮件 sylius sylius:cancel-unpaid-orders 删除在配置期间未支付的订单。配置参数——sylius_order.order_expiration_period. sylius:debug:resource 调试资源元数据. sylius:fixtures:list 列出可用的fixtures sylius:fixtures:load 从给定的套件加载fixtures sylius:install 在您的首选环境中安装Sylius. sylius:install:assets 安装所有Sylius资产. sylius:install:check-requirements 检查所有的Sylius需求是否满足. sylius:install:database 安装Sylius数据库. sylius:install:sample-data 将样本数据安装到Sylius. sylius:install:setup Sylius配置设置. sylius:oauth-server:create-client 创建一个新客户 sylius:remove-expired-carts 删除在配置期间空闲的购物车。配置参数——sylius_order.cart_expires_after. sylius:theme:assets:install 在公共web目录下安装主题web资产 sylius:theme:list 显示被检测到的主题的列表. sylius:user:demote 通过删除角色来演示用户. sylius:user:promote 通过添加角色来提升用户. translation translation:update 更新的翻译文件 安装ShopAPI插件 ShopAPI插件提供了Sylius电子商务平台上的ShopApi实现。 使用安装插件包修改composer.json文件,在require节点中添加一行： &quot;sylius/shop-api-plugin&quot;: &quot;^1.0.0@beta&quot; 然后，执行： 1$ composer.phar update 输出结果为： 从输出信息中可以看出： 安装了sylius/shop-api-plugin (v1.0.0-beta.20) 安装了依赖库: ‘league/tactician’ ‘league/tactician-doctrine’ ‘league/tactician-bundle’ 更新了一些依赖包 扩展配置文件添加SyliusShopApi到AppKernel 12345678910111213141516// app/AppKernel.php /** * &#123;@inheritdoc&#125; */ public function registerBundles() &#123; $bundles = [ // ... new \\Sylius\\ShopApiPlugin\\ShopApiPlugin(), new \\League\\Tactician\\Bundle\\TacticianBundle(), ]; return array_merge(parent::registerBundles(), $bundles); &#125; app/config/config.yml 添加 - { path: &#39;^/shop-api&#39;, priorities: [&#39;json&#39;], fallback_format: json, prefer_extension: true } 到 fos_rest.format_listener.rules节 导入插件配置 12345678910111213141516# app/config/config.ymlimports: # ... - &#123; resource: \"@ShopApiPlugin/Resources/config/app/config.yml\" &#125;# ...fos_rest: # ... format_listener: rules: - &#123; path: '^/shop-api', priorities: ['json'], fallback_format: json, prefer_extension: true &#125; # &lt;-- Add this - &#123; path: '^/api', priorities: ['json', 'xml'], fallback_format: json, prefer_extension: true &#125; - &#123; path: '^/', stop: true &#125; 添加路由到 app/config/routing.yml123456# app/config/routing.yml# ...sylius_shop_api: resource: \"@ShopApiPlugin/Resources/config/routing.yml\" 配置防火墙 改变sylius.security.shop_regex参数也包含shop-api前缀 添加ShopAPI正则表达式参数shop_api.security.regex: &quot;^/shop-api” 添加ShopAPI防火墙配置: 12345678910111213141516parameters: # ... sylius.security.shop_regex: \"^/(?!admin|api|shop-api)[^/]++\" # shop-api has been added inside the brackets shop_api.security.regex: \"^/shop-api\"# ...security: firewalls: // ... shop_api: pattern: \"%shop_api.security.regex%\" stateless: true anonymous: true 调整签出配置避免与Sylius shop API发生冲突。例如(假设，您正在使用常规的Sylius安全定义): 1234567# app/config/config.yml# ...sylius_shop: checkout_resolver: pattern: \"%sylius.security.shop_regex%/checkout/\" (可选)跨源Ajax请求如果您已经安装了nelmio/NelmioCorsBundle以支持跨源Ajax请求 将NelmioCorsBundle添加到AppKernel中 1234567891011121314// app/AppKernel.php/** * &#123;@inheritdoc&#125; */public function registerBundles()&#123; $bundles = array( // ... new Nelmio\\CorsBundle\\NelmioCorsBundle(), // ... ); // ...&#125; 将配置添加到config.yml中 123456789101112131415161718192021# app/config/config.yml# ...nelmio_cors: defaults: allow_credentials: false allow_origin: [] allow_headers: [] allow_methods: [] expose_headers: [] max_age: 0 hosts: [] origin_regex: false forced_allow_origin_value: ~ paths: '^/shop-api/': allow_origin: ['*'] allow_headers: ['Content-Type', 'authorization'] allow_methods: ['POST', 'PUT', 'GET', 'DELETE', 'OPTIONS'] max_age: 3600 附加功能属性如果您想要接收序列化的属性，您需要在shop_api.included_attributes键下定义一个他们的代码数组。如: 123shop_api: included_attributes: - \"MUG_MATERIAL_CODE\" 授权默认情况下，不提供此bundle的授权。但是为了样例配置检查，它被测试与LexikJWTAuthenticationBundle一起工作 security.yml 1234567891011121314151617181920212223242526272829303132333435363738394041# app/config/security.ymlparameters: ... shop_api.security.regex: \"^/shop-api\"security: ... firewalls: ... shop_api_login: pattern: \"%shop_api.security.regex%/login\" stateless: true anonymous: true form_login: provider: sylius_shop_user_provider login_path: shop_api_login_check check_path: shop_api_login_check success_handler: lexik_jwt_authentication.handler.authentication_success failure_handler: lexik_jwt_authentication.handler.authentication_failure require_previous_session: false shop_api: pattern: \"%shop_api.security.regex%\" stateless: true anonymous: true guard: authenticators: - lexik_jwt_authentication.jwt_token_authenticator ... ... access_control: ... - &#123; path: \"%shop_api.security.regex%/login\", role: IS_AUTHENTICATED_ANONYMOUSLY &#125; - &#123; path: \"%shop_api.security.regex%/register\", role: IS_AUTHENTICATED_ANONYMOUSLY &#125; 在config.yml中的jwt parameters和jwt配置 123456789101112parameters: secret: \"Heron is the best animal in the world!\" jwt_private_key_path: '%kernel.root_dir%/config/jwt/private-test.pem' jwt_public_key_path: '%kernel.root_dir%/config/jwt/public-test.pem' jwt_key_pass_phrase: 'heron' jwt_token_ttl: 3600lexik_jwt_authentication: private_key_path: '%jwt_private_key_path%' public_key_path: '%jwt_public_key_path%' pass_phrase: '%jwt_key_pass_phrase%' token_ttl: '%jwt_token_ttl%' rsa keys例子 测试应用程序可以通过API测试用例进行测试。为了运行测试套件，执行以下命令: 1$ bin/phpunit Shop APIs1234567891011121314151617181920212223242526272829303132333435$ bin/console debug:router | grep shop-api shop_api_pickup_cart POST ANY ANY /shop-api/carts/&#123;token&#125; shop_api_cart_summary GET ANY ANY /shop-api/carts/&#123;token&#125; shop_api_add_to_cart POST ANY ANY /shop-api/carts/&#123;token&#125;/items shop_api_add_multiple_items_to_cart POST ANY ANY /shop-api/carts/&#123;token&#125;/multiple-items shop_api_drop_cart DELETE ANY ANY /shop-api/carts/&#123;token&#125; shop_api_change_item_quantity PUT ANY ANY /shop-api/carts/&#123;token&#125;/items/&#123;id&#125; shop_api_remove_item_from_cart DELETE ANY ANY /shop-api/carts/&#123;token&#125;/items/&#123;id&#125; shop_api_estimated_shipping_cost GET ANY ANY /shop-api/carts/&#123;token&#125;/estimated-shipping-cost shop_api_add_coupon_to_cart PUT ANY ANY /shop-api/carts/&#123;token&#125;/coupon shop_api_remove_coupon_to_cart DELETE ANY ANY /shop-api/carts/&#123;token&#125;/coupon shop_api_product_show_details_by_slug GET ANY ANY /shop-api/products-by-slug/&#123;slug&#125; shop_api_add_product_review_by_slug POST ANY ANY /shop-api/product-reviews-by-slug/&#123;slug&#125; shop_api_product_show_catalog_by_slug GET ANY ANY /shop-api/taxon-products-by-slug/&#123;taxonSlug&#125; shop_api_product_show_reviews_by_slug GET ANY ANY /shop-api/product-reviews-by-slug/&#123;slug&#125; shop_api_product_show_details_by_code GET ANY ANY /shop-api/products/&#123;code&#125; shop_api_product_show_catalog_by_code GET ANY ANY /shop-api/taxon-products/&#123;code&#125; shop_api_product_show_reviews_by_code GET ANY ANY /shop-api/products/&#123;code&#125;/reviews shop_api_add_product_review_by_code POST ANY ANY /shop-api/products/&#123;code&#125;/reviews shop_api_taxon_show_details GET ANY ANY /shop-api/taxons/&#123;code&#125; shop_api_taxon_show_tree GET ANY ANY /shop-api/taxons/ sylius_shop_api_register POST ANY ANY /shop-api/register sylius_shop_api_resend_verification_token POST ANY ANY /shop-api/resend-verification-link sylius_shop_api_user_verification PUT ANY ANY /shop-api/verify-account sylius_shop_api_reset_password PUT ANY ANY /shop-api/request-password-reset sylius_shop_password_reset PUT ANY ANY /shop-api/password-reset/&#123;token&#125; shop_api_address_checkout PUT ANY ANY /shop-api/checkout/&#123;token&#125;/address shop_api_summarize_checkout GET ANY ANY /shop-api/checkout/&#123;token&#125; shop_api_available_shipping_checkout GET ANY ANY /shop-api/checkout/&#123;token&#125;/shipping shop_api_choose_shipping_method PUT ANY ANY /shop-api/checkout/&#123;token&#125;/shipping/&#123;shippingId&#125; shop_api_available_payment_methods_checkout GET ANY ANY /shop-api/checkout/&#123;token&#125;/payment shop_api_choose_payment_method_checkout PUT ANY ANY /shop-api/checkout/&#123;token&#125;/payment/&#123;paymentId&#125; shop_api_complete_checkout PUT ANY ANY /shop-api/checkout/&#123;token&#125;/complete shop_api_me GET ANY ANY /shop-api/me shop_api_login_check POST ANY ANY /shop-api/login_check","categories":[{"name":"PHP","slug":"PHP","permalink":"https://jigangduan.github.io/categories/PHP/"},{"name":"Symfony","slug":"PHP/Symfony","permalink":"https://jigangduan.github.io/categories/PHP/Symfony/"},{"name":"电商","slug":"PHP/Symfony/电商","permalink":"https://jigangduan.github.io/categories/PHP/Symfony/电商/"}],"tags":[{"name":"php","slug":"php","permalink":"https://jigangduan.github.io/tags/php/"},{"name":"symfony","slug":"symfony","permalink":"https://jigangduan.github.io/tags/symfony/"},{"name":"电商","slug":"电商","permalink":"https://jigangduan.github.io/tags/电商/"}]},{"title":"Android 网页获取短信验证码 可行性预研","slug":"WebPage-Get-SMS","date":"2017-12-18T08:09:01.000Z","updated":"2020-07-25T02:57:18.171Z","comments":true,"path":"2017/12/18/WebPage-Get-SMS/","link":"","permalink":"https://jigangduan.github.io/2017/12/18/WebPage-Get-SMS/","excerpt":"目标： Android 网页获取短信验证码 目前状态： 预言阶段（技术上未实现）","text":"目标： Android 网页获取短信验证码 目前状态： 预言阶段（技术上未实现） 网页端方案： Android WebKit插件开发 SMS-BrowserPlugin 方案描述： WebKit插件包括PluginService和Plugin.so动态库, Plugin.so提供与WebKit的交互，提供JS的接口；PluginService静态注册WebKit插件action，实现短信拦截功能。 Android端拦截短信方案 方案一： 监听SMS广播 方案二： NotificationListenserServic监听Notifications，过滤短信应用包名的通知信息 过程记录： 研究Android WebKit插件原理及实现方式 创建示例Plugin项目 动态库需要Android中相关插件部分接口头文件，寻找头文件，下载后放入项目中。又需要依赖其他lib和头文件，依赖过重，依赖文件无从查起，放弃此方案，该用Android源码下编译方式 Android源码下编译方式 安装虚拟机Ubuntu环境，安装SSH-Server,Samba 安装JDK1.6及Android编译所需要的依赖库（JDK版本和依赖环境需要与要编译的Android版本相关） 安装repo 下载android-4.0_r1源码（翻墙下载速度过慢，使用中科大镜像。下载中由于网速不稳定问题，容易卡住，卡住后没有任何反应，需要停止再重新下载） 下载后仓库和工作区源码容量近80G，编译存储空间溢出，删除掉仓库.repo，进剩下源码部分 编译源码 编译SampleBrowserPlugin，生成SampleBrowserPlugin.apk和SampleBrowserPlugin.odex 合并.apk和.odex （SampleBrowserPlugin.apk无法直接安装，合并.apk和.odex，再打包重新签名。但安装还是报错） 使用源码编译的动态库 解压缩.apk，得到动态库armeabi-v7a/libsampleplugin.so 文件 将libsampleplugin.so加入到示例Plugin项目中 编译项目生成APK，安装应用并启动 编写HTML文件，包含插件相关参数的对象 推入设备的SDCard中，使用浏览器打开(结果还是插件无法加载) 编译项目生成APK，安装应用并启动 脚本使用插件对象 编写HTML文件，包含插件相关参数的对象 推入设备的SDCard中，使用浏览器打开(结果还是插件无法加载) 目前遇到的问题： 插件无法被浏览器正常的加载 后续方向： 分析Web API是否有对应的接口 不可行, 分析WebExtension是否可行 不可行，WebExtension由HTML、CSS、JS构成，不能访问Android原生接口 借助服务器中转 参考文档： Android浏览器插件开发 android 浏览器插件开发 开发者需要了解的WebKit Android Webkit插件 解析Android WebKit插件基本结构 深入理解Android：WebKit卷 Android WebKit插件的基本结构 Android短信拦截机制适配的坑(下)–4.4以上系统，主要是6.0 Android短信拦截机制适配的坑(上)–4.4以下系统 AndroidXRef Android 清华大学镜像 下载Android源代码错误汇总分析 你真的理解AccessibilityService吗 深入理解SELinux SEAndroid（第一部分） Android 开源项目指南 【android源码】编译android M源码、刷机，开启源码学习的First Step 如何利用拦截马实现短信拦截 微信抢红包外挂源码 6.0短信监听 GetSMSDemo PermissionGen NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？ 安卓通知栏管理详解及分析 NotificationListenerService","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"预研","slug":"Android/预研","permalink":"https://jigangduan.github.io/categories/Android/预研/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android中odex和apk文件的合并方法","slug":"merge-odex-apk","date":"2017-12-14T03:48:01.000Z","updated":"2020-07-25T02:57:18.212Z","comments":true,"path":"2017/12/14/merge-odex-apk/","link":"","permalink":"https://jigangduan.github.io/2017/12/14/merge-odex-apk/","excerpt":"Android Rom中的APK是被分开的，分为apk和odex。APK中的dex被分离出来成了单独的文件odex,包括了Java编译的文件，而apk包含了资源文件和.so。 这样做可以使其厂商保证一定的反盗版，因为没有dex文件的apk是无法正常安装的，而厂商直接将odex和不完整的apk文件放到手机rom固化到/system/bin中可以让一般用户无法正常导出使用。 可能想到的是合并odex和apk变成apk中包含dex文件的，这样合并后最终apk文件安装在/data/中，而rom存放在 /system/app中，所以最终导致了用户可装在Android手机中的软件会变少，占用系统空间。 下面介绍如何重新打包和签名的方法：","text":"Android Rom中的APK是被分开的，分为apk和odex。APK中的dex被分离出来成了单独的文件odex,包括了Java编译的文件，而apk包含了资源文件和.so。 这样做可以使其厂商保证一定的反盗版，因为没有dex文件的apk是无法正常安装的，而厂商直接将odex和不完整的apk文件放到手机rom固化到/system/bin中可以让一般用户无法正常导出使用。 可能想到的是合并odex和apk变成apk中包含dex文件的，这样合并后最终apk文件安装在/data/中，而rom存放在 /system/app中，所以最终导致了用户可装在Android手机中的软件会变少，占用系统空间。 下面介绍如何重新打包和签名的方法： 重新打包下载编译和反编译工具: smali和baksmali：下载地址：https://bitbucket.org/JesusFreke/smali/downloads/ 将ROM中的framework中的文件全复制出来1$ cp /home/jigangduan/android/out/target/product/generic/system/framework/*.* boot/ 通过odex生成class文件1java -jar ../smail/baksmali-2.0.jar -x -d boot/ 111.odex 反编译生成： 123456789101112131415161718out/└── com └── android └── sampleplugin ├── AnimationSurface.smali ├── BackgroundSurface.smali ├── BackgroundTest.smali ├── graphics │ ├── CubeRenderer.smali │ └── Cube.smali ├── PaintSurface$1.smali ├── PaintSurface.smali ├── R$attr.smali ├── R$drawable.smali ├── R.smali ├── R$string.smali ├── SamplePlugin.smali └── VideoSurface.smali 通过class生成classes.dex 文件1$ java -Xmx512M -jar ../smail/smali-2.0.jar out -o classes.dex 将classes.dex放到apk文件12345678$ zip -m 111.apk classes.dexzip I/O error: Permission deniedzip error: Could not create output file (111.apk)$ sudo chmod +w 111.apk$ zip -m 111.apk classes.dex adding: classes.dex (deflated 52%) 打包重新签名生成证书 *.keystore12345678910111213141516171819202122$ keytool -genkeypair -alias mydemo.keystore -keyalg RSA -validity 100 -keystore mydemo.keystoreEnter keystore password: Keystore password is too short - must be at least 6 charactersEnter keystore password: Re-enter new password:What is your first and last name? [Unknown]: 111What is the name of your organizational unit? [Unknown]: logitWhat is the name of your organization? [Unknown]: logitWhat is the name of your City or Locality? [Unknown]: changshaWhat is the name of your State or Province? [Unknown]: hnWhat is the two-letter country code for this unit? [Unknown]: chIs CN=111, OU=logit, O=logit, L=changsha, ST=hn, C=ch correct? [no]: yEnter key password for &lt;mydemo.keystore&gt;(RETURN if same as keystore password): 给apk签名12345678910111213$ jarsigner -verbose -keystore mydemo.keystore -signedjar 111_ca.apk 111.apk mydemo.keystoreEnter Passphrase for keystore: updating: META-INF/MANIFEST.MF adding: META-INF/MYDEMO_K.SF adding: META-INF/MYDEMO_K.RSA signing: AndroidManifest.xml signing: lib/armeabi-v7a/libsampleplugin.so signing: res/drawable-mdpi/sample_browser_plugin.png signing: resources.arsc signing: classes.dexWarning:The signer certificate will expire within six months.","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"https://jigangduan.github.io/categories/Android/逆向/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"逆向","slug":"逆向","permalink":"https://jigangduan.github.io/tags/逆向/"},{"name":"反编译","slug":"反编译","permalink":"https://jigangduan.github.io/tags/反编译/"}]},{"title":"MySQL简单操作(11)-管理工具","slug":"my-common-grammar11","date":"2017-12-09T08:25:25.000Z","updated":"2020-07-25T02:57:18.216Z","comments":true,"path":"2017/12/09/my-common-grammar11/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar11/","excerpt":"","text":"phpMyAdminNavicat for MySQLMySQL Workbench","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(10)-存储引擎","slug":"my-common-grammar10","date":"2017-12-09T07:25:25.000Z","updated":"2020-07-25T02:57:18.216Z","comments":true,"path":"2017/12/09/my-common-grammar10/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar10/","excerpt":"","text":"查看数据表的创建命令： 1SHOW CREATE table tal_name MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎 每一种存储引擎使用不同的存储机制，索引技巧，锁定水平，最终提供广泛且不同的功能 MySQL支持类型： MyISAM InnoDB Memory CSV Archive 并发控制当多个连接对记录进行修改时保证数据的一致性和完整性 锁 共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化 排他锁（写锁）：在任何时候只能有一个写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作 锁颗粒 表锁，是一种开销最小的锁策略 行锁，是一种开销最大的锁策略 事务处理事务用于保证数据库的完整性 事务的特性： 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability) 外键和索引 外键 是保障数据一致性的策略 索引 是对数据表中一列或多列的值进行排序的一种结构 存储引擎特点特点 | MyISAM | InnoDB | Memory | Archive存储限制 | 256TB | 64TB | 有 | 无事务安全 | - | 支持 | - | -支持索引 | 支持 | 支持 | 支持 | -锁颗粒 | 表锁 | 行锁 | 表锁 | 行锁数据压缩 | 支持 | - | - | 支持支持外键 | - | 支持 | - | - 索引： 普通索引，唯一索引，全文索引，btree索引，hash索引 …… 设置存储引擎 通过修改MySQL配置文件实现 1default-storage-engine = engine 通过创建数据表命令实现 1234CREATE TABLE table_name( ... ...) ENGINE = engine; 通过修改数据表命令实现 1ALTER TABLE table_name ENGINE [=] engine_name;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(9)-MySQL存储过程","slug":"my-common-grammar9","date":"2017-12-09T06:25:25.000Z","updated":"2020-07-25T02:57:18.218Z","comments":true,"path":"2017/12/09/my-common-grammar9/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar9/","excerpt":"","text":"SQL命令 –&gt; MySQL引擎 -分析-&gt; 语法正确 –&gt; 可识别命令 -执行-&gt; 执行结果 -返回-&gt; 客户端 存储过程是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理 优点： 增强SQL语句的功能和灵活性 实现较快的执行速度 减少网络流量 存储过程语法结构解析1234567CREATE[DEFINER = &#123; user | CURRENT_USER&#125;]PROCEDURE sp_name([proc_parameter[,...]])[characteristic ...] routine_bodyproc_parameter:[IN | OUT | INOUT] param_name type 参数 IN， 表示该参数的值必须在调用存储过程时指定 OUT， 表示该参数的值可以被存储过程改变，并且可以返回 INOUT， 表示该参数的调用时指定，并且可以被改变和返回 特性123COMMENT 'string'| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125;| SQL SECURITY &#123; DEFINER | INVOKER &#125; COMMENT: 注释 CONTAINS SQL：包含SQL语句，但不包含读或写数据的语句 NO SQL：不包含SQL语句 READS SQL DATA：包含读数据的语句 MODIFIES SQL DATA：包含写数据的语句 SQL SECURITY { DEFINER | INVOKER } 指明谁有权限来执行 过程体 由合法的SQL语句构成 可以是任意的SQL语句（不能创建数据库和表） 如果为复合结构则使用BEGIN…END语句 复合结构可以包含声明，循环，控制结构 调用存储过程 CALL sp_name([parameter[,…]]) CALL sp_name[()] 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name 创建不带参数的存储过程1CREATE PROCEDURE sp1 SELECT VERSION(); 创建带IN类型参数的存储过程举例： 123456DELIMITER //CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)BEGINDELETE FROM users WHERE id = p_id;END// 创建带IN和OUT类型参数的存储过程举例： 12345678910DELIMITER //CREATE PROCEDURE removeUserAndReturnUserNums(IN p_id INT UNSIGNED, OUT userNums INT UNSIGNED)BEGINDELETE FROM users WHERE id = p_id;SELECT count(id) FROM users INTO userNums;END//DELIMITER ; 1CALL removeUserAndReturnUserNums(27, @nums); 创建带多个OUT类型参数的存储过程举例： 1234567891011DELIMITER //CREATE PROCEDURE removeUserByAgeAndReturnUserNums(IN p_age SMALLINT UNSIGNED, OUT deleteUsers SMALLINT UNSIGNED, OUT userCounts SMALLINT UNSIGNED)BEGINDELETE FROM users WHERE age = p_age;SELECT ROW_COUNT() INTO deleteUsers;SELECT COUNT(ID) INTO userCounts;END//DELIMITER ; 修改存储过程1234ALTER PROCEDURE sp_name [characteristic ...]COMMENT 'string'| &#123; CONTAINS SQL | NO SQL | READA SQL DATA | MODIFIES SQL DATA&#125;| SQL SECURITY &#123; DEFINER | INVOKER &#125; 存储过程与自定义函数的区别 存储过程实现的功能复杂一些；而函数的针对性更强 存储过程可以返回多个值；函数只能有一个返回值 存储过程一般独立的来执行；而函数可以作为其他SQL语句的组成部分出现","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(8)-自定义函数","slug":"my-common-grammar8","date":"2017-12-09T05:25:25.000Z","updated":"2020-07-25T02:57:18.217Z","comments":true,"path":"2017/12/09/my-common-grammar8/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar8/","excerpt":"","text":"用户自定义函数(user-defined function, UDF)是一种对MySQL扩展的途径，其用法与内置函数相同 创建自定义函数 1234CREATE FUNCTION function_nameRETURNS&#123;STRING|INTEGER|REAL|DECIMAL&#125;routine_body 函数体 由合法的SQL语句构成 可以是简单的SELECT或INSERT语句 如果为复合结构则使用BEGIN…END语句 复合结构可以包含声明，循环，控制结构 创建不带参数的自定义函数举例： 12CREATE FUNCTION f1() RETRUNS VARCHAR(30)RETURN DATE_FORMAT(NOW(), '%Y年%m月%d日 %H点:%i分:%s秒'); 创建带参数的自定义函数123CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (num+num2)/2; 删除自定义函数1DROP FUNCTION function_name; 创建具有复合结构函数体的自定义函数123456CREATE FUNCTION adduser(username VARCHAR(20))RETURNS INT UNSIGNEDBEGININSERT test(username) VALUES(username);RETURN LAST_INSERT_ID();END//","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(7)-运算符和函数","slug":"my-common-grammar7","date":"2017-12-09T04:25:25.000Z","updated":"2020-07-25T02:57:18.217Z","comments":true,"path":"2017/12/09/my-common-grammar7/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar7/","excerpt":"","text":"字符函数 函数名 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 RIGHT() 获取右侧字符 LENGTH() 获取字符串长度 LTRIM() 删除前导空格 RTRIM() 删除后导空格 TRIM() 删除前导空格和后导空格 SUBSTRING() 字符串截取 [NOT] LIKE 模式匹配(%代表0或多个任意字符；_代表任意一个字符) REPLACE() 字符串替换 数值运算符和函数 函数名 描述 CEIL() 进一取整 DIV 整数除法 FLOOR() 舍一取整 MOD 取余数(取模) POWER() 幂运算 ROUND() 四舍五入 TRUNCATE() 数字截取 比较运算符和函数 函数名 描述 [NOT] BETWEEN…AND… [不]在范围之内 [NOT] IN() [不]在列出值范围内 IS [NOT] NULL [不]为空 日期时间函数 函数名 描述 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_ADD() 当前变化 DATEDIFF() 当前差值 DATE_FORMAT() 日期格式化 信息函数 函数名 描述 CONNECTION_ID() 连接ID DATEBASE() 当前数据库 LAST_INSERT_ID() 最后插入记录的ID号 USER() 当前用户 VERSION() 版本信息 聚合 函数名 描述 AVG() 平均值 COUNT() 计数 MAX() 最大值 MIN() 最小值 SUM() 求和 加密 函数名 描述 MD5() 信息摘要算法 PASSWORD() 密码算法","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(6)-子查询与连接","slug":"my-common-grammar6","date":"2017-12-09T03:25:25.000Z","updated":"2020-07-25T02:57:18.217Z","comments":true,"path":"2017/12/09/my-common-grammar6/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar6/","excerpt":"","text":"子查询子查询（Subquery）是指出现在其他SQL语句内的SELECT子句 例如： 1SELECT * FROM t1 WHERE col1 = (SELECT col2 FROM t2); 其中 SELECT * FROM t1 称为Outer Query/Outer Statement；SELECT col2 FROM t2 称为Subquery 子查询指嵌套在查询内部，且必须始终出现在圆括号內 子查询可以包括多个关键字或条件，如 DISTINCT,GROUP BY,ORDER BY,LIMIT,函数等 子查询的外层查询可以是： SELECT,INSERT,UPDATE,SET或DO 子查询返回值子查询可以返回标量,一行，一列或子查询 由比较运算符引发的子查询使用比较运算符的子查询 =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, &lt;=&gt; 语法结构 operand comparison_operator subquery 用 ANY, SOME 或 ALL 修饰的比较运算符 12345operand comparison_operator ANY(subquery)operand comparison_operator SOME(subquery)operand comparison_operator ALL(subquery) 运算符\\关键字 ANY SOME ALL &gt;, &gt;= 最小值 最小值 最大值 &lt;, &lt;= 最大值 最大值 最小值 = 任意值 任意值 - &lt;&gt;, != - - 任意值 由[NOT] IN引发的子查询语法结构 operand comparison_operator [NOT] IN (subquery) =ANY 运算符与 IN 等效 !=ALL 或 &lt;&gt;ALL 运算符与 NOT IN 等效 由[NOT] EXISTS引发的子查询如果子查询返回任何行，EXISTS 将返回TRUE；否则为FALSE 使用 INSERT…SELECT 插入记录将查询结果写入数据表 1INSERT [INTO] tbl_name [(col_name, ...)] SELECT ... 多表更新1UPDATE table_references SET col_name1=&#123;expr1|DEFAULT&#125; [, col_name2=&#123;expr2|DEFAULT&#125;] ... [WHERE where_condition] CREATE…SELECT创建数据表同时将查询结果写入到数据表 123CREATE TABLE [IF NOT EXISTS] tabl_name [(create_definition, ...)]select_statement 连接的语法MySQL在SELECT语句，多表更新，多表删除语句中支持JOIN操作 1234table_reference&#123;[INNER | CROSS] JOIN | &#123;LEFT|RIGHT&#125; [OUTER] JOIN&#125;table_referenceON conditional_expr 数据表参照table_reference 1tal_name [[AS] alias] | table_subquery [AS] alias 数据表可以使用tab_name AS alias_name 或tab_name alias_name赋予别名 table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名 连接类型 INNER JOIN, 內连接 在MySQL中，JOIN， CROSS JOIN和INNER JOIN是等价的 LEFT [OUTER] JOIN, 左外连接 RIGHT [OUTER] JOIN, 右外连接 连接条件使用ON关键字来设定连接条件，也可以使用WHERE来代替 通用使用ON关键字来设定条件条件；使用WHERE关键字来进行结果记录的过滤。 內连接INNER JOIN显示左表及右表符合连接条件的记录 举例： 1SELECT goods_id, goods_name, cate_name FROM tab_goods INNER JOIN tdb_goods_cates ON tdb_goods.cate_id = tdb_goods_cates.cate_id; 左外连接 LEFT [OUTER] JOIN显示左表的全部记录及右表符合条件连接的记录 A LEFT JOIN B join_condition 数据表B的结果集依赖数据A 数据表A的结果集根据左连接条件依赖所有数据表(B表除外) 左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下） 如果数据表A的某条记录符号WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行 举例： 1SELECT goods_id, goods_name, cate_name FROM tab_goods LEFT JOIN tdb_goods_cates ON tdb_goods.cate_id = tdb_goods_cates.cate_id; 右外连接 RIGHT [OUTER] JOIN显示右表的全部记录及左表符合条件连接的记录 举例： 1SELECT goods_id, goods_name, cate_name FROM tab_goods RIGHT JOIN tdb_goods_cates ON tdb_goods.cate_id = tdb_goods_cates.cate_id; 多表连接举例： 123SELECT goods_id, goods_name, cate_name, brand_name FROM tab_goods AS gINNER JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idINNER JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id; 关于连接的几点说明外连接如果使用內连接查找的记录在数据表中不存在，并且在WHERE子句中尝试以下操作：col_namd IS NULL时，如果col_name被定义为NOT NULL,MySQL将在找到符合连接条件的记录停止搜索更多的行 无限级分类表设计举例： 12345CREATE TABLE tab_goods_types( type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, type_name VARCHAR(20) NOT NULL, parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); 自身连接同一个数据表对其自身进行连接 举例： 12SELECT s.type_id, s.type_name, p.type_name FROM tdb_goods_types AS s LEFT JOIN tdb_goods_types AS pON s.parent_id = p.type_id; 多表删除123DELETE tab_name[.*] [, tal_name[.*]] ...FROM table_references[WHERE where_condition]","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(5)-操作数据表中的记录","slug":"my-common-grammar5","date":"2017-12-09T02:25:25.000Z","updated":"2020-07-25T02:57:18.217Z","comments":true,"path":"2017/12/09/my-common-grammar5/","link":"","permalink":"https://jigangduan.github.io/2017/12/09/my-common-grammar5/","excerpt":"","text":"插入记录 INSERT 1INSERT [INTO] tal_name [(col_name,...)] &#123;VALUES|VALUE&#125;(&#123;expr|DEFAULT&#125;,...),(...),...; expr 表达式 举例： 1INSERT users VALUES(NULL,'Tom','123',25,1); 自动递增的字段设置成NULL或DEFAULT将自增的值 INSERT SET 1INSERT [INTO] tal_name SET col_name=&#123;expr|DEFAULT&#125;; 与第一种方式的区别是，这个方法可以使用子查询(subQuery) INSERT SELECT 1INSERT [INTO] tal_name (col_name,...) SELECT ...; 可以将查询结果插入到指定数据表 更新记录 UPDATE 表单更新 1UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;exp1|DEFAULT&#125;[,col_name2=&#123;exp2|DEFAULT&#125;]... [WHERE where_condition]; 删除记录 DELETE 表单删除 1DELETE FROM tal_name [WHERE where_condition]; 查询表达式解析SELECT 查找记录123456789SELECT select_expr [,select_expr ...][ FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name | position&#125; [ASC | DESC], ...] [HAVING where_conditon] [ORDER BY &#123;col_name | expr | position&#125; [ASC|DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]]; select_expr 查询表达式 每一个表达式表示想要的一列，必须有至少一个 多个列之间以英文逗号分隔 星号（）表示所有列，tab_name.可以表示命名表的所有列 查询表达式可以使用[AS] alias_name为其赋予别名 别名可用于GROUP BY, ORDRE BY或HAVING子句 WHERE 条件表达式对记录进行过滤， 如果没有指定WHERE子句，则显示所有记录。在WHERE表达式中，可以使用MySQL支持的函数或运算符 GROUP BY 对查询结果分组1[GROUP BY &#123;col_name | position&#125; [ASC | DESC], ...] ASC 升序，默认 DESC 降序 HAVING 设置分组条件[HAVING where_conditon] GROUP BY 对查询结果排序1[ORDER BY &#123;col_name | expr | position&#125; [ASC|DESC], ...] LIMIT 限制查询数量1[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(4)-约束以及修改数据表","slug":"my-common-grammar4","date":"2017-12-08T15:25:25.000Z","updated":"2020-07-25T02:57:18.216Z","comments":true,"path":"2017/12/08/my-common-grammar4/","link":"","permalink":"https://jigangduan.github.io/2017/12/08/my-common-grammar4/","excerpt":"","text":"约束保障数据的完整性和一致性 约束分为表级约束和列级约束 约束类型包括: NOT NULL(非空约束) PRIMARY KEY(主键约束) UNIQUE KEY(唯一约束) DEFAULT(默认约束) FOREIGN KEY(外键约束) FOREIGN KEY(外键约束) 保持数据一致性，完整性 实现一对一或一对多关系 外键约束的要求 父表和子表必须使用相同的存储引擎，而且禁止使用临时表 数据表的存储引擎只能为InnoDB 外键列和参考列必须具有相似的数据类型。其中数字长度或是否符号位必须相同；而字符长度可以不同 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引 编辑数据表的默认存储引擎MySQL配置文件 default-storage-engine=INNODB 外键约束的参照操作 CASCADE: 从父表删除或更新且自动删除或更新子表中匹配到行 SET UNLL: 从父表删除或更新行，并设置子表中的外键行为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL RESTRICT: 拒绝对父表的删除或更新操作 NO ACTION: 标准SQL的关键字，在MySQL中与RESTRICT相同 修改数据表 添加单列 1ALTER TABLE tal_name ADD [COLUMN] col_name column_definition [FIRST | AFTER col_name]; 添加多列 1ALTER TABLE tal_name ADD [COLUMN] (col_name column_definition,...); 删除列 1ALTER TABLE tal_name DROP [COLUMN] col_name; 添加主键约束 1ALTER TABLE tal_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...); 添加唯一约束 1ALTER TABLE tal_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEC|KEY] [index_name][index_type] (index_col_name,...); 添加外键约束 1ALTER TABLE tal_name ADD [CONSTRAINT [symbol]] FOREING KEY [index_name](index_col_name,...) reference_definition; 添加/删除默认约束 1ALTER TABLE tal_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;; 删除主键约束 1ALTER TABLE tal_name DROP PRIMARY KEY; 删除唯一约束 1ALTER TABLE tal_name DROP &#123;INDEX|KEY&#125; index_name; 删除外键约束 1ALTER TABLE tal_name DROP FOREIGN KEY fk_symbol; 修改列定义 1ALTER TABLE tal_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]; 修改列名称 1ALTER TABLE tal_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name]; 数据表更名 方法一： 1ALTER TABLE tal_name RENAME [TO|AS] new_tbl_name; 方法二： 1RENAME TABLE tal_name TO new_tbl_name [, tabl_name2 TO new_tal_name2];","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(3)-数据表","slug":"my-common-grammar3","date":"2017-12-08T14:25:25.000Z","updated":"2020-07-25T02:57:18.216Z","comments":true,"path":"2017/12/08/my-common-grammar3/","link":"","permalink":"https://jigangduan.github.io/2017/12/08/my-common-grammar3/","excerpt":"","text":"创建数据表 1234CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type [NULL | NOT NULL | [AUTO_INCREMENT] PRIMARY KEY] [UNIQUE KEY] [DEFAULT default_value], ...); 举例： 12345CREATE TABLE tb1 ( username VARCHAR(20), age TINYINT UNSIGNED, salary FLOAT(8,2) UNSIGNED); NULL, 字段值可以为空 NOT NULL, 字段值禁止为空 AUTO_INCREMENT, 自动编号，且必须与主键组合使用；默认情况，初始值为1，每次增量为1 PRIMARY KEY 主键约束 每张表只能存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL UNIQUE KEY 唯一约束 可以保证记录唯一性 字段可以为空值(NULL) 每张表可以存在多个唯一约束 DEFAULT 默认值 当插入记录时，如果没有明确为字段赋值，则自动赋默认值 查看数据表 1SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]; 查看数据表结构 1SHOW COLUMNS FROM tal_name; 插入记录 1INSERT [INTO] tal_name[(col_name,...)] VALUES(val,...); 举例： 1INSERT ta1(username,salary) VALUES('John',4500.69); 查找记录 1SELECT expr,... FROM tal_name;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(2)-数据类型","slug":"my-common-grammar2","date":"2017-12-08T13:25:25.000Z","updated":"2020-07-25T02:57:18.216Z","comments":true,"path":"2017/12/08/my-common-grammar2/","link":"","permalink":"https://jigangduan.github.io/2017/12/08/my-common-grammar2/","excerpt":"","text":"整型 数据类型 存储范围 字节 TINYINT 有符号：-128～127；无符号：0～255 1 SMALLINT 有符号：-32768～32767；无符号：0～65535 2 MEDIUMINT 有符号：-8388608～8388607；无符号：0～16777215 3 INT 有符号：-2^31～2^31-1；无符号：0～2^32-1 4 BIGINT 有符号：-2^63～2^63-1；无符号：0～2^64-1 8 浮点型FLOAT[M,D]DOUBLE[M,D] M是数字总位数，D是小数点后的位数 日期时间型 类型 字节 YEAR 1 TIME 3 DATE 3 DATETIME 8 TIMESTAMP 4 字符型 类型 存储需求 CHAR(M) M个字节, 0 &lt;= M &lt;= 255 VARCHAR(M) L+1个字节, L &lt;= M &amp;&amp; 0 &lt;= M &lt;= 65535 TINYTEXT L+1个字节, L &lt;= 2^8 TEXT L+1个字节, L &lt;= 2^16 MEDIUMTEXT L+1个字节, L &lt;= 2^24 LONGTEXT L+1个字节, L &lt;= 2^32 ENUM(‘value1’, ‘value2’) 1或2个字节，取决枚举值个数（最多65,535） SET(‘value1’, ‘value2’) 1,2,3,4或8个字节，取决set成员数目(最多64个成员)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"MySQL简单操作(1)-数据库","slug":"my-common-grammar","date":"2017-12-08T12:25:25.000Z","updated":"2020-07-25T02:57:18.215Z","comments":true,"path":"2017/12/08/my-common-grammar/","link":"","permalink":"https://jigangduan.github.io/2017/12/08/my-common-grammar/","excerpt":"","text":"登陆/退出1mysql -u`username` -p`password` -P`port` -h`host` MySQL默认端口号 3306 MySQL超级用户名 root 退出 mysql &gt; exit; mysql &gt; quit; mysql &gt; \\q; 修改提示符1shell&gt;mysql -uroot -proot --prompt 提示符 或 1mysql&gt;prompt 提示符 参数 描述 \\D 日期 \\d 当前数据库 \\h 服务器名称 \\u 当前用户 常见命令 显示当前服务器版本 1SELECT VERSION(); 显示当前日前时间 1SELECT NOW(); 显示当前用户 1SELECT USER(); 操作数据库 打开数据库 1USE database_name; 用户当前打开的数据库 1SELECT DATABASE(); 创建数据库 1CREATE &#123;DATABASE | SCHEMAS&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name; 查看当前服务器下的数据库列表 1SHOW &#123;DATABASE | SCHEMAS&#125; [LIKE 'pattern' | WHERE expr]; 修改数据库 1ALTER &#123;DATABASE | SCHEMAS&#125; db_name [DEFAULT] CHARACTER SET [=] charset_name; 删除数据库 1DROP &#123;DATABASE | SCHEMAS&#125; [IF NOT EXISTS] db_name;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"}]},{"title":"SampleBrowserPlugin介绍","slug":"BrowserPlugin","date":"2017-12-04T14:56:21.000Z","updated":"2020-07-25T02:57:18.148Z","comments":true,"path":"2017/12/04/BrowserPlugin/","link":"","permalink":"https://jigangduan.github.io/2017/12/04/BrowserPlugin/","excerpt":"对于Android浏览器插件的开发可以参考源码的实例,development/samples/browseplugin实例。本文对此实例进行介绍。","text":"对于Android浏览器插件的开发可以参考源码的实例,development/samples/browseplugin实例。本文对此实例进行介绍。 介绍这个示例插件是为了给插件开发者一个参考点，看看android浏览器插件是如何创建的，以及如何使用可用的APIs。一个插件就像标准的apk一样被打包，可以通过市场或adb安装。示例插件尝试尽可能多地使用APIs，但不幸的是，并不是所有的APIs都被覆盖。 试图让一个插件演示一个屏幕上所有可能的API交互是不现实的。另一方面，我们也不希望每一个功能都有一个单独的插件，因为那会导致许多独立的apk需要维护。为了解决这个问题，我们开发了使用“子插件”的想法。在一个插件中，插件只有一个特定的功能，但是它们都可以共享尽可能多的通用代码。每个子插件及其功能的详细描述可以在子插件部分中找到。 插件结构样例插件被打包为一个插件，但是包含许多独特的子插件(如音频和paint)。 这个包由两部分组成: 包含配置的Java代码; C++共享库，包含浏览器/插件绑定和子插件类。 JAVA Android.mk: 指定APK(SampleBrowserPlugin)的名称，以及包含哪些共享库。 AndroidManifest.xml: 类似于标准的android清单文件，除了它必须包含特定于插件的&quot;uses-permission&quot;和&quot;service&quot; 元素。&quot;service&quot;元素包含描述service的java组件的子元素。 src/*: java源文件的位置。这包含了SamplePlugin。类是我们的插件的java组件。组件必须存在并实现所需的接口，尽管简单地返回null是有效的。 res/*: 静态资源的位置(例如插件的图标) C++ jni/Android.mk: 指定与apk一起包含的共享库的构建参数。该库包含插件和浏览器之间的所有绑定。 jni/main.*: 这段代码是插件和浏览器之间的绑定点。它支持标准的netscape风格插件以及所有android特定APIs所需的所有功能。插件的起始点是NP_Initialize函数。NPP_New函数负责读取输入的args，并选择适当的子插件实例化。大多数其他函数要么返回固定值，要么将它们的输入传递给子插件进行处理。 jni/PluginObject.*: pluginObject提供了一个方便的容器来存储变量(插件的状态)。这个对象的两个主要职责是 构造和存储NPClass对象(使用苹果提供的代码完成) 为子插件对象提供抽象类，并在实例化后存储子插件。 jni/*/*: 每个子插件都有一个包含其类定义和逻辑的文件夹。子插件从浏览器接收事件，它也可以使用netscape插件功能和专用的android界面来与浏览器进行通信。 如何部署只需简单地在设备/模拟器上编译和安装插件即… 运行&quot;make SampleBrowserPlugin&quot;(编译libsampleplugin.so，构建apk) 前面的命令生成一个apk文件，以便记录它的位置 运行&quot;adb install [apk_file]&quot;，将其安装在设备/模拟器上 浏览器会自动识别插件的可用性 现在插件已经安装好了，你可以像通过设置 -&gt; 应用 -&gt; 管理应用程序一样管理它。要执行插件，您需要在一个文档中包含一个html代码片段，该文档可由浏览器访问。mime-type不能改变，但您可以更改宽度、高度和参数。这些参数用于通知插件要执行的插件，以及使用哪个绘图模型。 1234&lt;object type=\"application/x-testbrowserplugin\" height=50 width=250&gt; &lt;param name=\"DrawingModel\" value=\"Surface\" /&gt; &lt;param name=\"PluginType\" value=\"Background\" /&gt;&lt;/object&gt; 子插件每个子插件对应一个插件类型，可以支持一个或多个绘图模型。在下面的小节中，有关于每个子插件的描述以及创建html代码片段所需的信息。 动画 插件类型: 动画 绘制模型: 位图 这个插件在屏幕上画了一个小球。如果这个插件不是完全在屏幕上，并且它被触摸了，那么它就会试图在屏幕上显示它自己。 音频 插件类型:音频 绘制模型:位图 这个插件播放一个位于/sdcard/sdample.raw的原始音频文件(需要提供你自己的)。它使用touch来触发播放、暂停和停止按钮。 后台 插件类型:后台 绘制模型:Surface 这个插件的可视组件很少，但主要是在后台运行API测试。这个插件处理缩放它自己的位图，在这个例子中是一个简单的文本字符串。这个插件的输出在日志中被发现，因为如果它检测到任何API失败，它会打印错误。测试的一些API是定时器、javascript访问和位图格式。 表单 插件类型:表单 绘制模型:位图 这个插件模仿了一个简单的用户名/密码表单。您可以通过触摸或使用导航键来选择文本框。一旦选中，这个框就会突出显示，键盘就会出现。如果选择的文本框不是完全的视图，那么插件将确保它以屏幕为中心。 PAINT 插件类型: Paint 绘制模型: Surface 这个插件提供了一个用户可以“Paint”的界面。输入方法可以在鼠标(点)和触摸(线)之间进行切换。这个插件有一个固定的表面，可以让浏览器在缩放时缩放。 相关知识可以参考https://developer.mozilla.org/en/Gecko_Plugin_API_Reference","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Browser Plugin","slug":"Android/Browser-Plugin","permalink":"https://jigangduan.github.io/categories/Android/Browser-Plugin/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"}]},{"title":"SDKMAN! 软件开发工具包管理器","slug":"sdkman","date":"2017-11-30T05:11:25.000Z","updated":"2020-07-25T02:57:18.228Z","comments":true,"path":"2017/11/30/sdkman/","link":"","permalink":"https://jigangduan.github.io/2017/11/30/sdkman/","excerpt":"SDKMAN!是在大多数Unix系统上管理多个软件开发套件的并行版本的工具。它提供了一个方便的命令行接口(CLI)和用于安装、切换、删除和列出候选对象的API。以前被称为GVM的Groovy环境管理器，它是由非常有用的RVM和rbenv工具所启发的，这些工具在Ruby社区中广泛使用。","text":"SDKMAN!是在大多数Unix系统上管理多个软件开发套件的并行版本的工具。它提供了一个方便的命令行接口(CLI)和用于安装、切换、删除和列出候选对象的API。以前被称为GVM的Groovy环境管理器，它是由非常有用的RVM和rbenv工具所启发的，这些工具在Ruby社区中广泛使用。 安装在类unix平台上安装SDKMAN!，就像以前一样容易。SDKMAN!在Mac OSX、Linux、Cygwin、Solaris和FreeBSD上可以顺利安装。我们还支持Bash和ZSH shell。 只需打开一个新的终端并输入: 1$ curl -s \"https://get.sdkman.io\" | bash 按照屏幕上的说明完成安装。 接下来，打开一个新的终端或输入: 1$ source \"$HOME/.sdkman/bin/sdkman-init.sh\" 最后，运行以下代码片段，以确保安装成功: 1$ sdk version 如果一切顺利，则应该显示该版本: 1sdkman 5.0.0+51 Beta通道对于更喜欢冒险的人来说，我们有一个测试频道。所有新的CLI特性都将首先针对这一组用户进行试用。Beta版本在大多数情况下可以被认为是稳定的，但偶尔也会中断。要加入测试程序，只需更新~/.sdkman/etc/config文件如下: 1sdkman_beta_channel=true 接下来，打开一个新的终端并执行一个强制更新: 1$ sdk selfupdate force 要离开测试通道，只需将上面的配置设置为false，并遵循相同的步骤。 卸载在不太可能的情况下，您希望卸载SDKMAN！我们还没有自动化的方法来做这件事。如果你真的想把它从你的系统中删除，那就很容易做到。下面的内容将指导您进行备份，然后从系统中删除整个安装。 12tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman 最后一步是编辑和删除您的.bashrc, .bash_profile 和/或 .profile文件中的初始化代码片段。如果你使用ZSH，从.zshrc中删除它。要删除的代码片段如下: 12#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!![[ -s \"/home/dudette/.sdkman/bin/sdkman-init.sh\" ]] &amp;&amp; source \"/home/dudette/.sdkman/bin/sdkman-init.sh\" 一旦删除，您就成功地从你的机器卸载了SDKMAN！。 安装到自定义位置安装SDKMAN！到一个除$HOME/.sdkman以外的自定义位置是可能的。这可以通过在安装之前将您的定制位置导出为SDKMAN_DIR来实现。只需打开一个新的终端并输入: 1$ export SDKMAN_DIR=\"/usr/local/sdkman\" &amp;&amp; curl -s \"https://get.sdkman.io\" | bash 为此，您的用户对该文件夹拥有完全访问权限是至关重要的。同样重要的是，如果该文件夹不存在，SDKMAN!将尝试创建它。 使用安装SDK最新稳定版本通过运行下面的命令，安装您的SDK的最新稳定版本(比如Java JDK)。 1$ sdk install java 您将看到如下输出: 12345678Downloading: java 8u111In progress...######################################################################## 100.0%Installing: java 8u111Done installing! 如果您希望将此版本设置为默认值，则会提示您。 1Do you want java 8u111 to be set as default? (Y/n): 回答yes(或回车)将确保所有后续的shell都将在默认情况下使用这个版本的SDK。 1Setting java 8u111 as default. 特定版本需要一个SDK的特定版本吗?简单地限定你需要的版本: 1$ sdk install scala 2.12.1 所有后续步骤都与上面相同。 安装本地版本需要一个快照吗?已经有本地安装了吗?设置一个本地版本: 1$ sdk install groovy 3.0.0-SNAPSHOT /path/to/groovy-3.0.0-SNAPSHOT 删除版本删除一个安装版本。 1$ sdk uninstall scala 2.11.6 候选列表获得一份可用的候选列表: 1$ sdk list 这将提供一个可搜索的字母列表，其中有名称、当前稳定的默认版本、网站URL、描述以及每个候选人的简单安装命令。输出被用管道连接到更少的标准键盘快捷键，可以使用q退出。 12345678910111213141516171819202122================================================================================Available Candidates================================================================================q-quit /-search downj-down ?-search upk-up h-help--------------------------------------------------------------------------------Groovy (2.4.5) http://www.groovy-lang.org/Groovy is a powerful, optionally typed and dynamic language, with static-typingand static compilation capabilities, for the Java platform aimed at multiplyingdevelopers’ productivity thanks to a concise, familiar and easy to learn syntax.It integrates smoothly with any Java program, and immediately delivers to yourapplication powerful features, including scripting capabilities, Domain-SpecificLanguage authoring, runtime and compile-time meta-programming and functionalprogramming. $ sdk install groovy--------------------------------------------------------------------------------Scala (2.11.7) http://www.scala-lang.org/... 版本列表要获得候选版本的列表: 1sdk list groovy 这将产生一个列表视图，显示SDK的可用、本地、安装和当前版本。 12345678910111213141516171819202122232425================================================================================Available Groovy Versions================================================================================ &gt; * 2.4.4 2.3.1 2.0.8 1.8.3 2.4.3 2.3.0 2.0.7 1.8.2 2.4.2 2.2.2 2.0.6 1.8.1 2.4.1 2.2.1 2.0.5 1.8.0 2.4.0 2.2.0 2.0.4 1.7.9 2.3.9 2.1.9 2.0.3 1.7.8 2.3.8 2.1.8 2.0.2 1.7.7 2.3.7 2.1.7 2.0.1 1.7.6 2.3.6 2.1.6 2.0.0 1.7.5 2.3.5 2.1.5 1.8.9 1.7.4 2.3.4 2.1.4 1.8.8 1.7.3 2.3.3 2.1.3 1.8.7 1.7.2 2.3.2 2.1.2 1.8.6 1.7.11 2.3.11 2.1.1 1.8.5 1.7.10 2.3.10 2.1.0 1.8.4 1.7.1================================================================================+ - local version* - installed&gt; - currently in use================================================================================ 使用版本在当前终端选择使用一个给定版本: 1$ sdk use scala 2.12.1 重要的是要认识到，这将只改变当前shell的候选版本。要使此更改持久，请使用default命令。 默认的版本选择一个给定版本的默认值: 1$ sdk default scala 2.11.6 这将确保所有后续的shell都将以2.11.6的版本开始使用。 当前版本(s)要了解目前正在使用的候选: 12$ sdk current java Using java version 8u111 要了解目前所有候选的使用情况: 12345$ sdk current Using: groovy: 2.4.7 java: 8u111 scala: 2.12.1 过时的版本(s)看看你的系统上的候选人目前的情况是怎样的: 123$ sdk outdated springboot Outdated: springboot (1.2.4.RELEASE, 1.2.3.RELEASE &lt; 1.2.5.RELEASE) 看看所有候选都过时了: 12345$ sdk outdated Outdated: gradle (2.3, 1.11, 2.4, 2.5 &lt; 2.6) grails (2.5.1 &lt; 3.0.4) springboot (1.2.4.RELEASE, 1.2.3.RELEASE &lt; 1.2.5.RELEASE) SDKMAN！版本显示当前的SDKMAN！版本 1$ sdk version 广播消息在命令行上获取最新的SDK发布通知: 1234567$ sdk broadcast==== BROADCAST =================================================================* 06/12/16: Scala 2.12.1 released on SDKMAN! #scala* 23/11/16: Gradle 3.2.1 released on SDKMAN! #gradle* 22/11/16: Ceylon 1.3.1 released on SDKMAN! #ceylonlang================================================================================ 值得一提的是，每当在SDKMAN!上发布一个SDK版本时，在使用CLI时将会出现一个通知。每一次新的广播都被推到推特上。 离线模式最初被称为“飞机模式”，它允许SDKMAN!在离线工作时发挥作用。它有一个参数，可以通过它来启用或禁用离线模式。 123456$ sdk offline enable Forced offline mode enabled.$ sdk offline disable Online mode re-enabled! 当在离线模式下运行时，大多数命令仍然可以工作，即使它们的操作是缩小的。一个例子是list命令，它只显示当前安装的和活动的版本(s): 12345678910$ sdk list ------------------------------------------------------------ Offline Mode: only showing installed groovy versions ------------------------------------------------------------ &gt; 2.4.4 * 2.4.3 ------------------------------------------------------------ * - installed &gt; - currently in use ------------------------------------------------------------ 当因特网变得可用/不可用时，离线模式也将自动禁用/启用。当然，需要网络连接的命令不会起作用，但会发出警告。 自升级安装一个新版本的SDKMAN！如果可用。 1$ sdk selfupdate 如果没有新版本可用，将显示适当的消息。重新安装可能是通过将force参数传递给命令: 1$ sdk selfupdate force 自动检查新版本的SDKMAN！也将代表用户执行。 冲洗有时可能需要冲洗 SDKMAN!的本地状态。flush命令可以帮助执行以下操作，并允许执行以下操作: Candidates1$ sdk flush candidates 清除候选列表。打开一个新的终端将获取并存储最新的列表。当一个新的候选在SDKMAN上可用时，通常需要这样做 Broadcast1$ sdk flush broadcast 清除广播缓存，下载下一个命令调用的最新可用新闻。 Archives1$ sdk flush archives 清除包含所有下载的SDK二进制文件的缓存。这可以占用很多空间，所以值得不时地清理一下！ 临时文件夹1$ sdk flush temp 在安装新版本的候选版本和SDKMAN的时候，清除准备工作文件夹。 帮助您可以通过运行以下命令获得基本的帮助: 1$ sdk help 这应该会产生一些类似的东西: 12345678910111213141516171819202122Usage: sdk [version] sdk offline commands: install or i [version] uninstall or rm list or ls use or u [version] default or d [version] current or c [candidate] outdated or o [candidate] version or v broadcast or b help or h offline selfupdate [force] flush candidate : ... version : where optional, defaults to latest stable if not providedeg: sdk install groovy 配置尽管配置是有限的，但是可配置项的列表会随着需要而增长。可以在~/.sdkman/etc/config文件中找到配置。目前，以下是可配置的: 1234567891011121314151617181920# make sdkman non-interactive, preferred for CI environmentssdkman_auto_answer=true|false# perform automatic selfupdatessdkman_auto_selfupdate=true|false# disables SSL certificate verification# https://github.com/sdkman/sdkman-cli/issues/327# HERE BE DRAGONS....sdkman_insecure_ssl=true|false# disable GVM alias, for users of the Go Version Managersdkman_disable_gvm_alias=true|false# configure curl timeoutssdkman_curl_connect_timeout=5sdkman_curl_max_time=4# subscribe to the beta channelsdkman_beta_channel=true Windows PowerShell 使用SDKMAN","categories":[{"name":"包管理器","slug":"包管理器","permalink":"https://jigangduan.github.io/categories/包管理器/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/tags/工具/"},{"name":"jvm","slug":"jvm","permalink":"https://jigangduan.github.io/tags/jvm/"}]},{"title":"CocoaPods 简介","slug":"cocoapods","date":"2017-11-30T05:03:18.000Z","updated":"2020-07-25T02:57:18.196Z","comments":true,"path":"2017/11/30/cocoapods/","link":"","permalink":"https://jigangduan.github.io/2017/11/30/cocoapods/","excerpt":"CocoaPods是Swift和Objective-C Cocoa项目的一个依赖关系管理器。它有超过4万个libraries，在超过280万个应用程序中被使用。CocoaPods可以帮助你优雅地扩展你的项目。","text":"CocoaPods是Swift和Objective-C Cocoa项目的一个依赖关系管理器。它有超过4万个libraries，在超过280万个应用程序中被使用。CocoaPods可以帮助你优雅地扩展你的项目。 安装CocoaPods是用Ruby构建的，在OS X上默认安装有Ruby，我们建议你使用默认的Ruby。 使用默认的Ruby安装要求您在安装gems时使用sudo。指南中还有进一步的安装说明。 12# Xcode 8 + 9$ sudo gem install cocoapods 开始在Xcode项目目录中列出一个名为Podfile的文本文件中的依赖项: 12345678platform :ios, '8.0'use_frameworks!target 'MyApp' do pod 'AFNetworking', '~&gt; 2.6' pod 'ORStackView', '~&gt; 3.0' pod 'SwiftyJSON', '~&gt; 2.3'end 提示: CocoaPods提供了一个pod init命令来创建一个带有智能默认值的Podfile。你应该使用它。 现在您可以在您的项目中安装依赖项: 1$ pod install 在构建项目时，确保始终打开Xcode工作区，而不是项目文件: 1$ open App.xcworkspace 现在您可以导入您的依赖项了: 1#import &lt;Reachability/Reachability.h&gt; 创建pod有时候，对于你的一个依赖项，CocoaPods还没有一个pod。幸运的是，创建pod非常简单: 123$ pod spec create Peanut$ edit Peanut.podspec$ pod spec lint Peanut.podspec 你可以在指南中找到很多关于这个过程的信息。当你完成的时候，你可以得到一个账户，把你的pod推到CocoaPods的树干上。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"包管理器","slug":"iOS/包管理器","permalink":"https://jigangduan.github.io/categories/iOS/包管理器/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"cocoapods","slug":"cocoapods","permalink":"https://jigangduan.github.io/tags/cocoapods/"}]},{"title":"Android 自动化测试 - 第6部分","slug":"introduction-automated-android-testing-part-6","date":"2017-11-20T10:31:58.000Z","updated":"2020-07-25T02:57:18.209Z","comments":true,"path":"2017/11/20/introduction-automated-android-testing-part-6/","link":"","permalink":"https://jigangduan.github.io/2017/11/20/introduction-automated-android-testing-part-6/","excerpt":"在之前的5篇博客文章中，我们讨论了从头开始构建Android应用的不同方面。我们专注于在过程中包括测试。以下是与前几篇文章的链接: 第1部分 - 为什么我们要写测试? 第2部分 - 进行测试设置你的应用程序 第3部分 - 创建API调用 第4部分 - 创建repositories 第5部分 - 遵循MVP模式 在本系列的最后一篇文章中，我们将介绍为我们在第5部分中创建的视图创建Espresso测试。这篇文章的Github repo可以在这里找到。 如果数据是动态的，那么测试一个视图包含所期望的确切信息是很棘手的。这些数据可以随时更改，我们的测试不应该因为它而失败。为了使测试可靠且可重复，我们不应该调用任何生产APIs。 模拟API调用的响应将使我们能够编写依赖于模拟数据的测试。有几种方法可以模拟我们的API调用: 选项1 - 使用WireMock并运行一个独立的服务器，它为特定的网络调用提供相同的静态JSON。 选项2 - 使用OkHttp的MockWebServer，它在你的设备上运行一个webserver，并提供你所请求的任何响应。 选项3 - 创建一个返回虚拟对象的Retrofit REST接口的自定义实现。 显然，这个选择完全取决于您如何编写UI测试。在我的例子中，WireMock是额外的工作，因为我需要确保我有一个独立的服务器，它运行的是一个静态IP地址。 与WireMock相比，MockWebServer要容易得多，因为您不需要设置一个独立的web服务器(服务器在设备上运行)。MockWebServer也很灵活，因为您可以给它不同的场景。一些有用的特性，比如指定某个调用的失败率或模拟慢速网络，都是可以使用MockWebServer实现的。(阅读更多这里) 我将使用选项3来测试UI与模拟响应数据匹配的目的。如果我想为慢网络环境添加测试(或某种非功能测试)，我将选择选项2。如果您不能使用OkHttp，那么我将选择选项1作为Wiremock与任何HTTP客户机一起工作。","text":"在之前的5篇博客文章中，我们讨论了从头开始构建Android应用的不同方面。我们专注于在过程中包括测试。以下是与前几篇文章的链接: 第1部分 - 为什么我们要写测试? 第2部分 - 进行测试设置你的应用程序 第3部分 - 创建API调用 第4部分 - 创建repositories 第5部分 - 遵循MVP模式 在本系列的最后一篇文章中，我们将介绍为我们在第5部分中创建的视图创建Espresso测试。这篇文章的Github repo可以在这里找到。 如果数据是动态的，那么测试一个视图包含所期望的确切信息是很棘手的。这些数据可以随时更改，我们的测试不应该因为它而失败。为了使测试可靠且可重复，我们不应该调用任何生产APIs。 模拟API调用的响应将使我们能够编写依赖于模拟数据的测试。有几种方法可以模拟我们的API调用: 选项1 - 使用WireMock并运行一个独立的服务器，它为特定的网络调用提供相同的静态JSON。 选项2 - 使用OkHttp的MockWebServer，它在你的设备上运行一个webserver，并提供你所请求的任何响应。 选项3 - 创建一个返回虚拟对象的Retrofit REST接口的自定义实现。 显然，这个选择完全取决于您如何编写UI测试。在我的例子中，WireMock是额外的工作，因为我需要确保我有一个独立的服务器，它运行的是一个静态IP地址。 与WireMock相比，MockWebServer要容易得多，因为您不需要设置一个独立的web服务器(服务器在设备上运行)。MockWebServer也很灵活，因为您可以给它不同的场景。一些有用的特性，比如指定某个调用的失败率或模拟慢速网络，都是可以使用MockWebServer实现的。(阅读更多这里) 我将使用选项3来测试UI与模拟响应数据匹配的目的。如果我想为慢网络环境添加测试(或某种非功能测试)，我将选择选项2。如果您不能使用OkHttp，那么我将选择选项1作为Wiremock与任何HTTP客户机一起工作。 用Gradle flavors来模拟数据通过使用Gradle flavors，我们可以很容易地模拟出API的响应。如果你读了第二篇关于Gradle flavors的文章，你应该已经有了一个“mock”和“production”的flavor。 确保您已经切换到mockDebug flavor。 在src目录中创建一个mock文件夹。 然后在mock文件夹中创建一个包，它模仿了主包名。使一个类称为MockGithubUserRestServiceImpl。最终的文件结构应该是这样的: ![](https://i0.wp.com/riggaroo.co.za/wp-content/uploads/2016/09/Screen-Shot-2016-09-02-at-11.41.31-AM.png?ssl=1) 创建一个prod目录 将先前定义的Injection类移动到这个文件夹中。我们将在mock文件夹中创建另一个Injection类。这个类将会注入被模拟的Github服务，而不是生产API。 ![](https://i1.wp.com/riggaroo.co.za/wp-content/uploads/2016/09/Screen-Shot-2016-09-02-at-12.14.31-PM.png?resize=612%2C1024&amp;ssl=1) 在Injection类位于**mock**文件夹中,我们简单地返回MockGithubUserServiceImpl创建。 在prod文件夹中，我们将返回实际的更新Github服务。 Mock Injection类: 123456789101112131415public class Injection &#123; private static GithubUserRestService userRestService; public static UserRepository provideUserRepo() &#123; return new UserRepositoryImpl(provideGithubUserRestService()); &#125; static GithubUserRestService provideGithubUserRestService() &#123; if (userRestService == null) &#123; userRestService = new MockGithubUserRestServiceImpl(); &#125; return userRestService; &#125;&#125; Prod注射类: 123456789101112131415161718192021222324252627282930313233343536373839public class Injection &#123; private static final String BASE_URL = \"https://api.github.com\"; private static OkHttpClient okHttpClient; private static GithubUserRestService userRestService; private static Retrofit retrofitInstance; public static UserRepository provideUserRepo() &#123; return new UserRepositoryImpl(provideGithubUserRestService()); &#125; static GithubUserRestService provideGithubUserRestService() &#123; if (userRestService == null) &#123; userRestService = getRetrofitInstance().create(GithubUserRestService.class); &#125; return userRestService; &#125; static OkHttpClient getOkHttpClient() &#123; if (okHttpClient == null) &#123; HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BASIC); okHttpClient = new OkHttpClient.Builder().addInterceptor(logging).build(); &#125; return okHttpClient; &#125; static Retrofit getRetrofitInstance() &#123; if (retrofitInstance == null) &#123; Retrofit.Builder retrofit = new Retrofit.Builder().client(Injection.getOkHttpClient()).baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()); retrofitInstance = retrofit.build(); &#125; return retrofitInstance; &#125;&#125; 从模拟服务返回的数据依赖于您的特定需求。 下面是我MockGithubUserRestServiceImpl的实现: 1234567891011121314151617181920212223242526272829public class MockGithubUserRestServiceImpl implements GithubUserRestService &#123; private final List&lt;User&gt; usersList = new ArrayList&lt;&gt;(); private User dummyUser1, dummyUser2; public MockGithubUserRestServiceImpl() &#123; dummyUser1 = new User(\"riggaroo\", \"Rebecca Franks\", \"https://riggaroo.co.za/wp-content/uploads/2016/03/rebeccafranks_circle.png\", \"Android Dev\"); dummyUser2 = new User(\"riggaroo2\", \"Rebecca's Alter Ego\", \"https://s-media-cache-ak0.pinimg.com/564x/e7/cf/f3/e7cff3be614f68782386bfbeecb304b1.jpg\", \"A unicorn\"); usersList.add(dummyUser1); usersList.add(dummyUser2); &#125; @Override public Observable&lt;UsersList&gt; searchGithubUsers(final String searchTerm) &#123; return Observable.just(new UsersList(usersList)); &#125; @Override public Observable&lt;User&gt; getUser(final String username) &#123; if (username.equals(\"riggaroo\")) &#123; return Observable.just(dummyUser1); &#125; else if (username.equals(\"riggaroo2\")) &#123; return Observable.just(dummyUser2); &#125; return Observable.just(null); &#125;&#125; 在这种情况下，我只是返回一些虚构的数据。让我们运行这个应用的模拟版本，无论你搜索什么，我们都应该得到相同的结果。 ![](https://i1.wp.com/riggaroo.co.za/wp-content/uploads/2016/09/gif-dummydata.gif?resize=480%2C854&amp;ssl=1) 现在我们有了一个工作虚拟应用程序！我们现在可以写Espresso UI测试。 写Espresso测试的基础在编写一个Espresso测试时，下面的公式用于在UI中执行函数: 123onView(withId(R.id.menu_search)) // withId(R.id.menu_search) is a ViewMatcher .perform(click()) // click() is a ViewAction .check(matches(isDisplayed())); // matches(isDisplayed()) is a ViewAssertion ViewMatchers - 用于在activity中找到一个视图。有一堆不同种类的matchers。例如:withId(R.id.menu_search)、withText(&quot;Search&quot;)、withTag(&quot;custom_tag&quot;)。 ViewActions - 用于与视图交互。例如:click()、doubleClick()、swipeUp()、typeText() ViewAssertations - 用于断言某些视图具有特定的属性。例如:doesNotExist()、isAbove()、isBelow()。 对于不同的Espresso方法，有一个很好的备忘单，在这里可以找到pdf格式的:android-espresso-testing.pdf。值得一提的是，在写Espresso测试时，可以使用普通的hamcrest matchers。方法如not(), allOf() 和 anyOf()都是有效的。 编写Espresso UI测试如果您还记得，在第2篇文章中，我们讨论了需要添加哪些依赖项来编写Espresso测试。现在我们来写一份Espresso测试。 创建一个文件夹androidTestMock。 这个文件夹中的测试只运行在mock的变体上，而不是在production版本上。然后创建一个与主包名匹配的目录。在该目录中，添加一个名为UserSearchActivityTest的新类。你的项目应该是这样的: ![](https://i1.wp.com/riggaroo.co.za/wp-content/uploads/2016/09/AndroidTestMock_folder.png?resize=768%2C703&amp;ssl=1) 我们将首先编写一个基本的测试，以确保当activity启动时，文本“开始键入搜索”将显示出来: 1234567891011121314public class UserSearchActivityTest &#123; @Rule public ActivityTestRule&lt;UserSearchActivity&gt; testRule = new ActivityTestRule&lt;&gt;(UserSearchActivity.class); @Test public void searchActivity_onLaunch_HintTextDisplayed()&#123; //Given activity automatically launched //When user doesn't interact with the view //Then onView(withText(\"Start typing to search\")) .check(matches(isDisplayed())); &#125;&#125; @Rule ActivityTestRule指定该测试将使用哪个activity。在这种情况下，这个测试将使用UserSearchActivity运行。这将自动启动UserSearchActivity。传递额外参数将指示您是否希望该activity自动启动或不启动。 测试searchActivity_onLaunch_HintTextDisplayed()是非常简单的。它在视图中搜索文本，并断言文本在UI中可见 下一步测试稍微复杂一点: 12345678910111213141516@Testpublic void searchText_ReturnsCorrectlyFromWebService_DisplaysResult() &#123; //Given activity is automatically launched //When onView(allOf(withId(R.id.menu_search), withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE))).perform( click()); // When using a SearchView, there are two views that match the id menu_search - one that represents the icon, and the other the edit text view. We want to click on the visible one. onView(withId(R.id.search_src_text)).perform(typeText(\"riggaroo\"), pressKey(KeyEvent.KEYCODE_ENTER)); //Then onView(withText(\"Start typing to search\")).check(matches(not(isDisplayed()))); onView(withText(\"riggaroo - Rebecca Franks\")).check(matches(isDisplayed())); onView(withText(\"Android Dev\")).check(matches(isDisplayed())); onView(withText(\"A unicorn\")).check(matches(isDisplayed())); onView(withText(\"riggaroo2 - Rebecca's Alter Ego\")).check(matches(isDisplayed()));&#125; 输入到SearchView并按enter键后，我们断言假的结果会显示在UI上。 我们现在已经为积极的场景编写了测试，我们也应该为这个消极的情况添加一个测试。 我们需要调整MockGithubUserRestServiceImpl为了让它返回自定义错误可见如果需要。 12345678910111213private static Observable dummyGithubSearchResult = null;public static void setDummySearchGithubCallResult(Observable result) &#123; dummyGithubSearchResult = result;&#125;@Overridepublic Observable&lt;UsersList&gt; searchGithubUsers(final String searchTerm) &#123; if (dummyGithubSearchResult != null) &#123; return dummyGithubSearchResult; &#125; return Observable.just(new UsersList(usersList));&#125; 在上面的代码中，创建了一个方法，目的是为搜索结果设置一个可观察的虚拟数据。 当searchGithubUsers()被调用时，该可观察的值将被返回。 现在我们可以创建一个测试来检查是否在UI上显示了错误。 123456789101112@Testpublic void searchText_ServiceCallFails_DisplayError()&#123; String errorMsg = \"Server Error\"; MockGithubUserRestServiceImpl.setDummySearchGithubCallResult(Observable.error(new Exception(errorMsg))); onView(allOf(withId(R.id.menu_search), withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE))).perform( click()); // When using a SearchView, there are two views that match the id menu_search - one that represents the icon, and the other the edit text view. We want to click on the visible one. onView(withId(R.id.search_src_text)).perform(typeText(\"riggaroo\"), pressKey(KeyEvent.KEYCODE_ENTER)); onView(withText(errorMsg)).check(matches(isDisplayed()));&#125; 在这个测试中，我们首先确保服务将返回一个异常。然后，我们断言错误消息将显示在UI上。 让我们运行测试: 他们都通过了! Android代码覆盖率为了了解您的测试有多有效，获得代码覆盖度量是非常棒的。 为了在您的UI测试中启用代码覆盖率，可以在您的build.gradle:中添加testCoverageEnabled = true。 123456789buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; debug &#123; testCoverageEnabled = true &#125;&#125; 运行任务createMockDebugCoverageReport。你将在这里找到HTML报告所在地:app/build/reports/coverage/mock/debug/index.html。 Yay-我们只有模拟UI测试的82%的覆盖率。考虑到我们在第四篇和这篇文章中看到的覆盖率报告，它可以很好地说明我们整个应用程序的测试覆盖率。现在我们可以迭代地返回并尝试覆盖更多的代码区域。 PS-代码覆盖目前与Jack编译器不兼容。为了使代码覆盖率报告工作，我切换到使用Retrolambda。如果你对学习有兴趣，可以去看看这个分支。 结论我们已经完成了我们的功能。唷!6的博客文章。显然，在这款应用中还可以完成更多的测试，比如测试你的应用在低内存设备上的表现，或者在网络连接不佳的情况下，也可以添加一些非功能测试。 这一系列的结论是“引入Android自动化测试”。 进一步的阅读 先进的Espresso测试 – Chiu-Ki – https://realm.io/news/chiu-ki-chan-advanced-android-espresso-testing/ Screen Robots – https://realm.io/news/kau-jake-wharton-testing-robots/ TestButler – https://github.com/linkedin/test-butler","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"}]},{"title":"Android 自动化测试 - 第5部分","slug":"introduction-automated-android-testing-part-5","date":"2017-11-20T09:15:26.000Z","updated":"2020-07-25T02:57:18.208Z","comments":true,"path":"2017/11/20/introduction-automated-android-testing-part-5/","link":"","permalink":"https://jigangduan.github.io/2017/11/20/introduction-automated-android-testing-part-5/","excerpt":"在这一系列的博客文章中，我们正在研究一个叫做Github用户搜索的样本应用。第1-4部分介绍了为什么我们应该进行测试、设置测试、创建API调用并创建一个演示程序。看一下前面的文章，第5部分是这个系列的延续。 在第5部分中，我们将查看与第4部分中创建的Presenter的交互，我们将创建UI来显示搜索结果的列表。","text":"在这一系列的博客文章中，我们正在研究一个叫做Github用户搜索的样本应用。第1-4部分介绍了为什么我们应该进行测试、设置测试、创建API调用并创建一个演示程序。看一下前面的文章，第5部分是这个系列的延续。 在第5部分中，我们将查看与第4部分中创建的Presenter的交互，我们将创建UI来显示搜索结果的列表。 创建UI对于用户界面，我们需要一个简单的列表来显示列表中的avatar、name和其他用户信息。 在第4部分中，我们定义了一个Activity应该实现的视图契约。这是Android专用代码所在的位置(诸如可见性变化或任何UI更改都将位于此处)。为了更新你的记忆，这是我们在上一篇文章中创建的视图契约: 12345678910111213141516interface UserSearchContract &#123; interface View extends MvpView &#123; void showSearchResults(List&lt;User&gt; githubUserList); void showError(String message); void showLoading(); void hideLoading(); &#125; interface Presenter extends MvpPresenter&lt;View&gt; &#123; void search(String term); &#125;&#125; 让我们实现视图! 创建一个名为UserSearchActivity的类。这个类将实现UserSearchContract.View契约并扩展AppCompatActivity。定义一个变量userSearchPresenter UserSearchContract.Presenter类型。这是我们将与之交互的对象，以执行我们的网络调用。 123456789101112131415161718192021222324252627282930313233343536373839public class UserSearchActivity extends AppCompatActivity implements UserSearchContract.View &#123; private UserSearchContract.Presenter userSearchPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_search); userSearchPresenter = new UserSearchPresenter(Injection.provideUserRepo(), Schedulers.io(), AndroidSchedulers.mainThread()); userSearchPresenter.attachView(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); userSearchPresenter.detachView(); &#125; @Override public void showSearchResults(List&lt;User&gt; githubUserList) &#123; &#125; @Override public void showError(String message) &#123; &#125; @Override public void showLoading() &#123; &#125; @Override public void hideLoading() &#123; &#125;&#125; 在onCreate()中，创建presenter对象。提供在注入类中定义的User repo。通过io()调度器和AndroidSchedulers.mainThread()调度器,RxJava订阅他们应该知道哪个线程上执行他们的工作。 下一行,你可以看到我调用userSearchPresenter.attachView(this)。它将视图附加到presenter，以便presenter可以通知视图任何更改。因为presenter不知道activity的生命周期,在onDestroy()我们需要通知presenter不复存在的观点是,我们应该叫userSearchPresenter.detachView()。这将注销任何RxJava订阅，防止内存泄漏。 创建activity_user_search.xml文件夹中的xml。这将包含一个RecyclerView、一个ProgressBar、一个错误TextView和一个Toolbar。我使用了ConstraintLayout来设计我的屏幕，所以我不会过多地讲细节，因为它主要是拖放。(如果你想读更多关于ConstraintLayout的文章，请参阅我的博客文章) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_user_search\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"za.co.riggaroo.gus.presentation.search.UserSearchActivity\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" android:theme=\"?attr/actionBarTheme\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintLeft_toLeftOf=\"@+id/activity_user_search\" app:layout_constraintRight_toRightOf=\"@+id/activity_user_search\" app:layout_constraintTop_toTopOf=\"@+id/activity_user_search\"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view_users\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_marginBottom=\"16dp\" android:clipToPadding=\"false\" android:scrollbars=\"vertical\" app:layoutManager=\"android.support.v7.widget.LinearLayoutManager\" app:layout_constraintBottom_toBottomOf=\"@+id/activity_user_search\" app:layout_constraintLeft_toLeftOf=\"@+id/activity_user_search\" app:layout_constraintRight_toRightOf=\"@+id/activity_user_search\" app:layout_constraintTop_toBottomOf=\"@+id/toolbar\" tools:listitem=\"@layout/list_item_user\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:id=\"@+id/text_view_error_msg\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dp\" android:text=\"@string/search_for_some_users\" android:visibility=\"visible\" app:layout_constraintBottom_toBottomOf=\"@+id/recycler_view_users\" app:layout_constraintLeft_toLeftOf=\"@+id/toolbar\" app:layout_constraintRight_toRightOf=\"@+id/recycler_view_users\" app:layout_constraintTop_toBottomOf=\"@+id/toolbar\" tools:text=\"No Data has loaded\"/&gt; &lt;ProgressBar android:id=\"@+id/progress_bar\" style=\"@style/Widget.AppCompat.ProgressBar\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:layout_marginBottom=\"16dp\" android:layout_marginTop=\"16dp\" android:visibility=\"gone\" app:layout_constraintBottom_toBottomOf=\"@+id/activity_user_search\" app:layout_constraintLeft_toLeftOf=\"@+id/recycler_view_users\" app:layout_constraintRight_toRightOf=\"@+id/recycler_view_users\" app:layout_constraintTop_toBottomOf=\"@+id/toolbar\" tools:visibility=\"visible\"/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 我们还需要向工具栏添加一个SearchView，这样我们就可以在某个地方输入。添加一个menu_user_search.xml文件到菜单资源文件夹。在它里面，你需要添加一个SearchView: 12345678910 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;item android:id=\"@+id/menu_search\" android:icon=\"@drawable/ic_search\" app:showAsAction=\"always|collapseActionView\" android:title=\"@string/search_icon_title\" app:actionViewClass=\"android.support.v7.widget.SearchView\"/&gt;&lt;/menu&gt; 我们需要创建一个布局，该布局将用于RecyclerView中的每个条目。布局文件夹中创建一个名为list_item_user.xml的文件。我用ConstraintLayout包含一个ImageView和两个textview。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/constraintLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/imageview_userprofilepic\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginTop=\"16dp\" app:layout_constraintLeft_toLeftOf=\"@+id/constraintLayout\" app:layout_constraintTop_toTopOf=\"@+id/constraintLayout\" app:srcCompat=\"@mipmap/ic_launcher\"/&gt; &lt;TextView android:id=\"@+id/textview_username\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginTop=\"16dp\" android:textAppearance=\"@style/TextAppearance.AppCompat.Medium\" app:layout_constraintLeft_toRightOf=\"@+id/imageview_userprofilepic\" app:layout_constraintTop_toTopOf=\"@+id/constraintLayout\" tools:text=\"Rebecca Franks\"/&gt; &lt;TextView android:id=\"@+id/textview_user_profile_info\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginEnd=\"16dp\" android:layout_marginLeft=\"16dp\" android:layout_marginRight=\"16dp\" android:layout_marginStart=\"16dp\" android:textAppearance=\"@style/TextAppearance.AppCompat.Caption\" app:layout_constraintBottom_toBottomOf=\"@+id/constraintLayout\" app:layout_constraintLeft_toRightOf=\"@+id/imageview_userprofilepic\" app:layout_constraintRight_toRightOf=\"@+id/constraintLayout\" app:layout_constraintTop_toBottomOf=\"@+id/textview_username\" tools:text=\"JHB, South Africa. Lots of code, lots and lots and lots of code.\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 现在，我们已经有了所需的所有布局，让我们将XML与Activity联系起来。首先，在onCreate()中，我们将获得对我们需要的视图的引用。 1234567891011121314151617181920private UsersAdapter usersAdapter; private SearchView searchView; private Toolbar toolbar; private ProgressBar progressBar; private RecyclerView recyclerViewUsers; private TextView textViewErrorMessage; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); progressBar = (ProgressBar) findViewById(R.id.progress_bar); textViewErrorMessage = (TextView) findViewById(R.id.text_view_error_msg); recyclerViewUsers = (RecyclerView) findViewById(R.id.recycler_view_users); usersAdapter = new UsersAdapter(null, this); recyclerViewUsers.setAdapter(usersAdapter); &#125; 我们需要将SearchView连接到我们的activity中，以使它触发presenters search()方法。在onCreateOptionsMenu()中，添加以下代码: 1234567891011121314151617181920212223242526@Override public boolean onCreateOptionsMenu(Menu menu) &#123; super.onCreateOptionsMenu(menu); getMenuInflater().inflate(R.menu.menu_user_search, menu); final MenuItem searchActionMenuItem = menu.findItem(R.id.menu_search); searchView = (SearchView) searchActionMenuItem.getActionView(); searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() &#123; @Override public boolean onQueryTextSubmit(String query) &#123; if (!searchView.isIconified()) &#123; searchView.setIconified(true); &#125; userSearchPresenter.search(query); toolbar.setTitle(query); searchActionMenuItem.collapseActionView(); return false; &#125; @Override public boolean onQueryTextChange(String s) &#123; return false; &#125; &#125;); searchActionMenuItem.expandActionView(); return true; &#125; 这将使正确的菜单inflate，找到搜索视图并设置一个查询文本侦听器。在这种情况下，只有当有人按下键盘上的提交时，我们才会以查询的方式调用搜索提供器。我们也可以在onQueryTextChange中完成，但是由于在Github API上的限制，我将坚持onQueryTextSubmit。默认情况下，项目将被扩展。 接下来，我们将实现presenter在完成加载时将调用的回调。 12345678910111213141516171819202122232425262728@Override public void showSearchResults(List&lt;User&gt; githubUserList) &#123; recyclerViewUsers.setVisibility(View.VISIBLE); textViewErrorMessage.setVisibility(View.GONE); usersAdapter.setItems(githubUserList); &#125; @Override public void showError(String message) &#123; textViewErrorMessage.setVisibility(View.VISIBLE); recyclerViewUsers.setVisibility(View.GONE); textViewErrorMessage.setText(message); &#125; @Override public void showLoading() &#123; progressBar.setVisibility(View.VISIBLE); recyclerViewUsers.setVisibility(View.GONE); textViewErrorMessage.setVisibility(View.GONE); &#125; @Override public void hideLoading() &#123; progressBar.setVisibility(View.GONE); recyclerViewUsers.setVisibility(View.VISIBLE); textViewErrorMessage.setVisibility(View.GONE); &#125; 我们基本上只是在这里切换视图的可见性，并将usersAdapter设置为服务返回的新items。 为了完整起见，这里是UserSearchAdapter类，它用于activity的RecyclerView: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class UsersAdapter extends RecyclerView.Adapter&lt;UserViewHolder&gt; &#123; private final Context context; private List&lt;User&gt; items; UsersAdapter(List&lt;User&gt; items, Context context) &#123; this.items = items; this.context = context; &#125; @Override public UserViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_user, parent, false); return new UserViewHolder(v); &#125; @Override public void onBindViewHolder(UserViewHolder holder, int position) &#123; User item = items.get(position); holder.textViewBio.setText(item.getBio()); if (item.getName() != null) &#123; holder.textViewName.setText(item.getLogin() + \" - \" + item.getName()); &#125; else &#123; holder.textViewName.setText(item.getLogin()); &#125; Picasso.with(context).load(item.getAvatarUrl()).into(holder.imageViewAvatar); &#125; @Override public int getItemCount() &#123; if (items == null) &#123; return 0; &#125; return items.size(); &#125; void setItems(List&lt;User&gt; githubUserList) &#123; this.items = githubUserList; notifyDataSetChanged(); &#125;&#125; class UserViewHolder extends RecyclerView.ViewHolder &#123; final TextView textViewBio; final TextView textViewName; final ImageView imageViewAvatar; UserViewHolder(View v) &#123; super(v); imageViewAvatar = (ImageView) v.findViewById(R.id.imageview_userprofilepic); textViewName = (TextView) v.findViewById(R.id.textview_username); textViewBio = (TextView) v.findViewById(R.id.textview_user_profile_info); &#125;&#125; 注射类 12345678910111213141516171819202122232425262728293031323334353637383940public class Injection &#123; private static final String BASE_URL = \"https://api.github.com\"; private static OkHttpClient okHttpClient; private static GithubUserRestService userRestService; private static Retrofit retrofitInstance; public static UserRepository provideUserRepo() &#123; return new UserRepositoryImpl(provideGithubUserRestService()); &#125; static GithubUserRestService provideGithubUserRestService() &#123; if (userRestService == null) &#123; userRestService = getRetrofitInstance().create(GithubUserRestService.class); &#125; return userRestService; &#125; static OkHttpClient getOkHttpClient() &#123; if (okHttpClient == null) &#123; HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BASIC); okHttpClient = new OkHttpClient.Builder().addInterceptor(logging).build(); &#125; return okHttpClient; &#125; static Retrofit getRetrofitInstance() &#123; if (retrofitInstance == null) &#123; Retrofit.Builder retrofit = new Retrofit.Builder().client(Injection.getOkHttpClient()).baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()); retrofitInstance = retrofit.build(); &#125; return retrofitInstance; &#125;&#125; 现在，如果你运行这款应用，你应该能够在Github上搜索用户名，并查看结果。 耶!我们有一个工作应用程序。这篇文章的代码可以在这里找到。在接下来的部分中，我们将考虑为应用程序编写UI测试！","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"}]},{"title":"Android 自动化测试 - 第4部分","slug":"introduction-android-testing-part-4","date":"2017-11-17T12:28:15.000Z","updated":"2020-07-25T02:57:18.208Z","comments":true,"path":"2017/11/17/introduction-android-testing-part-4/","link":"","permalink":"https://jigangduan.github.io/2017/11/17/introduction-android-testing-part-4/","excerpt":"在这篇博文中，我们正在开发一个名为Github用户搜索的Android应用程序。在之前的博客文章中，我们研究了为测试创建应用程序、创建API调用和编写API转换的第一个基本测试。阅读第1部分、第2部分和第3部分。 这篇文章将着眼于创建一个与repository通信并向视图传递信息的presenter。这还包括为presenter编写单元测试。这篇博文的示例github repo将会在这里找到。","text":"在这篇博文中，我们正在开发一个名为Github用户搜索的Android应用程序。在之前的博客文章中，我们研究了为测试创建应用程序、创建API调用和编写API转换的第一个基本测试。阅读第1部分、第2部分和第3部分。 这篇文章将着眼于创建一个与repository通信并向视图传递信息的presenter。这还包括为presenter编写单元测试。这篇博文的示例github repo将会在这里找到。 创建Presenter 为了开始创建，创建称为MvpView和MvpPresenter的基本接口。所有的MVP功能都将扩展这两个接口。 12public interface MvpView &#123;&#125; 123456public interface MvpPresenter&lt;V extends MvpView&gt; &#123; void attachView(V mvpView); void detachView();&#125; 创建一个BasePresenter。这将提供功能来检查一个视图是否附加到presenter上，以及管理RxJava订阅的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041 public class BasePresenter&lt;T extends MvpView&gt; implements MvpPresenter&lt;T&gt; &#123; private T view; private CompositeSubscription compositeSubscription = new CompositeSubscription(); @Override public void attachView(T mvpView) &#123; view = mvpView; &#125; @Override public void detachView() &#123; compositeSubscription.clear(); view = null; &#125; public T getView() &#123; return view; &#125; public void checkViewAttached() &#123; if (!isViewAttached()) &#123; throw new MvpViewNotAttachedException(); &#125; &#125; private boolean isViewAttached() &#123; return view != null; &#125; protected void addSubscription(Subscription subscription) &#123; this.compositeSubscription.add(subscription); &#125; protected static class MvpViewNotAttachedException extends RuntimeException &#123; public MvpViewNotAttachedException() &#123; super(\"Please call Presenter.attachView(MvpView) before\" + \" requesting data to the Presenter\"); &#125; &#125;&#125; 正如您可以看到的，在presenter中有一个CompositeSubscription。该对象将持有一组RxJava订阅。detachView()方法调用compositeSubscription.clear()将从所有订阅退订,防止内存泄漏和视图崩溃(代码将不会运行时视图被摧毁,因为它是unsubscribed)。当一个presenter在一个子类中创建一个订阅器时，我们将调用addSubscription() 在一个名为UserSearchContract的类中创建视图和presenter之间的契约。在这个类中，创建一个用于视图和presenter的两个接口。 12345678910111213141516interface UserSearchContract &#123; interface View extends MvpView &#123; void showSearchResults(List&lt;User&gt; githubUserList); void showError(String message); void showLoading(); void hideLoading(); &#125; interface Presenter extends MvpPresenter&lt;View&gt; &#123; void search(String term); &#125;&#125; 在view中，有4种方法，showSearchResults()、showLoading()、hideLoading()、showError()。在presenter中，有一个名为search()的方法。 presenter不关心view是如何显示结果的，也不关心它如何显示错误。类似地，一个view并不关心一个presenter如何搜索，只要它使用这些回调来通知，实现就无关紧要了。 分离视图和presenter之间的逻辑很简单。考虑为另一种类型的UI重用演示程序，这将使您意识到代码应该在哪里。例如，如果您必须使用Java Swing，那么在这种情况下，您的演示器可以保持不变，只有您的视图实现会有所不同。这可以帮助您通过简单地问自己一个问题来放置逻辑:如果我有不同类型的UI，那么presenter中的逻辑会有意义吗? 现在，view和presenter之间的契约被定义了。创建/导航到UserSearchPresenter。这里将创建UserRepository的订阅，它将调用Github API。 1234567891011class UserSearchPresenter extends BasePresenter&lt;UserSearchContract.View&gt; implements UserSearchContract.Presenter &#123; private final Scheduler mainScheduler, ioScheduler; private UserRepository userRepository; UserSearchPresenter(UserRepository userRepository, Scheduler ioScheduler, Scheduler mainScheduler) &#123; this.userRepository = userRepository; this.ioScheduler = ioScheduler; this.mainScheduler = mainScheduler; &#125;&#125; 在这里，presenter扩展了BasePresenter，并实现了第3步中定义的UserSearchContract.Presenter契约。该类将实现search()方法。 在尝试进行单元测试时，使用构造函数注入可以轻松地模拟UserRepository。schedulers也被注入到构造函数中，因为单元测试总是使用Schedulers.immediate()，但是在视图中，我们将使用不同的线程。 现在，为了实现search(): 1234567891011121314151617181920212223@Override public void search(String term) &#123; checkViewAttached(); getView().showLoading(); addSubscription(userRepository.searchUsers(term).subscribeOn(ioScheduler).observeOn(mainScheduler).subscribe(new Subscriber&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; getView().hideLoading(); getView().showError(e.getMessage()); //TODO You probably don't want this error to show to users - Might want to show a friendlier message :) &#125; @Override public void onNext(List&lt;User&gt; users) &#123; getView().hideLoading(); getView().showSearchResults(users); &#125; &#125;)); &#125; 首先，运行checkViewAttached()，如果在方法开始运行时没有附加视图，它将抛出一个异常。然后告诉视图，它应该通过调用showLoading()开始加载。创建userRepository.searchUsers()的订阅。将subscribeOn()设置为ioScheduler变量，因为我们希望在IO线程上发生这些网络调用。设置observeOn() mainScheduler，因为我们希望在主线程上观察到这个订阅的结果。然后通过调用addSubscription，将订阅添加到复合订阅中。 在onNext()方法中，通过使用API返回的用户列表调用hideLoading()和showSearchResults()来处理结果。在onError()中，停止加载，并使用异常的消息调用showError()。 下面是UserSearchPresenter的完整代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445package za.co.riggaroo.gus.presentation.search;import java.util.List;import rx.Scheduler;import rx.Subscriber;import za.co.riggaroo.gus.data.UserRepository;import za.co.riggaroo.gus.data.remote.model.User;import za.co.riggaroo.gus.presentation.base.BasePresenter;class UserSearchPresenter extends BasePresenter&lt;UserSearchContract.View&gt; implements UserSearchContract.Presenter &#123; private final Scheduler mainScheduler, ioScheduler; private UserRepository userRepository; UserSearchPresenter(UserRepository userRepository, Scheduler ioScheduler, Scheduler mainScheduler) &#123; this.userRepository = userRepository; this.ioScheduler = ioScheduler; this.mainScheduler = mainScheduler; &#125; @Override public void search(String term) &#123; checkViewAttached(); getView().showLoading(); addSubscription(userRepository.searchUsers(term).subscribeOn(ioScheduler).observeOn(mainScheduler).subscribe(new Subscriber&lt;List&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; getView().hideLoading(); getView().showError(e.getMessage()); //TODO You probably don't want this error to show to users - Might want to show a friendlier message :) &#125; @Override public void onNext(List&lt;User&gt; users) &#123; getView().hideLoading(); getView().showSearchResults(users); &#125; &#125;)); &#125;&#125; 为UserSearchPresenter编写单元测试现在已经定义了presenter，让我们为它创建一些单元测试。 选择UserSearchPresenter类名。按“ALT+Enter”并选择“Create Test”。选择“app/src/test/java”文件夹，因为这是一个不需要Android依赖的单元测试。结果测试的位置如下:app/src/test/java/za/co/riggaroo/gus/presentation 在UserSearchPresenterTest中，创建setup方法，并定义测试所需的变量。 12345678910111213141516public class UserSearchPresenterTest &#123; @Mock UserRepository userRepository; @Mock UserSearchContract.View view; UserSearchPresenter userSearchPresenter; @Before public void setUp() throws Exception &#123; MockitoAnnotations.initMocks(this); userSearchPresenter = new UserSearchPresenter(userRepository, Schedulers.immediate(), Schedulers.immediate()); userSearchPresenter.attachView(view); &#125;&#125; 通过创建UserRepository和UserSearchContract.View的模拟实例，我们将确保我们只是在测试UserSearchPresenter。在setUp()方法中,我们称之为MockitoAnnotations.initMocks()。然后使用模拟对象和即时调度程序创建搜索演示程序。使用模拟视图对象调用attachView()，因为只有当一个视图被连接时，它才会起作用。 第一个测试将测试一个有效的搜索词是否有正确的回调: 123456789101112131415161718192021222324252627282930private static final String USER_LOGIN_RIGGAROO = \"riggaroo\"; private static final String USER_LOGIN_2_REBECCA = \"rebecca\"; @Test public void search_ValidSearchTerm_ReturnsResults() &#123; UsersList userList = getDummyUserList(); when(userRepository.searchUsers(anyString())).thenReturn(Observable.&lt;List&lt;User&gt;&gt;just(userList.getItems())); userSearchPresenter.search(\"riggaroo\"); verify(view).showLoading(); verify(view).hideLoading(); verify(view).showSearchResults(userList.getItems()); verify(view, never()).showError(anyString()); &#125; UsersList getDummyUserList() &#123; List&lt;User&gt; githubUsers = new ArrayList&lt;&gt;(); githubUsers.add(user1FullDetails()); githubUsers.add(user2FullDetails()); return new UsersList(githubUsers); &#125; User user1FullDetails() &#123; return new User(USER_LOGIN_RIGGAROO, \"Rigs Franks\", \"avatar_url\", \"Bio1\"); &#125; User user2FullDetails() &#123; return new User(USER_LOGIN_2_REBECCA, \"Rebecca Franks\", \"avatar_url2\", \"Bio2\"); &#125; 这个测试断言:假定(Given)用户repository返回一组用户，当(when)在演示程序中调用search()时，将(then)调用showLoading()和showSearchResults()。这个测试还断言showError()方法永远不会被调用。 下一个测试是在UserRepository抛出错误时测试负面场景的测试。 123456789101112@Test public void search_UserRepositoryError_ErrorMsg() &#123; String errorMsg = \"No internet\"; when(userRepository.searchUsers(anyString())).thenReturn(Observable.error(new IOException(errorMsg))); userSearchPresenter.search(\"bookdash\"); verify(view).showLoading(); verify(view).hideLoading(); verify(view, never()).showSearchResults(anyList()); verify(view).showError(errorMsg); &#125; 这个测试正在测试以下内容:假定(Given) userRepository返回一个异常，在调用search()时，应该调用showError()。 我们将添加的最后一个测试将断言，如果视图没有附加，将抛出一个异常。 123456789@Test(expected = BasePresenter.MvpViewNotAttachedException.class) public void search_NotAttached_ThrowsMvpException() &#123; userSearchPresenter.detachView(); userSearchPresenter.search(\"test\"); verify(view, never()).showLoading(); verify(view, never()).showSearchResults(anyList()); &#125; 让我们运行测试，看看我们有多少测试覆盖率。右键单击测试名称并单击“Run tests with coverage”。 我们对UserSearchPresenter有100%的覆盖率！耶! 下一篇博客文章将讨论创建视图和为视图编写测试。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"}]},{"title":"Android 自动化测试 - 第3部分","slug":"introduction-android-testing-part3","date":"2017-11-17T11:30:11.000Z","updated":"2020-07-25T02:57:18.208Z","comments":true,"path":"2017/11/17/introduction-android-testing-part3/","link":"","permalink":"https://jigangduan.github.io/2017/11/17/introduction-android-testing-part3/","excerpt":"在之前的两篇博文中，我介绍了如何在Android中进行测试，我们创建了一个样本应用，我们将继续在这篇博文中继续开发。如果您错过了这两个帖子，我建议您阅读第1部分和第2部分。 在本文中，我们将从Github API中获取用户列表，并为其编写单元测试。我们将从这个检查点的下一个repo开始。","text":"在之前的两篇博文中，我介绍了如何在Android中进行测试，我们创建了一个样本应用，我们将继续在这篇博文中继续开发。如果您错过了这两个帖子，我建议您阅读第1部分和第2部分。 在本文中，我们将从Github API中获取用户列表，并为其编写单元测试。我们将从这个检查点的下一个repo开始。 创建Web服务调用要使用Github API，我们将使用翻新和RxJava。我不打算在本系列中解释RxJava或Retrofit。如果您不熟悉RxJava，我建议您阅读这些文章。如果你没有使用过Retrofit，我建议阅读这里。 为了获得一个搜索词的用户列表，我们需要使用下面的端点: 1https://api.github.com/search/users?per_page=2&amp;q=rebecca 要获得更多的用户信息(例如用户的个人信息和位置)，我们需要进行后续调用: 1https://api.github.com/users/riggaroo 要开始使用这些端点，我们应该创建它们正在返回的JSON对象，并将它们包含在我们的项目中。我通常在在线生成它们。让我们创建以下类:User类和UsersList类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package za.co.riggaroo.gus.data.remote.model;import com.google.gson.annotations.Expose;import com.google.gson.annotations.SerializedName;public class User &#123; @SerializedName(\"login\") @Expose private String login; @SerializedName(\"id\") @Expose private Integer id; @SerializedName(\"avatar_url\") @Expose private String avatarUrl; @SerializedName(\"gravatar_id\") @Expose private String gravatarId; @SerializedName(\"url\") @Expose @SerializedName(\"type\") @Expose private String type; @SerializedName(\"name\") @Expose private String name; @SerializedName(\"location\") @Expose private String location; @SerializedName(\"email\") @SerializedName(\"bio\") @Expose private String bio; @SerializedName(\"followers\") @Expose private Integer followers; @SerializedName(\"following\") @Expose private Integer following; @SerializedName(\"created_at\") @Expose private String createdAt; @SerializedName(\"updated_at\") @Expose private String updatedAt; ... //see more at https://github.com/riggaroo/GithubUsersSearchApp/blob/testing-tutorial-part3-complete/app/src/main/java/za/co/riggaroo/gus/data/remote/model/User.java&#125; 12345678910111213141516171819202122232425262728293031323334package za.co.riggaroo.gus.data.remote.model;import com.google.gson.annotations.Expose;import com.google.gson.annotations.SerializedName;import java.util.ArrayList;import java.util.List;public class UsersList &#123; @SerializedName(\"total_count\") @Expose private Integer totalCount; @SerializedName(\"items\") @Expose private List&lt;User&gt; items = new ArrayList&lt;User&gt;(); public Integer getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(Integer totalCount) &#123; this.totalCount = totalCount; &#125; public List&lt;User&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;User&gt; items) &#123; this.items = items; &#125;&#125; 创建模型后，导航到GithubUserRestService。这是我们将创建我们的Retrofit调用的地方。 123456789101112131415import retrofit2.http.GET;import retrofit2.http.Path;import retrofit2.http.Query;import rx.Observable;import za.co.riggaroo.gus.data.remote.model.User;import za.co.riggaroo.gus.data.remote.model.UsersList;public interface GithubUserRestService &#123; @GET(\"/search/users?per_page=2\") Observable&lt;UsersList&gt; searchGithubUsers(@Query(\"q\") String searchTerm); @GET(\"/users/&#123;username&#125;\") Observable&lt;User&gt; getUser(@Path(\"username\") String username);&#125; 第一个网络调用将执行搜索以获得用户列表，第二个网络调用将获得关于用户的更多信息。 导航到UserRepositoryImpl。在这里，我们将把两个网络调用合并起来，并将数据转换为一个将在前端使用的视图。这是使用RxJava首先获取搜索词的用户列表，然后为每个用户提供另一个网络调用，以查找更多的用户信息。(如果您自己实现了这个API，我将尝试让一个网络调用返回所有必需的信息——正如我在减少移动数据使用谈话中所讨论的那样)。 1234567891011121314151617181920212223242526272829import java.io.IOException;import java.util.List;import rx.Observable;import za.co.riggaroo.gus.data.remote.GithubUserRestService;import za.co.riggaroo.gus.data.remote.model.User;public class UserRepositoryImpl implements UserRepository &#123; private GithubUserRestService githubUserRestService; public UserRepositoryImpl(GithubUserRestService githubUserRestService) &#123; this.githubUserRestService = githubUserRestService; &#125; @Override public Observable&lt;List&lt;User&gt;&gt; searchUsers(final String searchTerm) &#123; return Observable.defer(() -&gt; githubUserRestService.searchGithubUsers(searchTerm).concatMap( usersList -&gt; Observable.from(usersList.getItems()) .concatMap(user -&gt; githubUserRestService.getUser(user.getLogin())).toList())) .retryWhen(observable -&gt; observable.flatMap(o -&gt; &#123; if (o instanceof IOException) &#123; return Observable.just(null); &#125; return Observable.error(o); &#125;)); &#125;&#125; 在上面的代码中，我使用Observable.defer()来创建一个observable对象，这意味着只有当它有一个订阅者(不像Observable.create()在创建时运行)时，才会运行observables代码。正如下面的注释所纠正的那样，Observable.create()是一个不安全的RxJava API，它不应该被使用。 当有订阅者时，将调用githubUserRestService来搜索提供的searchTerm。从那里,我使用concatMap用户列表,发出他们一个接一个地进入一个新的观察,然后调用githubUserRestService.getUser()为每个用户列表。然后，这个可观察到的用户就变成了一个用户列表。 在这些网络调用上也定义了一个重试机制。retryWhen()将在抛出IOException时重新尝试可观察的对象。当用户没有网络时(您可能想要添加一个终止条件，例如仅重新尝试某些次数)，就会抛出IOException。 您可能会注意到，我在代码中使用lambda表达式，您可以通过使用新的Jack工具链来构建应用程序。请阅读有关如何在Android上启用Java 8的功能。 现在我们有了一个存储库和两个网络调用来获得一个用户列表！我们应该为刚刚编写的代码编写测试 单元测试 — Mockito是什么?为了对repository对象进行单元测试，我们将使用Mockito。Mockito是什么?根据MIT许可，它是一个开源的Java开源测试框架。该框架允许在自动化单元测试中创建测试双对象(模拟对象)。(维基百科) Mockito允许你stub方法调用，并验证与对象的交互。 当我们编写单元测试时，我们需要考虑单独测试某个组件。我们不应该测试任何超出这类职责的东西。Mockito帮助我们实现这一分离 好了，让我们写一些测试吧！ 为UserRepositoryImpl编写单元测试 选择UserRepositoryImpl的类名，并按“ALT+ENTER”键。将弹出一个对话框，选择“Create Test”选项。选择该选项，将出现一个新的对话框: 您可以选择生成方法，但我通常会选择未选择的选项。然后，它将要求您选择应该放置测试的目录。在编写一个不需要Android上下文的JUnit测试时，选择app/src/test目录。 现在我们已经准备好设置单元测试了。要做到这一点，需要创建一个UserRepository对象。我们还需要创建一个GithubUserRestService的模拟实例，因为我们不会直接在这个测试中对API进行攻击。这个测试将确认在UserRepository中正确地完成了转换。下面是设置我们的单元测试的代码: 12345678910@Mock GithubUserRestService githubUserRestService; private UserRepository userRepository; @Before public void setUp() throws Exception &#123; MockitoAnnotations.initMocks(this); userRepository = new UserRepositoryImpl(githubUserRestService); &#125; 我们将编写的第一个测试将测试GithubUserRestService是否具有正确的参数。它还将测试它是否返回预期的结果。下面是我所写的示例测试: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Test public void searchUsers_200OkResponse_InvokesCorrectApiCalls() &#123; //Given when(githubUserRestService.searchGithubUsers(anyString())).thenReturn(Observable.just(githubUserList())); when(githubUserRestService.getUser(anyString())) .thenReturn(Observable.just(user1FullDetails()), Observable.just(user2FullDetails())); //When TestSubscriber&lt;List&lt;User&gt;&gt; subscriber = new TestSubscriber&lt;&gt;(); userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber); //Then subscriber.awaitTerminalEvent(); subscriber.assertNoErrors(); List&lt;List&lt;User&gt;&gt; onNextEvents = subscriber.getOnNextEvents(); List&lt;User&gt; users = onNextEvents.get(0); Assert.assertEquals(USER_LOGIN_RIGGAROO, users.get(0).getLogin()); Assert.assertEquals(USER_LOGIN_2_REBECCA, users.get(1).getLogin()); verify(githubUserRestService).searchGithubUsers(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_2_REBECCA); &#125; private UsersList githubUserList() &#123; User user = new User(); user.setLogin(USER_LOGIN_RIGGAROO); User user2 = new User(); user2.setLogin(USER_LOGIN_2_REBECCA); List&lt;User&gt; githubUsers = new ArrayList&lt;&gt;(); githubUsers.add(user); githubUsers.add(user2); UsersList usersList = new UsersList(); usersList.setItems(githubUsers); return usersList; &#125; private User user1FullDetails() &#123; User user = new User(); user.setLogin(USER_LOGIN_RIGGAROO); user.setName(\"Rigs Franks\"); user.setAvatarUrl(\"avatar_url\"); user.setBio(\"Bio1\"); return user; &#125; private User user2FullDetails() &#123; User user = new User(); user.setLogin(USER_LOGIN_2_REBECCA); user.setName(\"Rebecca Franks\"); user.setAvatarUrl(\"avatar_url2\"); user.setBio(\"Bio2\"); return user; &#125; 这个测试分为三个部分: 给定(given)，什么时候(when)，什么时候(then)。 我将我的测试分离开来，因为它确保您的测试是结构化的，并让您思考您正在测试的特定功能。 在这个测试中，我正在测试以下内容:给定Github服务返回某些用户时，当我搜索用户时，结果应该返回并正确地转换。 我发现测试的命名也很重要。我喜欢遵循的命名结构如下: [Name of method under test]_[Conditions of test case]_[Expected Result] 在这个例子中，方法的名字是 在本例中，该方法的名称是searchUsers_200OkResponse_InvokesCorrectApiCalls()。 在这个测试用例中，一个TestSubscriber订阅了可观察到的搜索查询。 然后在TestSubscriber上进行断言，以确保它具有预期的结果。 下一个单元测试将测试如果一个IOException被搜索服务调用抛出，那么网络调用将被重试。 123456789101112131415161718192021@Test public void searchUsers_IOExceptionThenSuccess_SearchUsersRetried() &#123; //Given when(githubUserRestService.searchGithubUsers(anyString())) .thenReturn(getIOExceptionError(), Observable.just(githubUserList())); when(githubUserRestService.getUser(anyString())) .thenReturn(Observable.just(user1FullDetails()), Observable.just(user2FullDetails())); //When TestSubscriber&lt;List&lt;User&gt;&gt; subscriber = new TestSubscriber&lt;&gt;(); userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber); //Then subscriber.awaitTerminalEvent(); subscriber.assertNoErrors(); verify(githubUserRestService, times(2)).searchGithubUsers(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_2_REBECCA); &#125; 在这个测试中，我们断言githubUserRestService被调用两次，而其他的网络调用一次被调用一次。我们还断言订阅者没有终止错误。 UserRepositoryImpl的最终单元测试代码我已经添加了比上面描述的更多的测试。它们测试不同的情况，但是它们遵循上一节中描述的相同的概念。下面是UserRepositoryImpl的完整测试类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class UserRepositoryImplTest &#123; private static final String USER_LOGIN_RIGGAROO = \"riggaroo\"; private static final String USER_LOGIN_2_REBECCA = \"rebecca\"; @Mock GithubUserRestService githubUserRestService; private UserRepository userRepository; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); userRepository = new UserRepositoryImpl(githubUserRestService); &#125; @Test public void searchUsers_200OkResponse_InvokesCorrectApiCalls() &#123; //Given when(githubUserRestService.searchGithubUsers(anyString())).thenReturn(Observable.just(githubUserList())); when(githubUserRestService.getUser(anyString())) .thenReturn(Observable.just(user1FullDetails()), Observable.just(user2FullDetails())); //When TestSubscriber&lt;List&lt;User&gt;&gt; subscriber = new TestSubscriber&lt;&gt;(); userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber); //Then subscriber.awaitTerminalEvent(); subscriber.assertNoErrors(); List&lt;List&lt;User&gt;&gt; onNextEvents = subscriber.getOnNextEvents(); List&lt;User&gt; users = onNextEvents.get(0); Assert.assertEquals(USER_LOGIN_RIGGAROO, users.get(0).getLogin()); Assert.assertEquals(USER_LOGIN_2_REBECCA, users.get(1).getLogin()); verify(githubUserRestService).searchGithubUsers(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_2_REBECCA); &#125; private UsersList githubUserList() &#123; User user = new User(); user.setLogin(USER_LOGIN_RIGGAROO); User user2 = new User(); user2.setLogin(USER_LOGIN_2_REBECCA); List&lt;User&gt; githubUsers = new ArrayList&lt;&gt;(); githubUsers.add(user); githubUsers.add(user2); UsersList usersList = new UsersList(); usersList.setItems(githubUsers); return usersList; &#125; private User user1FullDetails() &#123; User user = new User(); user.setLogin(USER_LOGIN_RIGGAROO); user.setName(\"Rigs Franks\"); user.setAvatarUrl(\"avatar_url\"); user.setBio(\"Bio1\"); return user; &#125; private User user2FullDetails() &#123; User user = new User(); user.setLogin(USER_LOGIN_2_REBECCA); user.setName(\"Rebecca Franks\"); user.setAvatarUrl(\"avatar_url2\"); user.setBio(\"Bio2\"); return user; &#125; @Test public void searchUsers_IOExceptionThenSuccess_SearchUsersRetried() &#123; //Given when(githubUserRestService.searchGithubUsers(anyString())) .thenReturn(getIOExceptionError(), Observable.just(githubUserList())); when(githubUserRestService.getUser(anyString())) .thenReturn(Observable.just(user1FullDetails()), Observable.just(user2FullDetails())); //When TestSubscriber&lt;List&lt;User&gt;&gt; subscriber = new TestSubscriber&lt;&gt;(); userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber); //Then subscriber.awaitTerminalEvent(); subscriber.assertNoErrors(); verify(githubUserRestService, times(2)).searchGithubUsers(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_2_REBECCA); &#125; @Test public void searchUsers_GetUserIOExceptionThenSuccess_SearchUsersRetried() &#123; //Given when(githubUserRestService.searchGithubUsers(anyString())).thenReturn(Observable.just(githubUserList())); when(githubUserRestService.getUser(anyString())) .thenReturn(getIOExceptionError(), Observable.just(user1FullDetails()), Observable.just(user2FullDetails())); //When TestSubscriber&lt;List&lt;User&gt;&gt; subscriber = new TestSubscriber&lt;&gt;(); userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber); //Then subscriber.awaitTerminalEvent(); subscriber.assertNoErrors(); verify(githubUserRestService, times(2)).searchGithubUsers(USER_LOGIN_RIGGAROO); verify(githubUserRestService, times(2)).getUser(USER_LOGIN_RIGGAROO); verify(githubUserRestService).getUser(USER_LOGIN_2_REBECCA); &#125; @Test public void searchUsers_OtherHttpError_SearchTerminatedWithError() &#123; //Given when(githubUserRestService.searchGithubUsers(anyString())).thenReturn(get403ForbiddenError()); //When TestSubscriber&lt;List&lt;User&gt;&gt; subscriber = new TestSubscriber&lt;&gt;(); userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber); //Then subscriber.awaitTerminalEvent(); subscriber.assertError(HttpException.class); verify(githubUserRestService).searchGithubUsers(USER_LOGIN_RIGGAROO); verify(githubUserRestService, never()).getUser(USER_LOGIN_RIGGAROO); verify(githubUserRestService, never()).getUser(USER_LOGIN_2_REBECCA); &#125; private Observable getIOExceptionError() &#123; return Observable.error(new IOException()); &#125; private Observable&lt;UsersList&gt; get403ForbiddenError() &#123; return Observable.error(new HttpException( Response.error(403, ResponseBody.create(MediaType.parse(\"application/json\"), \"Forbidden\")))); &#125;&#125; 运行单元测试在编写完这些测试之后，我们需要运行它们，看看它们是否通过了测试，看看有多少代码被测试覆盖了。 要运行测试，您可以右键单击测试类名，并选择“Run UserRepositoryImplTest with Coverage” 然后你会看到结果出现在Android Studio的右边。 我们在UserRepositoryImpl上有100%的单元测试覆盖率。耶! 在下一篇博客文章中，我们将讨论实现UI以显示搜索结果集并为其编写更多的测试。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"}]},{"title":"Android 自动化测试 - 第2部分 安装","slug":"automated-android-testing-part-2-setup","date":"2017-11-17T10:34:14.000Z","updated":"2020-07-25T02:57:18.193Z","comments":true,"path":"2017/11/17/automated-android-testing-part-2-setup/","link":"","permalink":"https://jigangduan.github.io/2017/11/17/automated-android-testing-part-2-setup/","excerpt":"在本系列文章中，我们将介绍自动化的Android测试的介绍。在这个自动化测试系列的第1部分中，我们讨论了为什么要编写测试、测试文件夹所在的位置以及在Android中使用的不同类型的测试。 在本文中，我们将介绍Android应用程序的典型结构和设置，以便进行测试。我将在本系列中从头开始创建一个简单的应用程序，并逐步完成我的思想过程中的每一步。我们将要创建的应用是一个简单的应用，它可以为用户搜索Github的API。下面是我们将要创建的一个粗略的模型:","text":"在本系列文章中，我们将介绍自动化的Android测试的介绍。在这个自动化测试系列的第1部分中，我们讨论了为什么要编写测试、测试文件夹所在的位置以及在Android中使用的不同类型的测试。 在本文中，我们将介绍Android应用程序的典型结构和设置，以便进行测试。我将在本系列中从头开始创建一个简单的应用程序，并逐步完成我的思想过程中的每一步。我们将要创建的应用是一个简单的应用，它可以为用户搜索Github的API。下面是我们将要创建的一个粗略的模型: 开始使用一款新应用 打开Android Studio，选择“Start a new Android Project”。 把这个项目叫做“Gus”(Github User Search)和公司域名“riggaroo.co.za”。这将创建一个包名 —— za.co.riggaroo.gus。单击next。 接下来，选择您希望支持的Android版本(我一般不会低于API 16。如果您选择了API 16和以上的API，您将覆盖95.2%的用户。选择API版本16并单击“Next”。 选择“Empty Activity”并单击“Next”。 将activity的名称更改为UserSearchActivity和布局文件到activity_user_search。单击“Finish”。 如果你运行这个应用程序，你应该看到如下的空白activity。 添加测试依赖导航到您的应用程序build.gradle文件，并添加以下依赖项。需要添加的测试依赖包括Espresso、Mockito、PowerMock和Hamcrest。Retrofit、OkHttp、RxJava和RxAndroid也将被添加，这样我们就可以进行有效的网络连接，并实现更简洁的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445compile &apos;com.squareup.okhttp3:logging-interceptor:3.4.0-RC1&apos; compile &apos;com.android.support:appcompat-v7:24.1.1&apos; compile &apos;com.android.support.constraint:constraint-layout:1.0.0-alpha4&apos; //Retrofit, RxJava and OkHttp. compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos; compile &apos;com.squareup.okhttp3:okhttp:3.4.0-RC1&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos; compile &apos;io.reactivex:rxandroid:1.2.1&apos; compile &apos;io.reactivex:rxjava:1.1.6&apos; compile &apos;com.squareup.picasso:picasso:2.5.2&apos; //Dependencies for JUNit and unit tests. testCompile &quot;junit:junit:4.12&quot; testCompile &quot;org.mockito:mockito-all:1.10.19&quot; testCompile &quot;org.hamcrest:hamcrest-all:1.3&quot; testCompile(&quot;org.powermock:powermock-module-junit4:1.6.2&quot;) testCompile(&quot;org.powermock:powermock-api-mockito:1.6.2&quot;) testCompile &apos;com.squareup.okhttp3:mockwebserver:3.4.0-RC1&apos; //Dependencies for Espresso androidTestCompile &apos;com.android.support:appcompat-v7:24.1.1&apos; androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) androidTestCompile(&quot;com.android.support.test:runner:0.5&quot;) &#123; exclude module: &apos;support-annotations&apos; exclude module: &apos;support-v4&apos; &#125; androidTestCompile(&quot;com.android.support.test:rules:0.5&quot;) &#123; exclude module: &apos;support-annotations&apos; exclude module: &apos;support-v4&apos; &#125; androidTestCompile(&quot;com.android.support.test.espresso:espresso-intents:2.2.2&quot;) &#123; exclude module: &apos;recyclerview-v7&apos; exclude module: &apos;support-annotations&apos; exclude module: &apos;support-v4&apos; &#125; androidTestCompile(&apos;com.android.support.test.espresso:espresso-contrib:2.2.1&apos;) &#123; exclude module: &apos;recyclerview-v7&apos; exclude module: &apos;support-annotations&apos; exclude module: &apos;support-v4&apos; &#125; testCompile是用于单元测试的配置(位于src/test)，而androidTestCompile用于交互测试(位于src/androidTest)。这两种类型的测试之间的差异可以在本系列的第1部分中找到。 使用Gradle Build Flavors使能Mocking为了方便快捷地对UI进行测试，我们不会对Github提供的APIs进行访问。我们将模拟响应并模拟不同网络的响应。有几种不同的方法来实现这一点。我要演示的方法是使用Gradle product flavors。 Flavors允许你构建不同版本的应用程序，有一些源代码差异或资源差异。例如，如果你想要制作一个免费版本的应用程序和一个带有更多功能的付费版本，那么使用product flavors将是实现这一目标的好方法。 在这个例子中，我们将创建一个“production”和“mock”的flavor。我们还可以添加一个“staging”的flavor，如果我们有一个舞台环境，我们想让我们的应用指向它。这将允许我们在一个设备上安装一个production版本的应用程序，同时也可以在mock版本上安装。 为了使用productFlavors，导航到你的app build.gradle文件，并将以下内容添加到android{ }部分。下面的代码意味着对于mock变体，applicationId将不同，这意味着我可以同时在一个设备上安装。对于prod版本，applicationId将从defaultConfig设置中获取。 12345678productFlavors &#123; prod &#123; &#125; mock &#123; applicationId &quot;za.co.riggaroo.gus.mock&quot; &#125;&#125; 调用Gradle Sync，然后在IDE的左边，您应该看到一个“Build Variants”选项卡。打开它，你可以看到你的应用的不同风格。 如果您选择了一个不同的变体，当您单击run时，将部署到您的设备上的构建将使用该变量的源码集和applicationId。 运行单元测试为了运行项目中存在的默认单元测试(ExampleUnitTest)，您可以通过几种方式来完成: 在Android Studio中，导航到app/src/test/java文件夹，右键单击。点击“Run Tests”。 使用Gradle: 在终端你可以运行 ./gradlew check 运行交互测试(需要设备或模拟器)为了运行运行项目中默认交互测试(ExampleInstrumentationTest),你可以在以下方面: 在Android Studio中，导航到app/src/androidTest/java文件夹，右键单击。单击“Run All Tests”。 使用Gradle: 在终端你可以运行 ./gradlew connectedAndroidTest 如何构造您的代码以实现简单的测试为了方便测试，我将使用依赖项注入。您可以在没有任何框架的情况下实现这一点，但是很多人都提倡使用Dagger 2来实现它。这篇博客文章不会使用Dagger。 在以下文件夹结构中创建这些类: 我有4个顶级文件夹用于应用程序的不同部分。这可能会让你的应用变得更复杂。这些是我喜欢创建的基本文件夹: presentation —— 在这个文件夹中，我通过特性创建子文件夹和组功能。在此情况，我创建了一个名为search的文件夹，它将保存搜索屏幕的view和presenter。它还将包含用于搜索屏幕的适配器和任何其他视图相关代码。 data —— 这将包含从Github API获取数据的存储库(repositories)。 model - 包含将在表示层上使用的模型，以及来自于服务调用的模型。 injection —— 将用于依赖注入的类。 我们已经介绍了示例应用程序的设置、如何运行不同类型的测试以及我们将遵循的文件夹结构。这让我们有了一条很好的途径来确保我们可以为我们的应用程序写测试，如果你想看看这篇博文的结果，就看看这篇博文对应的完整代码吧。 本系列的下一篇博文将详细介绍如何通过测试实现该特性。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"}]},{"title":"Android 自动化测试 - 第1部分 介绍","slug":"introduction-automated-android-testing","date":"2017-11-17T09:29:12.000Z","updated":"2020-07-25T02:57:18.209Z","comments":true,"path":"2017/11/17/introduction-automated-android-testing/","link":"","permalink":"https://jigangduan.github.io/2017/11/17/introduction-automated-android-testing/","excerpt":"很多人对如何在Android中进行测试感到困惑和不确定。在过去，测试Android应用程序是非常困难的，并没有太多的方向。在这个系列中，将尝试让你的测试更容易一些。这第一篇文章只是为了让你开始测试，接下来的几章将深入Android的测试。让我们开始吧！","text":"很多人对如何在Android中进行测试感到困惑和不确定。在过去，测试Android应用程序是非常困难的，并没有太多的方向。在这个系列中，将尝试让你的测试更容易一些。这第一篇文章只是为了让你开始测试，接下来的几章将深入Android的测试。让我们开始吧！ 为什么要测试呢？ 测试迫使你以不同的方式思考，并隐含地使你的代码更清晰。 如果您的代码有测试，您会对自己的代码更有信心。 闪亮的绿色状态栏和详细的报告详细，说明编写测试的后果覆盖了你多少的代码。 回归测试变得容易很多，因为自动化测试会首先收集错误。 回归测试对我来说是最大的好处。如果你重构代码，且测试仍然通过，你会相信你没有造成任何破坏。测试的问题在于，您可能不会立即看到测试的好处，因为真正的价值只会在需要重构的几个月后才会显现出来。 Android中有哪些类型的测试？单元测试单元测试通常以可重复的方式实现尽可能小的代码单元（可以是方法，类或组件）的功能。 用于执行此测试的工具： JUnit - 正常的测试断言。 Mockito - 模拟其他未经测试的类。 PowerMock - 模拟静态类，如Android环境类等。 UI测试 - 交互测试UI测试或交互测试模拟典型的用户与您的应用程序的交互。点击按钮，输入文本是UI测试可以完成的一些事情。 用于执行此测试的工具： Espresso - 用于在你的应用中进行测试，选择项目，确保某些东西是可见的。 UIAutomator - 用于测试不同应用之间的交互。 还有其他工具可用于此类测试，如 Robotium， Appium， Calabash， Robolectric。 开始自动化测试我需要做什么?为了让你在应用中开始自动测试，你应该遵循某种架构模式，帮助你以一种简洁、可测试的方式测试和构建你的应用程序。很容易进行测试的一个模式是模型视图展示者(MVP)，用于查看网络和数据库访问的视图和存储库模式。 当然，这不是您作为Android开发者唯一的选择，它是您可以探索的许多方法之一，以便获得测试覆盖率和简洁的架构。 我发现在没有定义结构的情况下实现测试非常困难，通常我的测试是无用的，我不知道要测试什么，在大型应用程序中获取代码也很困难。我的UI测试也不是很可靠，因为他们正在对生产服务器进行测试。希望我们可以在这个博客系列中解决这些问题。 以可测试的方式构建应用程序下面是一个图表，描述了我将用作博客系列文章的其余部分的指导原则: 视图(Views) - Activities和Fragments。这是我们设置文本并进行UI更改的地方。我通常喜欢在这部分中保留Android特定的代码，并尽量不传递比视图更深入的内容，显然这并不总是容易的，但这是一个很好的指导，可以尝试遵循。视图应该只与presenters对话。 展示者(Presenters) - 这是决定在视图中应该显示什么内容的业务逻辑。Presenters与Repositories交互以获取信息，并将信息传达给视图。如果你可以避免使用Android特有的代码，尽量避免使用Android的代码，因为这会使单元测试变得更加困难。 存储库(Repositories) — 决定从哪里获取数据，它们是否来自本地持久化的数据?还是应该从网络中获得数据?Repositories和presenters交谈 模型(Models) — 通常是POJOs，这些模型被Presenter和View使用，以便将信息从Presenter中传递给View。 单元测试将测试Presenters和Repositories。UI测试将测试视图一直到Repositories。 有很多很好的文章描述了MVP和其他架构选项——这篇博客文章不会详细介绍这些细节。请阅读更多关于Android架构的文章，这里,这里和这里。 在我的Android应用中，自动测试在哪里?在你的Android应用文件夹结构中，有两个文件夹可以存放测试: test和androidTest androidTest —— Android交互测试就在这里。这个文件夹中的测试需要运行在Android模拟器或物理设备上。 test/ – 单元测试被放置在这个文件夹中。单元测试运行在本地机器上的JVM上，不运行在Android设备或模拟器上。这意味着他们不能访问Android类(例如Context类)。 现在我们已经知道了不同种类的测试以及在我们的应用中放置它们的位置。下一篇文章我们将深入介绍如何构造代码，以便更好地进行单元测试。请看这里的第2部分！","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"}]},{"title":"现代ANDROID开发入门资源","slug":"resources-getting-started-android-development","date":"2017-11-14T01:54:31.000Z","updated":"2020-07-25T02:57:18.228Z","comments":true,"path":"2017/11/14/resources-getting-started-android-development/","link":"","permalink":"https://jigangduan.github.io/2017/11/14/resources-getting-started-android-development/","excerpt":"原文地址 作者：Rebecca 在为DVT的移动开发者研究生项目汇集了资源之后，我意识到我所引用的内容可以成为现代Android开发入门的重要指导。 值得注意的是，我们有一个非常实际的方法来培养DVT的毕业生。我们举办工作坊和实际项目，以确保我们的毕业生对Android的发展有一个很好的理解。 随着网上大量的内容可用，当我开始Android开发时，我不知道在开发应用程序时应该注意哪些地方或什么。有一个简洁的列表，就像这个博客文章中的那个，对我来说是非常宝贵的。我希望你也能找到它的价值。 这里是一个链接，代码实验室和参考资料的列表，这对任何想要开始Android开发的开发人员都是有用的。","text":"原文地址 作者：Rebecca 在为DVT的移动开发者研究生项目汇集了资源之后，我意识到我所引用的内容可以成为现代Android开发入门的重要指导。 值得注意的是，我们有一个非常实际的方法来培养DVT的毕业生。我们举办工作坊和实际项目，以确保我们的毕业生对Android的发展有一个很好的理解。 随着网上大量的内容可用，当我开始Android开发时，我不知道在开发应用程序时应该注意哪些地方或什么。有一个简洁的列表，就像这个博客文章中的那个，对我来说是非常宝贵的。我希望你也能找到它的价值。 这里是一个链接，代码实验室和参考资料的列表，这对任何想要开始Android开发的开发人员都是有用的。 一般编程实践一般编程实践是开发职业生涯开始成功的关键。这些做法包括： 源代码管理（Git） - 源代码管理是一种管理代码版本的工具，它可以协同编写软件。 Git工作流程 - 在使用源代码管理时，有很多不同的方式来管理软件。流行的方法包括：Gitflow工作流程，集中式工作流程，分叉工作流程等 持续集成 - 持续集成可确保您的代码在不属于您自己的计算机的服务器上构建。看看使用像Jenkins，Buddybuild，Circle CI，Travis等构建服务器。 合并请求 - 合并请求是获得您开发的代码非常详细的反馈的好方法。 敏捷/Scrum方法 - 大多数现代软件开发团队遵循Scrum方法进行工作。 代码质量工具 - 公司用许多工具来衡量代码质量和代码库的健康状况。诸如测试覆盖范围的行数或代码库所具有的技术债务等度量标准是可见的。一些经常使用的工具：Sonar，FindBugs，Checkstyle和Android Lint。 Android基础介绍有一大堆网站提供了Android开发入门的基础知识。我的建议是遵循官方文档来理解基础知识，然后在进入应用程序设计的更多技术方面（参见本文后面的部分）中查看其他资源（如博客等）以获取更多信息。 一些入门资源： Android应用基础 Android中的一些主要组件： Activities, Fragments, Services, Broadcast Receivers。 Android应用程序清单 代码实验室 - 建立您的第一个Android应用程序 掌握Android中的布局Android中有很多不同的布局类型，从FrameLayout到RelativeLayout到ConstraintLayout。确保你对这些常用的布局类型感到满意：FrameLayout，RelativeLayout，LinearLayout，ConstraintLayout，CoordinatorLayout。 资源： 支持不同的屏幕尺寸 代码实验室 - ConstraintLayout 代码实验室 - CoordinatorLayout 构建系统 - 使用Gradle使用Gradle在开发Android应用程序时可能会被忽视。确保你了解基础知识，甚至更好 - 学习如何编写自己的gradle任务！ 资源： Gradle文档 配置你的构建 Android中的网络尽管大部分Android文档都没有引用Retrofit或OkHttp，但在Android中进行联网时，这些是最常用的库。熟悉Android Studio中提供的不同分析工具也是很好的做法。 资源： 了解RESTful服务 Retrofit - 适用于Android和Java的类型安全的HTTP客户端 OkHttp - 用于Android和Java应用程序的HTTP和HTTP/2客户端 Android中的网络分析器 - Android Studio中的一款工具，可用于分析您的网络呼叫。 Charles Proxy - 用于在测试时拦截网络呼叫。 架构您的Android应用程序不幸的是，编写代码并让应用程序编译并不是知道如何编写可维护的Android应用程序的结束。大规模的Android应用程序需要遵循良好的架构设计，以使其可维护和可测试。编写Android应用程序时可以遵循许多不同的模式。通常使用MVP，MVVM和Clean Architecture等模式。确保你了解模式之间的差异，因为你会在外遇到许多不同的模式。 资源： Android体系结构组件指南 我在Android体系结构组件3部分组成的系列（部分1，2，3） Android体系结构组件视频介绍 Google Sample App Github存储库 代码实验室 - 持久性 代码实验室 - 生命周期感知组件 测试你的Android应用程序一旦你掌握了创建Android应用程序的机会，你将需要考虑如何测试它们。单元测试和UI测试是非常重要的概念，您需要确保自己理解。有很多不同的工具可以用来编写UI测试。大多数Android开发人员使用Espresso和JUnit编写测试，但是还有很多其他工具，例如Robotium，Calabash，Appium等等。我推荐使用Espresso和JUnit。 资源： Android测试支持库 Espresso JUnit Mockito 代码实验 - Android测试 代码实验 - Android性能测试 发布您的Android应用程序 准备您的应用程序的发布 应用程序签名 版本化您的应用程序 ProGuard 安全为了保护您的应用程序，确保没有人能够访问未经授权的内容，应该做很多事情。确保你正在使用ProGuard（前面提到过）。了解中间者是什么样。了解不同的加密方法以及安全地将信息存储在Android应用程序中的方法，包括保护您的API令牌，证书锁定等。 资源： Android的安全提示 证书锁定 SafetyNet API Android密钥库系统 高级Android主题一旦你已经涵盖了编写Android应用程序的所有基础知识，有几个高级主题，你可能需要覆盖，以便贡献给一些代码库： Kotlin - Kotlin是Android的新编程语言，开发人员正在Kotlin积极编写他们的代码。值得关注Kotlin并穿过Kotlin Koans。还有一个Kotlin代码实验室。 RxJava - RxJava是用于基于事件的异步编程的库。它允许您将操作组合在一起以执行复杂的任务（如将多个网络调用组合在一起），并且可以非常有用地管理您的代码在哪个线程上执行。有一个伟大的视频来自杰克·沃顿，描述如何使用RxJava和使用它的好处。 Dagger（依赖注入） - 依赖注入是一种在应用程序中管理对象及其依赖关系的方法。DI的概念不是一个Android的概念，但也可以在许多其他框架中使用。DI可以使您的代码更有效地提高内存并提高可测试性。Dagger 2是最受欢迎的Android DI框架。 Material Design - 大多数Android应用程序都遵循Google的材料设计指南。指南是以用户熟悉的标准方式设计您的应用程序的一种方式。 Android支持库 - Android中的支持库对于确保您的应用在多个Android版本中的外观和行为保持一致非常重要。有几个不同的库有不同的目的。链接的文章描述了图书馆背后的推理。 内存泄漏 - 在Android中，创建内存泄漏非常容易。这可能会导致应用程序中的错误行为（随机崩溃）。阅读有关内存泄漏的信息。很多开发人员在应用程序中使用LeakCanary来确保没有任何内存泄漏。 跟上现代Android开发的最新进展有很多方法可以跟上Android社区的最新变化和发展。我觉得有用的一些方法是： 订阅Android Weekly简讯 在Reddit上关注/r/androiddev 在Twitter上关注Android Google Developer Experts 在Twitter上关注Android Studio，Android Dev 听Android开发播客(Fragmented, Android Developers Backstage, The Context, Android Snacks) 作为一名Android开发人员，您会遇到许多概念，例如处理通知，小部件，主题和样式化应用程序等。此列表涵盖了我认为有必要成为卓越的Android开发人员的主要主题，大部分其他主题你可以自己去理解。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"ReactorKit 介绍","slug":"ReactorKit","date":"2017-11-09T10:40:18.000Z","updated":"2020-07-25T02:57:18.161Z","comments":true,"path":"2017/11/09/ReactorKit/","link":"","permalink":"https://jigangduan.github.io/2017/11/09/ReactorKit/","excerpt":"ReactorKit是一个响应式和单向的Swift应用程序架构的框架。这个文章介绍了ReactorKit的基本概念，并描述了如何使用ReactorKit构建应用程序。 如果您希望看到实际的代码，您可能希望首先看到示例部分。访问API参考的代码级文档。","text":"ReactorKit是一个响应式和单向的Swift应用程序架构的框架。这个文章介绍了ReactorKit的基本概念，并描述了如何使用ReactorKit构建应用程序。 如果您希望看到实际的代码，您可能希望首先看到示例部分。访问API参考的代码级文档。 基本概念ReactorKit是Flux和响应式编程的结合。user actions和view states通过可观察的流传递到每一层。这些流是单向的: view只能发射actions，reactor只能发射states。 设计目标 可测试性：ReactorKit的第一个目的是将业务逻辑从视图中分离出来。这可以使代码可测试。一个reactor对视图没有任何依赖性。只需要测试reactors和测试视图绑定。有关详细信息，请参见测试部分。 从小处开始: ReactorKit并不要求整个应用程序遵循单一的架构。对于一个或多个特定的视图，可以部分地采用ReactorKit。你不需要重写所有的东西来在你现有的项目中使用ReactorKit。 更少的成本: ReactorKit专注于避免复杂的代码为简单的事情。与其他架构相比，ReactorKit的代码需要更少的代码。开始简单，扩大规模 ViewView显示数据。view controller和cell被视为view。view将用户输入绑定到action流，并将view states绑定到每个UI组件。view层中没有业务逻辑。view定义了如何映射action流和state流。 要定义一个view，只需让现有的类遵循一个名为View的协议。然后，你的类会自动地有一个名为reactor的属性。这个属性通常是在view之外设置的。 12345class ProfileViewController: UIViewController, View &#123; var disposeBag = DisposeBag()&#125;profileViewController.reactor = UserViewReactor() // inject reactor 当reactor属性发生变化时，就会调用bind(reactor:)。实现这个方法来定义action流和state流的绑定。 1234567891011func bind(reactor: ProfileViewReactor) &#123; // action (View -&gt; Reactor) refreshButton.rx.tap.map &#123; Reactor.Action.refresh &#125; .bind(to: reactor.action) .disposed(by: self.disposeBag) // state (Reactor -&gt; View) reactor.state.map &#123; $0.isFollowing &#125; .bind(to: followButton.rx.isSelected) .disposed(by: self.disposeBag)&#125; 支持 Storyboard如果使用storyboard来初始化view controllers，使用StoryboardView协议。所有的东西都是一样的，唯一不同的是，在视图加载之后，StoryboardView执行绑定。 12345678let viewController = MyViewController()viewController.reactor = MyViewReactor() // 不会立即执行`bind(reactor:)`class MyViewController: UIViewController, StoryboardView &#123; func bind(reactor: MyViewReactor) &#123; // 在视图加载后(viewDidLoad)调用 &#125;&#125; ReactorReactor是一个独立于UI的层，它负责管理视图的状态。reactor最重要的作用是将控制流从一个视图中分离出来。每个视图都有对应的reactor，并把所有的逻辑都委托给它的reactor。reactor不依赖于视图，因此可以很容易地测试它。 符合Reactor协议来定义一个reactor。该协议需要定义三种类型: Action、Mutation和State。它还需要一个名为initialState的属性。 12345678910111213141516171819class ProfileViewReactor: Reactor &#123; // represent user actions enum Action &#123; case refreshFollowingStatus(Int) case follow(Int) &#125; // represent state changes enum Mutation &#123; case setFollowing(Bool) &#125; // represents the current view state struct State &#123; var isFollowing: Bool = false &#125; let initialState: State = State()&#125; 一个Action代表一个用户交互，而State代表一个视图状态。Mutation是Action与State之间的_桥梁_。一个reactor将action流转换成state流的两个步骤:mutate()和reduce()。 mutate() mutate()接收到一个Action并产生一个Observable&lt;Mutation&gt;。 1func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; 每个副作用，比如异步操作或API调用，都是在这个方法中执行的。 123456789101112131415func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; &#123; switch action &#123; case let .refreshFollowingStatus(userID): // receive an action return UserAPI.isFollowing(userID) // create an API stream .map &#123; (isFollowing: Bool) -&gt; Mutation in return Mutation.setFollowing(isFollowing) // convert to Mutation stream &#125; case let .follow(userID): return UserAPI.follow() .map &#123; _ -&gt; Mutation in return Mutation.setFollowing(true) &#125; &#125;&#125; reduce() reduce()从以前的State和Mutation中生成一个新的State。 1func reduce(state: State, mutation: Mutation) -&gt; State 这个方法是一个纯函数。它应该以同步方式返回一个新State。不要在这个函数中执行任何副作用。 12345678func reduce(state: State, mutation: Mutation) -&gt; State &#123; var state = state // create a copy of the old state switch mutation &#123; case let .setFollowing(isFollowing): state.isFollowing = isFollowing // manipulate the state, creating a new state return state // return the new state &#125;&#125; transform() transform()变换每个流。有三个transform()函数: 123func transform(action: Observable&lt;Action&gt;) -&gt; Observable&lt;Action&gt;func transform(mutation: Observable&lt;Mutation&gt;) -&gt; Observable&lt;Mutation&gt;func transform(state: Observable&lt;State&gt;) -&gt; Observable&lt;State&gt; 实现这些方法来转换和合并其他可观察的流。例如，transform(mutation:)是将全局事件流与mutation流相结合的最佳位置。有关详细信息，请参见全局状态部分。 这些方法也可以用于调试目的: 123func transform(action: Observable&lt;Action&gt;) -&gt; Observable&lt;Action&gt; &#123; return action.debug(\"action\") // Use RxSwift's debug() operator&#125; 高级ServiceReactorKit有一个特殊的层命名为Service。service层执行实际的业务逻辑。reactor是视图和管理事件流的服务之间的中间层。当一个reactor从视图接收到用户操作时，reactor将调用service逻辑。该service发出一个网络请求，并将响应发送回reactor。然后，reactor创建一个带有服务响应的mutation流。 这里有一个服务的例子: 1234567891011121314protocol UserServiceType &#123; func user(id: Int) -&gt; Observable&lt;User&gt; func follow(id: Int) -&gt; Observable&lt;Void&gt;&#125;final class UserService: Service, UserServiceType &#123; func user(id: Int) -&gt; Observable&lt;User&gt; &#123; return foo() &#125; func follow(id: Int) -&gt; Observable&lt;Void&gt; &#123; return bar() &#125;&#125; 全局状态不像Redux，ReactorKit并没有定义一个全局应用程序状态。这意味着您可以使用任何东西来管理一个全局状态。您可以使用一个Variable，一个PublishSubject，甚至一个reactor。ReactorKit不需要有一个全局状态，所以你可以在你的应用中使用ReactorKit在一个特定的特性。 在Action → Mutation → State流中没有全局状态。您应该使用transform(mutation:)来将全局状态转换为一个mutation。让我们假设我们有一个全局Variable，该Variable存储当前经过身份验证的用户。如果您想发出Mutation.setUser(User?)当currentUser被更改时，您可以如下所做: 12345var currentUser: Variable&lt;User&gt; // global statefunc transform(mutation: Observable&lt;Mutation&gt;) -&gt; Observable&lt;Mutation&gt; &#123; return Observable.merge(mutation, currentUser.map(Mutation.setUser))&#125; 然后，每当视图向reactor发送一个action，而currentUser被改变时，这个mutation就会被释放出来。 View交流在多个视图之间进行通信，您必须熟悉回调闭包或委托模式。反应堆建议你使用reactive的扩展。最常见的控制实例是UIButton.rx.tap。关键的概念是将您的自定义视图视为UIButton或UILabel。 让我们假设我们有一个显示消息的ChatViewController。ChatViewController拥有一个MessageInputView。当用户在MessageInputView上点击发送按钮时，文本将被发送到ChatViewController，而ChatViewController将绑定到反应器的操作。这是一个示例:MessageInputView的Rx扩展: 123456extension Reactive where Base: MessageInputView &#123; var sendButtonTap: ControlEvent&lt;String&gt; &#123; let source = base.sendButton.rx.tap.withLatestFrom(...) return ControlEvent(events: source) &#125;&#125; 你可以在ChatViewController中使用那个扩展。例如: 123messageInputView.rx.sendButtonTap .map(Reactor.Action.send) .bind(to: reactor.action) 测试ReactorKit有一个内置的测试功能。您将能够轻松地测试一个view和一个reactor，并使用下面的指令。 什么测试首先，你必须决定要测试什么。有两件事要测试:一个view和一个reactor。 View Action:一个适当的action被发送到一个指定用户交互的reactor上吗? State: view属性是否正确地按state设置呢? Reactor State:一个state随着action而改变吗? View测试一个view可以用一个stub reactor进行测试。reactor有一个stub属性，它可以记录actions并强制改变states。如果启用了一个reactor的stub，mutate() 和reduce()都不会被执行。一个stub有这些属性: 1234var isEnabled: Bool &#123; get set &#125;var state: Variable&lt;Reactor.State&gt; &#123; get &#125;var action: ActionSubject&lt;Reactor.Action&gt; &#123; get &#125;var actions: [Reactor.Action] &#123; get &#125; // recorded actions 下面是一些示例测试案例: 12345678910111213141516171819202122232425262728293031func testAction_refresh() &#123; // 1. prepare a stub reactor let reactor = MyReactor() reactor.stub.isEnabled = true // 2. prepare a view with a stub reactor let view = MyView() view.reactor = reactor // 3. send an user interaction programatically view.refreshControl.sendActions(for: .valueChanged) // 4. assert actions XCTAssertEqual(reactor.stub.actions.last, .refresh)&#125;func testState_isLoading() &#123; // 1. prepare a stub reactor let reactor = MyReactor() reactor.stub.isEnabled = true // 2. prepare a view with a stub reactor let view = MyView() view.reactor = reactor // 3. set a stub state reactor.stub.state.value = MyReactor.State(isLoading: true) // 4. assert view properties XCTAssertEqual(view.activityIndicator.isAnimating, true)&#125; Reactor测试一个reactor可以独立测试。 1234567func testIsBookmarked() &#123; let reactor = MyReactor() reactor.action.onNext(.toggleBookmarked) XCTAssertEqual(reactor.currentState.isBookmarked, true) reactor.action.onNext(.toggleBookmarked) XCTAssertEqual(reactor.currentState.isBookmarked, false)&#125; 有时，一个state会被多个action改变。例如，一个.refresh的动作将第state.isLoading个设置为true，并在刷新后设置为false。在这种情况下，很难用currentState测试state.isLoading，所以您可能需要使用RxTest或RxExpect。下面是一个使用RxExpect的示例测试用例: 1234567891011121314func testIsLoading() &#123; RxExpect(\"it should change isLoading\") &#123; test in let reactor = test.retain(MyReactor()) test.input(reactor.action, [ next(100, .refresh) // send .refresh at 100 scheduler time ]) test.assert(reactor.state.map &#123; $0.isLoading &#125;) .since(100) // values since 100 scheduler time .assert([ true, // just after .refresh false, // after refreshing ]) &#125;&#125; 约定ReactorKit提供了一些约定来编写干净简洁的代码。 您必须在view之外创建reactor，并将其传递给view的reactor属性。 Good 12let view = MyView()view.reactor = MyViewReactor(provider: provider) Bad 12345class MyView: UIView, View &#123; init() &#123; self.reactor = MyViewReactor() &#125;&#125; 示例 Counter: 最简单和最基本的ReactorKit例子 GitHub Search:一个提供GitHub库搜索的简单应用程序 RxTodo: 使用ReactorKit的iOS待办事项 Cleverbot: 使用Cleverbot和ReactorKit的iOS消息应用 Drrrible: Dribbble iOS使用ReactorKit(App Store)对 Passcode:iOS RxSwift、ReactorKit和IGListKit示例的Passcode","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"iOS第三方库","slug":"iOS/iOS第三方库","permalink":"https://jigangduan.github.io/categories/iOS/iOS第三方库/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"}]},{"title":"Android 架构组件 - 分页库","slug":"architecture-paging","date":"2017-11-09T06:45:09.000Z","updated":"2020-07-25T02:57:18.192Z","comments":true,"path":"2017/11/09/architecture-paging/","link":"","permalink":"https://jigangduan.github.io/2017/11/09/architecture-paging/","excerpt":"分页库使您的应用程序可以更容易地根据需要从数据源加载信息，而不会使设备超载，或者等待一个大的数据库查询等待太长的时间。","text":"分页库使您的应用程序可以更容易地根据需要从数据源加载信息，而不会使设备超载，或者等待一个大的数据库查询等待太长的时间。 概述许多应用程序都使用大量的数据，但只需要在任何时候加载和显示一小部分数据。一个应用程序可能会有数千个可能显示的项目，但它可能只需要一次访问其中的几十个。如果应用程序不小心，它可能最终会请求它实际上不需要的数据，从而给设备和网络带来性能负担。如果数据被存储或与远程数据库同步，这也会降低应用程序的速度，并浪费用户的数据计划。 尽管现有的Android api允许在内容中进行分页，但它们带来了巨大的限制和缺点: CursorAdapter使将数据库查询结果映射到ListView项变得更加容易，但是它在UI线程上运行数据库查询，并且在页面内容中使用Cursor效率不高。有关使用CursorAdapter的缺点的更多细节，请参见该博客在Android上发布大型数据库查询。 AsyncListUtil允许将基于位置的数据转换为RecyclerView，但不允许非位置分页，它在可数的数据集中强制null作为占位符。 新的分页库解决了这些问题。这个库包含几个类，可以简化请求数据的过程。这些类还可以与现有的体系结构组件无缝协作，比如Room。 类分页库提供了以下类，以及附加的支持类: DataSource 使用这个类来定义一个数据源，您需要从它获取分页数据。根据您需要访问数据的方式，您将扩展它的两个子类中的一个: 使用KeyedDataSource，如果您需要使用来自item N的数据来获取item N+1。例如，如果您正在为一个讨论应用程序获取线程评论，您可能需要传递一个评论的ID来获取下一个评论的内容。 使用TiledDataSource，如果您需要从您在数据存储中选择的任何位置获取数据页。这个类支持从您选择的任何位置开始请求一组数据项，比如“返回从位置1200开始的20个数据项”。 如果您使用Room持久性库来管理您的数据，它可以自动为您创建一个TiledDataSource，例如: 12@Query(\"select * from users WHERE age &gt; :age order by name DESC, id ASC\")TiledDataSource&lt;User&gt; usersOlderThan(int age); PagedList 这个类从一个数据源加载数据。您可以配置一次加载了多少数据，以及应该预先获取多少数据，从而最小化了用户等待数据加载的时间。这个类可以向其他类提供更新信号，比如RecyclerView.Adapter，允许您在数据加载到页面时更新RecyclerView的内容。 PagedListAdapter 这个类是RecyclerView.Adapter的实现，它显示了PagedList的数据。例如，当加载一个新页面时，PagedListAdapter表示数据已经到达的RecyclerView;这样，RecyclerView就可以用实际的条目替换任何占位符，执行适当的动画。 PagedListAdapter还使用一个后台线程来计算PagedList下一次的更改(例如，当数据库更改生成一个带有更新数据的新PagedList时)，并根据需要调用notifyItem…()) 方法来更新列表的内容。然后，RecyclerView执行必要的更改。例如，如果一个项目改变了PagedList版本之间的位置，那么RecyclerView将使该项目移动到列表中的新位置。 LivePagedListProvider 这个类从您提供的DataSource生成LiveData&lt;PagedList&gt;。此外，如果您使用Room持久性库来管理数据库，那么DAO可以使用TiledDataSource为您生成LivePagedListProvider，例如: 12@Query(\"SELECT * from users order WHERE age &gt; :age order by name DESC, id ASC\")public abstract LivePagedListProvider&lt;Integer, User&gt; usersOlderThan(int age); 整数参数告诉Room使用TiledDataSource，以基于位置的负载为基础。 紧挨着，分页库的组件组织了来自后台线程的数据流，以及UI线程的表示。例如，当在数据库中插入一个新项时，数据源就会失效，而LivePagedListProvider会在后台线程中生成一个新的PagedList。 图1所示 分页库组件在后台线程中完成了大部分工作，因此它们不会负担UI线程 这个新创建的PagedList被发送到UI线程上的PagedListAdapter。然后，PagedListAdapter会在后台线程上使用DiffUtil来计算当前列表和新列表之间的差异。当完成比较,PagedListAdapter使用差异列表信息做出适当的调用RecyclerView.Adapter.notifyItemInserted())信号,插入一个新项。 在UI线程上的RecyclerView知道它只需要绑定一个新条目，并将它显示在屏幕上。 下面的代码示例显示了所有的片段一起工作。当用户在数据库中添加、删除或更改时，RecyclerView的内容会自动且有效地更新: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Daointerface UserDao &#123; @Query(\"SELECT * FROM user ORDER BY lastName ASC\") public abstract LivePagedListProvider&lt;Integer, User&gt; usersByLastName();&#125;class MyViewModel extends ViewModel &#123; public final LiveData&lt;PagedList&lt;User&gt;&gt; usersList; public MyViewModel(UserDao userDao) &#123; usersList = userDao.usersByLastName().create( /* initial load position */ 0, new PagedList.Config.Builder() .setPageSize(50) .setPrefetchDistance(50) .build()); &#125;&#125;class MyActivity extends AppCompatActivity &#123; @Override public void onCreate(Bundle savedState) &#123; super.onCreate(savedState); MyViewModel viewModel = ViewModelProviders.of(this).get(MyViewModel.class); RecyclerView recyclerView = findViewById(R.id.user_list); UserAdapter&lt;User&gt; adapter = new UserAdapter(); viewModel.usersList.observe(this, pagedList -&gt; adapter.setList(pagedList)); recyclerView.setAdapter(adapter); &#125;&#125;class UserAdapter extends PagedListAdapter&lt;User, UserViewHolder&gt; &#123; public UserAdapter() &#123; super(DIFF_CALLBACK); &#125; @Override public void onBindViewHolder(UserViewHolder holder, int position) &#123; User user = getItem(position); if (user != null) &#123; holder.bindTo(user); &#125; else &#123; // Null defines a placeholder item - PagedListAdapter will automatically invalidate // this row when the actual object is loaded from the database holder.clear(); &#125; &#125; public static final DiffCallback&lt;User&gt; DIFF_CALLBACK = new DiffCallback&lt;User&gt;() &#123; @Override public boolean areItemsTheSame(@NonNull User oldUser, @NonNull User newUser) &#123; // User properties may have changed if reloaded from the DB, but ID is fixed return oldUser.getId() == newUser.getId(); &#125; @Override public boolean areContentsTheSame(@NonNull User oldUser, @NonNull User newUser) &#123; // NOTE: if you use equals, your object must properly override Object#equals() // Incorrectly returning false here will result in too many animations. return oldUser.equals(newUser); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件 - Room持久性库","slug":"architecture-room","date":"2017-11-09T06:03:04.000Z","updated":"2020-07-25T02:57:18.193Z","comments":true,"path":"2017/11/09/architecture-room/","link":"","permalink":"https://jigangduan.github.io/2017/11/09/architecture-room/","excerpt":"","text":"Room持久性库为SQLite提供了一个抽象层，以便在充分利用SQLite的同时，允许流畅的数据库访问。 该库帮助用户在运行应用程序的设备上创建应用程序的数据缓存，该缓存作为应用程序的单一来源，允许用户在应用内查看关键信息的一致副本，而不管用户是否有互联网连接。 要将Room导入到您的Android项目中，请参见向您的项目添加组件。 要想在应用程序的数据存储持久性解决方案中应用Room的功能，请参阅Room培训指南。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件 - 保存界面状态","slug":"architecture-saving-states","date":"2017-11-09T05:12:41.000Z","updated":"2020-07-25T02:57:18.193Z","comments":true,"path":"2017/11/09/architecture-saving-states/","link":"","permalink":"https://jigangduan.github.io/2017/11/09/architecture-saving-states/","excerpt":"您所做的或者不做的，保持UI状态是用户体验的一个关键部分。无论用户是旋转设备，用户重新启动应用，还是系统关闭应用，重要的是你的activity保持了用户所期望的状态 如果要保存的UI数据是简单而轻量级的，那么您可以单独使用onSaveInstanceState()来保存您的状态数据。 如果要保存的是复杂数据，可以使用ViewModel对象、onSaveInstanceState()方法和持久化本地存储的组合。 本页讨论了这些方法中的每一个。","text":"您所做的或者不做的，保持UI状态是用户体验的一个关键部分。无论用户是旋转设备，用户重新启动应用，还是系统关闭应用，重要的是你的activity保持了用户所期望的状态 如果要保存的UI数据是简单而轻量级的，那么您可以单独使用onSaveInstanceState()来保存您的状态数据。 如果要保存的是复杂数据，可以使用ViewModel对象、onSaveInstanceState()方法和持久化本地存储的组合。 本页讨论了这些方法中的每一个。 管理简单的情况: onSaveInstanceState()onSaveInstanceState())回调被设计用来存储相对少量的数据，以便轻松地重新加载UI控制器的状态，如activity或fragment，如果系统停止并稍后重新创建该控制器。这个回调是为了处理两种情况: 由于内存限制，该应用程序在后台运行时会杀死应用程序的进程。 发生配置更改，例如屏幕旋转或更改为输入语言。 由于这两种情况都暗示，在系统中activity停止，但未完成的情况下，onSaveInstanceState()将被调用。例如，如果用户离开应用程序几个小时，系统会从内存中弹出相关的进程，系统会调用onSaveInstanceState()的默认实现来保存具有ID的每个UI控制器。稍后，当用户返回到应用程序时，系统将用保存的状态恢复activity。 注意:onSaveInstanceState()在用户显式关闭该活动时，或者在调用finish()时，不会调用onSaveInstanceState()。 系统自动保存并为您恢复大量的UI数据:onSaveInstanceState()的默认实现保存了activity的视图层次结构的信息，比如EditText小部件中的文本或ListView小部件的滚动位置。您还可以通过重写onSaveInstanceState()回调来将自定义数据保存到这个包中。如果您重写该方法，以保存每个单独实体未捕获的附加信息，那么您应该调用缺省实现，除非您准备好保存每个实体的状态。 onSaveInstanceState()不是用来存储大量数据的，比如位图，或者复杂的数据结构，这些数据结构需要长时间的序列化或反序列化。如果序列化的对象是复杂的，串行化可以消耗大量的内存。由于这个过程在配置更改期间发生在主线程上，因此序列化可能会导致删除帧和视觉口吃，如果时间过长的话。因此，不要在复杂的数据结构中使用onSaveInstanceState()，而是要确保将这些结构存储在本地持久存储中;在创建数据的时候存储数据是一个好主意，这样可以最小化丢失数据的机会。然后，使用onSaveInstanceState()为每个对象存储唯一的id。 本文档的下一部分提供了关于保存更复杂数据的更多细节。 管理更复杂的状态:分而治之当一个activity结束时需要保存更复杂的数据结构，可以通过将工作划分为几种类型的存储机制，从而有效地保存和恢复UI状态。 有两种一般的方法可以让用户离开activity，导致用户可能期望的两种不同结果: 用户完全关闭该activity。用户可以完全关闭该activity，如果他们将activity从屏幕上划掉，导航出去，或者退出activity。在这些情况下，假设用户已经永久地离开了activity，并且如果他们重新打开了activity，他们将期望从一个干净的状态开始。 用户可以旋转手机，或者把activity放在后台，然后再回到它上面。例如，用户执行搜索，然后按下home键或接听一个电话。当他们返回到搜索activity时，他们期望找到搜索关键字和结果，就像以前一样。 要在这两种情况下实现复杂数据结构的行为，您可以使用本地持久性、ViewModel类和onSaveInstanceState()方法。每种方法都存储了activity中使用的不同类型的数据。 本地持久性:如果您打开并关闭该activity，则存储所有您不想丢失的数据。 示例:一个包含音频文件和元数据的歌曲对象集合。 ViewModel:存储在内存中的所有数据，以显示相关的UI控制器。 示例:最近搜索的歌曲对象和最近的搜索查询。 onSaveInstanceState():如果系统停止，然后重新创建UI控制器，就需要存储少量的数据，以便轻松地重新加载活动状态。这里不再存储复杂的对象，而是将复杂的对象持久化到本地存储中，并在onSaveInstanceState()中为这些对象存储一个惟一的ID。 示例:存储最近的搜索查询。 举个例子，考虑一个允许你搜索你的歌曲库的activity。下面是如何处理不同的事件： 当用户添加一首歌时，ViewModel会立即代表本地保存这些数据。如果这个新添加的歌曲是应该在UI中显示的，那么您还应该更新ViewModel对象中的数据，以反映这首歌的添加。记住要从主线程中执行所有的数据库插入操作。 当用户搜索歌曲时，无论从数据库中加载的用于UI控制器的复杂歌曲数据都应该立即存储在ViewModel对象中。您还应该在ViewModel对象中保存搜索查询本身。 当activity进入后台时，系统调用onSaveInstanceState()。您应该在onSaveInstanceState()包中保存搜索查询。这少量的数据很容易保存。它也是将activity恢复到当前状态所需的所有信息。 恢复复杂状态: 重组部件当用户返回activity的时候，有两种可能的场景来重建activity: 该activity在被系统停止之后重新创建。该activity在onSaveInstanceState()包中保存了查询，并且应该将查询传递给ViewModel。ViewModel看到它没有缓存的搜索结果，并且使用给定的搜索查询来装载搜索结果。 该activity是在配置更改之后创建的。该activity在onSaveInstanceState()包中保存了查询，并且ViewModel已经缓存了搜索结果。您将查询从onSaveInstanceState()bundle传递到ViewModel，这就决定了它已经加载了必要的数据，并且不需要重新查询数据库 ⚠️:当一个activity最初创建时，onSaveInstanceState() bundle不包含数据，ViewModel对象是空的。当您创建ViewModel对象时，您将传递一个空查询，该查询将告诉ViewModel对象，目前还没有数据可加载。因此，activity从一个空的状态开始。 根据您的activity实现，您可能不需要使用onSaveInstanceState()。例如，浏览器可能会将用户返回到他们在浏览器退出之前所看到的精确的网页。如果您的activity以这种方式运行，您可以放弃使用onSaveInstanceState()，而是在本地保存所有内容。在搜索示例中，这可能意味着在共享首选项中持久化最近的查询。 此外，当您从一个intent打开一个activity时，当配置更改和系统恢复activity时，附加的附加部分将被交付到activity中。如果将搜索查询作为一个intent extra传递，您可以使用extras bundle而不是onSaveInstanceState() bundle。 在这两种情况中，您仍然会使用ViewModel来避免在配置更改期间从数据库中重新加载数据的循环。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件 - ViewModel","slug":"architecture-viewmodel","date":"2017-11-09T03:26:10.000Z","updated":"2020-07-25T02:57:18.193Z","comments":true,"path":"2017/11/09/architecture-viewmodel/","link":"","permalink":"https://jigangduan.github.io/2017/11/09/architecture-viewmodel/","excerpt":"ViewModel类旨在以生命周期的方式存储和管理与ui相关的数据。ViewModel类允许数据在诸如屏幕旋转之类的配置更改中存活。 注意:要将ViewModel导入到您的Android项目中，请参见向您的项目添加组件。 Android框架管理UI控制器的生命周期，比如activities和fragments。该框架可能会决定销毁或重新创建UI控制器，以响应完全超出您控制的某些用户操作或设备事件。 如果系统破坏或重新创建一个UI控制器，那么存储在其中的任何与UI相关的数据都将丢失。例如，你的应用可能会在其中一个activity中包含一个用户列表。当为配置更改重新创建activity时，新activity必须重新获取用户列表。对于简单的数据，该activity可以使用onSaveInstanceState())方法，并从onCreate())中的bundle中恢复其数据，但是这种方法只适用于少量的数据，这些数据可以序列化然后反序列化，而不是像用户列表或位图那样的潜在的大量数据。 另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在被销毁后清除它们，以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改重新创建对象的情况下，由于对象可能不得不重新发出已经发出的调用，这是对资源的浪费。 诸如activities和fragments之类的UI控制器主要是用来显示UI数据、对用户操作作出反应，或者处理操作系统通信，比如权限请求。要求UI控制器也负责从数据库或网络加载数据，这增加了类的膨胀。给UI控制器分配过多的责任会导致一个单独的类，它试图独自处理应用程序的所有工作，而不是将工作委托给其他类。以这种方式为UI控制器分配过多的责任也会使测试变得更加困难。 将视图数据所有权与UI控制器逻辑分离是更容易、更高效的。","text":"ViewModel类旨在以生命周期的方式存储和管理与ui相关的数据。ViewModel类允许数据在诸如屏幕旋转之类的配置更改中存活。 注意:要将ViewModel导入到您的Android项目中，请参见向您的项目添加组件。 Android框架管理UI控制器的生命周期，比如activities和fragments。该框架可能会决定销毁或重新创建UI控制器，以响应完全超出您控制的某些用户操作或设备事件。 如果系统破坏或重新创建一个UI控制器，那么存储在其中的任何与UI相关的数据都将丢失。例如，你的应用可能会在其中一个activity中包含一个用户列表。当为配置更改重新创建activity时，新activity必须重新获取用户列表。对于简单的数据，该activity可以使用onSaveInstanceState())方法，并从onCreate())中的bundle中恢复其数据，但是这种方法只适用于少量的数据，这些数据可以序列化然后反序列化，而不是像用户列表或位图那样的潜在的大量数据。 另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在被销毁后清除它们，以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改重新创建对象的情况下，由于对象可能不得不重新发出已经发出的调用，这是对资源的浪费。 诸如activities和fragments之类的UI控制器主要是用来显示UI数据、对用户操作作出反应，或者处理操作系统通信，比如权限请求。要求UI控制器也负责从数据库或网络加载数据，这增加了类的膨胀。给UI控制器分配过多的责任会导致一个单独的类，它试图独自处理应用程序的所有工作，而不是将工作委托给其他类。以这种方式为UI控制器分配过多的责任也会使测试变得更加困难。 将视图数据所有权与UI控制器逻辑分离是更容易、更高效的。 实现ViewModel架构组件为UI控制器提供ViewModel助手类，负责为UI准备数据。在配置更改期间，ViewModel对象将自动保留，以便它们保存的数据立即可用到下一个activity或fragment实例。例如，如果您需要在应用程序中显示一个用户列表，请确保将责任分配给一个ViewModel，而不是一个activity或fragment，如下面的示例代码所示: 1234567891011121314public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;Users&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // 执行一个异步操作来获取用户. &#125;&#125; 然后，您可以从以下activity中访问该列表: 1234567891011public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; // Create a ViewModel the first time the system calls an activity's onCreate() method. // Re-created activities receive the same MyViewModel instance created by the first activity. MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // update UI &#125;); &#125;&#125; 如果该activity被重新创建，它将收到第一个activity创建的MyViewModel实例。当所有者activity完成后，框架调用ViewModel对象的onCleared())方法，以便它可以清理资源。 ⚠️:ViewModel永远不能引用视图、Lifecycle或任何可能引用activity上下文的类。 ViewModel对象的设计是为了比具体的视图实例或LifecycleOwners实例活得更活。这个设计还意味着您可以更容易地编写测试来覆盖ViewModel，因为它不知道视图和生命周期对象。ViewModel对象可以包含LifecycleObservers，比如LiveData对象。然而，ViewModel对象永远不能观察对生命周期敏感的观察对象的变化，例如LiveData对象。如果ViewModel需要Application context，例如找到一个系统服务，它可以扩展AndroidViewModel类，并拥有一个在构造函数中接收到Application的构造函数，因为Application类扩展了Context。 ViewModel的生命周期ViewModel对象是在获得ViewModel时被传递到ViewModelProvider的生命周期的范围。ViewModel仍然存在于内存中，直到它被限定的生命周期永久地消失:在activity的情况下，当它finishes时，在一个fragment中，当它被detached时。 图1演示了一个activity的各个生命周期状态，当它进行轮转，然后结束。插图还显示了与相关活动生命周期相邻的ViewModel的生命周期。这个特殊的图说明了activity的状态。同样的基本状态也适用于fragment的生命周期。 在系统调用activity对象的onCreate()方法时，通常需要一个ViewModel。系统可以在activity的整个生命周期中多次调用onCreate()，例如在设备屏幕被旋转时。ViewModel存在于您第一次请求ViewModel时，直到activity完成并销毁。 fragments之间共享数据在一个activity中，两个或多个fragments需要相互通信是很常见的。设想一个常见的master-detail fragments，其中有一个fragment，用户从一个列表中选择一个项目，另一个fragment显示所选项的内容。这个案例并不简单，因为两个fragments都需要定义一些接口描述，而所有者activity必须将两者结合在一起。此外，两个fragments必须处理另一个fragment尚未创建或可见的场景。 这个常见的痛点可以通过使用ViewModel对象来解决。这些fragments可以使用它们的activity范围来共享一个视图模型，以处理这种通信，如下面的示例代码所示: 1234567891011121314151617181920212223242526272829303132public class SharedViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) &#123; selected.setValue(item); &#125; public LiveData&lt;Item&gt; getSelected() &#123; return selected; &#125;&#125;public class MasterFragment extends Fragment &#123; private SharedViewModel model; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; &#123; model.select(item); &#125;); &#125;&#125;public class DetailFragment extends Fragment &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); model.getSelected().observe(this, &#123; item -&gt; // Update the UI. &#125;); &#125;&#125; 请注意，在获取ViewModelProvider时，两个fragments都使用getActivity()。因此，这两个fragments都接收相同的SharedViewModel实例，该实例的作用域是activity。 这种方法提供了以下好处: activity不需要做任何事情，也不需要知道任何关于这种通信的信息。 除了SharedViewModel合同之外，Fragments不需要相互了解。如果其中一个fragments消失了，另一个则继续正常工作。 每个fragment都有自己的生命周期，并且不受另一个生命周期的影响。如果一个fragment替换另一个fragment，UI将继续工作，没有任何问题。 用ViewModel替换Loaders像CursorLoader这样的Loader类经常用于同步数据库数据保持应用程序的UI。您可以使用ViewModel，以及其他一些类来替换loader。使用ViewModel将UI控制器与数据加载操作分离，这意味着类之间的强引用较少。 在使用loaders的一种常见方法中，应用程序可能使用一个CursorLoader来观察数据库的内容。当数据库中的值发生变化时，loader会自动触发数据的重新加载，并更新UI: ViewModel使用Room和LiveData来替换loader。ViewModel确保数据在设备配置更改中得以保存。当数据库发生变化时，Room会通知您的LiveData，而LiveData则会用修改后的数据更新您的UI。 这篇博客文章描述了如何使用一个带有LiveData的ViewModel来替换一个AsyncTaskLoader。 随着您的数据变得越来越复杂，您可能会选择一个单独的类来加载数据。ViewModel的目的是封装UI控制器的数据，使数据能够在配置更改中存活。有关如何在配置更改中加载、持久化和管理数据的信息，请参见保存UI状态。 Android应用程序架构的指南建议构建一个存储库类来处理这些函数。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件 - LiveData","slug":"architecture-livedata","date":"2017-11-08T10:47:44.000Z","updated":"2020-07-25T02:57:18.192Z","comments":true,"path":"2017/11/08/architecture-livedata/","link":"","permalink":"https://jigangduan.github.io/2017/11/08/architecture-livedata/","excerpt":"LiveData是一个可观察的数据持有者类。与常规的可观察到的不同，LiveData是生命周期感知的，这意味着它尊重其他应用组件的生命周期，比如activities、fragments或services。这一认识确保了LiveData只更新了处于活动生命周期状态的应用程序组件观察者。","text":"LiveData是一个可观察的数据持有者类。与常规的可观察到的不同，LiveData是生命周期感知的，这意味着它尊重其他应用组件的生命周期，比如activities、fragments或services。这一认识确保了LiveData只更新了处于活动生命周期状态的应用程序组件观察者。 注意:要将LiveData组件导入到您的Android项目中，请参见向您的项目添加组件。 LiveData考虑一个观察者，它由Observer类表示，如果它的生命周期处于STARTED或RESUMED状态，则处于活跃状态。LiveData只会通知活动的观察者关于更新的信息。不活跃的观察者在观察LiveData对象的情况下不会被通知更改。 您可以向一个实现LifecycleOwner接口的对象注册一个观察者。当对应的生命周期对象的状态更改为DESTROYED时，该关系允许观察者被删除。这对于活动和片段尤其有用，因为它们可以安全地观察LiveData对象，而不用担心泄漏活动，当它们的生命周期被销毁时，它们会立即被取消订阅。 有关如何使用LiveData的更多信息，请参阅使用LiveData对象 使用LiveData的优点使用LiveData提供以下优点: 确保UI与数据状态匹配 LiveData遵循观察者模式。当生命周期状态发生变化时，LiveData会通知观察者对象。您可以通过合并代码来更新这些观察者对象中的UI。每次当应用数据发生变化时，你的观察者都可以更新UI，而不是每次更新时都更新UI。 没有内存泄漏 观察者被绑定到Lifecycle对象，当他们的相关生命周期被破坏时，他们将自己清理干净。 不会因为停止activities而崩溃 如果观察者的生命周期是不活跃的，例如在后台堆栈中的activity，那么它就不会接收任何LiveData事件。 不用手动处理生命周期 UI组件只是观察相关数据，不用停止或恢复观察。LiveData自动管理所有这些，因为它在观察时知道相关的生命周期状态变化。 一直到最新数据 如果一个生命周期变得不活跃，再次活跃它就会接收到最新的数据。例如，一个在后台的activity在它返回到前台后接收到最新的数据 适当的配置更改 如果一个activity或fragment由于配置更改而被重新创建，比如设备旋转，它会立即接收到最新可用的数据。 共享资源 您可以使用singleton模式扩展一个LiveData对象，以包装系统服务，这样它们就可以在您的应用程序中共享。LiveData对象连接到系统服务一次，然后任何需要资源的观察者都可以看到LiveData对象。要了解更多信息，请参阅扩展LiveData。 使用LiveData对象按照以下步骤使用LiveData对象: 创建一个LiveData实例来保存某种类型的数据。这通常在您的ViewModel类中完成 创建一个Observer对象，该对象定义onChanged()方法，该方法控制在LiveData对象的数据更改时发生的情况。您通常在UI控制器中创建一个Observer对象，例如一个activity或fragment。 使用observe())方法将观察者对象连接到LiveData对象。observe()方法接受一个LifecycleOwner对象。它将Observer对象订阅到LiveData对象，以便通知更改。您通常将Observer对象附加在UI控制器中，例如activity或fragment。 注意:您可以使用observeForever(Observer)方法注册一个没有关联的LifecycleOwner对象的观察者。在这种情况下，观察者被认为总是处于活动状态，因此总是被告知修改。您可以调用removeObserver(Observer)方法删除观察器。 当您更新存储在LiveData对象中的值时，只要附加的LifecycleOwner处于活跃状态，它就会触发所有已注册的观察者。 LiveData允许用户界面控制器的观察者订阅更新。当LiveData对象所持有的数据发生变化时，UI会自动更新响应。 创建LiveData对象LiveData是一个可以用于任何数据的包装器，包括实现Collections的对象，如List。LiveData对象通常存储在ViewModel对象中，并通过getter方法访问，如下面的示例所示: 1234567891011121314public class NameViewModel extends ViewModel &#123;// Create a LiveData with a Stringprivate MutableLiveData&lt;String&gt; mCurrentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (mCurrentName == null) &#123; mCurrentName = new MutableLiveData&lt;String&gt;(); &#125; return mCurrentName; &#125;// Rest of the ViewModel...&#125; 最初，LiveData对象中的数据没有设置。 注意:确保存储LiveData对象在ViewModel对象中更新UI，而不是activity或fragment，原因如下: 避免膨胀的活动和碎片。现在，这些UI控制器负责显示数据，而不是保存数据状态。 将LiveData实例与特定活动或片段实例分离，并允许LiveData对象在配置更改中存活。 您可以在ViewModel指南中更多地了解ViewModel类的好处和使用情况 观察LiveData对象在大多数情况下，应用程序组件的onCreate())方法是开始观察LiveData对象的正确位置，原因如下: 确保系统不会从activity或fragment的onResume()方法中发出冗余的调用。 为了确保activity或fragment拥有数据，它可以在活动开始时显示。一旦应用程序组件处于STARTED状态，它就会从它所观察到的LiveData对象中接收到最新的值。只有在已经设置了LiveData对象时才会出现这种情况。 一般来说，LiveData只在数据发生变化时才提供更新，而且只对活动的观察者进行更新。这种行为的一个例外是，当观察者从一个非活动状态转变为一个活动状态时，也会收到一个更新。此外，如果观察者第二次从非活动状态变为活动状态，它只会收到一个更新，如果该值在上一次激活时发生了变化。 下面的示例代码演示了如何开始观察一个LiveData对象: 1234567891011121314151617181920212223242526public class NameActivity extends AppCompatActivity &#123; private NameViewModel mModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. mModel = ViewModelProviders.of(this).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. mNameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. mModel.getCurrentName().observe(this, nameObserver); &#125;&#125; 在调用了observe())之后，nameObserver被作为参数传递，onChanged())立即被调用，提供了当前在mCurrentName中存储的最新值。如果LiveData对象没有在mCurrentName中设置值，则不会调用onChanged()。 更新LiveData对象LiveData没有公开可用的方法来更新存储的数据。MutableLiveData类公开了setValue(T))和postValue(T))方法，如果需要编辑存储在LiveData对象中的值，则必须使用这些方法。通常在ViewModel中使用MutableLiveData，然后ViewModel只向观察者公开不可变的LiveData对象。 在设置了观察者关系之后，您可以更新LiveData对象的值，如下面的例子所示，当用户点击一个按钮时，它会触发所有观察者: 1234567mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String anotherName = \"John Doe\"; mModel.getCurrentName().setValue(anotherName); &#125;&#125;); 在示例中调用setValue(T)的结果是观察者 被调用了有John Doe值的onChanged()方法 。示例显示了按钮按下，但是setValue()或postValue()的被调用可以是各种更新mName的原因，包括响应网络请求或数据库加载完成;在所有情况下，对setValue()或postValue()的调用会触发观察者并更新UI。 注意:您必须调用setValue(T)方法来从主线程更新LiveData对象。如果代码是在一个工作线程中执行的，那么您可以使用postValue(T)方法来更新LiveData对象。 使用LiveData RoomRoom持久化库支持可观察的查询，这些查询返回了LiveData对象。可观察的查询是作为数据库访问对象(DAO)的一部分编写的。 当数据库被更新时，Room会生成所有必要的代码来更新LiveData对象。当需要时，生成的代码在后台线程上异步地运行查询。此模式有助于将数据显示在UI中，与存储在数据库中的数据保持同步。您可以在Room持久化库指南中了解更多关于Room和DAO的内容。 扩展LiveDataLiveData认为，如果观察者的生命周期处于STARTED或RESUMED状态，那么观察者处于活跃状态，以下示例代码说明了如何扩展LiveData类: 123456789101112131415161718192021222324public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123; private StockManager mStockManager; private SimplePriceListener mListener = new SimplePriceListener() &#123; @Override public void onPriceChanged(BigDecimal price) &#123; setValue(price); &#125; &#125;; public StockLiveData(String symbol) &#123; mStockManager = new StockManager(symbol); &#125; @Override protected void onActive() &#123; mStockManager.requestPriceUpdates(mListener); &#125; @Override protected void onInactive() &#123; mStockManager.removeUpdates(mListener); &#125;&#125; 在本例中，价格listener的实现包括以下重要方法: onActive())方法调用，当LiveData对象有一个活跃的观察者时。这意味着您需要从这个方法开始观察股票价格的更新。 onInactive())方法调用，当LiveData对象没有任何活跃的观察者时。由于没有观察人员在监听，因此没有理由与StockManager服务保持联系。 setValue(T))方法更新LiveData实例的值，并通知任何活跃的观察者关于这个变化。 您可以使用StockLiveData类如下: 12345678910public class MyFragment extends Fragment &#123; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); LiveData&lt;BigDecimal&gt; myPriceListener = ...; myPriceListener.observe(this, price -&gt; &#123; // Update the UI. &#125;); &#125;&#125; observe())方法将片断作为第一个参数传递，它是LifecycleOwner的一个实例。这样做意味着这个观察者被绑定到与所有者相关的Lifecycle对象，这意味着: 如果Lifecycle对象不是处于活跃状态，那么即使值发生变化，也不会调用观察者。 在Lifecycle对象被销毁之后，观察者会被自动删除。 LiveData对象是生命周期感知的事实，这意味着您可以在多个activities、fragments和services之间共享它们。为了保持这个示例的简单性，您可以将LiveData类作为一个单例对象来实现: 123456789101112131415161718192021222324252627282930313233public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123; private static StockLiveData sInstance; private StockManager mStockManager; private SimplePriceListener mListener = new SimplePriceListener() &#123; @Override public void onPriceChanged(BigDecimal price) &#123; setValue(price); &#125; &#125;; @MainThread public static StockLiveData get(String symbol) &#123; if (sInstance == null) &#123; sInstance = new StockLiveData(symbol); &#125; return sInstance; &#125; private StockLiveData(String symbol) &#123; mStockManager = new StockManager(symbol); &#125; @Override protected void onActive() &#123; mStockManager.requestPriceUpdates(mListener); &#125; @Override protected void onInactive() &#123; mStockManager.removeUpdates(mListener); &#125;&#125; 你可以在fragment中使用它，如下: 12345678public class MyFragment extends Fragment &#123; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; StockLiveData.get(getActivity()).observe(this, price -&gt; &#123; // Update the UI. &#125;); &#125;&#125; 多个fragments和activities可以观察到MyPriceListener实例。如果其中一个或多个具有可见性和活跃性，LiveData只连接到系统服务。 变换LiveData您可能想要对LiveData对象中存储的值进行更改，然后将其发送给观察者，或者您可能需要根据另一个对象的值返回一个不同的LiveData实例。Lifecycle包提供了Transformations类，其中包括支持这些场景的辅助方法。 Transformations.map()) 对存储在LiveData对象中的值应用一个函数，并将结果传播到下游。 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); Transformations.switchMap()) 与map()类似，将一个函数应用到LiveData对象中存储的值，并将结果发送到下游。传递给switchMap()的函数必须返回一个LiveData对象，如下面的例子所示: 123456private LiveData&lt;User&gt; getUser(String id) &#123; ...;&#125;LiveData&lt;String&gt; userId = ...;LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) ); 您可以使用转换方法在观察者的生命周期中携带信息。除非观察者在观察返回的LiveData对象，否则这些转换不会被计算。因为转换是惰性地计算的，所以与生命周期相关的行为在不需要额外的显式调用或依赖项的情况下被隐式地传递下去。 如果您认为在ViewModel对象中需要一个Lifecycle对象，那么转换可能是更好的解决方案。例如，假设您有一个UI组件，该组件接受一个地址，并返回该地址的邮政编码。您可以为该组件实现简单的ViewModel，如下示例代码所示: 1234567891011class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository; &#125; private LiveData&lt;String&gt; getPostalCode(String address) &#123; // DON'T DO THIS return repository.getPostCode(address); &#125;&#125; 然后，UI组件需要从先前的LiveData对象中取消注册，并在每次调用getPostalCode()时注册新实例。此外，如果UI组件被重新创建，它将触发另一个repository.getPostCode()方法的调用，而不是使用以前的调用的结果 相反，您可以将邮政编码查询作为地址输入的转换实现，如下面的示例所示: 12345678910111213141516class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; private final MutableLiveData&lt;String&gt; addressInput = new MutableLiveData(); public final LiveData&lt;String&gt; postalCode = Transformations.switchMap(addressInput, (address) -&gt; &#123; return repository.getPostCode(address); &#125;); public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository &#125; private void setInput(String address) &#123; addressInput.setValue(address); &#125;&#125; 在本例中，postalCode字段是public的和final，因为字段永远不会更改。postalCode字段定义为addressInput的转换，这意味着在addressInput更改时调用repository.getPostCode()方法。如果有一个活动的观察者，如果在repository.getPostCode()被调用时没有活动的观察者，那么在观察者被添加之前没有计算。 该机制允许应用程序在较低级别创建基于需求的延迟计算的LiveData对象。ViewModel对象可以很容易地获得对LiveData对象的引用，然后在它们上面定义转换规则。 创建新的转换在你的应用中有十几个不同的具体的转换，但它们不是默认提供的。为了实现您自己的转换，您可以使用MediatorLiveData类，它侦听其他的LiveData对象，并处理它们发出的事件。MediatorLiveData正确地将其状态传播到源LiveData对象。要了解更多关于此模式的信息，请参阅Transformations类的参考文档。 合并多个LiveData源MediatorLiveData是LiveData的一个子类，它允许您合并多个live数据源。当任何原始的LiveData源对象发生变化时，MediatorLiveData对象的观察者就会被触发。 例如，如果您的UI中有一个LiveData对象，可以从本地数据库或网络更新，那么您可以将以下源添加到MediatorLiveData对象: 与存储在数据库中的数据相关联的LiveData对象。 与从网络访问的数据相关联的LiveData对象。 您的activity只需要观察MediatorLiveData对象来接收来自两个源的更新。对于一个详细的示例，请参阅 应用程序架构指南的附录:网络状态部分。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件 - 使用Lifecycle组件来处理生命周期","slug":"architecture-lifecycle","date":"2017-11-08T08:50:06.000Z","updated":"2020-07-25T02:57:18.173Z","comments":true,"path":"2017/11/08/architecture-lifecycle/","link":"","permalink":"https://jigangduan.github.io/2017/11/08/architecture-lifecycle/","excerpt":"Lifecycle组件执行操作以响应另一个组件的生命周期状态的变化，例如activities和fragments。这些组件可以帮助您生成更有组织的、更轻的代码，这样更容易维护。 一个常见的模式是在activities和fragments的生命周期方法中实现相关组件的操作。然而，这种模式导致了代码的糟糕组织和错误的扩散。通过使用lifecycle组件，您可以将依赖组件的代码从生命周期方法中转移到本身组件中 android.arch.lifecycle包提供了类和接口，允许您构建基于生命周期的组件，这些组件可以根据activity或fragment的当前生命周期状态自动调整它们的行为。 ⚠️:导入android.arch.lifecycle在您的Android项目，请参见向您的项目添加组件。","text":"Lifecycle组件执行操作以响应另一个组件的生命周期状态的变化，例如activities和fragments。这些组件可以帮助您生成更有组织的、更轻的代码，这样更容易维护。 一个常见的模式是在activities和fragments的生命周期方法中实现相关组件的操作。然而，这种模式导致了代码的糟糕组织和错误的扩散。通过使用lifecycle组件，您可以将依赖组件的代码从生命周期方法中转移到本身组件中 android.arch.lifecycle包提供了类和接口，允许您构建基于生命周期的组件，这些组件可以根据activity或fragment的当前生命周期状态自动调整它们的行为。 ⚠️:导入android.arch.lifecycle在您的Android项目，请参见向您的项目添加组件。 大多数在Android框架中定义的应用程序组件都有生命周期。生命周期由操作系统或在您的过程中运行的框架代码来管理。它们是Android如何工作的核心，你的应用必须尊重它们。如果不这样做，可能会触发内存泄漏或应用程序崩溃。 假设我们有一个activity，在屏幕上显示的设备位置。一个常见的实现可能如下: 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 尽管这个示例看起来很好，但在实际应用中，您最终会有太多的调用来管理UI和其他组件以响应生命周期的当前状态。管理多个组件在生命周期方法中放置了相当数量的代码，例如onStart()和onStop()，这使得它们难以维护。 1234567891011121314151617181920212223242526class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, location -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); Util.checkUserStatus(result -&gt; &#123; // what if this callback is invoked AFTER activity is stopped? if (result) &#123; myLocationListener.start(); &#125; &#125;); &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); &#125;&#125; android.arch.lifecycle包提供了类和接口，帮助您以一种弹性和隔离的方式来解决这些问题。 LifecycleLifecycle是一个类，它包含组件的生命周期状态的信息(比如activity或fragment)，并允许其他对象观察这个状态。 Lifecycle使用两个主要枚举来跟踪其相关组件的生命周期状态: Event 从框架和生命周期类中分派的lifecycle事件。这些事件映射到activities和fragments中的回调事件。 State Lifecycle对象跟踪的组件的当前状态。 可以将states看作图和事件的节点，就像这些节点之间的边沿。 一个类可以通过向其方法添加注释来监视组件的生命周期状态。然后，您可以通过调用Lifecycle类的addObserver())方法添加一个观察者，并传递一个观察者的实例，如下面的例子所示: 12345678910111213public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void disconnectListener() &#123; ... &#125;&#125;myLifecycleOwner.getLifecycle().addObserver(new MyObserver()); 在上面的例子中，myLifecycleOwner对象实现了LifecycleOwner接口，这将在下面的部分中解释。 LifecycleOwnerLifecycleOwner是一个表示类具有Lifecycle的单一方法接口。它有一个方法getLifecycle())，它必须由类来实现。如果您试图管理整个应用程序过程的生命周期，请参见ProcessLifecycleOwner。 这个接口从单个类中抽象出Lifecycle的所有权，例如Fragment和AppCompatActivity，并允许编写与它们一起工作的组件。任何定制的应用程序类都可以实现LifecycleOwner接口。 实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝地工作，因为所有者可以提供一个lifecycle，一个观察者可以注册观察。 对于位置跟踪示例，我们可以让MyLocationListener类实现LifecycleObserver，然后用onCreate()方法中的activity生命周期初始化它。这使得MyLocationListener类能够自给自足，这意味着在MyLocationListener中声明了对lifecycle状态变化的响应，而不是activity。让单独的组件存储它们自己的逻辑，可以使活动和片段逻辑更容易管理。 1234567891011121314class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, getLifecycle(), location -&gt; &#123; // update UI &#125;); Util.checkUserStatus(result -&gt; &#123; if (result) &#123; myLocationListener.enable(); &#125; &#125;); &#125;&#125; 一个常见的用例是如果生命周期处于不良好状态，就避免调用某些回调。例如，如果回调在activity状态保存后运行一个fragment事务，它将触发崩溃，因此我们永远不希望调用那个回调。 为了使这个用例简单，Lifecycle类允许其他对象查询当前状态。 12345678910111213141516171819202122232425class MyLocationListener implements LifecycleObserver &#123; private boolean enabled = false; public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) void start() &#123; if (enabled) &#123; // connect &#125; &#125; public void enable() &#123; enabled = true; if (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123; // connect if not connected &#125; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void stop() &#123; // disconnect if connected &#125;&#125; 有了这个实现，我们的LocationListener类完全是生命周期感知的。如果我们需要从另一个activity或fragment中使用LocationListener，我们只需要初始化它。所有的安装和拆卸操作都是由类本身管理的。 如果一个库提供了需要使用Android生命周期的类，我们建议您使用lifecycle组件。您的库客户端可以轻松地集成这些组件，而无需在客户端进行手动的生命周期管理。 实现自定义LifecycleOwner支持库26.1.0的Fragments和Activities已经实现了LifecycleOwner接口。 如果您有一个定制的类，您想要创建一个LifecycleOwner，您可以使用LifecycleRegistry类，但是您需要将事件转发到这个类中，如下面的代码示例所示: 1234567891011121314151617181920212223public class MyActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry mLifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLifecycleRegistry = new LifecycleRegistry(this); mLifecycleRegistry.markState(Lifecycle.State.CREATED); &#125; @Override public void onStart() &#123; super.onStart(); mLifecycleRegistry.markState(Lifecycle.State.STARTED); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125;&#125; lifecycle组件的最佳实践Lifecycle组件可以使您在各种情况下更容易地管理生命周期。几个例子: 在粗粒度和细粒度的位置更新之间切换。使用生命周期感知组件来支持细粒度的位置更新，而你的位置应用是可见的，当应用在后台时切换到粗粒度的更新。LiveData，一个生命周期感知组件，允许你的应用在你的使用改变位置时自动更新UI 停止并启动视频缓冲。使用生命周期感知的组件尽快启动视频缓冲，但是延迟播放直到应用程序完全启动。您还可以使用生命周期感知组件在应用程序被销毁时终止缓冲。 启动和停止网络连接。使用生命周期感知组件来支持网络数据的实时更新(流)，当应用处于前台时，当应用进入后台时自动暂停。 暂停并恢复动画绘图。当应用在后台时，使用生命周期感知的组件来处理暂停的动画，当应用程序处于前台时，可以使用它。 处理on stop事件当Lifecycle属于AppCompatActivity或Fragment，onSaveInstanceState()被调用时，生命周期的状态会变化到CREATED，ON_STOP事件将派发。 当一个Fragment或AppCompatActivity的状态通过onSaveInstanceState()保存时，它的UI被认为是不可变的，直到ON_START被调用。在保存状态后尝试修改UI可能会导致应用程序的导航状态出现不一致，这就是为什么在保存状态后，如果应用程序运行了FragmentTransaction，那么FragmentManager会抛出一个异常。有关详细信息,请参阅commit())。 如果观察者的关联Lifecycle不是STARTED，LiveData阻止这个边界情况的发生，就避免调用它的观察者。在幕后，它调用isAtLeast()，然后决定调用它的观察者。 不幸的是，AppCompatActivity的onStop()方法是在onSaveInstanceState()之后调用的，它在UI状态更改不被允许的情况下留下了一个空白，但是Lifecycle还没有被转移到CREATED的状态。 为了防止这一问题，beta2版本中的Lifecycle类并将状态标记为CREATED，而无需发送事件，以便任何检查当前状态的代码都能获得真正的值，即使事件直到onStop()被系统调用时才会被发送。 不幸的是，这个解决方案有两个主要问题: 在API级别23和更低的情况下，Android系统实际上可以节省activity的状态，即使它被另一个activity所覆写。换句话说，Android系统调用onSaveInstanceState()，但它不一定调用onStop()。这就产生了一个潜在的很长的时间间隔，观察者仍然认为生命周期是活动的，即使它的UI状态不能被修改。 任何想要向LiveData类公开类似行为的类都必须实现Lifecycle beta 2版本和更低版本提供的解决方案。 注意:为了使这个流更简单，并提供更好的兼容性，从版本1.0-rc1开始，生命周期对象被标记为CREATED和ON_STOP已被派发，并且在调用onSaveInstanceState()时不等待对onStop()方法的调用。这不太可能影响您的代码，但是您需要注意的是，它不符合API级别26和更低的活动类中的调用顺序。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android架构组件 添加到你的项目","slug":"adding-components","date":"2017-11-08T08:24:19.000Z","updated":"2020-07-25T02:57:18.172Z","comments":true,"path":"2017/11/08/adding-components/","link":"","permalink":"https://jigangduan.github.io/2017/11/08/adding-components/","excerpt":"","text":"架构组件可以从Google的Maven存储库中获得。要使用这些步骤，请遵循以下步骤: 添加Google Maven存储库在默认情况下，Android Studio项目不会被配置为访问这个存储库。 要将它添加到您的项目中，为您的项目打开 build.gradle文件(而不是您的应用程序或模块)，如下所示: 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url 'https://maven.google.com' &#125; &#125;&#125; 添加架构组件打开您的应用程序或模块build.gradle文件，并添加依赖项: Lifecycles: implementation &quot;android.arch.lifecycle:runtime:1.0.3&quot; //使用着lifecycle:extensions or lifecycle:common-java8 就不需 annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.0&quot; //如果您使用common-java8中的DefaultLifecycleObserver，则不需要 对于Lifecycles的Java8 Lanaguage支持，添加: implementation &quot;android.arch.lifecycle:common-java8:1.0.0&quot; LiveData和ViewModel： implementation &quot;android.arch.lifecycle:extensions:1.0.0&quot; 要在测试中控制LiveData后台线程，请添加: testImplementation &quot;android.arch.core:core-testing:1.0.0&quot; 要使用ReactiveStreams API的LiveData，请添加: implementation &quot;android.arch.lifecycle:reactivestreams:1.0.0&quot; Room implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot; annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot; 对于测试Room迁移，添加: testImplementation &quot;android.arch.persistence.room:testing:1.0.0&quot; 对Room RxJava的支持，添加: implementation &quot;android.arch.persistence.room:rxjava2:1.0.0&quot; Paging implementation &quot;android.arch.paging:runtime:1.0.0-alpha3&quot; 要了解更多信息，请参阅添加构建依赖项。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件指南","slug":"GuidetoAppArchitecture","date":"2017-11-08T03:23:22.000Z","updated":"2020-07-25T02:57:18.153Z","comments":true,"path":"2017/11/08/GuidetoAppArchitecture/","link":"","permalink":"https://jigangduan.github.io/2017/11/08/GuidetoAppArchitecture/","excerpt":"本指南适用于开发app的开发人员，现在希望了解最佳实践和推荐的体系结构，构建健壮、高质量的apps。 注意:本指南假定读者熟悉Android框架。如果你是应用开发的新手，请查看入门培训系列，其中包含了本指南的必备主题。","text":"本指南适用于开发app的开发人员，现在希望了解最佳实践和推荐的体系结构，构建健壮、高质量的apps。 注意:本指南假定读者熟悉Android框架。如果你是应用开发的新手，请查看入门培训系列，其中包含了本指南的必备主题。 app开发人员面临的常见问题与传统的桌面应用不同，在大多数情况下，它们都有一个单一入口点，并作为一个单一的整体流程运行，而Android应用程序的结构要复杂得多。一个典型的Android应用程序是由多个应用组件组成的，包括activities、fragments、services、content providers和broadcast receivers。 大部分应用程序组件都是在应用程序清单中声明的，Android操作系统使用这些组件来决定如何将你的应用集成到用户体验中。正如前面提到的，桌面应用程序传统上是一个单一的过程，一个正确编写的Android应用程序需要更加灵活，因为用户可以通过设备上的不同应用程序，不断地切换流量和任务。 例如，考虑一下当你在你最喜欢的社交网络应用中分享一张照片时会发生什么。这款应用会触发一个摄像头的intent，Android操作系统会启动一个摄像头应用来处理这个请求。在这一点上，用户离开了社交网络应用，但他们的体验是无缝的。反过来，摄像头应用可能会触发其他intents，比如启动文件选择器，这可能会启动另一个应用。最终用户会回到社交网络应用，分享照片。另外，用户可以在这个过程的任何时候被一个电话打断，然后在完成电话呼叫后返回来分享照片。 在Android中，这种应用程序的行为是很常见的，所以你的应用程序必须正确处理这些流程。请记住，移动设备是资源受限的，因此在任何时候，操作系统可能需要杀死一些应用程序来为新的应用程序腾出空间。 这一切的关键在于，你的应用程序组件可以单独启动，也可以不按顺序启动，可以随时被用户或系统摧毁。因为应用组件是短暂的，它们的生命周期(当它们被创建和销毁时)不在你的控制之下，你不应该在应用程序组件中存储任何应用数据或状态，而应用程序组件不应该相互依赖。 常见的架构原则如果你不能使用应用程序组件来存储应用数据和状态，那么应用程序应该如何构建呢? 你应该关注的最重要的事情是你的应用中关注点的分离。 在Activity或Fragment中编写所有代码是一个常见的错误。任何不处理UI或操作系统交互的代码都不应该在这些类中。让他们尽可能地精简，这样可以避免许多与生命周期相关的问题。不要忘记你不拥有这些类，它们只是在操作系统和你的应用之间体现契约的胶类。Android操作系统可能会在任何时候基于用户交互或低内存等其他因素破坏它们。最好是减少对它们的依赖，以提供可靠的用户体验。 第二个重要原则是，应该模型驱动UI，最好是持久模型。 持久性是理想的两个原因:如果操作系统破坏了你的应用程序来释放资源，你的用户不会丢失数据，即使网络连接很脆弱或没有连接，你的应用也会继续工作。模型是负责处理应用程序数据的组件。它们独立于应用程序中的视图和应用程序组件，因此它们与这些组件的生命周期问题是隔离的。保持UI代码的简单性和应用程序逻辑的自由使管理变得更加容易。将你的应用程序建立在具有明确责任管理数据的模型类上，这将使它们具有可测试性，并且你的应用程序是一致的。 推荐应用架构在本节中，我们将演示如何通过使用用例来构造应用程序的结构组件。 注意:要有一种编写应用程序所有场景中最好的方式是不可能的。也就是说，对于大多数用例来说，推荐的体系结构应该是一个良好的起点。如果你已经有了编写Android应用程序的好方法，你就不需要改变了。 假设我们正在构建一个显示用户配置文件的UI。这个用户配置文件将从我们自己的私有后端使用REST API获取。 构建用户界面UI将由一个fragment UserProfileFragment.java 及其相应的布局文件user_profile_layout.xml组成。 为了驱动UI，我们的数据模型需要保存两个数据元素。 用户ID: 用户的标识符。最好是使用fragment参数将这些信息传递到fragment中。如果Android操作系统破坏了你的进程，那么这个信息就会被保存下来，所以当你的应用重新启动时，id还可以使用。 User对象: 保存用户数据的POJO。 我们将基于ViewModel类创建一个UserProfileViewModel，保存此信息。 ViewModel为特定的UI组件提供数据，例如fragment或activity，并处理与数据处理业务部分的通信，例如调用其他组件来加载数据或转发用户修改。ViewModel不知道视图，也不受配置更改的影响，比如由于旋转造成的重新创建一个activity。 现在我们有3个文件： user_profile.xml: 屏幕的UI定义 UserProfileViewModel.java: 为UI准备数据类 UserProfileFragment.java: 在ViewModel中显示数据并对用户交互作出反应的UI控制器 下面开始我们的实现(为了简单起见，省略布局文件): 1234567891011public class UserProfileViewModel extends ViewModel &#123; private String userId; private User user; public void init(String userId) &#123; this.userId = userId; &#125; public User getUser() &#123; return user; &#125;&#125; 123456789101112131415161718public class UserProfileFragment extends Fragment &#123; private static final String UID_KEY = \"uid\"; private UserProfileViewModel viewModel; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); String userId = getArguments().getString(UID_KEY); viewModel = ViewModelProviders.of(this).get(UserProfileViewModel.class); viewModel.init(userId); &#125; @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.user_profile, container, false); &#125;&#125; 现在，我们有了这三个代码模块，我们如何连接它们?毕竟，当ViewModel的user字段被设置时，我们需要一种方法来通知UI。这就是LiveData类的用武之地。 LiveData是一个可观察的数据持有者。它让应用程序中的组件可以在不创建显式和严格的依赖路径的情况下，观察LiveData对象的变化。LiveData还尊重应用程序组件(activities、fragments、services)的生命周期状态，并做正确的事情来防止对象泄漏，这样您的应用程序就不会消耗更多的内存 注意:如果您已经在使用RxJava或Agera这样的库，您可以继续使用它们，而不是使用LiveData。但是当您使用它们或其他方法时，请确保您正确地处理生命周期，这样当相关的生命周期所有者被停止时，您的数据流就会暂停，而当生命周期所有者被销毁时，流就会被销毁。您还可以添加android.arch.lifecycle:reactivestreams部件以使用LiveData与另一个响应式流库(例如RxJava2)。 现在，我们在UserProfileViewModel中使用LiveData&lt;User&gt;字段替换User字段，以便在数据更新时可以通知fragment。LiveData最重要的一点是生命周期感知，当不再需要时，它将自动清除引用。 12345678public class UserProfileViewModel extends ViewModel &#123; ... //private User user; private LiveData&lt;User&gt; user; public LiveData&lt;User&gt; getUser() &#123; return user; &#125;&#125; 现在，我们修改UserProfileFragment来观察数据并更新UI。 1234567@Overridepublic void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); viewModel.getUser().observe(this, user -&gt; &#123; // update UI &#125;);&#125; 每次更新用户数据时，都会调用onChanged)的回调，并刷新UI。 如果您熟悉使用observable回调函数的其他库，您可能已经意识到，我们不必覆写片段的onStop()方法来停止观察数据。这对于LiveData来说是不必要的，因为它是生命周期感知的，这意味着除非fragment处于活动状态(接收到onStart()，但是没有接收onStop())，否则它将不会调用回调。当片段接收到onDestroy()时，LiveData也会自动删除观察者。 我们也没有做任何特别的事情来处理配置更改(例如，用户旋转屏幕)。当配置发生变化时，ViewModel会自动恢复，因此当新fragment出现时，它将接收到相同的ViewModel实例，并且将立即使用当前数据调用回调。这就是viewmodel不直接引用视图的原因;它们可以比视图的生命周期活的长。查看一个ViewModel的生命周期。 获取数据现在我们已经将ViewModel连接到fragment，但是ViewModel如何获取用户数据呢?在本例中，我们假设我们的后端提供了一个REST API。我们将使用Retrofit库来访问我们的后端，尽管您可以使用不同的库来实现相同的目的。 这是我们的retrofit Webservice与我们的后端通信: 123456789public interface Webservice &#123; /** * @GET 声明一个HTTP GET请求 * @Path(\"user\") 在userId参数上的注释 * 替换 @GET路径中&#123;user&#125;占位符 */ @GET(\"/users/&#123;user&#125;\") Call&lt;User&gt; getUser(@Path(\"user\") String userId);&#125; ViewModel的一个幼稚的实现是直接调用Webservice来获取数据并将其返回给用户对象。即使它很好用，但你的应用也很难在成长的过程中维护。它给ViewModel类带来了太多的责任，这违背了我们之前提到的关注点分离原则。此外，ViewModel的范围与Activity或Fragment生命周期相关联，因此在其生命周期结束时丢失所有数据是一个糟糕的用户体验。相反，我们的ViewModel将把这个工作委托给一个新的Repository模块。 Repository模块 负责处理数据操作。他们为应用程序的其余部分提供了一个干净的API，他们知道从哪里获取数据，以及在数据更新时要做什么API调用。您可以将它们视为不同数据源之间的中介(持久模型、web服务、缓存等)。 下面的UserRepository类使用WebService来获取用户数据项。 12345678910111213141516public class UserRepository &#123; private Webservice webservice; // ... public LiveData&lt;User&gt; getUser(int userId) &#123; // This is not an optimal implementation, we'll fix it below final MutableLiveData&lt;User&gt; data = new MutableLiveData&lt;&gt;(); webservice.getUser(userId).enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; // error case is left out for brevity data.setValue(response.body()); &#125; &#125;); return data; &#125;&#125; 尽管Repository模块看起来没有必要，但它有一个重要的目的;它从应用的其余部分中提取数据源。现在，我们的ViewModel不知道数据是由Webservice获取的，这意味着我们可以根据需要将其交换到其他实现。 注意:为了简单起见，我们省略了网络错误的例子。对于暴露错误和加载状态的另一种实现，请参阅附录:暴露网络状态。 管理组件之间的依赖关系:上面的UserRepository类需要一个Webservice的实例来完成它的工作。它可以简单地创建它，但是要这样做，构造它还需要知道Webservice类的依赖项。这将大大复杂化并复制代码(例如，需要一个Webservice实例的每个类都需要知道如何使用它的依赖项来构造它)。此外，UserRepository可能不是唯一需要Webservice的类。如果每个类都创建一个新的Webservice，那么它将是非常资源非常重的。 有两类模式可以用来解决这个问题: 依赖注入: 依赖注入允许类在不构造它们的情况下定义它们的依赖关系。在运行时，另一个类负责提供这些依赖项。我们推荐Google的Dagger 2库，用于在Android应用中实现依赖注入。Dagger 2通过使用依赖树来自动构造对象，并提供对依赖项的编译时间保证 服务定位器: 服务定位器提供一个注册表，在这个注册表中，类可以获得它们的依赖，而不是构建它们。它比依赖项注入(DI)要容易得多，所以如果您不熟悉DI，那么使用服务定位器代替。 这些模式允许您扩展您的代码，因为它们为管理依赖关系提供了清晰的模式，而不需要复制代码或增加复杂性。它们都允许交换实现进行测试;这是使用它们的主要好处之一。 在本例中，我们将使用Dagger 2来管理依赖关系。 连接ViewModel和Repository现在，我们来使用repository修改UserProfileViewModel。 123456789101112131415161718192021public class UserProfileViewModel extends ViewModel &#123; private LiveData&lt;User&gt; user; private UserRepository userRepo; @Inject // UserRepository参数由Dagger 2提供 public UserProfileViewModel(UserRepository userRepo) &#123; this.userRepo = userRepo; &#125; public void init(String userId) &#123; if (this.user != null) &#123; // ViewModel是每个片段Fragment的，因此我们知道userId不会改变 return; &#125; user = userRepo.getUser(userId); &#125; public LiveData&lt;User&gt; getUser() &#123; return this.user; &#125;&#125; 缓存数据上面的repository实现很好地提取了对web服务的调用，但是因为它只依赖于一个数据源，所以它不是很有用。 上面的UserRepository实现的问题是，在获取数据之后，它并没有将数据保存在任何地方。如果用户离开UserProfileFragment并返回到它，该应用程序将重新获取数据。这有两个原因:它浪费了宝贵的网络带宽，并迫使用户等待新的查询完成。为了解决这个问题，我们将向我们的UserRepository添加一个新的数据源，该数据源将在内存中缓存User对象。 123456789101112131415161718192021222324@Singleton // 通知Dagger，这个类应该被构造一次public class UserRepository &#123; private Webservice webservice; // 在内存缓存中很简单，为了简洁而省略了细节 private UserCache userCache; public LiveData&lt;User&gt; getUser(String userId) &#123; LiveData&lt;User&gt; cached = userCache.get(userId); if (cached != null) &#123; return cached; &#125; final MutableLiveData&lt;User&gt; data = new MutableLiveData&lt;&gt;(); userCache.put(userId, data); // 这仍然是次优的，但比以前更好. // 一个完整的实现还必须处理错误案例. webservice.getUser(userId).enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; data.setValue(response.body()); &#125; &#125;); return data; &#125;&#125; 持久化数据在我们当前的实现中，如果用户旋转屏幕或离开并返回应用程序，那么现有的UI将立即可见，因为repository从内存缓存中检索数据。但是，如果用户离开了应用，几个小时后又回来了，在Android操作系统扼杀了这个过程之后，又会发生什么呢? 使用当前的实现，我们将需要从网络获取数据。这不仅是一种糟糕的用户体验，而且也是一种浪费，因为它将使用移动数据来重新获取相同的数据。您可以简单地通过缓存web请求来解决这个问题，但是它会产生新的问题。如果相同的用户数据来自另一种类型的请求(例如，获取好友列表)，会发生什么情况?然后，你的应用程序可能会显示不一致的数据，这是最令人困惑的用户体验。例如，相同用户的数据可能会以不同的方式出现，因为好友请求和用户请求可以在不同的时间执行。你的应用需要将它们合并，以避免显示不一致的数据。 处理这个问题的正确方法是使用一个持久化模型。这就是Room持久化库来拯救的地方。 Room是一个对象映射库，它为本地数据持久化提供了最小的样板代码。在编译时，它会根据模式验证每个查询，因此，损坏的SQL查询会导致编译时错误，而不是运行时失败。Room抽象了处理原始SQL表和查询的一些底层实现细节。它还允许对数据库数据进行更改(包括集合和连接查询)，通过LiveData对象公开这些更改。此外，它还显式地定义了解决常见问题的线程约束，例如访问主线程上的存储。 注意:如果您的应用程序已经使用了另一个持久性解决方案，比如SQLite对象关系映射(ORM)，那么您就不需要用Room来替换现有的解决方案了。然而，如果你正在写一款新应用或重构现有的应用，我们推荐使用房间来保存你的应用的数据。这样，您就可以利用该库的抽象和查询验证功能。 使用Room，我们需要定义我们的本地模式。首先，用@Entity注释User类，将其标记为数据库中的一个表。 12345678@Entityclass User &#123; @PrimaryKey private int id; private String name; private String lastName; // getters and setters for fields&#125; 然后，通过为应用程序扩展RoomDatabase来创建一个数据库类: 123@Database(entities = &#123;User.class&#125;, version = 1)public abstract class MyDatabase extends RoomDatabase &#123;&#125; 注意，MyDatabase是抽象的。Room自动提供它的实现。有关详细信息，请参阅Room文档。 现在我们需要一种方法来将用户数据插入到数据库中。为此，我们将创建一个数据访问对象(DAO)。 1234567@Daopublic interface UserDao &#123; @Insert(onConflict = REPLACE) void save(User user); @Query(\"SELECT * FROM user WHERE id = :userId\") LiveData&lt;User&gt; load(String userId);&#125; 然后，从我们的数据库类引用DAO。 1234@Database(entities = &#123;User.class&#125;, version = 1)public abstract class MyDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125; 请注意，load方法返回一个LiveData&lt;User&gt;。Room知道数据库何时被修改，当数据发生变化时，它会自动通知所有的活动观察者。因为它使用LiveData，所以这将是有效的，因为只有在至少有一个活动观察者的情况下，它才会更新数据。 注意:基于表修改的Room检查失效，这意味着它可能会发送错误的正向通知。 现在，我们可以修改我们的UserRepository来合并Room数据源。 1234567891011121314151617181920212223242526272829303132333435@Singletonpublic class UserRepository &#123; private final Webservice webservice; private final UserDao userDao; private final Executor executor; @Inject public UserRepository(Webservice webservice, UserDao userDao, Executor executor) &#123; this.webservice = webservice; this.userDao = userDao; this.executor = executor; &#125; public LiveData&lt;User&gt; getUser(String userId) &#123; refreshUser(userId); // 从数据库直接返回一个LiveData. return userDao.load(userId); &#125; private void refreshUser(final String userId) &#123; executor.execute(() -&gt; &#123; // 在后台线程中运行 // 检查用户最近是否被获取 boolean userExists = userDao.hasUser(FRESH_TIMEOUT); if (!userExists) &#123; // 刷新数据 Response response = webservice.getUser(userId).execute(); // TODO 检查错误等. // 更新数据库。LiveData会自动刷新 // 除了更新数据库之外，我们不需要做其他任何事情 userDao.save(response.body()); &#125; &#125;); &#125;&#125; 请注意，即使我们更改了来自UserRepository的数据，我们也不需要更改UserProfileViewModel或UserProfileFragment。这是抽象提供的灵活性。这对于测试来说也很好，因为您可以在测试您的UserProfileViewModel时提供一个假的UserRepository。 现在我们的代码已经完成了。如果用户在几天后返回相同的UI，他们将立即看到用户信息，因为我们已经持久化了它。同时，如果数据陈旧，我们的存储库将更新背景中的数据。当然，根据您的用例，如果它太老了，您可能不愿意显示持久的数据。 在一些用例中，例如“下拉刷新”，如果当前有网络操作正在进行中，那么UI向用户显示是很重要的。将UI操作与实际数据分开是一种很好的做法，因为它可能会因为各种原因而被更新(例如，如果我们获取一个朋友列表，同样的用户可能会被再次获取，从而触发一个LiveData更新)。从UI的角度来看，在飞行中有请求的事实只是另一个数据点，类似于任何其他的片段数据(比如User对象)。 对于这个用例有两种常见的解决方案: 更改getUser以返回包含网络操作状态的LiveData。提供了一个示例实现:附录:暴露网络状态 部分。 在repository类中提供另一个public函数，可以返回用户的刷新状态。如果您想在UI中显示网络状态，只在对显式的用户操作(如拉到刷新)的响应中显示网络状态，那么这个选项就更好了。 单一来源的真相不同REST API端点返回相同的数据是很常见的。例如，如果我们的后端有另一个返回好友列表的端点，那么相同的用户对象可能来自两个不同的API端点，可能是不同的粒度。如果UserRepository按原样返回来自Webservice请求的响应，那么我们的UIs可能会显示不一致的数据，因为数据可能会在这些请求之间的服务器端发生变化。这就是为什么在UserRepository实现中，Webservice回调只是将数据保存到数据库中。然后，对数据库的更改将触发对LiveData对象回调的活动。 在这个模型中，数据库作为唯一的真理来源，并且应用程序的其他部分通过存储库访问它。不管您是否使用磁盘缓存，我们建议您将存储库数据源指定为您应用程序其余部分的唯一来源。 测试我们已经提到分离的好处之一是可测试性。让我们看看如何测试每个代码模块。 用户界面和交互: 这将是你唯一需要Android UI Instrumentation test的时候。测试UI代码的最佳方法是创建一个Espresso测试。您可以创建fragment并提供一个mock ViewModel。由于fragment只与ViewModel进行对话，因此对其进行模拟将足以充分测试此UI。 ViewModel: 可以使用JUnit对ViewModel进行测试。您只需要模拟UserRepository来测试它。 UserRepository: 您还可以使用JUnit来测试UserRepository。您需要模拟Webservice和DAO。您可以测试它是否提供了正确的Webservice调用，将结果保存到数据库中，并且如果数据被缓存和更新，就不会产生任何不必要的请求。由于Webservice和UserDao都是接口，所以您可以模拟它们，或者为更复杂的测试用例创建假的实现。 UserDao: 测试DAO类的推荐方法是使用instrumentation测试。由于这些instrumentation测试不需要任何UI，所以它们仍然会运行得很快。对于每一个测试，您都可以创建一个内存中的数据库，以确保测试没有任何副作用(比如更改磁盘上的数据库文件)。 Room还允许指定数据库实现，这样您就可以通过提供SupportSQLiteOpenHelper的JUnit实现来测试它。通常不建议采用这种方法，因为在设备上运行的SQLite版本可能与主机上的SQLite版本不同。 Webservice: 重要的是要使测试独立于外部世界，因此即使您的Webservice测试也应该避免对后端进行网络调用。有很多库可以帮助解决这个问题。例如，MockWebServer是一个很棒的库，它可以帮助您为测试创建一个假的本地服务器。 测试工件: 架构组件提供了一个maven工件来控制它的后台线程。在android.arch.core:core-testing工件，有两个JUnit规则: InstantTaskExecutorRule: 此规则可用于强制体系结构组件立即执行调用线程上的任何后台操作。 CountingTaskExecutorRule: 这个规则可以在instrumentation测试中使用，等待架构组件的后台操作，或者将它作为一个空闲的资源连接到Espresso。 最终的架构下图显示了我们推荐的体系结构中的所有模块以及它们之间的交互方式: 指导原则编程是一个有创意的领域，开发Android应用也不是一个例外。解决一个问题有很多方法，比如在多个activities或fragments之间通信数据，检索远程数据，并在本地进行脱机模式，或者其他一些常见的应用程序遇到的其他常见场景。 虽然下面的建议不是强制性的，但是根据我们的经验，从长远来看，遵循这些建议将使您的代码基础更加健壮、可测试和可维护。 在清单中定义的入口点 — activities、services、broadcast receivers等 — 不是数据的来源。相反，它们应该只协调与该入口点相关的数据子集。由于每个应用程序组件都很短，取决于用户与设备的交互以及运行时的整体健康状况，所以您不希望这些入口点成为数据的来源。 无情地在你的应用程序的不同模块之间创建明确的责任界限。例如，不要将代码从网络中跨多个类或包加载到您的代码库中。类似地，不要把不相关的职责——比如数据缓存和数据绑定——放到同一个类中。 尽可能少地暴露于每个模块。不要试图创建一个从一个模块中暴露内部实现细节的“只有那个”的快捷方式。你可能会在短期内获得一些时间，但随着代码库的不断发展，你将会花费很多时间来支付技术债务。 当您定义模块之间的交互时，请考虑如何使每个模块独立地进行测试。例如，有一个定义良好的API从网络中获取数据，这将使测试在本地数据库中持久存储数据的模块变得更加容易。相反，如果您将这两个模块的逻辑混合在一个地方，或者将您的网络代码洒在整个代码库中，那么要进行测试将会困难得多。 你的应用程序的核心是让它脱颖而出的原因。不要把时间花在重新发明轮子上，或者一次又一次地编写相同的样板代码。相反，把你的精力集中在让你的应用独一无二的东西上，让Android架构组件和其他推荐的库处理重复的样板文件。 保持尽可能多的相关和新鲜的数据，这样当设备处于脱机状态时，你的应用就可以使用了。虽然你可能喜欢持续的高速连接，但你的用户可能不会。 您的repository应该指定一个数据源作为事实的单一来源。当你的应用程序需要访问这段数据时，它应该总是来自于单一的真相来源。要了解更多信息，请参阅单一来源的真相。 附录:暴露网络状态在上面推荐应用架构章节中，我们故意省略了网络错误和加载状态，以保持示例的简单性。在本节中，我们将演示如何使用Resource类公开网络状态，以封装数据及其状态。 下面是一个示例实现: 1234567891011121314151617181920212223//描述具有状态的数据的泛型类public class Resource&lt;T&gt; &#123; @NonNull public final Status status; @Nullable public final T data; @Nullable public final String message; private Resource(@NonNull Status status, @Nullable T data, @Nullable String message) &#123; this.status = status; this.data = data; this.message = message; &#125; public static &lt;T&gt; Resource&lt;T&gt; success(@NonNull T data) &#123; return new Resource&lt;&gt;(SUCCESS, data, null); &#125; public static &lt;T&gt; Resource&lt;T&gt; error(String msg, @Nullable T data) &#123; return new Resource&lt;&gt;(ERROR, data, msg); &#125; public static &lt;T&gt; Resource&lt;T&gt; loading(@Nullable T data) &#123; return new Resource&lt;&gt;(LOADING, data, null); &#125;&#125; 因为从网络中加载数据是一个常见的用例，所以我们将创建一个助手类NetworkBoundResource，它可以在多个位置重用。下面是NetworkBoundResource的决策树: 它首先通过对resource的数据库进行观察。当第一次从数据库加载条目时，NetworkBoundResource会检查结果是否足够好，是否可以从网络中获取。请注意，这两种情况都可能同时发生，因为您可能想要在从网络中更新缓存数据同时显示缓存的数据 如果网络调用成功完成，它会将响应保存到数据库中，并重新初始化流。如果网络请求失败，我们将直接发送失败。 注意:在将新数据保存到磁盘之后，我们将从数据库重新初始化流，但是通常我们不需要这样做，因为数据库将会分派更改。另一方面，依赖于数据库来调度更改将依赖于不好的副作用，因为如果数据库能够避免在数据没有变化的情况下发送更改，则可能会中断。我们也不希望将来自网络的结果发送出去，因为这将与单一的真相来源相违背(也许数据库中有一些触发器将改变保存的值)。我们也不想在没有新数据的情况下分派SUCCESS，因为它会向客户发送错误的信息。 下面是NetworkBoundResource类为其孩子提供的公共API： 123456789101112131415161718192021222324252627// ResultType: Resource数据类型// RequestType: API response类型public abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; &#123; // 调用将API响应的结果保存到数据库中 @WorkerThread protected abstract void saveCallResult(@NonNull RequestType item); // 调用数据库中的数据来决定是否应该从网络中获取数据。 @MainThread protected abstract boolean shouldFetch(@Nullable ResultType data); // 调用从数据库中获取缓存的数据 @NonNull @MainThread protected abstract LiveData&lt;ResultType&gt; loadFromDb(); // 创建API调用. @NonNull @MainThread protected abstract LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; createCall(); // fetch失败时。子类可能希望重新设置诸如速率限制器之类的组件 @MainThread protected void onFetchFailed() &#123; &#125; // 返回一个代表resource的LiveData，在基类中实现 public final LiveData&lt;Resource&lt;ResultType&gt;&gt; getAsLiveData();&#125; 注意，上面的类定义了两个类型参数(ResultType，RequestType)，因为从API返回的数据类型可能与本地使用的数据类型不匹配。 还要注意，上面的代码使用了网络请求的ApiResponse。ApiResponse是一个围绕Retrofit2.Call类的简单包装器，用于将其响应转换为LiveData。 下面是NetworkBoundResource类的其余实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; &#123; private final MediatorLiveData&lt;Resource&lt;ResultType&gt;&gt; result = new MediatorLiveData&lt;&gt;(); @MainThread NetworkBoundResource() &#123; result.setValue(Resource.loading(null)); LiveData&lt;ResultType&gt; dbSource = loadFromDb(); result.addSource(dbSource, data -&gt; &#123; result.removeSource(dbSource); if (shouldFetch(data)) &#123; fetchFromNetwork(dbSource); &#125; else &#123; result.addSource(dbSource, newData -&gt; result.setValue(Resource.success(newData))); &#125; &#125;); &#125; private void fetchFromNetwork(final LiveData&lt;ResultType&gt; dbSource) &#123; LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; apiResponse = createCall(); // 我们将dbSource作为新的源重新连接, // 它将很快地发布最新的价值 result.addSource(dbSource, newData -&gt; result.setValue(Resource.loading(newData))); result.addSource(apiResponse, response -&gt; &#123; result.removeSource(apiResponse); result.removeSource(dbSource); //noinspection ConstantConditions if (response.isSuccessful()) &#123; saveResultAndReInit(response); &#125; else &#123; onFetchFailed(); result.addSource(dbSource, newData -&gt; result.setValue( Resource.error(response.errorMessage, newData))); &#125; &#125;); &#125; @MainThread private void saveResultAndReInit(ApiResponse&lt;RequestType&gt; response) &#123; new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... voids) &#123; saveCallResult(response.body); return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; // we specially request a new live data, // otherwise we will get immediately last cached value, // which may not be updated with latest results received from network. result.addSource(loadFromDb(), newData -&gt; result.setValue(Resource.success(newData))); &#125; &#125;.execute(); &#125; public final LiveData&lt;Resource&lt;ResultType&gt;&gt; getAsLiveData() &#123; return result; &#125;&#125; 现在，我们可以使用NetworkBoundResource来在存储库中编写磁盘和网络绑定用户实现。 12345678910111213141516171819202122232425262728class UserRepository &#123; Webservice webservice; UserDao userDao; public LiveData&lt;Resource&lt;User&gt;&gt; loadUser(final String userId) &#123; return new NetworkBoundResource&lt;User,User&gt;() &#123; @Override protected void saveCallResult(@NonNull User item) &#123; userDao.insert(item); &#125; @Override protected boolean shouldFetch(@Nullable User data) &#123; return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)); &#125; @NonNull @Override protected LiveData&lt;User&gt; loadFromDb() &#123; return userDao.load(userId); &#125; @NonNull @Override protected LiveData&lt;ApiResponse&lt;User&gt;&gt; createCall() &#123; return webservice.getUser(userId); &#125; &#125;.getAsLiveData(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"Android 架构组件简介","slug":"AndroidArchitectectureComponents","date":"2017-11-08T01:35:45.000Z","updated":"2020-07-25T02:57:18.147Z","comments":true,"path":"2017/11/08/AndroidArchitectectureComponents/","link":"","permalink":"https://jigangduan.github.io/2017/11/08/AndroidArchitectectureComponents/","excerpt":"","text":"一组帮助您设计健壮的、可测试的和可维护的应用程序库。管理UI组件生命周期和处理数据持久性。 应用架构指南 添加组件到你的项目 使用Lifecycle组件来处理生命周期 LiveData ViewModel 保存UI状态 Room持久性库 分页库 轻松管理app的生命周期新的lifecycle组件感知生命周期，可以帮助您管理您的活动和片段生命周期。保存配置更改，避免内存泄漏，并使用LiveData、ViewModel、LifecycleObserver和LifecycleOwner，轻松地将数据加载到UI中。 试一试codelab 查看文档 获得示例项目 Room:SQLite对象映射库使用Room 避免使用样板代码，并轻松地将SQLite表数据转换为Java对象。Room提供了SQLite语句的编译时间检查，并可以返回RxJava、Flowable和LiveData observables。 试一试codelab 查看文档 获得示例项目","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"}],"tags":[{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"}]},{"title":"使用协程的UI编程指南","slug":"GuideUIProgrammingCoroutines","date":"2017-11-06T11:08:01.000Z","updated":"2020-07-25T02:57:18.152Z","comments":true,"path":"2017/11/06/GuideUIProgrammingCoroutines/","link":"","permalink":"https://jigangduan.github.io/2017/11/06/GuideUIProgrammingCoroutines/","excerpt":"本指南假定读者熟悉基本的协程概念，并给出了在UI应用程序中如何使用kotlinx.coroutines的具体示例。 所有的UI应用程序库都有一个共同点。它们有一个线程，所有UI的状态都被限制，所有的UI更新都必须在这个特定的线程中发生。对于协程，这意味着您需要一个适当的协程分派器上下文，它将协程执行限制在这个UI线程中。 特别是，kotlinx.coroutines 有三个模块为不同的UI应用程序库提供了协程上下文: kotlinx-coroutines-android – Android应用程序的UI上下文 kotlinx-coroutines-javafx – JavaFx UI应用程序的JavaFx上下文 kotlinx-coroutines-swing – Swing UI应用程序的Swing上下文 这个指南同时涵盖了所有的UI库，因为每个模块只包含一个对象定义，而这个对象定义只有几页长。您可以使用它们中的任何一个作为示例，为您最喜欢的UI库编写相应的上下文对象，即使它没有包含在这个框中","text":"本指南假定读者熟悉基本的协程概念，并给出了在UI应用程序中如何使用kotlinx.coroutines的具体示例。 所有的UI应用程序库都有一个共同点。它们有一个线程，所有UI的状态都被限制，所有的UI更新都必须在这个特定的线程中发生。对于协程，这意味着您需要一个适当的协程分派器上下文，它将协程执行限制在这个UI线程中。 特别是，kotlinx.coroutines 有三个模块为不同的UI应用程序库提供了协程上下文: kotlinx-coroutines-android – Android应用程序的UI上下文 kotlinx-coroutines-javafx – JavaFx UI应用程序的JavaFx上下文 kotlinx-coroutines-swing – Swing UI应用程序的Swing上下文 这个指南同时涵盖了所有的UI库，因为每个模块只包含一个对象定义，而这个对象定义只有几页长。您可以使用它们中的任何一个作为示例，为您最喜欢的UI库编写相应的上下文对象，即使它没有包含在这个框中 目录 设置 JavaFx Android 基本的UI协程 启动UI协程 取消UI协程 在UI上下文中使用参与者 扩展协程 最多协程job 事件合并 阻塞操作 UI冻结的问题 阻塞操作 高级的主题 生命周期和协程父子层次结构 在没有分派的情况下，在UI事件处理程序中启动协程 设置本指南中的可运行示例是为JavaFx提供的。这样做的好处是，所有的示例都可以直接在任何OS上启动，而不需要模拟器或类似的操作，而且它们是完全自包含的(每个示例都在一个文件中)。对于需要在Android上进行复制(如果有的话)需要做什么改变，有一些单独的注释。 JavaFxJavaFx的基本示例应用程序包含一个窗口，其中包含一个名为hello的文本标签，它最初包含“hello World！”在右下角的字符串和一个粉红色的圆圈命名为fab(浮动操作按钮) JavaFX应用程序的start函数调用setup函数，将其引用传递给hello和fab节点。这就是在本指南的其他部分中放置各种代码的地方: 123fun setup(hello: Text, fab: Circle) &#123; // placeholder&#125; 你可以在这里得到完整的代码 您可以从GitHub上复制kotlinx.coroutines项目到您的工作站，并在IDE中打开项目。本指南的所有示例都在ui/kotlinx-coroutinjavafx-javafx模块的测试文件夹中。通过这种方式，您将能够运行并查看每个示例的工作方式，并通过进行更改来进行试验。 Android按照Android和Kotlin的入门指导，在Android Studio中创建Kotlin项目。您还可以在应用程序中添加Kotlin Android扩展。 在Android Studio 2.3中，你会得到一个与下图相似的应用程序: 转到应用程序的context_main.xml，并将“hello”的ID分配给text view，“hello World！”string，因此它可以在你的应用中作为hello，与Kotlin Android扩展一起使用。在创建的项目模板中，粉红色的浮动操作按钮已经被命名为fab。 在您的应用程序的MainActivity.kt中，删除了块fab.setOnClickListener { ... }，并将setup(hello，fab)调用添加为onCreate函数的最后一行。在文件的末尾创建一个占位符设置函数。这就是在本指南的其他部分中放置各种代码的地方: 123fun setup(hello: TextView, fab: FloatingActionButton) &#123; // placeholder&#125; 将对kotlinx-coroutines-android模块的依赖关系添加到app/build.gradle文件的dependencies { … } 部分: 1compile &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.19.3&quot; 协程是Kotlin的实验特征。您需要在Kotlin编译器中启用协程，将以下行添加到gradle.properties文件: 1kotlin.coroutines=enable 您可以从GitHub上克隆kotlinx.coroutines项目到您的工作站。Android的最终模板项目是在ui/kotlinx-coroutines-android/exam-app目录中。你可以在Android Studio中加载它，以遵循Android的这个指南。 基本的UI协程本节展示了在UI应用程序中使用协程的基本用法。 启动UI协程kotlinx-coroutines- JavaFx模块包含JavaFx上下文，它将协程执行分派给JavaFx应用程序线程。我们将其导入为UI，以使所有示例易于移植到Android: 1import kotlinx.coroutines.experimental.javafx.JavaFx as UI 被限制在UI线程的协程可以自由地在UI中更新任何东西，并在不阻塞UI线程的情况下挂起。例如，我们可以用命令式的方式编写动画。以下代码以每秒10到1秒的时间更新文本，使用launch 协程构建器: 123456789fun setup(hello: Text, fab: Circle) &#123; launch(UI) &#123; // launch coroutine in UI context for (i in 10 downTo 1) &#123; // countdown from 10 to 1 hello.text = \"Countdown $i ...\" // update text delay(500) // wait half a second &#125; hello.text = \"Done!\" &#125;&#125; 你可以在这里得到完整的代码 所以,这里发生了什么?因为我们在UI上下文中启动了协程，我们可以从这个协程中自由地更新UI，并调用延迟的函数，比如延迟。当延迟等待时，UI不会被冻结，因为它不会阻塞UI线程——它只是挂起了协程。 Android应用程序的相应代码是相同的。您只需要将setup函数的主体复制到Android项目的相应函数中。 取消UI协程我们可以对launch函数返回的Job对象进行引用，当我们想要停止时，可以使用它来取消协程。当点击桃色的圆圈时，让我们取消协程: 12345678910fun setup(hello: Text, fab: Circle) &#123; val job = launch(UI) &#123; // launch coroutine in UI context for (i in 10 downTo 1) &#123; // countdown from 10 to 1 hello.text = \"Countdown $i ...\" // update text delay(500) // wait half a second &#125; hello.text = \"Done!\" &#125; fab.onMouseClicked = EventHandler &#123; job.cancel() &#125; // cancel coroutine on click&#125; 你可以在这里得到完整的代码 现在，如果在倒计时还在运行的时候，圆圈被单击，倒计时就停止了。注意,Job.cancel是完全线程安全的和非阻塞的。它只是向协程发出信号，以取消它的工作，而不等待它真正终止。它可以从任何地方调用。在已经取消或已经完成的协程上调用它，什么也不做。 Android对应的线如下图所示: 1fab.setOnClickListener &#123; job.cancel() &#125; // 在点击取消协程 在UI上下文中使用参与者在本节中，我们将展示UI应用程序如何在其UI上下文中使用参与者(actors)，确保在启动的协程s的数量上没有无限制的增长。 扩展协程我们的目标是编写一个名为onClick的扩展协程构建器函数，这样每当单击时，我们就可以执行这个简单代码倒计时动画: 123456789fun setup(hello: Text, fab: Circle) &#123; fab.onClick &#123; // start coroutine when the circle is clicked for (i in 10 downTo 1) &#123; // countdown from 10 to 1 hello.text = \"Countdown $i ...\" // update text delay(500) // wait half a second &#125; hello.text = \"Done!\" &#125;&#125; onClick的第一个实现是在每个鼠标事件上启动一个新的协程，并将相应的鼠标事件传递给所提供的操作(以防我们需要它): 1234567fun Node.onClick(action: suspend (MouseEvent) -&gt; Unit) &#123; onMouseClicked = EventHandler &#123; event -&gt; launch(UI) &#123; action(event) &#125; &#125;&#125; 你可以在这里得到完整的代码 注意，每次单击圆圈时，它启动一个新的协程，它们都在竞争更新文本。试一试。看起来不太好。以后我们会修复它。 在Android上，可以为视图类编写相应的扩展，这样在上面所示的setup函数中的代码可以不用修改就可以使用。Android上没有MouseEvent，所以省略了。 1234567fun View.onClick(action: suspend () -&gt; Unit) &#123; setOnClickListener &#123; launch(UI) &#123; action() &#125; &#125;&#125; 最多协程job在开始新的Job之前，我们可以取消一份积极的Job，以确保在大多数情况下，协程正在对倒计时进行动画。然而，这通常不是最好的主意。cancel函数只是作为一个信号来中止一个协程。取消是合作的，而协程此时可能正在做一些不可撤销的事情，或者忽略了一个取消信号。更好的解决方案是使用参与者(actor)来执行不应该同时执行的任务。让我们改变onClick扩展实现: 12345678910fun Node.onClick(action: suspend (MouseEvent) -&gt; Unit) &#123; // launch one actor to handle all events on this node val eventActor = actor&lt;MouseEvent&gt;(UI) &#123; for (event in channel) action(event) // pass event to action &#125; // install a listener to offer events to this actor onMouseClicked = EventHandler &#123; event -&gt; eventActor.offer(event) &#125;&#125; 你可以在这里得到完整的代码 下面的关键思想是一个参与者(actor)协程和一个常规事件处理程序的集成，那就是在SendChannel上有一个不等待的offer函数。如果可能的话，它会立即向参与者(actor)发送一个元素，否则就会丢弃一个元素。一个offer实际上返回一个我们忽略的布尔结果。 在Android上，没有MouseEvent，所以我们只是将一个Unit发送给actor作为一个信号。视图类的相应扩展如下: 12345678910fun View.onClick(action: suspend () -&gt; Unit) &#123; // launch one actor val eventActor = actor&lt;Unit&gt;(UI) &#123; for (event in channel) action() &#125; // install a listener to activate this actor setOnClickListener &#123; eventActor.offer(Unit) &#125;&#125; 事件合并有时处理最近的事件更合适，而不是在我们忙于处理前一个事件时忽略事件。参与者协程构建器接受一个可选的容量参数，该参数控制该参与者在其邮箱中使用的通道的实现。在 Channel()工厂函数的文档中给出了所有可用选项的描述。 让我们修改代码以通过Channel.CONFLATED容量值来使用ConflatedChannel。这种变化只会产生一个参与者: 12345678910fun Node.onClick(action: suspend (MouseEvent) -&gt; Unit) &#123; // launch one actor to handle all events on this node val eventActor = actor&lt;MouseEvent&gt;(UI, capacity = Channel.CONFLATED) &#123; // &lt;--- Changed here for (event in channel) action(event) // pass event to action &#125; // install a listener to offer events to this actor onMouseClicked = EventHandler &#123; event -&gt; eventActor.offer(event) &#125;&#125; 您可以在这里得到完整的JavaFx代码。在Android上，你需要更新val eventActor =…从上一个例子中得到的行。 现在，如果在动画运行时单击圆，它将在结束后重新启动动画。只有一次。当动画运行时，重复的点击量会被合并，只有最近的事件才会被处理。 这也是UI应用程序需要的一种行为，这些应用程序必须根据最近收到的更新来更新它们的UI，从而对传入的高频事件流做出反应。使用ConflatedChannel的协程可以避免由于缓存事件而导致的延迟。 您可以在上面一行中进行capacity参数的实验，以了解它如何影响代码的行为。设置capacity = Channel.UNLIMITED创建一个与LinkedListChannel邮箱关联的协程，它可以缓冲所有事件。在这种情况下，动画会在单击圆圈时多次运行。 阻塞操作本节解释如何使用带有线程阻塞操作的UI协程。 UI冻结的问题如果所有的api都被写为挂起执行线程的函数，那就太好了。然而，事实并非如此。有时您需要进行cpu消耗计算，或者仅仅需要调用一些第三方api来访问网络，例如，这样可以阻止调用线程。您不能直接从UI线程或UI限制的协程完成，因为这会阻塞UI线程并导致UI的冻结。 下面的例子说明了这个问题。我们将使用onClick扩展和上一节中使用UI限制 事件合并 actor来处理UI线程中的最后一次点击。对于这个例子，我们将对斐波那契数进行简单的计算: 12fun fib(x: Int): Int = if (x &lt;= 1) 1 else fib(x - 1) + fib(x - 2) 每次点击圆圈时，我们都会计算更大的斐波那契数。为了使UI更加明显，还有一个快速计数动画，它总是在运行，并且不断地更新UI上下文中的文本: 1234567891011121314151617fun setup(hello: Text, fab: Circle) &#123; var result = \"none\" // the last result // counting animation launch(UI) &#123; var counter = 0 while (true) &#123; hello.text = \"$&#123;++counter&#125;: $result\" delay(100) // update the text every 100ms &#125; &#125; // compute the next fibonacci number of each click var x = 1 fab.onClick &#123; result = \"fib($x) = $&#123;fib(x)&#125;\" x++ &#125;&#125; 您可以在这里得到完整的JavaFx代码。你可以将fib函数和setup函数的主体复制到Android项目中。 试着在这个例子中点击圆圈。在大约30 - 40次点击之后，我们的天真计算将会变得非常缓慢，你会立刻看到UI线程是如何冻结的，因为动画在UI冻结期间停止运行。 阻塞操作在UI线程上的阻塞操作的修复非常简单，用协程。我们将把我们的“阻塞”fib函数转换为一个非阻塞的挂起函数，通过使用run函数将它的执行上下文更改到后台线程的CommonPool，从而在后台线程中运行计算。注意，fib函数现在被标记为suspend修饰符。它不会阻塞已被调用的协程，但在后台线程的计算工作时暂停执行。 123suspend fun fib(x: Int): Int = run(CommonPool) &#123; if (x &lt;= 1) 1 else fib(x - 1) + fib(x - 2)&#125; 你可以在这里得到完整的代码 您可以运行此代码，并验证UI不是冻结的，而大量的斐波那契数字正在计算中。然而，这段代码计算fib稍微慢一些，因为对fib的每次递归调用都经过了run。这在实践中并不是一个大问题，因为运行足够智能，可以检查协程已经在所需的上下文中运行，并且避免了将协程分派到另一个线程上的开销。尽管如此，它仍然是一个开销，在这个原始代码中可以看到，它只在调用之间增加了run的整数。对于一些更重要的代码，额外run调用的开销不会很大。 但是，这个特殊的fib实现可以像以前一样快速地运行，但是在后台线程中，通过将原来的fib函数重命名为fibBlocking，并在fibBlocking上定义fib和run包装: 123456suspend fun fib(x: Int): Int = run(CommonPool) &#123; fibBlocking(x)&#125;fun fibBlocking(x: Int): Int = if (x &lt;= 1) 1 else fibBlocking(x - 1) + fibBlocking(x - 2) 你可以在这里得到完整的代码 您现在可以在不阻塞UI线程的情况下享受全速天真的斐波那契运算。我们只需要运行(CommonPool)。 注意，由于fib函数是由代码中的单个参与者调用的，因此在任何给定的时间内都有一个并发计算，因此这段代码对资源的利用率有一个自然的限制。它可以在大多数CPU核心中饱和。 高级的主题本节介绍各种高级主题。 生命周期和协程父子层次结构一个典型的UI应用程序有许多具有生命周期的元素。Windows、UI控件、activities、views、fragments和其他可视化元素被创建和销毁。一个长时间运行的协程，执行一些IO或后台计算，可以保留对相应UI元素的引用，时间超过所需的时间，防止所有已被破坏且不再显示的UI对象树的垃圾回收。 这个问题的自然解决方案是将一个Job对象与每个具有生命周期的UI对象相关联，并在该Job的上下文中创建所有的协程。 例如，在Android应用程序中，一个Activity最初被创建，当它不再需要时被销毁，当它的内存必须被释放时被销毁。一个自然的解决方案是将Job的实例附加到Activity的实例上。我们可以通过定义以下JobHolder接口来创建一个小型框架: 123interface JobHolder &#123; val job: Job&#125; 现在，一个与job相关的activity需要实现这个JobHolder接口，并定义其onDestroy函数来取消对应的作业: 12345678910class MainActivity : AppCompatActivity(), JobHolder &#123; override val job: Job = Job() // 该活动的job实例 override fun onDestroy() &#123; super.onDestroy() job.cancel() // 当activity被破坏时取消job &#125; // the rest of code&#125; 我们还需要一个方便的方法来检索应用程序中的任何视图的Job。这很简单，因为一个Job是它的视图的一个Android上下文，所以我们可以定义如下的View.contextJob扩展属性: 12val View.contextJob: Job get() = (context as? JobHolder)?.job ?: NonCancellable 在这里，我们使用NonCancellable的Job实现作为一个空对象，因为我们的contextJob扩展属性是在没有附加Job的上下文中调用的。 有一个可以使用的contextJob的便利是，我们可以简单地使用它来启动所有的协程，而不用担心显式地维护我们已经开始的协程的列表。所有的生命周期管理将由Job之间的亲子关系的机制来处理。 例如，上一节的View.onClick扩展现在可以使用contextJob来定义: 12345678910fun View.onClick(action: suspend () -&gt; Unit) &#123; // launch one actor as a parent of the context job val eventActor = actor&lt;Unit&gt;(contextJob + UI, capacity = Channel.CONFLATED) &#123; for (event in channel) action() &#125; // install a listener to activate this actor setOnClickListener &#123; eventActor.offer(Unit) &#125;&#125; 注意，在上面的代码中如何使用contextJob + UI表达式来启动一个参与者。它为我们的新参与者定义了一个协程上下文，包括job和UI分派器。由这个actor(contextJob + UI)表达式启动的协程将会成为相应上下文作业的一个孩子。当活动被破坏，它的工作被取消时，所有的孩子都被取消了。 jobs之间的父子关系形成了一个层次结构。代表视图和在其上下文中执行某些后台Job的协程可以创建更多的子节点。当父job被取消时，整棵树都被取消了。其中一个例子是在《协程指南》的“子协程”部分。 在没有分派的情况下，在UI事件处理程序中启动协程让我们在设置中编写下面的代码，以可视化从UI线程启动协程时执行的顺序: 1234567891011fun setup(hello: Text, fab: Circle) &#123; fab.onMouseClicked = EventHandler &#123; println(\"Before launch\") launch(UI) &#123; println(\"Inside coroutine\") delay(100) println(\"After delay\") &#125; println(\"After launch\") &#125;&#125; 你可以在这里得到完整的代码 当我们启动这段代码并点击一个粉红色的圆圈时，以下消息被打印到控制台: 1234Before launchAfter launchInside coroutineAfter delay 您可以看到，launch之后立即执行，而coroutine则被发布到UI线程上，以便稍后执行。kotlinx.coroutines的所有UI调度程序都是这样实现的。为什么如此? 基本上，这里的选择是“js风格”的异步方法(异步操作总是延迟到稍后在调度线程中执行)和“c#风格”的方法(在invoker线程中执行异步操作，直到第一个挂起点)。c#方法似乎更有效率,它最终建议像“使用收益率如果需要….”。这是容易出错的。js风格的方法更一致，不需要程序员考虑是否需要让步。 然而，在这个特殊的情况下，当协程从一个事件处理程序开始，并且没有其他的代码时，这个额外的分派确实增加了额外的开销而不带来任何额外的值。在这种情况下，可以使用一个可选的CoroutineStart参数启动，async和actor协程构建器可以用于性能优化。将其设置为CoroutineStart.UNDISPATCHED的值，将立即开始执行协程，直到其第一个挂起点，如下示例所示: 1234567891011fun setup(hello: Text, fab: Circle) &#123; fab.onMouseClicked = EventHandler &#123; println(\"Before launch\") launch(UI, CoroutineStart.UNDISPATCHED) &#123; // &lt;--- Notice this change println(\"Inside coroutine\") delay(100) // &lt;--- And this is where coroutine suspends println(\"After delay\") &#125; println(\"After launch\") &#125;&#125; 你可以在这里得到完整的代码 当我们启动这段代码并点击一个粉红色的圆圈时，以下消息被打印到控制台: 1234Before launchInside coroutineAfter launchAfter delay","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"},{"name":"kotlinx.coroutines","slug":"kotlinx-coroutines","permalink":"https://jigangduan.github.io/tags/kotlinx-coroutines/"}]},{"title":"kotlinx.coroutines入门指南示例","slug":"GuideToKotlinxCoroutinesByExample","date":"2017-11-06T11:01:27.000Z","updated":"2020-07-25T02:57:18.152Z","comments":true,"path":"2017/11/06/GuideToKotlinxCoroutinesByExample/","link":"","permalink":"https://jigangduan.github.io/2017/11/06/GuideToKotlinxCoroutinesByExample/","excerpt":"这是一个关于kotlinx.coroutines核心特性的简短指南，有一系列的例子。 介绍和设置作为一种语言，Kotlin在其标准库中只提供了最低限度的低级api，以使各种其他库能够利用这些库。与其他具有类似功能的语言不同，async和await在Kotlin中不是关键字，甚至都不是它的标准库的一部分。 kotlinx.coroutines是一个如此丰富的库。它包含了许多高级的可支持内核的原语，包括async和await。您需要添加对kotlinx-coroutines-core模块的依赖，这是在您的项目中使用本指南中的基础。 目录 协程基础 你的第一个协程 桥接阻塞和非阻塞的世界 等待job 提取函数重构 协程是轻量级的 协程就像守护线程 取消和超时 取消协程执行 取消是需要协作的 使计算代码可取消 在finally关闭资源 运行不可取消块 超时 组织挂起函数 默认顺序 使用async并发 懒启动async 异步式函数 协程context和分派器 分派器和线程 非限制 vs 限制 分派器 调试协程和线程 线程之间跳转 context中的job 子协程 结合contexts 父协程责任 命名协程的调试 取消显式工作 通道 通道基础知识 通道的关闭和迭代 构建通道生成器 管道 用管道求素数 扇出 扇入 缓冲通道 通道是公平的 共享的可变状态和并发性 这个问题 Volatiles毫无用处 线程安全的数据结构 细粒度线程约束 粗粒度线程约束 Mutex 参与者 Select表达式 选择通道 关闭时的select 选择发送 选择deferred值 切换到deferred值的通道 进一步的阅读","text":"这是一个关于kotlinx.coroutines核心特性的简短指南，有一系列的例子。 介绍和设置作为一种语言，Kotlin在其标准库中只提供了最低限度的低级api，以使各种其他库能够利用这些库。与其他具有类似功能的语言不同，async和await在Kotlin中不是关键字，甚至都不是它的标准库的一部分。 kotlinx.coroutines是一个如此丰富的库。它包含了许多高级的可支持内核的原语，包括async和await。您需要添加对kotlinx-coroutines-core模块的依赖，这是在您的项目中使用本指南中的基础。 目录 协程基础 你的第一个协程 桥接阻塞和非阻塞的世界 等待job 提取函数重构 协程是轻量级的 协程就像守护线程 取消和超时 取消协程执行 取消是需要协作的 使计算代码可取消 在finally关闭资源 运行不可取消块 超时 组织挂起函数 默认顺序 使用async并发 懒启动async 异步式函数 协程context和分派器 分派器和线程 非限制 vs 限制 分派器 调试协程和线程 线程之间跳转 context中的job 子协程 结合contexts 父协程责任 命名协程的调试 取消显式工作 通道 通道基础知识 通道的关闭和迭代 构建通道生成器 管道 用管道求素数 扇出 扇入 缓冲通道 通道是公平的 共享的可变状态和并发性 这个问题 Volatiles毫无用处 线程安全的数据结构 细粒度线程约束 粗粒度线程约束 Mutex 参与者 Select表达式 选择通道 关闭时的select 选择发送 选择deferred值 切换到deferred值的通道 进一步的阅读 协程基础本节介绍基本的协程概念。 你的第一个协程运行下面的代码: 12345678fun main(args: Array&lt;String&gt;) &#123; launch &#123; // 启动新协程 delay(1000L) // 非阻塞延迟1秒 (默认时间单位是ms) println(\"World!\") // 打印在延迟后 &#125; println(\"Hello,\") // 主函数继续，而协程延迟 Thread.sleep(2000L) // 阻塞主线程2秒，以保持JVM的生命&#125; 你可以在这里得到完整的代码 运行这段代码: 12Hello,World! 本质上，协程是轻量的线程。它们是由launch 协程构建器启动的。你可以用同样的结果取代launch { ... }，用thread { ... } 和delay(…)，用Thread.sleep(…)。试一试。 如果您开始用thread替换launch，编译器会产生以下错误: 1错误:Kotlin:挂起函数只允许从一个协程或另一个挂起函数调用 这是因为delay是一种特殊的挂起函数，它不会阻塞线程，而是挂起了协程，它只能在一个协程中使用。 桥接阻塞和非阻塞的世界第一个例子混合了非阻塞delay(...)和阻塞Thread.sleep(...)在相同的mian代码中。很容易迷路。让我们通过使用runBlocking来清楚地分离阻塞和非阻塞的世界。 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; // 开始主协程 launch &#123; // 启动新协程 delay(1000L) println(\"World!\") &#125; println(\"Hello,\") // 当孩子被延迟时，主协程仍在继续 delay(2000L) // 非阻塞延迟2秒使JVM存活&#125; 你可以在这里得到完整的代码 结果是一样的，但是这段代码只使用非阻塞的delay。 runBlocking { ... } 作为一个适配器，在这里使用它来启动顶级的主协程。runBlocking块之外的常规代码,直到runBlocking内部的协程活跃。 这也是为挂起函数编写单元测试的一种方法: 123456class MyTest &#123; @Test fun testMySuspendingFunction() = runBlocking&lt;Unit&gt; &#123; // 这里我们可以使用任何我们喜欢的断言样式来使用挂起函数 &#125;&#125; 等待job拖延一段时间，而另一种协程正在工作，这不是一种好方法。让我们明确地等待(以非阻塞方式)直到我们启动的后台任务完成: 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; // 启动新的协程，并保持job的引用 delay(1000L) println(\"World!\") &#125; println(\"Hello,\") job.join() // 等到孩子协程完成&#125; 你可以在这里得到完整的代码 现在的结果仍然是相同的，但是主协程的代码并没有以任何方式与后台作业的持续时间相关联。好多了。 提取函数重构让我们在launch { ... } 中提取代码块到一个单独的函数。当您在这段代码中执行”Extract function”重构时，您将得到一个带有suspend修饰符的新函数。这是你的第一个挂起函数。挂起函数可以像普通函数一样在内部使用，但是它们的附加功能是，它们可以使用其他的挂起函数，比如这个例子中的delay，挂起执行的协程。 1234567891011fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; doWorld() &#125; println(\"Hello,\") job.join()&#125;// 这是你的第一个挂起函数suspend fun doWorld() &#123; delay(1000L) println(\"World!\")&#125; 你可以在这里得到完整的代码 协程是轻量级的运行下面的代码: 123456789fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val jobs = List(100_000) &#123; // 启动大量的协程和他们的jobs列表 launch &#123; delay(1000L) print(\".\") &#125; &#125; jobs.forEach &#123; it.join() &#125; // 等待所有的jobs完成&#125; 你可以在这里得到完整的代码 它启动了100K的协程，一秒钟之后，每一个协程就会打印一个点。现在，用线程来试一下。将会发生什么?(很可能你的代码会产生某种内存溢出错误) 协程就像守护线程下面的代码启动了一个长时间运行的协程，它每秒打印两次”I’m sleeping”，然后在一些delay之后返回main函数: 123456789fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; launch &#123; repeat(1000) &#123; i -&gt; println(\"I'm sleeping $i ...\") delay(500L) &#125; &#125; delay(1300L) // 在延迟之后退出&#125; 您可以运行并看到它打印了三行并终止: 123I&apos;m sleeping 0 ...I&apos;m sleeping 1 ...I&apos;m sleeping 2 ... 活跃的协程并不能使整个过程保持活跃。它们就像守护进程线程。 取消和超时本节介绍协程取消和超时。 取消协程执行在小应用程序中，”main”方法的返回听起来似乎是一个好主意，可以让所有的协程隐式终止。在一个较大的、长期运行的应用程序中，您需要更细粒度的控制。launch函数返回一个可以用来取消运行的协程的Job: 12345678910111213fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; repeat(1000) &#123; i -&gt; println(\"I'm sleeping $i ...\") delay(500L) &#125; &#125; delay(1300L) // 延迟一点 println(\"main: I'm tired of waiting!\") job.cancel() // 取消job job.join() // 等待job的完成 println(\"main: Now I can quit.\")&#125; 你可以在这里得到完整的代码 它产生以下输出: 12345678910111213141516171819202122232425262728293031323334353637I&apos;m sleeping 0 ...I&apos;m sleeping 1 ...I&apos;m sleeping 2 ...main: I&apos;m tired of waiting!main: Now I can quit.``` 只要main调用了`job.cancel`，我们看不到其他协程的输出，因为它被取消了。还有一个[Job](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html)扩展函数[cancelAndJoin](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/cancel-and-join.html)，它结合了[cancel](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/cancel.html)和[join](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/join.html)调用。### &lt;a name=&quot;cancellation_cooperative&quot;&gt;&lt;/a&gt;取消是需要协作的协程取消是需要协作的。一个取消的代码必须进行协作。所有的挂起函数在`kotlinx.coroutines`都是可取消的。他们检测协程的取消，取消时抛出[CancellationException](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception.html)。但是，如果一个协程正在计算并且没有检查取消，那么它就不能被取消，就像下面的例子所示:```kotlinfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val startTime = System.currentTimeMillis() val job = launch &#123; var nextPrintTime = startTime var i = 0 while (i &lt; 5) &#123; // 循环计算，只是浪费CPU // 每秒打印消息两次 if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;) nextPrintTime += 500L &#125; &#125; &#125; delay(1300L) // 延迟一点 println(&quot;main: I&apos;m tired of waiting!&quot;) job.cancelAndJoin() // 取消job并等待其完成 println(&quot;main: Now I can quit.&quot;)&#125; 你可以在这里得到完整的代码 运行它，看它会继续打印”I’m sleeping”，即使是在取消之后，直到工作完成了五个迭代之后。 使计算代码可取消有两种方法可以使计算代码可以被取消。第一个是周期性地调用一个挂起函数来检查取消。yield函数是这个目的的一个很好的选择。另一个是显式地检查取消状态。让我们来试试后面的方法。 在前面的例子中用while (isActive)替换while (i &lt; 5)并重新运行它。 123456789101112131415161718fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val startTime = System.currentTimeMillis() val job = launch &#123; var nextPrintTime = startTime var i = 0 while (isActive) &#123; // 可取消的计算循环 // 每秒打印消息两次 if (System.currentTimeMillis() &gt;= nextPrintTime) &#123; println(\"I'm sleeping $&#123;i++&#125; ...\") nextPrintTime += 500L &#125; &#125; &#125; delay(1300L) // 延迟一点 println(\"main: I'm tired of waiting!\") job.cancelAndJoin() // 取消job并等待其完成 println(\"main: Now I can quit.\")&#125; 你可以在这里得到完整的代码 可以看到，现在这个循环被取消了。isActive是通过CoroutineScope对象在协程代码中可用的属性。 在finally关闭资源可取消的挂起函数在协程中抛出CancellationException的地方可以用通常的方式来处理。例如,try {...} finally {…} 表达式和Kotlin use函数执行它们的终结动作，当协程被取消时： 12345678910111213141516fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; try &#123; repeat(1000) &#123; i -&gt; println(\"I'm sleeping $i ...\") delay(500L) &#125; &#125; finally &#123; println(\"I'm running finally\") &#125; &#125; delay(1300L) // 延迟一点 println(\"main: I'm tired of waiting!\") job.cancelAndJoin() // 取消job并等待其完成 println(\"main: Now I can quit.\")&#125; 你可以在这里得到完整的代码 join和cancelAndJoin等待所有的终结操作完成，因此上面的示例产生以下输出: 123456I&apos;m sleeping 0 ...I&apos;m sleeping 1 ...I&apos;m sleeping 2 ...main: I&apos;m tired of waiting!I&apos;m running finallymain: Now I can quit. 运行不可取消块在前一个示例的finally块中使用挂起函数的任何尝试都会导致CancellationException，因为运行该代码的协程被取消了。通常，这不是问题，因为所有行为良好的关闭操作(关闭文件、取消job或关闭任何通信通道)通常是非阻塞的，并且不涉及任何挂起函数。然而，在极少数情况下，当您需要在被取消的协程 挂起时，您可以将相应的代码打包在run(NonCancellable) {...}使用run函数和NonCancellable context，如下面的示例所示: 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; try &#123; repeat(1000) &#123; i -&gt; println(\"I'm sleeping $i ...\") delay(500L) &#125; &#125; finally &#123; run(NonCancellable) &#123; println(\"I'm running finally\") delay(1000L) println(\"And I've just delayed for 1 sec because I'm non-cancellable\") &#125; &#125; &#125; delay(1300L) // 延迟一点 println(\"main: I'm tired of waiting!\") job.cancelAndJoin() // 取消job并等待其完成 println(\"main: Now I can quit.\")&#125; 你可以在这里得到完整的代码 超时在实践中取消协程执行的最明显的原因是它的执行时间超过了一些超时。虽然您可以手动跟踪对应Job的引用，并启动一个单独的协程，以便在延迟之后取消跟踪，但是可以使用withTimeout函数来执行它。请看下面的例子: 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; withTimeout(1300L) &#123; repeat(1000) &#123; i -&gt; println(\"I'm sleeping $i ...\") delay(500L) &#125; &#125;&#125; 你可以在这里得到完整的代码 它产生以下输出: 1234I&apos;m sleeping 0 ...I&apos;m sleeping 1 ...I&apos;m sleeping 2 ...Exception in thread &quot;main&quot; kotlinx.coroutines.experimental.TimeoutCancellationException: Timed out waiting for 1300 MILLISECONDS withTimeout抛出的TimeoutCancellationException是CancellationException的子类。我们还没有看到它的堆栈跟踪在控制台上打印出来。这是因为在被取消的协程里CancellationException被认为是一个正常的原因。但是，在本例中，我们在main函数中使用了withTimeout。 因为取消只是一个异常，所有的资源都将以通常的方式关闭。如果你需要在任何类型的超时上做一些额外的动作,您可以在try {...} catch (e: TimeoutCancellationException) {...}块中使用超时来包装代码,者使用类似于withTimeout的withTimeoutOrNull函数，但在超时时它返回null，而不是抛出异常： 12345678910fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val result = withTimeoutOrNull(1300L) &#123; repeat(1000) &#123; i -&gt; println(\"I'm sleeping $i ...\") delay(500L) &#125; \"Done\" // will get cancelled before it produces this result &#125; println(\"Result is $result\")&#125; 你可以在这里得到完整的代码 运行这段代码时不再出现异常: 1234I&apos;m sleeping 0 ...I&apos;m sleeping 1 ...I&apos;m sleeping 2 ...Result is null 组成挂起函数这一节介绍了各种挂起函数的组成。 默认顺序假设我们在其他地方定义了两个挂起的函数，它们做一些有用的事情，比如远程服务调用或计算。我们只是假装它们很有用，但实际上每一个都只是为了这个例子的目的延迟了一秒钟： 123456789suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // 假装我们在做一些有用的事情 return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // 假装我们在做一些有用的事情 return 29&#125; 如果需要按顺序调用它们，我们需要做什么?首先是doSomethingUsefulOne，然后是doSomethingUsefulTwo，然后计算它们的结果的总和?在实践中，我们就会这样做，我们使用第一个函数的结果来决定是否需要调用第二个函数，或者决定如何调用它。 我们只是使用常规的顺序调用，因为在协程中的代码，就像常规代码一样，是默认的顺序。下面的例子通过测量执行两个挂起函数的总时间来演示它: 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = doSomethingUsefulOne() val two = doSomethingUsefulTwo() println(\"The answer is $&#123;one + two&#125;\") &#125; println(\"Completed in $time ms\")&#125; 你可以在这里得到完整的代码 它产生了这样的东西: 12The answer is 42Completed in 2017 ms 使用async并发如果在调用doSomethingUsefulOne和doSomethingUsefulTwo之间没有依赖关系，并且我们希望通过同时执行这两种方法来获得更快的答案?这就是async提供帮助的地方。 在概念上，async就像launch一样。它启动了一个单独的协程，它是一个轻量的线程，它可以和所有其他的协同工作。不同的是，launch返回一个Job，并且不带任何结果值，而async返回一个Deferred——一个轻量级的非阻塞future，它代表了稍后提供一个结果的承诺。您可以使用.await()在一个deferred值上获得它的最终结果，但是Deferred也是一项Job，所以您可以在需要的时候取消它。 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = async &#123; doSomethingUsefulOne() &#125; val two = async &#123; doSomethingUsefulTwo() &#125; println(\"The answer is $&#123;one.await() + two.await()&#125;\") &#125; println(\"Completed in $time ms\")&#125; 你可以在这里得到完整的代码 它产生了这样的东西: 12The answer is 42Completed in 1017 ms 速度是两倍，因为我们同时执行了两个协程。注意，与协程的并发性总是很明显的。 懒启动async使用一个具有CoroutineStart.LAZY值的可选start参数，可以使用惰性选项来使用async。只有当某个await或某个start函数被调用时，它才会启动它的协程。运行以下示例与之前的示例不同，仅通过此选项: 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125; val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125; println(\"The answer is $&#123;one.await() + two.await()&#125;\") &#125; println(\"Completed in $time ms\")&#125; 你可以在这里得到完整的代码 它产生了这样的东西: 12The answer is 42Completed in 2017 ms 因此，我们回到了顺序执行，因为我们首先start和await one，然后是two。它不是用于懒惰目的的用例。当计算值涉及到挂起函数时，它被设计为替代标准的惰性函数。 异步式函数我们可以定义异步式的函数，使用async协程构建器来异步调用doSomethingUsefulOne和doSomethingUsefulTwo。用”async”前缀来命名这样的函数是一种很好的方式，以强调它们只启动异步计算，并且需要使用产生的延迟值来获得结果。 123456789// asyncSomethingUsefulOne的结果类型是Deferred&lt;Int&gt;fun asyncSomethingUsefulOne() = async &#123; doSomethingUsefulOne()&#125;// asyncSomethingUsefulTwo的结果类型是Deferred&lt;Int&gt;fun asyncSomethingUsefulTwo() = async &#123; doSomethingUsefulTwo()&#125; 注意，这些asyncXXX函数不是挂起函数。它们可以在任何地方使用。然而，它们的使用总是意味着对调用代码的异步(这里即并发)执行。 下面的例子展示了他们在协程外的使用: 1234567891011121314// 注意，在本例中，我们没有将`runBlocking`放在`main`的右边fun main(args: Array&lt;String&gt;) &#123; val time = measureTimeMillis &#123; // 我们可以在协程外启动异步操作 val one = asyncSomethingUsefulOne() val two = asyncSomethingUsefulTwo() // 但是等待结果必须包括挂起或阻塞. // 这里我们在主线程使用`runBlocking &#123; ... &#125;`块等待结果 runBlocking &#123; println(\"The answer is $&#123;one.await() + two.await()&#125;\") &#125; &#125; println(\"Completed in $time ms\")&#125; 你可以在这里得到完整的代码 协程context和分派器协程总是在某些context中执行，这些context由CoroutineContext类型的值来表示，这是在Kotlin标准库中定义的。 协程context是一组不同的元素。主要的元素是我们之前见过的协程的Job，以及它的分派器，它在这一节中介绍。 分派器和线程协程context包括一个协程分派器(请参阅CoroutineDispatcher)，它决定了相应的协程执行的线程或线程的使用情况。协程分派器可以将协程执行限制在特定的线程中，将其分派到线程池中，或者让它不受限制地运行。 像launch和async这样的构建器都可以接受一个可选的CoroutineContext参数，该参数可用于显式地为新的协程和其他context元素指定分派器。 试试下面的例子: 12345678910111213141516fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val jobs = arrayListOf&lt;Job&gt;() jobs += launch(Unconfined) &#123; // 不受限制——将工作在主线程 println(\" 'Unconfined': I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; jobs += launch(coroutineContext) &#123; // 父ccontext，runBlocking 协程 println(\"'coroutineContext': I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; jobs += launch(CommonPool) &#123; // 将被分派到ForkJoinPool.commonPool(或同等的) println(\" 'CommonPool': I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; jobs += launch(newSingleThreadContext(\"MyOwnThread\")) &#123; // 将得到它自己的新线程 println(\" 'newSTC': I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; jobs.forEach &#123; it.join() &#125;&#125; 你可以在这里得到完整的代码 它产生以下输出(可能顺序不同): 1234 &apos;Unconfined&apos;: I&apos;m working in thread main &apos;CommonPool&apos;: I&apos;m working in thread ForkJoinPool.commonPool-worker-1 &apos;newSTC&apos;: I&apos;m working in thread MyOwnThread&apos;coroutineContext&apos;: I&apos;m working in thread main 我们在前面的部分中使用的缺省分派器是DefaultDispatcher，它等于当前实现中的CommonPool。因此，launch { ... } 与launch(DefaultDispather) { ... }相同，与launch(CommonPool) { ... }相同。 稍后将显示coroutineContext父类与非约束context之间的区别 注意，newSingleThreadContext创建了一个新的线程，这是一个非常昂贵的资源。在实际应用程序中，它必须在不再需要时释放，使用close函数，或者存储在顶级变量中，并在整个应用程序中重用。 非限制 vs 限制 分派器非限制(Unconfined)的协程分派器在调用者线程中启动了协程，但直到第一个挂起点才开始。挂起之后，它在被调用的挂起函数完全确定的线程中恢复。当协程不消耗CPU时间或更新任何限制在特定线程的共享数据(如UI)时，非限制分派器是合适的。 另一方面，可以通过CoroutineScope接口在任何协程的块中使用的coroutineContext属性，是对这个特定的协程的context的引用。通过这种方式，可以继承父context。特别是，runBlocking 协程的缺省调度程序被限制在调用程序线程中，因此继承它的作用是将执行限制在这个线程中，并具有可预测的FIFO调度。 1234567891011121314fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val jobs = arrayListOf&lt;Job&gt;() jobs += launch(Unconfined) &#123; // 不受限制——主要线程的工作 println(\" 'Unconfined': I'm working in thread $&#123;Thread.currentThread().name&#125;\") delay(500) println(\" 'Unconfined': After delay in thread $&#123;Thread.currentThread().name&#125;\") &#125; jobs += launch(coroutineContext) &#123; // 父ccontext，runBlocking 协程 println(\"'coroutineContext': I'm working in thread $&#123;Thread.currentThread().name&#125;\") delay(1000) println(\"'coroutineContext': After delay in thread $&#123;Thread.currentThread().name&#125;\") &#125; jobs.forEach &#123; it.join() &#125;&#125; 你可以在这里得到完整的代码 它产生以下输出(可能顺序不同): 1234 &apos;Unconfined&apos;: I&apos;m working in thread main&apos;coroutineContext&apos;: I&apos;m working in thread main &apos;Unconfined&apos;: After delay in thread kotlinx.coroutines.DefaultExecutor&apos;coroutineContext&apos;: After delay in thread main 因此，继承了runBlocking {…} 协程的coroutineContext 继续在主线程中执行，而未限制的线程则在默认的执行程序线程中恢复，而delay函数正在使用该线程。 调试协程和线程协程可以在一个线程上挂起，并在另一个线程上使用非限制(Unconfined)分派器或默认的多线程分派器。即使是单线程的分派器，也很难弄清楚协程在做什么，在什么地方，什么时候做什么。使用线程调试应用程序的常用方法是在每个日志语句的日志文件中打印线程名。这个特性得到了日志框架的广泛支持。在使用协程时，线程名称本身并没有提供太多context，所以kotlinx.coroutines包括调试工具，使其更容易。 运行下面的代码使用-Dkotlinx.coroutines.debug JVM选项: 12345678910111213fun log(msg: String) = println(\"[$&#123;Thread.currentThread().name&#125;] $msg\")fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val a = async(coroutineContext) &#123; log(\"I'm computing a piece of the answer\") 6 &#125; val b = async(coroutineContext) &#123; log(\"I'm computing another piece of the answer\") 7 &#125; log(\"The answer is $&#123;a.await() * b.await()&#125;\")&#125; 你可以在这里得到完整的代码 有三个协程。主要的协程(#1)—— 一个runBlocking，和两个协程计算deferred值a(#2)和b(#3)。它们都是在runBlocking上下文中执行的，并且仅限于主线程。这段代码的输出是: 123[main @coroutine#2] I&apos;m computing a piece of the answer[main @coroutine#3] I&apos;m computing another piece of the answer[main @coroutine#1] The answer is 42 日志函数在方括号中打印出线程的名称，您可以看到，它是主线程，但是当前执行的协程的标识符被附加。当打开调试模式时，这个标识符被连续地分配给所有创建的协程。 您可以在newCoroutineContext函数的文档中阅读更多关于调试工具的信息。 线程之间跳转运行下面的代码使用-Dkotlinx.coroutines.debug JVM选项: 123456789101112131415fun log(msg: String) = println(\"[$&#123;Thread.currentThread().name&#125;] $msg\")fun main(args: Array&lt;String&gt;) &#123; newSingleThreadContext(\"Ctx1\").use &#123; ctx1 -&gt; newSingleThreadContext(\"Ctx2\").use &#123; ctx2 -&gt; runBlocking(ctx1) &#123; log(\"Started in ctx1\") run(ctx2) &#123; log(\"Working in ctx2\") &#125; log(\"Back to ctx1\") &#125; &#125; &#125;&#125; 你可以在这里得到完整的代码 它演示了几种新技术。一个是使用runBlocking和一个显式指定的context，另一个是使用run函数来更改一个协程的上下文，同时仍然保持在相同的协程中，如下所示: 123[Ctx1 @coroutine#1] Started in ctx1[Ctx2 @coroutine#1] Working in ctx2[Ctx1 @coroutine#1] Back to ctx1 注意，这个例子也使用了来自Kotlin标准库的use函数来释放那些在不需要时创建的线程，这些线程是用newSingleThreadContext创建的。 context中的job协程的Job是其context的一部分。协程可以使用coroutineContext[Job]表达式从自己的context中检索它： 123fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; println(\"My job is $&#123;coroutineContext[Job]&#125;\")&#125; 你可以在这里得到完整的代码 当在调试模式下运行时，它会产生这样的东西: 1My job is &quot;coroutine#1&quot;:BlockingCoroutine&#123;Active&#125;@6d311334 因此，在CoroutineScope中，isActive是coroutineContext[Job]的一个便捷的快捷方式!! 子协程当一个协程的coroutineContext被用来launch另一个协程时，新的协程job就变成了父母的子Job。当父协程被取消时，所有的子协程也会被递归地取消。 123456789101112131415161718192021222324fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; // launch a coroutine to process some kind of incoming request val request = launch &#123; // it spawns two other jobs, one with its separate context val job1 = launch &#123; println(\"job1: I have my own context and execute independently!\") delay(1000) println(\"job1: I am not affected by cancellation of the request\") &#125; // and the other inherits the parent context val job2 = launch(coroutineContext) &#123; println(\"job2: I am a child of the request coroutine\") delay(1000) println(\"job2: I will not execute this line if my parent request is cancelled\") &#125; // request completes when both its sub-jobs complete: job1.join() job2.join() &#125; delay(500) request.cancel() // cancel processing of the request delay(1000) // delay a second to see what happens println(\"main: Who has survived request cancellation?\")&#125; 你可以在这里得到完整的代码 这段代码的输出是: 1234567891011121314151617181920212223242526272829job1: I have my own context and execute independently!job2: I am a child of the request coroutinejob1: I am not affected by cancellation of the requestmain: Who has survived request cancellation?``` ### &lt;a name=&quot;combining_contexts&quot;&gt;&lt;/a&gt;组合contexts使用`+`操作符可以组合使用协程contexts。右边的contexts替换了左边的contexts的相关条目。例如，父Job可以被继承，而它的分派器替换了:```kotlinfun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; // 启动一个协程来处理某种类型的传入请求 val request = launch(coroutineContext) &#123; // 使用`runBlocking`context // 在CommonPool中生成cpu密集型的子job !!! val job = launch(coroutineContext + CommonPool) &#123; println(&quot;job: I am a child of the request coroutine, but with a different dispatcher&quot;) delay(1000) println(&quot;job: I will not execute this line if my parent request is cancelled&quot;) &#125; job.join() // 当它的子job完成时，请求就完成了 &#125; delay(500) request.cancel() // 取消对请求的处理 delay(1000) // 延迟一秒看看会发生什么 println(&quot;main: Who has survived request cancellation?&quot;)&#125; 你可以在这里得到完整的代码 这段代码的预期结果是: 12job: I am a child of the request coroutine, but with a different dispatchermain: Who has survived request cancellation? 父协程责任一个父协程总是等待所有孩子的完成。父协程不必显式地跟踪它启动的所有子节点，它也不必使用Job.join在最后等待它们: 1234567891011121314fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; // launch a coroutine to process some kind of incoming request val request = launch &#123; repeat(3) &#123; i -&gt; // launch a few children jobs launch(coroutineContext) &#123; delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms println(\"Coroutine $i is done\") &#125; &#125; println(\"request: I'm done and I don't explicitly join my children that are still active\") &#125; request.join() // wait for completion of the request, including all its children println(\"Now processing of the request is complete\")&#125; 你可以在这里得到完整的代码 结果将是: 12345request: I&apos;m done and I don&apos;t explicitly join my children that are still activeCoroutine 0 is doneCoroutine 1 is doneCoroutine 2 is doneNow processing of the request is complete 命名协程的调试自动分配的id通常都很好，而且您只需要将来自相同的协程的日志记录关联起来。然而，当协程与特定的请求或特定的后台任务绑定时，为调试的目的，最好将其命名。CoroutineName context元素提供了与线程名称相同的功能。当调试模式打开时，它将显示在线程名称中，该名称将执行这个协程。 下面的例子演示了这个概念: 1234567891011121314151617fun log(msg: String) = println(\"[$&#123;Thread.currentThread().name&#125;] $msg\")fun main(args: Array&lt;String&gt;) = runBlocking(CoroutineName(\"main\")) &#123; log(\"Started main coroutine\") // run two background value computations val v1 = async(CoroutineName(\"v1coroutine\")) &#123; delay(500) log(\"Computing v1\") 252 &#125; val v2 = async(CoroutineName(\"v2coroutine\")) &#123; delay(1000) log(\"Computing v2\") 6 &#125; log(\"The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;\")&#125; 你可以在这里得到完整的代码 输出它产生使用-Dkotlinx.coroutines.debug JVM选项类似于: 1234[main @main#1] Started main coroutine[ForkJoinPool.commonPool-worker-1 @v1coroutine#2] Computing v1[ForkJoinPool.commonPool-worker-2 @v2coroutine#3] Computing v2[main @main#1] The answer for v1 / v2 = 42 显式取消Job让我们把关于contexts、children和jobs的知识放在一起。假设我们的应用程序有一个具有生命周期的对象，但是这个对象不是一个协程。例如，我们正在编写一个Android应用程序，并在Android activity的环境中launch各种各样的协程，以执行异步操作来获取和更新数据、执行动画等等。当活动被破坏以避免内存泄漏时，必须取消所有这些协程。 我们可以通过创建与activity生命周期相关联的Job实例来管理我们的协程的生命周期。一个job实例是使用job()工厂函数创建的，如下面的例子所示。我们需要确保所有的协程都是在这个job的context下启动的。然后，一次Job.cancel调用就会终止它们。此外,Job.join等待它们所有完成，因此我们也可以在本例中使用cancelAndJoin: 123456789101112131415fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = Job() // 创建一个job对象来管理我们的生命周期 // 现在launch 10个coroutines，每个都在不同的时间工作 val coroutines = List(10) &#123; i -&gt; // 他们都是我们工作对象的孩子 launch(coroutineContext + job) &#123; // 我们使用main runBlocking线程的上下文，但是使用我们自己的job对象 delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc println(\"Coroutine $i is done\") &#125; &#125; println(\"Launched $&#123;coroutines.size&#125; coroutines\") delay(500L) // 延迟半秒 println(\"Cancelling the job!\") job.cancelAndJoin() // 取消所有的协程，等待它们全部完成&#125; 你可以在这里得到完整的代码 这个例子的输出是: 1234Launched 10 coroutinesCoroutine 0 is doneCoroutine 1 is doneCancelling the job! 正如您所看到的，只有前三个协程打印了一条消息，而其他的则被单次调用job.cancelAndJoin()取消了。因此，我们在假想的Android应用程序中所需要做的就是在创建activity时创建父Job对象，将其用于子节点，并在活动destroyed时取消它。我们不能在Android生命周期的情况下join它们，因为它是同步的，但是当构建后端服务以确保有界的资源使用时，这种连接能力是很有用的。 通道Deferred值提供了一种方便的方法，可以在协程之间传递单个值。通道提供了一种传输数据流的方法。 通道基础知识一个通道在概念上非常类似于BlockingQueue。一个关键的区别是，它用挂起的send替代阻塞的put操作，用挂起的receive 替代阻塞的take操作。 12345678910fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val channel = Channel&lt;Int&gt;() launch &#123; // this might be heavy CPU-consuming computation or async logic, we'll just send five squares for (x in 1..5) channel.send(x * x) &#125; // here we print five received integers: repeat(5) &#123; println(channel.receive()) &#125; println(\"Done!\")&#125; 你可以在这里得到完整的代码 这段代码的输出是: 1234561491625Done! 通道的关闭和迭代与队列不同的是，通道可以关闭，以指示不再有更多的元素出现。在接收端，使用常规的for循环从通道接收元素是很方便的。 从概念上说，close就像向通道发送一个特殊的关闭令牌。当接收到这个关闭令牌时，迭代就停止了，因此可以保证所有之前发送的元素都被接收到: 12345678910fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val channel = Channel&lt;Int&gt;() launch &#123; for (x in 1..5) channel.send(x * x) channel.close() // we're done sending &#125; // here we print received values using `for` loop (until the channel is closed) for (y in channel) println(y) println(\"Done!\")&#125; 你可以在这里得到完整的代码 构建通道生成器在这种情况下，一种协程生成一系列元素的模式是很常见的。这是在并发代码中经常发现的生产者-消费者模式的一部分。您可以将这样一个生成器抽象为一个以通道为参数的函数，但这与通常的结果相反，即必须从函数返回结果。有一个名为produce的便利的协程构建器，它使得在生产者端很容易做，并且一个扩展函数consumeEach，它替代了消费者端的for循环: 123456789fun produceSquares() = produce&lt;Int&gt; &#123; for (x in 1..5) send(x * x)&#125;fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val squares = produceSquares() squares.consumeEach &#123; println(it) &#125; println(\"Done!\")&#125; 你可以在这里得到完整的代码 管道管道是一种模式，其中一种可能是无限的值流: 1234fun produceNumbers() = produce&lt;Int&gt; &#123; var x = 1 while (true) send(x++) // 从1开始的无限整数流&#125; 另一个协程或多个协程正在消耗这一流，进行一些处理，并产生一些其他的结果。在下面的例子中，数字是平方: 123fun square(numbers: ReceiveChannel&lt;Int&gt;) = produce&lt;Int&gt; &#123; for (x in numbers) send(x * x)&#125; 主程序启动并连接整个管道: 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val numbers = produceNumbers() // 从1和on生成整数 val squares = square(numbers) // 整数平方 for (i in 1..5) println(squares.receive()) // 打印前五 println(\"Done!\") // we are done squares.cancel() // 需要在更大的应用程序中取消这些协程 numbers.cancel()&#125; 你可以在这里得到完整的代码 我们不必在这个示例应用程序中取消这些协程，因为协程就像守护线程，但是在一个更大的应用程序中，如果我们不再需要它，我们就需要停止我们的管道。或者，我们可以像下面的例子中演示的那样，将管道协程作为主协程的孩子运行。 用管道求质数让我们用一个例子来说明管道的极端情况，这个例子可以用一个管道来生成质数。我们从一个无限的数字序列开始。这一次，我们引入了一个显式的context参数并将其传递给produce建造者，以便调用者可以控制我们的协作程序的运行位置: 1234fun numbersFrom(context: CoroutineContext, start: Int) = produce&lt;Int&gt;(context) &#123; var x = start while (true) send(x++) // 从start开始的无限整数流&#125; 下面的管道阶段将过滤传入的数字流，删除可以被给定的素数整除的所有数字: 123fun filter(context: CoroutineContext, numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce&lt;Int&gt;(context) &#123; for (x in numbers) if (x % prime != 0) send(x)&#125; 现在，我们通过从2启动一个数字流来构建我们的管道，从当前通道中获取一个质数，并为每个找到的素数启动新的管道阶段: 1numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ... 下面的例子输出了前10个素数，在主线程的context中运行整个管道。因为所有的协程都是在coroutineContext中作为主要的runBlocking协程的孩子发布的，所以我们不需要对我们已经开始的所有的协程有一个明确的列表。我们使用cancelChildren扩展函数来取消所有的子协程。 123456789fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; var cur = numbersFrom(coroutineContext, 2) for (i in 1..10) &#123; val prime = cur.receive() println(prime) cur = filter(coroutineContext, cur, prime) &#125; coroutineContext.cancelChildren() // cancel all children to let main finish&#125; 你可以在这里得到完整的代码 这段代码的输出是: 123456789102357111317192329 注意，您可以使用来自标准库的构建器buildIterator构建相同的管道。用produce换成buildIterator，send换成yield，receive换成next，ReceiveChannel 换成Iterator，并摆脱context。您也不需要runBlocking。但是，使用通道的管道的好处是，如果在CommonPool context中运行它，它实际上可以使用多个CPU内核。 无论如何，这是一种非常不切实际的求质数的方法。在实践中,管道涉及一些其他挂起调用(如异步调用远程服务),这些管道不能使用buildSeqeunce/buildIterator,因为他们不允许任意挂起,像produce,这是完全异步的。 扇出多个协程可以从相同的通道接收，在它们之间分配工作。让我们从一个定期产生整数的生产者(每秒钟10个数字)开始。 1234567fun produceNumbers() = produce&lt;Int&gt; &#123; var x = 1 // start from 1 while (true) &#123; send(x++) // produce next delay(100) // wait 0.1s &#125;&#125; 然后我们可以有几个处理器的协程。在本例中，他们只打印他们的id和接收的号码: 12345fun launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch &#123; channel.consumeEach &#123; println(\"Processor #$id received $it\") &#125; &#125; 现在，让我们启动5个处理器，让它们工作大约一秒钟。看看会发生什么: 123456fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val producer = produceNumbers() repeat(5) &#123; launchProcessor(it, producer) &#125; delay(950) producer.cancel() // cancel producer coroutine and thus kill them all&#125; 你可以在这里得到完整的代码 输出将类似于下面一个，尽管接收每个特定整数的处理器id可能不同: 12345678910Processor #2 received 1Processor #4 received 2Processor #0 received 3Processor #1 received 4Processor #3 received 5Processor #2 received 6Processor #4 received 7Processor #0 received 8Processor #1 received 9Processor #3 received 10 请注意，取消一个生产商的协程会关闭它的通道，从而最终终止处理器协程正在进行的通道的迭代。 扇入多个协程可以发送到相同的通道。例如，让我们有一个字符串的通道，以及一个挂起函数，它通过指定的延迟将指定的字符串发送到这个通道。 123456suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) &#123; while (true) &#123; delay(time) channel.send(s) &#125;&#125; 现在，让我们看看如果我们启动了一对发送字符串的协程(在本例中，我们在主线程中作为主协程的子协程启动它们): 123456789fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val channel = Channel&lt;String&gt;() launch(coroutineContext) &#123; sendString(channel, \"foo\", 200L) &#125; launch(coroutineContext) &#123; sendString(channel, \"BAR!\", 500L) &#125; repeat(6) &#123; // 接收前六 println(channel.receive()) &#125; coroutineContext.cancelChildren() // cancel all children to let main finish&#125; 你可以在这里得到完整的代码 它的输出是: 123456foofooBAR!foofooBAR! 缓冲通道到目前为止，所展示的通道没有任何缓冲。当发送方和接收方相遇时，没有缓冲的通道传输元素(也就是会合点)。如果首先调用send，那么它将被挂起，直到receive被调用，如果首先调用receive，它将被挂起，直到send被调用。 Channel()工厂函数和produce构建器都使用一个可选的capacity参数来指定缓冲区大小。缓冲区允许发送者在挂起之前发送多个元素，类似于具有指定容量的BlockingQueue，在缓冲区满时阻塞。 看看以下代码的行为: 123456789101112fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val channel = Channel&lt;Int&gt;(4) // create buffered channel val sender = launch(coroutineContext) &#123; // launch sender coroutine repeat(10) &#123; println(\"Sending $it\") // print before sending each element channel.send(it) // will suspend when buffer is full &#125; &#125; // don't receive anything... just wait.... delay(1000) sender.cancel() // cancel sender coroutine&#125; 你可以在这里得到完整的代码 它用一个有四个容量的缓冲通道打印“发送”5次: 12345Sending 0Sending 1Sending 2Sending 3Sending 4 前4个元素被添加到缓冲区中，当发送第5个元素时，发送器会挂起。 通道是公平的对通道的发送和接收操作是公平的，这与它们从多个协程调用的顺序是公平的。它们以先入先出的顺序服务，例如，第一个调用接收的协程获取元素。在下面的例子中，两个“ping”和“pong”从共享的“table”通道接收到“ball”对象。 12345678910111213141516171819data class Ball(var hits: Int)fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val table = Channel&lt;Ball&gt;() // a shared table launch(coroutineContext) &#123; player(\"ping\", table) &#125; launch(coroutineContext) &#123; player(\"pong\", table) &#125; table.send(Ball(0)) // serve the ball delay(1000) // delay 1 second coroutineContext.cancelChildren() // game over, cancel them&#125;suspend fun player(name: String, table: Channel&lt;Ball&gt;) &#123; for (ball in table) &#123; // receive the ball in a loop ball.hits++ println(\"$name $ball\") delay(300) // wait a bit table.send(ball) // send the ball back &#125;&#125; 你可以在这里得到完整的代码 “ping”协程是先开始的，所以它是第一个收到球的。即使在把球送回到table的时候，”ping” 协程马上又开始接球，球却被”pong” 协程 所接收，因为它已经在等待它了。 1234ping Ball(hits=1)pong Ball(hits=2)ping Ball(hits=3)pong Ball(hits=4) 请注意，有时通道可能会产生由于正在使用的执行器的性质而看起来不公平的执行。请参阅这个问题的详细信息。 共享的可变状态和并发性可以使用多线程的分派器并发地执行协程，比如默认的CommonPool。它展示了所有常见的并发问题。主要问题是对共享易变状态的访问同步。解决这一问题的方法与多线程世界中的解决方案类似，但也有一些是独特的。 这个问题让我们发动一千次的协程，一千次做同样的操作(总共有100万次执行)。我们还将测量他们的完成时间来进行进一步的比较: 12345678910111213suspend fun massiveRun(context: CoroutineContext, action: suspend () -&gt; Unit) &#123; val n = 1000 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis &#123; val jobs = List(n) &#123; launch(context) &#123; repeat(k) &#123; action() &#125; &#125; &#125; jobs.forEach &#123; it.join() &#125; &#125; println(\"Completed $&#123;n * k&#125; actions in $time ms\") &#125; 我们从一个非常简单的动作开始，它使用多线程的CommonPool context来增加一个共享的可变变量。 12345678var counter = 0fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(CommonPool) &#123; counter++ &#125; println(\"Counter = $counter\")&#125; 你可以在这里得到完整的代码 它最后会打印什么?它不太可能打印“计数器=1000000”，因为1000个coroutines可以同时从多个线程并行地增加计数器，而不需要任何同步。 注意:如果您的旧系统中有2个或更少的cpu，那么您将始终看到1000000，因为在本例中，CommonPool只运行一个线程。为了重现这个问题，你需要做出以下的改变: 123456789val mtContext = newFixedThreadPoolContext(2, \"mtPool\") // explicitly define context with two threadsvar counter = 0fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(mtContext) &#123; // use it instead of CommonPool in this sample and below counter++ &#125; println(\"Counter = $counter\")&#125; 你可以在这里得到完整的代码 Volatiles毫无用处有一种常见的误解是，volatile变量可以解决并发性问题。让我们试一试: 123456789@Volatile // in Kotlin `volatile` is an annotation var counter = 0fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(CommonPool) &#123; counter++ &#125; println(\"Counter = $counter\")&#125; 你可以在这里得到完整的代码 这段代码的工作速度较慢，但最终我们仍然不能得到“Counter=1000000”，因为volatile变量可以保证线性化(这是“原子”的技术术语)，并对相应的变量进行读写操作，但是不提供更大的操作的原子性(在我们的例子中是增加的)。 线程安全的数据结构对于线程和协程工作的通用解决方案是使用线程安全的(即同步的、线性化的或原子的)数据结构，为需要在共享状态上执行的相应操作提供所有必要的同步。在一个简单的计数器的例子中，我们可以使用AtomicInteger类，它具有原子的递增操作: 12345678var counter = AtomicInteger()fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(CommonPool) &#123; counter.incrementAndGet() &#125; println(\"Counter = $&#123;counter.get()&#125;\")&#125; 你可以在这里得到完整的代码 对于这个特殊的问题，这是最快的解决方案。它适用于普通的计数器、集合、队列和其他标准数据结构和基本操作。但是，它不容易扩展到复杂的状态，也不容易扩展到没有现成的线程安全实现的复杂操作。 细粒度线程约束线程约束是一种解决共享可变状态问题的方法，在这种状态下，所有对特定共享状态的访问都被限制在一个线程中。它通常在UI应用程序中使用，所有的UI状态都被限制在单一事件分派/应用程序线程中。使用单线程上下文可以很容易地应用于协程。 1234567891011val counterContext = newSingleThreadContext(\"CounterContext\")var counter = 0fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(CommonPool) &#123; // run each coroutine in CommonPool run(counterContext) &#123; // but confine each increment to the single-threaded context counter++ &#125; &#125; println(\"Counter = $counter\")&#125; 你可以在这里得到完整的代码 这段代码运行非常缓慢，因为它执行细粒度的线程限制。每个单独的递增从多线程的CommonPool上下文切换到使用run块的单线程上下文。 粗粒度线程约束在实践中，线程约束是在大块中执行的，例如，状态更新业务逻辑的大片段被限制在单个线程中。下面的例子是这样的，在单线程上下文中运行每个协程。 123456789val counterContext = newSingleThreadContext(\"CounterContext\")var counter = 0fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(counterContext) &#123; // run each coroutine in the single-threaded context counter++ &#125; println(\"Counter = $counter\")&#125; 你可以在这里得到完整的代码 现在的工作速度更快，产生了正确的结果。 Mutex对于这个问题的互斥解决方案是保护共享状态的所有修改，而这一关键部分不会同时执行。在一个阻塞的世界中，您通常会使用synchronized或ReentrantLock。协程的选择被称为 Mutex。它有lock和unlock函数，以限制临界区。关键的区别在于Mutex.lock是一个挂起函数。它不会阻塞线程。 还有withLock扩展函数，它可以方便地表示mutex.lock(); try { … } finally { mutex.unlock() } 模式: 1234567891011val mutex = Mutex()var counter = 0fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; massiveRun(CommonPool) &#123; mutex.withLock &#123; counter++ &#125; &#125; println(\"Counter = $counter\")&#125; 你可以在这里得到完整的代码 这个例子中的锁定是细粒度的，因此它会付出代价。但是，在某些情况下，这是一个很好的选择，您必须定期修改某些共享状态，但是这个状态并没有被限制的自然线程。 参与者参与者(actor)是一种结合在一起的协程，被限制和压缩到这个协程的状态，以及一个外联的沟通渠道。一个简单的参与者可以被编写为一个函数，但是一个具有复杂状态的参与者更适合于一个类。 有一个参与者(actor)协程构建器，它可以方便地将参与者的邮箱通道与它的范围相结合，接收消息，并将发送通道组合到产生的job对象中，这样就可以将单个引用作为它的句柄进行传递。 使用actor的第一步是定义一个参与者将要处理的消息类。Kotlin的sealed classes非常适合这个目的。我们定义CounterMsg sealed类，并使用IncCounter消息增加计数器和GetCounter消息以获取其值。稍后需要发送响应。一个CompletableDeferred通信原语，表示将来会被知道(通信)的一个单一值，用于此目的。 1234// 消息类型为counterActorsealed class CounterMsgobject IncCounter : CounterMsg() // 增量计数器单向消息class GetCounter(val response: CompletableDeferred&lt;Int&gt;) : CounterMsg() // 一个请求与应答 然后，我们定义了一个函数，该函数使用参与者协程构建器启动一个参与者: 12345678910// 这个函数将启动一个新的计数器参与者fun counterActor() = actor&lt;CounterMsg&gt; &#123; var counter = 0 // actor state for (msg in channel) &#123; // 遍历传入的消息 when (msg) &#123; is IncCounter -&gt; counter++ is GetCounter -&gt; msg.response.complete(counter) &#125; &#125;&#125; 主程序很简单: 1234567891011fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val counter = counterActor() // create the actor massiveRun(CommonPool) &#123; counter.send(IncCounter) &#125; // send a message to get a counter value from an actor val response = CompletableDeferred&lt;Int&gt;() counter.send(GetCounter(response)) println(\"Counter = $&#123;response.await()&#125;\") counter.close() // shutdown the actor&#125; 你可以在这里得到完整的代码 参与者自己在什么环境中被执行,这并不重要(对于正确性)。一个参与者是一个协程，而一个协程是按顺序执行的，因此将状态限制到特定的协程是解决共享可变状态问题的一个解决方案。 Actor比在负载下锁定更有效，因为在这种情况下，它总是有工作要做，而且它不需要切换到不同的上下文。 值得注意的是，一个参与者的协程构建器是一个生产协程构建器的双重角色。一个参与者与它接收消息的通道相关联，而一个生产者与它发送元素的通道相关联。 Select表达式Select表达式使得可以同时等待多个挂起函数，并选择第一个可用的函数。 选择通道让我们作两个字符串的生产者: fizz和buzz。fizz生产者每300毫秒就会产生”Fizz”的字符串: 123456fun fizz(context: CoroutineContext) = produce&lt;String&gt;(context) &#123; while (true) &#123; // sends \"Fizz\" every 300 ms delay(300) send(\"Fizz\") &#125;&#125; buzz生产者每500毫秒就会产生”Buzz”的字符串: 123456fun buzz(context: CoroutineContext) = produce&lt;String&gt;(context) &#123; while (true) &#123; // sends \"Buzz!\" every 500 ms delay(500) send(\"Buzz!\") &#125;&#125; 我们可以从一个通道或另一个通道接收挂起函数。但select表达式允许我们同时使用它的onReceive子句: 12345678910suspend fun selectFizzBuzz(fizz: ReceiveChannel&lt;String&gt;, buzz: ReceiveChannel&lt;String&gt;) &#123; select&lt;Unit&gt; &#123; // &lt;Unit&gt; means that this select expression does not produce any result fizz.onReceive &#123; value -&gt; // this is the first select clause println(\"fizz -&gt; '$value'\") &#125; buzz.onReceive &#123; value -&gt; // this is the second select clause println(\"buzz -&gt; '$value'\") &#125; &#125;&#125; 让我们来运行它七次: 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val fizz = fizz(coroutineContext) val buzz = buzz(coroutineContext) repeat(7) &#123; selectFizzBuzz(fizz, buzz) &#125; coroutineContext.cancelChildren() // cancel fizz &amp; buzz coroutines &#125; 你可以在这里得到完整的代码 这段代码的结果是: 1234567fizz -&gt; &apos;Fizz&apos;buzz -&gt; &apos;Buzz!&apos;fizz -&gt; &apos;Fizz&apos;fizz -&gt; &apos;Fizz&apos;buzz -&gt; &apos;Buzz!&apos;fizz -&gt; &apos;Fizz&apos;buzz -&gt; &apos;Buzz!&apos; 关闭时的select当通道关闭时，select中的onReceive子句失败，相应的select抛出一个异常。当通道关闭时，我们可以使用onReceiveOrNull子句执行特定的操作。下面的示例还显示了select是返回其所选子句的结果的表达式: 123456789101112131415suspend fun selectAorB(a: ReceiveChannel&lt;String&gt;, b: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; &#123; a.onReceiveOrNull &#123; value -&gt; if (value == null) \"Channel 'a' is closed\" else \"a -&gt; '$value'\" &#125; b.onReceiveOrNull &#123; value -&gt; if (value == null) \"Channel 'b' is closed\" else \"b -&gt; '$value'\" &#125; &#125; 让我们用通道a生成“Hello”字符串4次，而b通道生成“World”4次: 12345678910111213fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; // we are using the context of the main thread in this example for predictability ... val a = produce&lt;String&gt;(coroutineContext) &#123; repeat(4) &#123; send(\"Hello $it\") &#125; &#125; val b = produce&lt;String&gt;(coroutineContext) &#123; repeat(4) &#123; send(\"World $it\") &#125; &#125; repeat(8) &#123; // print first eight results println(selectAorB(a, b)) &#125; coroutineContext.cancelChildren() &#125; 你可以在这里得到完整的代码 这段代码的结果非常有趣，所以我们将在模式细节上进行分析: 12345678a -&gt; &apos;Hello 0&apos;a -&gt; &apos;Hello 1&apos;b -&gt; &apos;World 0&apos;a -&gt; &apos;Hello 2&apos;a -&gt; &apos;Hello 3&apos;b -&gt; &apos;World 1&apos;Channel &apos;a&apos; is closedChannel &apos;a&apos; is closed 有几条观察结果可以证明这一点。 首先，select对第一个子句有偏爱。当多个子句同时可选时，其中的第一个子句被选中。在这里，两个通道都在不断地生成字符串，因此一个通道，作为select中的第一个子句获胜。然而，由于我们使用的是非缓冲通道，所以a在发送调用时被暂时挂起，并给b发送了一个机会。 第二个观察结果是，当通道已经关闭时，onReceiveOrNull会立即被选中。 选择发送Select表达式有onSend子句，它可以用于很好的组合和选择的偏置性。 让我们来编写一个例子，当在主通道上的消费者无法跟上时，将它的值发送到一个侧通道的整数的生产者。 123456789fun produceNumbers(context: CoroutineContext, side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt;(context) &#123; for (num in 1..10) &#123; // 从1到10产生10个数字 delay(100) // every 100 ms select&lt;Unit&gt; &#123; onSend(num) &#123;&#125; // 发送到主通道 side.onSend(num) &#123;&#125; // 或者是侧通道 &#125; &#125;&#125; 消费者将会非常缓慢，花费250毫秒来处理每一个数字: 123456789101112fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val side = Channel&lt;Int&gt;() // allocate side channel launch(coroutineContext) &#123; // 这是侧边通道的一个非常快的消费者 side.consumeEach &#123; println(\"Side channel has $it\") &#125; &#125; produceNumbers(coroutineContext, side).consumeEach &#123; println(\"Consuming $it\") delay(250) // 让我们适当地消化所消耗的数字，不要着急 &#125; println(\"Done consuming\") coroutineContext.cancelChildren() &#125; 你可以在这里得到完整的代码 让我们看看会发生什么: 1234567891011Consuming 1Side channel has 2Side channel has 3Consuming 4Side channel has 5Side channel has 6Consuming 7Side channel has 8Side channel has 9Consuming 10Done consuming 选择deferred值deferred值可以使用onAwait子句来选择。让我们从一个异步函数开始，该函数在随机延迟之后返回deferred字符串值: 1234fun asyncString(time: Int) = async &#123; delay(time.toLong()) \"Waited for $time ms\"&#125; 让我们用随机的延迟来启动一打: 1234fun asyncStringsList(): List&lt;Deferred&lt;String&gt;&gt; &#123; val random = Random(3) return List(12) &#123; asyncString(random.nextInt(1000)) &#125;&#125; 现在，主函数将等待第一个函数完成并计算仍然处于活动状态的deferred值的数量。注意，我们已经在这里使用了select表达式是一个Kotlin DSL，因此我们可以使用任意代码为它提供子句。在本例中，我们迭代了deferred值的列表，为每个延迟值提供onAwait子句。 12345678910111213fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val list = asyncStringsList() val result = select&lt;String&gt; &#123; list.withIndex().forEach &#123; (index, deferred) -&gt; deferred.onAwait &#123; answer -&gt; \"Deferred $index produced answer '$answer'\" &#125; &#125; &#125; println(result) val countActive = list.count &#123; it.isActive &#125; println(\"$countActive coroutines are still active\")&#125; 你可以在这里得到完整的代码 输出是: 12Deferred 4 produced answer &apos;Waited for 128 ms&apos;11 coroutines are still active 切换到deferred值的通道让我们编写一个通道生成器函数，该函数使用一个deferred字符串值的通道，等待每个接收到的deferred值，但直到下一次deferred或通道被关闭时才会出现。这个示例将onReceiveOrNull和onAwait子句放在同一个select子句中: 1234567891011121314151617181920fun switchMapDeferreds(input: ReceiveChannel&lt;Deferred&lt;String&gt;&gt;) = produce&lt;String&gt; &#123; var current = input.receive() // start with first received deferred value while (isActive) &#123; // loop while not cancelled/closed val next = select&lt;Deferred&lt;String&gt;?&gt; &#123; // return next deferred value from this select or null input.onReceiveOrNull &#123; update -&gt; update // replaces next value to wait &#125; current.onAwait &#123; value -&gt; send(value) // send value that current deferred has produced input.receiveOrNull() // and use the next deferred from the input channel &#125; &#125; if (next == null) &#123; println(\"Channel was closed\") break // out of loop &#125; else &#123; current = next &#125; &#125;&#125; 为了测试它，我们将使用一个简单的async函数，它在指定的时间之后解析为指定的字符串: 1234fun asyncString(str: String, time: Long) = async &#123; delay(time) str&#125; 主函数是启动一个协程来打印开关的结果，并发送一些测试数据给它: 1234567891011121314151617fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val chan = Channel&lt;Deferred&lt;String&gt;&gt;() // the channel for test launch(coroutineContext) &#123; // launch printing coroutine for (s in switchMapDeferreds(chan)) println(s) // print each received string &#125; chan.send(asyncString(\"BEGIN\", 100)) delay(200) // enough time for \"BEGIN\" to be produced chan.send(asyncString(\"Slow\", 500)) delay(100) // not enough time to produce slow chan.send(asyncString(\"Replace\", 100)) delay(500) // give it time before the last one chan.send(asyncString(\"END\", 500)) delay(1000) // give it time to process chan.close() // close the channel ... delay(500) // and wait some time to let it finish&#125; 你可以在这里得到完整的代码 输出是: 1234BEGINReplaceENDChannel was closed 进一步的阅读 使用协程的UI编程指南 使用协程响应式流的指南 协程设计文档(保持) 完整的kotlinx.coroutines API参考","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"},{"name":"kotlinx.coroutines","slug":"kotlinx-coroutines","permalink":"https://jigangduan.github.io/tags/kotlinx-coroutines/"}]},{"title":"Anko 协程","slug":"Anko-Coroutines","date":"2017-11-03T05:14:08.000Z","updated":"2020-07-25T02:57:18.148Z","comments":true,"path":"2017/11/03/Anko-Coroutines/","link":"","permalink":"https://jigangduan.github.io/2017/11/03/Anko-Coroutines/","excerpt":"目录 在你的项目中使用Anko协程 Listener助手 asReference() bg()","text":"目录 在你的项目中使用Anko协程 Listener助手 asReference() bg() 在你的项目中使用Anko协程添加anko-coroutines 到你的build.gradle： 123dependencies &#123; compile &quot;org.jetbrains.anko:anko-coroutines:$anko_version&quot;&#125; Listener助手asReference()如果您的异步API不支持取消，你的协程可能会被无限期挂起。由于协程持有对被捕获对象的强引用，捕获的Activity或Fragment实例可能会导致内存泄漏。 在这种情况下使用asReference()而不是直接捕获: 1234567891011121314151617suspend fun getData(): Data &#123; ... &#125;class MyActivity : Activity() &#123; fun loadAndShowData() &#123; // Ref&lt;T&gt; uses the WeakReference under the hood val ref: Ref&lt;MyActivity&gt; = this.asReference() async(UI) &#123; val data = getData() // Use ref() instead of this@MyActivity ref().showData() &#125; &#125; fun showData(data: Data) &#123; ... &#125;&#125; bg()您可以使用bg()轻松地在后台线程上执行您的代码: 123456789101112fun getData(): Data &#123; ... &#125;fun showData(data: Data) &#123; ... &#125;async(UI) &#123; val data: Deferred&lt;Data&gt; = bg &#123; // 运行在后台 getData() &#125; // 该代码在UI线程上执行 showData(data.await())&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"},{"name":"Anko","slug":"Kotlin/Anko","permalink":"https://jigangduan.github.io/categories/Kotlin/Anko/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"anko","slug":"anko","permalink":"https://jigangduan.github.io/tags/anko/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"}]},{"title":"Anko SQLite","slug":"Anko-SQLite","date":"2017-11-03T03:05:26.000Z","updated":"2020-07-25T02:57:18.148Z","comments":true,"path":"2017/11/03/Anko-SQLite/","link":"","permalink":"https://jigangduan.github.io/2017/11/03/Anko-SQLite/","excerpt":"您是否厌倦了使用Android Cursor解析SQLite查询结果?您必须编写大量的样板代码来解析查询结果行，并将其封装在无数的try..finally块中，以便正确地关闭所有打开的资源。 Anko提供了许多扩展功能，以简化与SQLite数据库的工作。 目录 在项目中使用Anko SQLite 访问数据库 创建和删除表 插入数据 查询数据 解析查询结果 自定义行解析器 Cursor流 更新值 事务","text":"您是否厌倦了使用Android Cursor解析SQLite查询结果?您必须编写大量的样板代码来解析查询结果行，并将其封装在无数的try..finally块中，以便正确地关闭所有打开的资源。 Anko提供了许多扩展功能，以简化与SQLite数据库的工作。 目录 在项目中使用Anko SQLite 访问数据库 创建和删除表 插入数据 查询数据 解析查询结果 自定义行解析器 Cursor流 更新值 事务 在项目中使用Anko SQLite将anko-sqlite的依赖添加到您的build.gradle: 123dependencies &#123; compile \"org.jetbrains.anko:anko-sqlite:$anko_version\"&#125; 访问数据库如果使用SQLiteOpenHelper，通常会调用getReadableDatabase()或getWritableDatabase()(在生产代码中结果是相同的)，但是必须确保在接收到的SQLiteDatabase上调用close()方法。另外，您必须在某个地方缓存helper类，如果您在几个线程中使用它，那么您必须知道并发访问。这一切都很艰难。这就是为什么Android开发人员并不热衷于使用默认的SQLite API，而是更喜欢使用诸如ORMs之类的相当昂贵的包装器。 Anko提供了一个特殊的类ManagedSQLiteOpenHelper，它可以无缝地替换缺省值。以下是你如何使用它: 123456789101112131415161718192021222324252627282930class MyDatabaseOpenHelper(ctx: Context) : ManagedSQLiteOpenHelper(ctx, &quot;MyDatabase&quot;, null, 1) &#123; companion object &#123; private var instance: MyDatabaseOpenHelper? = null @Synchronized fun getInstance(ctx: Context): MyDatabaseOpenHelper &#123; if (instance == null) &#123; instance = MyDatabaseOpenHelper(ctx.getApplicationContext()) &#125; return instance!! &#125; &#125; override fun onCreate(db: SQLiteDatabase) &#123; // 这里创建表 db.createTable(&quot;Customer&quot;, ifNotExists = true, &quot;id&quot; to INTEGER + PRIMARY_KEY + UNIQUE, &quot;name&quot; to TEXT, &quot;photo&quot; to BLOB) &#125; override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123; // 在这里，您可以像往常一样删除表 db.dropTable(&quot;User&quot;, true) &#125;&#125;// 访问属性的Contextval Context.database: MyDatabaseOpenHelper get() = MyDatabaseOpenHelper.getInstance(getApplicationContext()) 什么感觉?不要将你的代码封装到try块中，现在你可以这样写: 123database.use &#123; // `this` is a SQLiteDatabase instance&#125; 在{}里执行了所有的代码之后，数据库将会被关闭。 异步调用的例子: 12345678910class SomeActivity : Activity() &#123; private fun loadAsync() &#123; async(UI) &#123; val result = bg &#123; database.use &#123; ... &#125; &#125; loadComplete(result) &#125; &#125;&#125; 🐧 下面提到的这些方法和所有方法可能会抛出SQLiteException。你必须自己处理，因为Anko假装错误不会发生，这是不合理的。 创建和删除表对于Anko，你可以很容易地创建新的表，并删除现有的表。语法很简单。 123456database.use &#123; createTable(&quot;Customer&quot;, true, &quot;id&quot; to INTEGER + PRIMARY_KEY + UNIQUE, &quot;name&quot; to TEXT, &quot;photo&quot; to BLOB)&#125; 在SQLite中，有5种主要类型:NULL、INTEGER、REAL、TEXT和BLOB。但是每一列可能都有一些修饰符，比如主键(PRIMARY KEY)或惟一(UNIQUE)的。您可以将这些修饰符附加到主类型名中。 要删除一个表，使用dropTable函数: 1dropTable(&quot;User&quot;, true) 插入数据通常，您需要一个ContentValues实例来将行插入到表中。这是一个例子: 12345val values = ContentValues()values.put(&quot;id&quot;, 5)values.put(&quot;name&quot;, &quot;John Smith&quot;)values.put(&quot;email&quot;, &quot;user@domain.org&quot;)db.insert(&quot;User&quot;, null, values) Anko允许消除这些仪式,通过直接把值作为insert()函数的参数: 1234567// Where db is an SQLiteDatabase// eg: val db = database.writeableDatabasedb.insert(&quot;User&quot;, &quot;id&quot; to 42, &quot;name&quot; to &quot;John&quot;, &quot;email&quot; to &quot;user@domain.org&quot;) 或者使用database.use: 123456database.use &#123; insert(&quot;User&quot;, &quot;id&quot; to 42, &quot;name&quot; to &quot;John&quot;, &quot;email&quot; to &quot;user@domain.org&quot;&#125; 请注意，在上面的示例中，database是一个数据库助手实例，而db是一个SQLiteDatabase对象 函数insertOrThrow(), replace(), replaceOrThrow()也存在并具有类似的语义。 查询数据Anko提供了一个方便的查询构建器。它可能是用db.select(tableName, vararg columns)，db是SQLiteDatabase的一个实例。 方法 描述 column(String) 添加一个用于选择查询的列 distinct(Boolean) 不同的查询 whereArgs(String) 指定原始字符串where查询 whereArgs(String, args) ✨ 指定带有参数的where查询 whereSimple(String, args) 指定带有?标志参数的where查询 orderBy(String, [ASC/DESC]) 按列排序 groupBy(String) 按列分组 limit(count: Int) 限制查询结果行数 limit(offset: Int, count: Int) 用偏移量限制查询结果行数 having(String) 指定原始having表达式 having(String, args) ✨ 指定带有参数的having表达式 函数标记✨以一种特殊的方式解析它的参数。它们允许您以任何顺序提供值，并支持无缝地转义。 1234db.select(&quot;User&quot;, &quot;name&quot;) .whereArgs(&quot;(_id &gt; &#123;userId&#125;) and (name = &#123;userName&#125;)&quot;, &quot;userName&quot; to &quot;John&quot;, &quot;userId&quot; to 42) 在这里，{userId}部分将被42替换，{userName}替换为&#39;John&#39;。如果它的类型不是数值(Int、Float等)或Boolean，则该值将被转义。对于其他类型，将被使用toString()表示。 whereSimple函数接受String类型的参数。它与SQLiteDatabase中的query()相同(问号?将会被实值的实值所取代) 我们如何执行查询?使用exec()函数。它接受一个扩展函数，它的类型是Cursor.() -&gt; T。它只是启动接收的扩展函数，然后关闭Cursor，这样您就不需要自己动手了: 123db.select(&quot;User&quot;, &quot;email&quot;).exec &#123; // 用电子邮件做一些事情&#125; 解析查询结果因此，我们有一些Cursor，我们如何将它解析为普通类呢?Anko提供了一些功能parseSingle, parseOpt和parseList，这样做更容易。 方法 描述 parseSingle(rowParser): T 解析1行 parseOpt(rowParser): T? 解析0或1行 parseList(rowParser): List&lt;T&gt; 解析0或多行 注意，parseSingle()和parseOpt()将抛出一个异常，如果接收到的Cursor包含超过一行。 现在的问题是:什么是rowParser?每个函数都支持两种不同类型的解析器: RowParser和MapRowParser: 1234567interface RowParser&lt;T&gt; &#123; fun parseRow(columns: Array&lt;Any&gt;): T&#125;interface MapRowParser&lt;T&gt; &#123; fun parseRow(columns: Map&lt;String, Any&gt;): T&#125; 如果您想以一种非常有效的方式编写查询，请使用RowParser(但是您必须知道每个列的索引)。parseRow接受了一个Any列表(Any类型实际上都可以是Long、Double、String或ByteArray)。另一方面，MapRowParser允许使用列名来获取行值。 Anko已经有了简单的单列行的解析器: ShortParser IntParser LongParser FloatParser DoubleParser StringParser BlobParser 同样，您可以从类构造函数创建row解析器。假设你有一个class: 1class Person(val firstName: String, val lastName: String, val age: Int) 解析器将非常简单: 1val rowParser = classParser&lt;Person&gt;() 现在，如果主构造函数有可选的参数，那么Anko不支持创建这样的解析器。另外，请注意，构造函数将使用Java反射来调用，因此编写一个自定义的RowParser对于大型数据集来说是更合理的。 如果使用Anko db.select()构建器，可以直接调用parseSingle、parseOpt或parseList，并传递一个适当的解析器。 自定义行解析器例如，让我们为columns (Int, String, String)创建一个新的解析器。最幼稚的做法是: 12345class MyRowParser : RowParser&lt;Triple&lt;Int, String, String&gt;&gt; &#123; override fun parseRow(columns: Array&lt;Any&gt;): Triple&lt;Int, String, String&gt; &#123; return Triple(columns[0] as Int, columns[1] as String, columns[2] as String) &#125;&#125; 现在，我们的代码中有三个显式的类型转换。让我们通过使用rowParser函数来摆脱它们: 123val parser = rowParser &#123; id: Int, name: String, email: String -&gt; Triple(id, name, email)&#125; 是它!rowParser将所有的类型转换为底层，您可以根据您的需要来命名lambda参数。 Cursor流Anko提供了一种以功能方式访问SQLite Cursor的方法。只需调用cursor.assequence()或cursormap.asmapsequence()扩展函数，就可以得到一个行序列。不要忘记关闭Cursor :) 更新值让我们给我们的一个用户一个新名字: 123update(&quot;User&quot;, &quot;name&quot; to &quot;Alice&quot;) .where(&quot;_id = &#123;userId&#125;&quot;, &quot;userId&quot; to 42) .exec() 更新还有一个whereSimple()方法，以防您想要以传统方式提供查询: 123update(&quot;User&quot;, &quot;name&quot; to &quot;Alice&quot;) .whereSimple(&quot;_id = ?&quot;, 42) .exec() 事务有一个名为transaction()的特殊函数，它允许您将多个数据库操作封装在一个SQLite事务中。 123transaction &#123; // 你的事务代码&#125; 如果在{}块中没有抛出异常，那么该事务将被标记为成功。 🐧 如果你想中止事务出于某种原因,抛出TransactionAbortException。在这种情况下，您不需要自己处理这个异常。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"},{"name":"Anko","slug":"Kotlin/Anko","permalink":"https://jigangduan.github.io/categories/Kotlin/Anko/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"anko","slug":"anko","permalink":"https://jigangduan.github.io/tags/anko/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"}]},{"title":"Anko 布局","slug":"Anko-Layouts","date":"2017-11-02T10:56:23.000Z","updated":"2020-07-25T02:57:18.148Z","comments":true,"path":"2017/11/02/Anko-Layouts/","link":"","permalink":"https://jigangduan.github.io/2017/11/02/Anko-Layouts/","excerpt":"为什么Anko布局? DSL的原因? 支持现有的代码 它是如何工作的 它是可扩展的吗? 在你的项目中使用Anko Layouts 理解Anko 基础知识 AnkoComponent 辅助块 主题块 布局和LayoutParams Listeners 定制的协程上下文 使用资源标识符 实例简化符号 UI包装 Include标签 Anko支持插件 安装Anko支持插件 使用插件 XML DSL转换器","text":"为什么Anko布局? DSL的原因? 支持现有的代码 它是如何工作的 它是可扩展的吗? 在你的项目中使用Anko Layouts 理解Anko 基础知识 AnkoComponent 辅助块 主题块 布局和LayoutParams Listeners 定制的协程上下文 使用资源标识符 实例简化符号 UI包装 Include标签 Anko支持插件 安装Anko支持插件 使用插件 XML DSL转换器 为什么Anko布局?DSL的原因?默认情况下，Android中的UI是用XML编写的。这在以下方面是不方便的: 不是类型安全; 不是空值安全; 它迫使您为每一个布局编写几乎相同的代码; 在设备上解析XML，浪费CPU时间和电池; 最重要的是，它不允许代码重用。 虽然您可以通过编程方式创建UI，但这几乎是不可能完成的，因为它有点难看，很难维护。这是一个普通的Kotlin版本(Java中的一个更长的版本): 1234567891011val act = thisval layout = LinearLayout(act)layout.orientation = LinearLayout.VERTICALval name = EditText(act)val button = Button(act)button.text = \"Say Hello\"button.setOnClickListener &#123; Toast.makeText(act, \"Hello, $&#123;name.text&#125;!\", Toast.LENGTH_SHORT).show()&#125;layout.addView(name)layout.addView(button) DSL使相同的逻辑易于阅读，易于编写，并且没有运行时开销。这里又有了: 123456verticalLayout &#123; val name = editText() button(\"Say Hello\") &#123; onClick &#123; toast(\"Hello, $&#123;name.text&#125;!\") &#125; &#125;&#125; 注意，onClick()支持协程(接受suspending lambda)，这样您就可以在没有显式的async(UI)调用的情况下编写异步代码。 支持现有的代码你不需要重写Anko的所有UI。您可以用Java编写旧的类。此外，如果您仍然希望(或有)编写一个Kotlin activity类，并出于某种原因使XML布局膨胀，您可以使用视图属性，这将使事情变得更简单: 1234// 与findViewById()相同，但使用起来更简单val name = find&lt;TextView&gt;(R.id.name)name.hint = \"Enter your name\"name.onClick &#123; /*do something*/ &#125; 通过使用Kotlin的Android扩展，您可以使您的代码更加紧凑。 它是如何工作的没有🎩。Anko由一些Kotlin的扩展函数和属性组成了类型安全的构造器，就像类型安全的构建器所描述的那样。 由于手工编写所有这些扩展有点乏味，所以它们是由Android SDK中的android.jar文件自动生成的。 它是可扩展的吗?简短的回答:是的。 例如，您可能想要在DSL中使用MapView。然后把它写在任何可以导入的Kotlin文件中: 12345inline fun ViewManager.mapView() = mapView(theme = 0) &#123;&#125;inline fun ViewManager.mapView(init: MapView.() -&gt; Unit): MapView &#123; return ankoView(&#123; MapView(it) &#125;, theme = 0, init = init)&#125; { MapView(it) }是您自定义View的工厂函数。它接受一个Context实例 现在你可以这样写了: 123frameLayout &#123; val mapView = mapView().lparams(width = matchParent)&#125; 如果你想让你的用户能够应用一个定制的主题，你也可以这样写: 12345inline fun ViewManager.mapView(theme: Int = 0) = mapView(theme) &#123;&#125;inline fun ViewManager.mapView(theme: Int = 0, init: MapView.() -&gt; Unit): MapView &#123; return ankoView(&#123; MapView(it) &#125;, theme, init)&#125; 在你的项目中使用Anko Layouts这些库依赖关系包括: 123456789dependencies &#123; // Anko Layouts compile \"org.jetbrains.anko:anko-sdk25:$anko_version\" // sdk15, sdk19, sdk21, sdk23 are also available compile \"org.jetbrains.anko:anko-appcompat-v7:$anko_version\" // Coroutine listeners for Anko Layouts compile \"org.jetbrains.anko:anko-sdk25-coroutines:$anko_version\" compile \"org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version\"&#125; 请阅读基于Gradle的项目部分，以获得详细信息。 理解Anko基础知识在Anko，你不需要从任何特殊的类继承:仅仅使用标准的Activity、Fragment、FragmentActivity或任何你想要的东西。 首先，导入org.jetbrains.anko.*。在您的类中使用Anko布局DSL。 在onCreate()中可以使用DSL: 123456789101112131415161718override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) verticalLayout &#123; padding = dip(30) editText &#123; hint = \"Name\" textSize = 24f &#125; editText &#123; hint = \"Password\" textSize = 24f &#125; button(\"Login\") &#123; textSize = 26f &#125; &#125;&#125; 🐧 没有明确的调用setContentView(R.layout.something): Anko为Activities自动设置内容视图(但只对他们)。 hint和textSize是与java风格的getter和setter绑定的合成扩展属性，padding是Anko的扩展属性。这些都存在于几乎所有View属性中，允许您编写text = &quot;Some text&quot;而不是setText(&quot;Some text&quot;)。 verticalLayout(一个线性布局，但已经有了LinearLayout.VERTICAL方向)、editText和button是构造新Viwe实例并将它们添加到父类的扩展函数。我们将引用这些函数作为块。 在Android框架中几乎所有的视图都存在块，它们在Activities、Fragments(默认情况下和android.support package)甚至是Context。例如，如果您有一个AnkoContext实例，您可以编写这样的块: 12345val name: EditText = with(ankoContext) &#123; editText &#123; hint = \"Name\" &#125;&#125; AnkoComponent尽管您可以直接使用DSL(在onCreate()或其他任何地方)，但不需要创建任何额外的类，在单独的类中使用UI通常是很方便的。如果您使用了提供的AnkoComponent接口，那么您还可以免费获得DSL布局预览功能。 1234567891011121314151617class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123; super.onCreate(savedInstanceState, persistentState) MyActivityUI().setContentView(this) &#125;&#125;class MyActivityUI : AnkoComponent&lt;MyActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;MyActivity&gt;) = with(ui) &#123; verticalLayout &#123; val name = editText() button(\"Say Hello\") &#123; onClick &#123; ctx.toast(\"Hello, $&#123;name.text&#125;!\") &#125; &#125; &#125; &#125;&#125; 辅助块正如您可能已经注意到的，前一节中的button()函数接受一个字符串参数。对于常用的View，例如TextView、EditText、Button或ImageView，都存在这样的辅助块。 如果您不需要为某个特定View设置任何属性，您可以省略 {}，编写button(“Ok”)，甚至只是button(): 1234verticalLayout &#123; button(\"Ok\") button(R.string.cancel)&#125; 主题块Anko提供了“themeable”版本，包括辅助块: 123verticalLayout &#123; themedButton(\"Ok\", theme = R.style.myTheme)&#125; 布局和LayoutParams可以使用LayoutParams对父容器中的小部件进行定位。在XML中，它是这样的: 123456&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dip\" android:layout_marginTop=\"10dip\" android:src=\"@drawable/something\" /&gt; 在Anko中，使用lparams()在View描述后，指定了LayoutParams。 12345678linearLayout &#123; button(\"Login\") &#123; textSize = 26f &#125;.lparams(width = wrapContent) &#123; horizontalMargin = dip(5) topMargin = dip(10) &#125;&#125; 如果您指定了lparams()，但是省略了width和/或height，它们的默认值都是wrapContent。但是您总是可以显式地传递它们:使用命名参数。 一些方便的辅助属性可以注意到: horizontalMargin 设置左和右的边距 verticalMargin 设置顶部和底部的边距 margin 同时设置了所有四个边距 注意，对于不同的布局，lparams()是不同的，例如，在相对布局的情况下: 123456789val ID_OK = 1relativeLayout &#123; button(\"Ok\") &#123; id = ID_OK &#125;.lparams &#123; alignParentTop() &#125; button(\"Cancel\").lparams &#123; below(ID_OK) &#125;&#125; ListenersAnko有一名监听器的助手，他们可以无缝地支持协程。您可以在listener内编写异步代码！ 123456button(\"Login\") &#123; onClick &#123; val user = myRetrofitService.getUser().await() showUser(user) &#125;&#125; 几乎和这个是一样的: 12345678button.setOnClickListener(object : OnClickListener &#123; override fun onClick(v: View) &#123; launch(UI) &#123; val user = myRetrofitService.getUser().await() showUser(user) &#125; &#125;&#125;) 当你有很多方法的时候，Anko是很有帮助的。考虑下面的代码，没有使用Anko: 1234567891011seekBar.setOnSeekBarChangeListener(object : OnSeekBarChangeListener &#123; override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) &#123; // Something &#125; override fun onStartTrackingTouch(seekBar: SeekBar?) &#123; // Just an empty method &#125; override fun onStopTrackingTouch(seekBar: SeekBar) &#123; // Another empty method &#125;&#125;) 现在,Anko: 1234567seekBar &#123; onSeekBarChangeListener &#123; onProgressChanged &#123; seekBar, progress, fromUser -&gt; // Something &#125; &#125;&#125; 如果您为相同的View设置onProgressChanged()和onStartTrackingTouch()，那么这两个“部分定义”的listener将被合并。对于相同的listener方法，最后一个获胜。 定制的协程上下文您可以将一个定制的协程context传递给listener助手: 123456button(\"Login\") &#123; onClick(yourContext) &#123; val user = myRetrofitService.getUser().await() showUser(user) &#125;&#125; 使用资源标识符前面几章中的所有例子都使用了原始Java字符串，但这并不是一个好的实践。通常，您将所有的字符串数据放入res/values/目录中，并在运行时调用它，例如getString(R.string.login)。 幸运的是，在Anko中，您可以将资源标识符传递给助手块(button(R.string.login))和扩展属性(button { textResource = R.string.login })。 注意，属性名不是相同的: text、hint、image，而是我们现在使用的是textResource、hintResource和imageResource 🐧 资源属性读时总是抛出AnkoException。 实例简化符号有时候，您需要从活动代码中传递一个Context实例到某个Android SDK方法。通常，你可以使用this，但是如果你在一个内部类里面呢?如果您在Kotlin编写，您可能会在Java和this@SomeActivity用SomeActivity.this。 对Anko，你可以写ctx。它是一个扩展属性，既可以在Activity和Service中工作，也可以从Fragment中访问(它的外壳是使用getActivity()方法)。您还可以使用act扩展属性获得一个Activity实例。 UI包装在开始之前，Anko总是使用UI标签作为顶级的DSL元素: 12345UI &#123; editText &#123; hint = \"Name\" &#125;&#125; 如果你想的话，你仍然可以使用这个标签。而且，扩展DSL要容易得多，因为您必须只声明一个ViewManager.customView函数。请参见扩展Anko获取更多信息。 Include标签可以很容易将XML布局插入到DSL中。使用include()函数: 123include&lt;View&gt;(R.layout.something) &#123; backgroundColor = Color.RED&#125;.lparams(width = matchParent) &#123; margin = dip(12) &#125; 您可以像往常一样使用lparams()，如果您提供了一个特定的类型而不是View，您也可以使用这个类型: 123include&lt;TextView&gt;(R.layout.textfield) &#123; text = \"Hello, world!\"&#125; Anko支持插件Anko支持插件可用于IntelliJ IDEA和Android Studio。它允许你在IDE工具窗口中直接预览与Anko一起编写的AnkoComponent类。 ⚠️ Anko支持插件目前只支持Android Studio 2.4+。 安装Anko支持插件你可以在这里下载Anko的支持插件。 使用插件假设你用Anko写了这些classes： 1234567891011121314151617class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123; super.onCreate(savedInstanceState, persistentState) MyActivityUI().setContentView(this) &#125;&#125;class MyActivityUI : AnkoComponent&lt;MyActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;MyActivity&gt;) = ui.apply &#123; verticalLayout &#123; val name = editText() button(\"Say Hello\") &#123; onClick &#123; ctx.toast(\"Hello, $&#123;name.text&#125;!\") &#125; &#125; &#125; &#125;.view&#125; 将光标放在MyActivityUI声明的地方，打开Anko布局预览工具窗口(“View” → “Tool Windows” → “Anko Layout Preview”)，并按下刷新。 这需要构建项目，因此在实际显示图像之前需要花费一些时间。 XML DSL转换器该插件还支持将XML格式的布局转换为Anko布局代码。打开一个XML文件并选择”Code” → “Convert to Anko Layouts DSL”。您可以同时转换多个XML布局文件。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"},{"name":"Anko","slug":"Kotlin/Anko","permalink":"https://jigangduan.github.io/categories/Kotlin/Anko/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"anko","slug":"anko","permalink":"https://jigangduan.github.io/tags/anko/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"}]},{"title":"Anko 通用模块","slug":"Anko-Commons","date":"2017-11-02T09:24:52.000Z","updated":"2020-07-25T02:57:18.148Z","comments":true,"path":"2017/11/02/Anko-Commons/","link":"","permalink":"https://jigangduan.github.io/2017/11/02/Anko-Commons/","excerpt":"目录 在您的项目中使用anko-commons助手 Intents Intent构建器函数 有用Intent调用 Dialogs Toasts SnackBars Alerts Selectors 进度dialogs 日志 强风格 日志记录器对象风格 Misc 颜色 维度值 applyRecursively()","text":"目录 在您的项目中使用anko-commons助手 Intents Intent构建器函数 有用Intent调用 Dialogs Toasts SnackBars Alerts Selectors 进度dialogs 日志 强风格 日志记录器对象风格 Misc 颜色 维度值 applyRecursively() 在您的项目中使用anko-commons助手添加anko-commons到对您的build.gradle的依赖: 1234dependencies &#123; compile \"org.jetbrains.anko:anko-commons:$anko_version\" compile \"org.jetbrains.anko:anko-design:$anko_version\" // For SnackBars&#125; IntentsIntent助手位于anko-commons工件内。 Intent构建器函数通常，您必须编写多行来启动一个新的活动。它还要求你为传输额外的值写额外的行。例如，用extra (“id”, 5)和一个特殊的标志来启动一个活动的代码： 1234val intent = Intent(this, SomeOtherActivity::class.java)intent.putExtra(\"id\", 5)intent.setFlag(Intent.FLAG_ACTIVITY_SINGLE_TOP)startActivity(intent) 四行太过分了。Anko向你提供了一个更简单的方法: 1startActivity(intentFor&lt;SomeOtherActivity&gt;(\"id\" to 5).singleTop()) 如果您不需要传递任何标志，那么解决方案就更简单了: 1startActivity&lt;SomeOtherActivity&gt;(\"id\" to 5) 有用Intent调用Anko对一些广泛使用的意图进行了包装: 目标 解决方案 打电话 makeCall(number) 发送短信 sendSMS(number, [text]) 浏览网页 browse(url) 分享文本内容 share(text, [subject]) 发送电子邮件 email(email, [subject], [text]) 方括号中的参数([])是可选的。如果发送了意图，方法返回true。 DialogsDialog助手位于anko-commons工件内。 Toasts简单地展示一个Toast的信息。 123toast(\"Hi there!\")toast(R.string.message)longToast(\"Wow, such duration\") SnackBars简单地显示一条SnackBar消息。 1234snackbar(view, \"Hi there!\")snackbar(view, R.string.message)longSnackbar(view, \"Wow, such duration\")snackbar(view, \"Action, reaction\", \"Click me!\") &#123; doStuff() &#125; Alerts一个用于显示alert dialogs的简单DSL。 1234alert(\"Hi, I'm Roy\", \"Have you tried turning it off and on again?\") &#123; yesButton &#123; toast(\"Oh…\") &#125; noButton &#123;&#125;&#125;.show() 上面的代码将显示默认的Android警告对话框。如果您想切换到appcompat实现，请使用Appcompat对话框: 1alert(Appcompat, \"Some text message\").show() 默认情况下包括Android和Appcompat对话框，但是您可以通过实现AlertBuilderFactory接口来创建您的定制工厂。 alert()功能无缝地支持Anko的布局，作为自定义视图: 12345alert &#123; customView &#123; editText() &#125;&#125;.show() Selectorsselector()显示一个带有文本条目列表的警告对话框: 1234val countries = listOf(\"Russia\", \"USA\", \"Japan\", \"Australia\")selector(\"Where are you from?\", countries, &#123; dialogInterface, i -&gt; toast(\"So you're living in $&#123;countries[i]&#125;, right?\")&#125;) 进度dialogsprogressDialog()创建并显示一个进度对话框。 1val dialog = progressDialog(message = \"Please wait a bit…\", title = \"Fetching data\") 一个不确定的进度对话框也有(见indeterminateProgressDialog())。 日志AnkoLogger位于anko-commons工件内。 强风格Android SDK提供了android.util.Log类，并提供了一些日志记录方法。使用方法非常简单，但是方法要求您传递一个标记参数。你可以通过使用AnkoLogger的接口来消除这个问题: 1234567class SomeActivity : Activity(), AnkoLogger &#123; private fun someMethod() &#123; info(\"London is the capital of Great Britain\") debug(5) // .toString() method will be executed warn(null) // \"null\" will be printed &#125;&#125; android.util.Log AnkoLogger v() verbose() d() debug() i() info() w() warn() e() error() wtf() wtf() 默认的标记名是一个类名(在本例中是SomeActivity)，但是您可以通过覆盖loggerTag属性来轻松地更改它。 每个方法有两个版本:普通和懒惰(内联): 12info(\"String \" + \"concatenation\")info &#123; \"String \" + \"concatenation\" &#125; 只有Log.isLoggable(tag, Log.INFO)是true，Lambda结果才会计算 日志记录器对象风格你也可以用AnkoLogger作为一个简单的对象。 12345678class SomeActivity : Activity() &#123; private val log = AnkoLogger&lt;SomeActivity&gt;(this) private val logWithASpecificTag = AnkoLogger(\"my_tag\") private fun someMethod() &#123; log.warning(\"Big brother is watching you!\") &#125;&#125; Misc颜色两个简单的扩展函数使代码更加可读。 函数 结果 0xff0000.opaque 不透明的红色 0x99.gray.opaque 灰色不透明的#999999 维度值您可以在dip(密度-独立像素)或sp(独立像素)中指定维度值:dip(dipValue)或sp(spValue)。注意，textSize属性已经接受sp(textSize=16f)。使用px2dip和px2sp进行反向转换。 applyRecursively()applyRecursively()将lambda表达式应用到传递View本身，然后递归地对视图中的每个子视图进行递归，如果是ViewGroup： 12345678910verticalLayout &#123; editText &#123; hint = \"Name\" &#125; editText &#123; hint = \"Password\" &#125;&#125;.applyRecursively &#123; view -&gt; when(view) &#123; is EditText -&gt; view.textSize = 20f&#125;&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"},{"name":"Anko","slug":"Kotlin/Anko","permalink":"https://jigangduan.github.io/categories/Kotlin/Anko/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"anko","slug":"anko","permalink":"https://jigangduan.github.io/tags/anko/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"}]},{"title":"Anko 简介","slug":"anko","date":"2017-11-02T09:02:35.000Z","updated":"2020-07-25T02:57:18.173Z","comments":true,"path":"2017/11/02/anko/","link":"","permalink":"https://jigangduan.github.io/2017/11/02/anko/","excerpt":"","text":"Anko是一个Kotlin库，它使Android应用程序开发的速度更快、更容易。它使您的代码干净、易于阅读，并且让您忘记了Android SDK的粗糙边缘。 Anko由几个部分组成: Anko Commons:一个全是助手的轻量级的库: Intents; Dialogs和toasts; Logging; 资源和尺寸; Anko Layouts:一种快速和类型安全的方式来编写动态的Android布局 Anko SQLite:用于Android SQLite的查询DSL和解析器集合 Anko Coroutines:基于kotlinx.coroutines库的实用工具 Anko示例项目","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"},{"name":"Anko","slug":"Kotlin/Anko","permalink":"https://jigangduan.github.io/categories/Kotlin/Anko/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"anko","slug":"anko","permalink":"https://jigangduan.github.io/tags/anko/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"}]},{"title":"ADB Shell","slug":"ADBShell","date":"2017-11-02T05:09:20.000Z","updated":"2020-07-25T02:57:18.147Z","comments":true,"path":"2017/11/02/ADBShell/","link":"","permalink":"https://jigangduan.github.io/2017/11/02/ADBShell/","excerpt":"Android调试桥(adb)是一种命令行工具，可以让您与仿真器或连接的Android设备进行通信。您可以在android sdk/platform-tools中找到adb工具，或者下载adb工具包。 目录 ADB调试 无线 包管理器 文件管理器 网络 调试 截图 系统","text":"Android调试桥(adb)是一种命令行工具，可以让您与仿真器或连接的Android设备进行通信。您可以在android sdk/platform-tools中找到adb工具，或者下载adb工具包。 目录 ADB调试 无线 包管理器 文件管理器 网络 调试 截图 系统 ADB调试adb devices打印所有附加的模拟器/设备的列表 1adb devices 打印所有附加的模拟器/设备的列表 12e4b25377 deviceemulator-5554 device adb forward设备的端口转发 adb forward &lt;local&gt; &lt;remote&gt; 1adb forward tcp:8000 tcp:9000 ##把PC端8000端口的数据, 转发到Android端的9000端口上 执行命令后, PC端的8000端口会被 adb监听, 这个时候我们只需要往8000端口写数据, 这个数据就会发送到手机端的9000端口上. 这个命令对于我们在调试的时候非常有用，特别在 IDA 调试中。 先决条件:在设备上启用USB调试。 adb forward查看设备中可以被调试的应用的进程号 adb jdwp 这个命令或许用途不是很多，但是对于调试的时候还是有点用途。可以忽略这个命令。 adb kill-server终止adb服务器进程 1adb kill-server 注释:如果服务器正在运行，就将其杀死。(终端adb.exe进程) 无线adb connect使用ADB Wi-Fi adb connect &lt;host&gt;[:&lt;port&gt;] 步骤1 通过USB连接到设备。 步骤2 1adb devices 附加的设备列表 1######## device 步骤3 1adb tcpip 5555 在TCP模式端口555重新启动 步骤4 找出Android设备的IP地址: Settings -&gt; About -&gt; Status -&gt; IP address。记住IP地址 #.#.#.# 步骤5 1adb connect #.#.#.# 连接到#.#.#.#:5555 步骤6 从设备中移除USB电缆，并确认你仍然可以访问设备: 1adb devices 附加的设备列表 1#.#.#.#:5555 device 注意:确保你的主机仍然连接到你的Android设备上的相同的wifi网络。 adb usb以USB模式重新启动ADB。 1adb usb 参见:adb connect 包管理器adb install安装一个Android应用程序(指定一个完整路径的.apk文件)到一个模拟器/设备。 adb install [option] &lt;path&gt; 12345678910111213adb install test.apkadb install -l test.apk ##安装锁定应用程序adb install -r test.apk ##替换现有的应用程序adb install -t test.apk ##允许test包adb install -s test.apk ##sdcard上安装应用程序adb install -d test.apk ##允许降级版本代码adb install -p test.apk ##部分应用程序安装 注意：如果应用已经安装了，需要使用 adb install –r [ apk 文件] 相当于升级安装 adb uninstall从模拟器/设备中删除一个包。 adb uninstall [options] &lt;PACKAGE&gt; 12adb uninstall com.test.appadb uninstall -k com.test.app ##在包删除后保留数据和缓存目录. adb shell pm list packages打印所有包，可选的只有那些包名包含文本的包。 adb shell pm list packages [options] &lt;FILTER&gt; 1234567891011121314151617adb shell pm list packagesadb shell pm list packages -f ##看到他们的相关文件.adb shell pm list packages -d ##只显示禁用的包.adb shell pm list packages -e ##过滤仅显示已启用的包.adb shell pm list packages -s ##只显示系统包.adb shell pm list packages -3 ##筛选只显示第三方包.adb shell pm list packages -i ##查看包的安装程序.adb shell pm list packages -u ##还包括卸载包.adb shell pm list packages --user &lt;USER_ID&gt; ##查询用户空间. adb shell pm path打印给定的APK的路径。 adb shell pm path &lt;PACKAGE&gt; 1adb shell pm path com.android.phone package:/system/priv-app/TeleService/TeleService.apk adb shell pm clear删除一个包相关的所有数据。 adb shell pm clear &lt;PACKAGE&gt; 1adb shell pm clear com.test.abc 注意:清除应用程序数据，缓存 文件管理器adb pull从模拟器/设备下载指定的文件到您的计算机 adb pull &lt;remote&gt; [local] 1adb pull /sdcard/demo.mp4 下载/sdcard/demo.mp4 到/platform-tools目录。 1adb pull /sdcard/demo.mp4 e:\\ 下载/sdcard/demo.mp4 到E盘。 adb push从你的电脑上上传一个指定的文件到一个模拟器/设备。 adb push &lt;local&gt; &lt;remote&gt; 1adb push test.apk /sdcard 复制 /platform-tools/test.apk 到 /sdcard 目录 1adb push d:\\test.apk /sdcard 复制 d:\\test.apk 到 /sdcard 目录 adb shell ls列出目录的内容 ls [options] &lt;directory&gt; 步骤1 1adb shell 步骤2 123456lsls -a ##不隐藏条目ls -i ##每个文件的打印索引号ls -s ##每个文件的打印大小，在块中ls -n ##列出数字uid和gidls -R ##递归地列出子目录 注意:按 Ctrl-C停止 adb shell cd改变当前工作目录 步骤1 1adb shell 步骤2 1cd /system adb shell rm删除文件或目录 步骤1 1adb shell 步骤2 12345rm /sdcard/test.txtrm -f /sdcard/test.txt ## 强制删除没有提示rm -r /sdcard/tmp ## 递归地删除目录的内容rm -d /sdcard/tmp ## 删除目录，即使它是一个非空目录rm -i /sdcard/test.txt ## 提示符之前删除 ⚠️:rm -d相当于rmdir命令 adb shell mkdir创建目录 mkdir [options] &lt;directory name&gt; 123mkdir /sdcard/tmpmkdir -m 777 /sdcard/tmp ## 设置权限模式mkdir -p /sdcard/tmp/sub1/sub2 ## 根据需要创建父目录 adb shell touch创建空文件或更改文件时间戳 touch [options] &lt;file&gt; 步骤1 1adb shell 步骤2 1touch /sdcard/tmp/test.txt adb shell pwd打印当前工作目录位置。 1pwd adb shell cp复制文件和目录 cp [options] &lt;source&gt; &lt;dest&gt; 步骤1 1adb shell 步骤2 1cp /sdcard/test.txt /sdcard/demo.txt adb shell mv移动或重命名文件 mv [options] &lt;source&gt; &lt;dest&gt; 步骤1 1adb shell 步骤2 12mv /sdcard/tmp /system/tmp ## 移动mv /sdcard/tmp /sdcard/test ## 重命名 网络adb shell netstat网络统计信息 netstat 步骤1 1adb shell 步骤2 1netstat adb shell ping测试两个网络连接之间的连接和延迟。 ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface] [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline] [-W timeout] [hop1 ...] destination 步骤1 1adb shell 步骤2 12ping www.google.comping www.google.com -c 4 adb shell netcfg通过配置文件配置和管理网络连接 netcfg [&lt;interface&gt; {dhcp|up|down}] 步骤1 1adb shell 步骤2 1netcfg adb shell ip显示、操作路由、设备、策略路由和隧道 ip [ OPTIONS ] OBJECT OBJECT := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp } OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]} 步骤1 1adb shell 步骤2 1ip -f inet addr show wlan0 ## 显示WiFi IP地址 调试adb logcat将日志数据打印到屏幕上。 adb logcat [option] [filter-specs] 1adb logcat 1234567adb logcat *:V ## 最低优先级，过滤只显示详细级别adb logcat *:D ## 只显示调试级别adb logcat *:I ## 只显示信息级别的过滤器adb logcat *:W ## 只显示警告级别adb logcat *:E ## 只显示错误级别adb logcat *:F ## 仅显示致命级别的过滤器adb logcat *:S ## 无声的，最高的优先级，没有任何东西被打印出来 adb logcat -b &lt;Buffer&gt; 123adb logcat -b radio ## 查看包含无线/电话相关消息的缓冲区.adb logcat -b event ## 查看包含与事件相关的消息的缓冲区.adb logcat -b main ## 默认的 1234567adb logcat -c ## 清除整个日志和退出。adb logcat -d ## 将日志转储到屏幕并退出。adb logcat -f ## test.logs记录日志消息输出以进行test.logs。adb logcat -g ## 打印指定的日志缓冲区和退出的大小。adb logcat -n &lt;count&gt; ## 将旋转日志的最大数量设置为可数。adb logcat -r &lt;kbytes&gt; ## 将日志文件旋转到输出的每一个字节。adb logcat -s ## 设置默认的过滤器规范为静默。 adb logcat -v &lt;format&gt; 1234567adb logcat -v brief ## D显示发送消息(默认格式)的进程的优先级/标记和PID.adb logcat -v process ## 只显示PID)adb logcat -v tag ## 只显示优先级/标记。adb logcat -v raw ## 显示原始的日志消息，没有其他的元数据字段。adb logcat -v time ## 显示发出消息的日期、调用时间、优先级/标记和PID。adb logcat -v threadtime ## 显示发出消息的线程的日期、调用时间、优先级、标记和PID和TID。adb logcat -v long ## 显示所有元数据字段和用空行分隔的消息。 adb shell dumpsys转储文件系统数据 把当前系统中所有应用运行的四大组件都会打印出来 adb shell dumpsys [options] 1234567adb shell dumpsysadb shell dumpsys meminfoadb shell dumpsys batteryadb shell dumpsys batterystats ## 从你的设备收集电池数据adb shell dumpsys batterystats --reset ## 消除旧的收集数据adb shell dumpsys activityadb shell dumpsys gfxinfo com.android.phone ## 测量com.android.phone 用户界面性能 adb shell dumpsys activity top可以查看当前应用的 activity 信息 用法： 运行需要查看的应用，然后运行此命令即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$ adb shell dumpsys activity topTASK com.android.settings id=513 ACTIVITY com.android.settings/.MainSettings f08d06d pid=7492 Local Activity d9b221 State: mResumed=true mStopped=false mFinished=false mChangingConfigurations=false mCurrentConfig=&#123;1.0 ?mcc?mnc zh_CN ldltr sw360dp w360dp h616dp 320dpi nrml long port finger -keyb/v/h -nav/h s.4 themeChanged=0 themeChangedFlags=0&#125; mLoadersStarted=true Active Fragments in c1729ea: #0: SettingsFragment&#123;99e54db #0 id=0x1020002&#125; mFragmentId=#1020002 mContainerId=#1020002 mTag=null mState=5 mIndex=0 mWho=android:fragment:0 mBackStackNesting=0 mAdded=true mRemoving=false mResumed=true mFromLayout=false mInLayout=false mHidden=false mDetached=false mMenuVisible=true mHasMenu=false mRetainInstance=false mRetaining=false mUserVisibleHint=true mFragmentManager=FragmentManager&#123;c1729ea in HostCallbacks&#123;2a70b78&#125;&#125; mHost=android.app.Activity$HostCallbacks@2a70b78 mContainer=android.widget.FrameLayout&#123;3f44a4f V.E...... ........ 0,128-720,1280 #1020002 android:id/content&#125; mView=com.miui.internal.widget.ActionBarOverlayLayout&#123;aa116cc V.E...... ........ 0,0-720,1152 #100b004e miui:id/action_bar_overlay_layout&#125; Child FragmentManager&#123;d6ea251 in SettingsFragment&#123;99e54db&#125;&#125;: FragmentManager misc state: mHost=android.app.Activity$HostCallbacks@2a70b78 mContainer=android.app.Fragment$1@935fab6 mParent=SettingsFragment&#123;99e54db #0 id=0x1020002&#125; mCurState=5 mStateSaved=false mDestroyed=false Added Fragments: #0: SettingsFragment&#123;99e54db #0 id=0x1020002&#125; FragmentManager misc state: mHost=android.app.Activity$HostCallbacks@2a70b78 mContainer=android.app.Activity$HostCallbacks@2a70b78 mCurState=5 mStateSaved=false mDestroyed=false ViewRoot: mAdded=true mRemoved=false mConsumeBatchedInputScheduled=false mConsumeBatchedInputImmediatelyScheduled=false mPendingInputEventCount=0 mProcessInputEventsScheduled=false mTraversalScheduled=false android.view.ViewRootImpl$NativePreImeInputStage: mQueueLength=0 android.view.ViewRootImpl$ImeInputStage: mQueueLength=0 android.view.ViewRootImpl$NativePostImeInputStage: mQueueLength=0 Choreographer: mFrameScheduled=false mLastFrameTime=113407 (34516 ms ago) View Hierarchy: com.android.internal.policy.PhoneWindow$DecorView&#123;430fc62 V.E...... R....... 0,0-720,1280&#125; com.miui.internal.widget.ActionBarOverlayLayout&#123;1267cae V.E...... ........ 0,0-720,1280 #100b004e miui:id/action_bar_overlay_layout&#125; android.widget.FrameLayout&#123;3f44a4f V.E...... ........ 0,128-720,1280 #1020002 android:id/content&#125; android.widget.FrameLayout&#123;9dc5534 V.E...... ........ 0,0-720,1152&#125; miui.view.ViewPager&#123;efe4f5d VFED..... ........ 0,0-720,1152 #100b0000 miui:id/view_pager&#125; android.widget.ListView&#123;8c295a3 G.ED.VC.. ......I. 0,0-0,0 #102000a android:id/list&#125; com.miui.internal.widget.ActionBarOverlayLayout&#123;aa116cc V.E...... ........ 0,0-720,1152 #100b004e miui:id/action_bar_overlay_layout&#125; android.widget.FrameLayout&#123;9510d15 V.E...... ........ 0,0-720,1152 #1020002 android:id/content&#125; android.widget.FrameLayout&#123;16c61d0 V.E...... ........ 0,0-720,1152&#125; android.widget.ListView&#123;7d335c9 VFED.VC.. .F...... 0,0-720,1152 #102000a android:id/list&#125; ... ... Looper (main, tid 1) &#123;d2363b7&#125; Message 0: &#123; when=+23s220ms what=1 target=com.xiaomi.mistatistic.sdk.controller.p$1 &#125; (Total messages: 1, polling=false, quitting=false) adb shell dumpsys package可以查看指定包名应用的详细信息(相当于应用的 AndroidManifest.xml 中的内容) adb shell dumpsys package [pkgname] 123456789101112131415$ adb shell dumpsys package com.android.settingsActivity Resolver Table: Full MIME Types: vnd.android.cursor.item/telephony-carrier: 94d08b7 com.android.settings/.MiuiApnEditor vnd.android.document/root: 2fea824 com.android.settings/.Settings$PublicVolumeSettingsActivity vnd.android.cursor.dir/telephony-carrier: 94d08b7 com.android.settings/.MiuiApnEditor Base MIME Types: vnd.android.document: 2fea824 com.android.settings/.Settings$PublicVolumeSettingsActivity ... ... 这里看到就是相当于把应用的清单文件打印出来而已。 adb shell dumpsys meminfo可以查看指定进程名或者是进程 id 的内存信息 adb shell dumpsys meminfo [pname/pid] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ adb shell dumpsys meminfo 7492Applications Memory Usage (kB):Uptime: 1360979 Realtime: 1360979** MEMINFO in pid 7492 [com.android.settings] ** Pss Private Private Swapped Heap Heap Heap Total Dirty Clean Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ ------ Native Heap 4526 4440 0 0 8384 7508 875 Dalvik Heap 6077 6016 36 3872 15479 10500 4979 Dalvik Other 994 992 0 4 Stack 280 280 0 0 Ashmem 12 12 0 0 Gfx dev 3228 3180 0 0 Other dev 4 0 4 0 .so mmap 733 208 0 2516 .apk mmap 13 0 0 0 .dex mmap 260 32 116 20 .oat mmap 1101 200 200 4 .art mmap 1809 1564 28 104 Other mmap 11 8 0 0 Unknown 261 260 0 0 TOTAL 19309 17192 384 6520 23863 18008 5854 App Summary Pss(KB) ------ Java Heap: 7608 Native Heap: 4440 Code: 756 Stack: 280 Graphics: 3180 Private Other: 1312 System: 1733 TOTAL: 19309 TOTAL SWAP (KB): 6520 Objects Views: 122 ViewRootImpl: 1 AppContexts: 4 Activities: 1 Assets: 5 AssetManagers: 2 Local Binders: 49 Proxy Binders: 32 Parcel memory: 6 Parcel count: 27 Death Recipients: 2 OpenSSL Sockets: 0 SQL MEMORY_USED: 0 PAGECACHE_OVERFLOW: 0 MALLOC_SIZE: 62 利用这个命令可以查看进程当前的内存情况 adb shell dumpsys dbinfo可以查看指定包名应用的数据库存储信息(包括存储的sql语句) adb shell dumpsys dbinfo [packagename] 12345678910111213141516171819202122232425262728293031323334$ adb shell dumpsys dbinfo com.android.mmsApplications Database Info:** Database info for pid 11635 [com.android.mms] **Connection pool for /data/user/0/com.android.mms/databases/cache.db: Open: true Max connections: 1 Available primary connection: Connection #0: isPrimaryConnection: true onlyAllowReadOnlyOperations: true Most recently executed operations: 0: [2017-12-25 10:37:27.000] executeForCursorWindow took 1ms - succeeded, sql=\"SELECT action_id, action, timestamp FROM ad_cache\" 1: [2017-12-25 10:37:27.000] prepare took 0ms - succeeded, sql=\"SELECT action_id, action, timestamp FROM ad_cache\" 2: [2017-12-25 10:37:26.999] executeForLong took 1ms - succeeded, sql=\"PRAGMA user_version;\" 3: [2017-12-25 10:37:26.999] prepare took 0ms - succeeded, sql=\"PRAGMA user_version;\" 4: [2017-12-25 10:37:26.998] executeForString took 1ms - succeeded, sql=\"SELECT locale FROM android_metadata UNION SELECT NULL ORDER BY locale DESC LIMIT 1\" 5: [2017-12-25 10:37:26.995] execute took 3ms - succeeded, sql=\"CREATE TABLE IF NOT EXISTS android_metadata (locale TEXT)\" 6: [2017-12-25 10:37:26.995] executeForLong took 0ms - succeeded, sql=\"PRAGMA wal_autocheckpoint=100\" 7: [2017-12-25 10:37:26.995] executeForLong took 0ms - succeeded, sql=\"PRAGMA wal_autocheckpoint\" 8: [2017-12-25 10:37:26.995] executeForLong took 0ms - succeeded, sql=\"PRAGMA journal_size_limit=524288\" 9: [2017-12-25 10:37:26.995] executeForLong took 0ms - succeeded, sql=\"PRAGMA journal_size_limit\" 10: [2017-12-25 10:37:26.995] executeForString took 0ms - succeeded, sql=\"PRAGMA synchronous\" 11: [2017-12-25 10:37:26.995] executeForString took 0ms - succeeded, sql=\"PRAGMA journal_mode=PERSIST\" 12: [2017-12-25 10:37:26.994] executeForString took 1ms - succeeded, sql=\"PRAGMA journal_mode\" 13: [2017-12-25 10:37:26.994] executeForLong took 0ms - succeeded, sql=\"PRAGMA foreign_keys\" 14: [2017-12-25 10:37:26.993] executeForLong took 1ms - succeeded, sql=\"PRAGMA page_size\" Available non-primary connections: &lt;none&gt; Acquired connections: &lt;none&gt; Connection waiters: &lt;none&gt; 这里可以清晰的看到应用执行过的 sql 语句信息。在对应用逆向的时候具有一定用途。毕竟可以查看应用操作数据库信息了。 adb shell dumpstate转储状态 12adb shell dumpstateadb shell dumpstate &gt; state.logs ## 将状态转储到文件中 adb shell input text输入文本内容 adb shell input text [需要输入文本框内容] 案例： 让需要输入内容的文本框获取焦点，adb shell input text ‘HelloWorld’ 注意：这个命令也可以模拟物理按键，虚拟键盘，滑动，滚动等事件 延伸：这个命令对于我们在需要输入一大堆信息到文本框中的时候非常有用，比如现在你在 PC 端有一段内容，想输入到手机的某个搜索框中，那么你可以通过把这段内容发送到手机，然后在复制操作。但是有了这个命令就非常简单，先让你想要输入的文本框获取焦点，然后运行这个命令即可。 截图adb shell screencap截屏操作。 adb shell screencap &lt;filename&gt; 1adb shell screencap /sdcard/screen.png 从设备中下载文件 1adb pull /sdcard/screen.png adb shell screenrecord [4.4+]录屏操作 录屏运行Android 4.4(API级别19)或更高的设备。 adb shell screenrecord [options] &lt;filename&gt; 1adb shell screenrecord /sdcard/demo.mp4 从设备中下载文件 1adb pull /sdcard/demo.mp4 注意:按下Ctrl-C停止屏幕记录，否则记录在三分钟内自动停止，或按时间限制设定的时间限制。 1adb shell screenrecord --size &lt;WIDTHxHEIGHT&gt; 设置视频大小:1280x720。默认值是设备的本地显示分辨率(如果支持的话)，如果不是的话，则是1280x720。为了得到最好的结果，使用你的设备的高级视频编码(AVC)编码器所支持的尺寸。 1adb shell screenrecord --bit-rate &lt;RATE&gt; 设置视频的视频比特率，以每秒兆比特的速度。默认值是4Mbps。你可以增加比特率来提高视频质量，但是这样做会导致更大的电影文件。下面的示例将记录比特率设置为5Mbps:adb shell screenrecord –bit-rate 5000000 /sdcard/demo.mp4 1adb shell screenrecord --time-limit &lt;TIME&gt; 设置最大的记录时间，以秒计。默认值和最大值是180(3分钟)。 1adb shell screenrecord --rotate 将输出旋转90度。这个特性是实验性的。 1adb shell screenrecord --verbose 在命令行屏幕上显示日志信息。如果您不设置此选项，则该实用程序在运行时不会显示任何信息。 系统adb root使用根权限重新启动adbd守护进程 1adb root 注意:adbd不能在生产构建中作为root运行(在模拟器中进行测试) adb sideloadflashing/恢复 Android update.zip包。 1adb sideload &lt;update.zip&gt; 注意:adb重新启动Android M+ adb shell ps打印进程状态 ps [options] 步骤1 1adb shell 步骤2 12psps -p adb shell top显示最高CPU进程 top [options] 步骤1 1adb shell 步骤2 12toptop -t ## 显示线程而不是进程. adb shell getprop通过安卓property服务获得property getprop [options] 步骤1 1adb shell 步骤2 1234getpropgetprop ro.build.version.sdkgetprop ro.chipnamegetprop | grep adb adb shell setprop设置property服务 setprop &lt;key&gt; &lt;value&gt; 步骤1 1adb shell 步骤2 1setprop service.adb.tcp.port 5555","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"ADB","slug":"Android/ADB","permalink":"https://jigangduan.github.io/categories/Android/ADB/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"adb","slug":"adb","permalink":"https://jigangduan.github.io/tags/adb/"}]},{"title":"掌握Android NDK构建系统——第2部分:独立的工具链","slug":"MasteringAndroidNDKBuildSystem2","date":"2017-11-02T03:31:23.000Z","updated":"2020-07-25T02:57:18.159Z","comments":true,"path":"2017/11/02/MasteringAndroidNDKBuildSystem2/","link":"","permalink":"https://jigangduan.github.io/2017/11/02/MasteringAndroidNDKBuildSystem2/","excerpt":"[翻译]掌握Android NDK构建系统——第2部分:独立的工具链原英文文章 这是“掌握NDK”的第2部分。在前面的部分(第1部分)中，我们介绍了如何使用ndk-build构建Android本地项目，我们还介绍了一些高级技术来管理和定制大型项目的构建脚本。 尽管对于大多数Android本地项目来说，ndk-build可能已经足够了，但是在某些情况下仍然可能需要独立的工具链。例如，如果您已经有一个c/c++项目，它可能非常复杂，并且有一个复杂的makefile。在这种情况下，你可能不想把所有东西都转换成Android.mk和Application.mk。在这种情况下，使用独立的工具链更有意义，它允许您保留最初的makefile，或者重用大多数原始makefile。因此，在本部分中，我将简要介绍独立工具链的用法，并给出一些代码示例。 所有例子的源代码可以在这里找到:https://github.com/robertwgh/mastering-ndk。","text":"[翻译]掌握Android NDK构建系统——第2部分:独立的工具链原英文文章 这是“掌握NDK”的第2部分。在前面的部分(第1部分)中，我们介绍了如何使用ndk-build构建Android本地项目，我们还介绍了一些高级技术来管理和定制大型项目的构建脚本。 尽管对于大多数Android本地项目来说，ndk-build可能已经足够了，但是在某些情况下仍然可能需要独立的工具链。例如，如果您已经有一个c/c++项目，它可能非常复杂，并且有一个复杂的makefile。在这种情况下，你可能不想把所有东西都转换成Android.mk和Application.mk。在这种情况下，使用独立的工具链更有意义，它允许您保留最初的makefile，或者重用大多数原始makefile。因此，在本部分中，我将简要介绍独立工具链的用法，并给出一些代码示例。 所有例子的源代码可以在这里找到:https://github.com/robertwgh/mastering-ndk。 目录 在我们开始之前 ndk-build工作流 为您的项目使用定制的工具链 总结 在我们开始之前Android NDK官方文档包含一章“标准工具链”，它提供了关于独立工具链的有用信息。但是，该文档缺少详细信息，并且没有示例来演示使用情况。因此，可能很难遵循官方文件。但无论如何，这仍然是一个很好的参考。 ndk-build工作流实际上，当我们使用ndk-build时，如果我们启用调试选项V=1，如下: 1ndk-build V=1 我们将看到ndk-build实际做了什么。下面的控制台打印来自于示例1的编译。 12345678910111213141516$ ndk-build V=1rm -f ./libs/arm64-v8a/lib*.so ./libs/armeabi/lib*.so ./libs/armeabi-v7a/lib*.so ./libs/armeabi-v7a-hard/lib*.so ./libs/mips/lib*.so ./libs/mips64/lib*.so ./libs/x86/lib*.so ./libs/x86_64/lib*.sorm -f ./libs/arm64-v8a/gdbserver ./libs/armeabi/gdbserver ./libs/armeabi-v7a/gdbserver ./libs/armeabi-v7a-hard/gdbserver ./libs/mips/gdbserver ./libs/mips64/gdbserver ./libs/x86/gdbserver ./libs/x86_64/gdbserverrm -f ./libs/arm64-v8a/gdb.setup ./libs/armeabi/gdb.setup ./libs/armeabi-v7a/gdb.setup ./libs/armeabi-v7a-hard/gdb.setup ./libs/mips/gdb.setup ./libs/mips64/gdb.setup ./libs/x86/gdb.setup ./libs/x86_64/gdb.setup[armeabi-v7a] Compile++ thumb: hello &lt;= hello.cpp/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-g++ -MMD -MP -MF ./obj/local/armeabi-v7a/objs-debug/hello/hello.o.d.org -fpic -ffunction-sections -funwind-tables -fstack-protector -no-canonical-prefixes -march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=softfp -fno-exceptions -fno-rtti -mthumb -Os -g -DNDEBUG -fomit-frame-pointer -fno-strict-aliasing -finline-limit=64 -O0 -UNDEBUG -marm -fno-omit-frame-pointer -ID:/development/android-ndk-r10d/sources/cxx-stl/stlport/stlport -ID:/development/android-ndk-r10d/sources/cxx-stl//gabi++/include -Ijni -DANDROID -Wa,--noexecstack -Wformat -Werror=format-security -fPIE -frtti -frtti -fexceptions -ID:/development/android-ndk-r10d/platforms/android-19/arch-arm/usr/include -c jni/hello.cpp -o ./obj/local/armeabi-v7a/objs-debug/hello/hello.o &amp;&amp; ./obj/convert-dependencies.sh ./obj/local/armeabi-v7a/objs-debug/hello/hello.o.d[armeabi-v7a] Executable : hello/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-g++ -Wl,--gc-sections -Wl,-z,nocopyreloc --sysroot=D:/development/android-ndk-r10d/platforms/android-19/arch-arm -Wl,-rpath-link=D:/development/android-ndk-r10d/platforms/android-19/arch-arm/usr/lib -Wl,-rpath-link=./obj/local/armeabi-v7a ./obj/local/armeabi-v7a/objs-debug/hello/hello.o D:/development/android-ndk-r10d/sources/cxx-stl/stlport/libs/armeabi-v7a/thumb/libstlport_static.a -lgcc -no-canonical-prefixes -march=armv7-a -Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -fPIE -pie -lc -lm -o ./obj/local/armeabi-v7a/hello[armeabi-v7a] Install : hello =&gt; libs/armeabi-v7a/helloinstall -p ./obj/local/armeabi-v7a/hello ./libs/armeabi-v7a/hello/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-strip --strip-unneeded ./libs/armeabi-v7a/hello 我们可以看到，ndk-build实际上做了如下的事情: 在输出文件夹libs中删除以前构建的文件。 从源代码构建hello.o。 从hello.o构建可执行。 根据ABI，将可执行文件复制到子文件夹里的文件夹。 上面的构建信息显示了ndk-build如何调用工具链来构建项目。基本上/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-g++是一个独立的工具链在NDK安装中。如果我们读取整个命令，我们会发现该命令只调用了cross-compilation版本的g++，并带有诸如include路径、库路径等构建参数。使用独立的工具链最直接的方法是模仿ndk-build的工作方式，并直接根据目标体系结构和平台调用正确的编译器。 在NDK_ROOT/toolchains目录下，我们可以找到ARM、X86、x8664、MIPS等不同的工具链。还有不同编译器的版本，比如g++和clang。因此，我们基本上可以选择适合我们项目的任何东西。 为您的项目使用定制的工具链显然，上面的方法是有效的，但是它非常冗长，不适合较大的项目。我们所能做的是为特定的平台和ABI创建一个“customized”工具链，借助NDK安装中提供的$NDK/build/tools/make-standalone-toolchain.sh工具的帮助。 让我们来看一个例子。假设我们有一个具有以下配置的项目: 支持android-19平台。 主机系统是Windows 7 64位。 目标架构是ARM。 我们可以创建一个脚本generate_standalone_toolchain.sh帮助我们输出我们需要的工具链: 12345NDK=/cygdrive/d/development/android-ndk-r10dSYSROOT=$NDK/platforms/android-19/arch-arm/mkdir -p /cygdrive/d/development/standalone_toolchain/$NDK/build/tools/make-standalone-toolchain.sh --arch=arm --platform=android-19 --system=windows-x86_64 --install-dir=/cygdrive/d/development/standalone_toolchain/chmod -R 755 /cygdrive/d/development/standalone_toolchain 辅助脚本$NDK/build/tools/make-standalone-toolchain.sh在/tmp下创建一个临时目录，将文件复制到该目录，并最终将文件复制到指定的文件夹。请确保您有足够的权限，否则在访问/tmp目录时将遇到“权限拒绝”错误。 如果正确配置了路径，我们应该看到以下控制台信息: 12345678$ ./generate_standalone_toolchain.shAuto-config: --toolchain=arm-linux-androideabi-4.8Copying prebuilt binaries...Copying sysroot headers and libraries...Copying c++ runtime headers and libraries...Copying files to: /cygdrive/d/development/standalone_toolchain/Cleaning up...Done. 一旦这样做,我们可以看到整个工具链复制从NDK_ROOT/toolchains到/cygdrive/d/development/standalone_toolchain/。 示例: helloworld为了测试定制的工具链，我们创建了一个示例项目helloworld。项目结构非常简单: 123+-- helloworld| +-- hello.cpp| +-- Makefile hello.cpp 12345#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;&#125; Makefile 1234567891011121314151617STANDALONE_TOOLCHAIN=/cygdrive/d/development/standalone_toolchain/bin/CC=$(STANDALONE_TOOLCHAIN)/arm-linux-androideabi-gccCXX=$(STANDALONE_TOOLCHAIN)/arm-linux-androideabi-g++CFLAGS=-march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -c -WallLDFLAGS=-march=armv7-a -Wl,--fix-cortex-a8SOURCES=hello.cppOBJECTS=$(SOURCES:.cpp=.o)EXECUTABLE=helloall: $(SOURCES) $(EXECUTABLE)$(EXECUTABLE): $(OBJECTS) $(CXX) $(LDFLAGS) $(OBJECTS) -o $@.cpp.o: $(CXX) $(CFLAGS) $&lt; -o $@clean: rm *.o hello; 我们可以简单地按照下面的方式编译代码，我们将得到可执行文件: 1234$ cd helloworld$ make/cygdrive/d/development/standalone_toolchain/bin//arm-linux-androideabi-g++ -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -c -Wall hello.cpp -o hello.o/cygdrive/d/development/standalone_toolchain/bin//arm-linux-androideabi-g++ -march=armv7-a -Wl,--fix-cortex-a8 hello.o -o hello 另一个示例:clcompute这是一个比较复杂的例子，使用OpenCL进行平行矢量加法。假设我们有CL和库文件可用: 12345+-- D:\\opencl_lib| +-- include| +-- CL| +-- libs| +-- libOpenCL.so CL包含头文件可以从Khronos组网站上下载。而libopenclso库文件可以从一个具有opencl功能的手机中检索到。你可以使用adb pull从你的手机(或平板电脑)中拉出它。您可以参考本文的第1部分中的表，以获得ibOpenCL.so的详细位置。对于不同的SoC芯片组。 项目结构: 123+-- clcompute| +-- clcompute.cpp| +-- Makefile Makefile 12345678910111213141516171819STANDALONE_TOOLCHAIN=/cygdrive/d/development/standalone_toolchain/bin/OPENCL=/cygdrive/d/opencl_lib/CC=$(STANDALONE_TOOLCHAIN)/arm-linux-androideabi-gccCXX=$(STANDALONE_TOOLCHAIN)/arm-linux-androideabi-g++CFLAGS=-march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -c -I $(OPENCL)/inc/LDFLAGS=-march=armv7-a -Wl,--fix-cortex-a8 -L$(OPENCL)/libs/ -lOpenCLSOURCES=clcompute.cppOBJECTS=$(SOURCES:.cpp=.o)EXECUTABLE=clcomputeall: $(SOURCES) $(EXECUTABLE)$(EXECUTABLE): $(OBJECTS) $(CXX) $(LDFLAGS) $(OBJECTS) -o $@.cpp.o: $(CXX) $(CFLAGS) $&lt; -o $@clean: rm *.o $(EXECUTABLE); 正如您所看到的，一旦您导出了独立的工具链，当您指定了通往工具链的路径时，makefile基本上与普通的makefile相同。我们可以想象，通过使用独立的工具链，我们可以构建一些复杂的项目，这些项目可能需要大量的工作，这是使用ndk-build的 总结在这个技术说明(第1部分和第2部分)中，我们介绍了与Android本地项目编译相关的使用和技术。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"https://jigangduan.github.io/categories/Android/NDK/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"ndk","slug":"ndk","permalink":"https://jigangduan.github.io/tags/ndk/"},{"name":"翻译","slug":"翻译","permalink":"https://jigangduan.github.io/tags/翻译/"}]},{"title":"掌握Android NDK构建系统——第1部分:使用ndk-build技巧","slug":"MasteringAndroidNDKBuildSystem1","date":"2017-11-01T10:31:23.000Z","updated":"2020-07-25T02:57:18.159Z","comments":true,"path":"2017/11/01/MasteringAndroidNDKBuildSystem1/","link":"","permalink":"https://jigangduan.github.io/2017/11/01/MasteringAndroidNDKBuildSystem1/","excerpt":"[翻译]掌握Android NDK构建系统——第1部分:使用ndk-build技巧原英文文章 这篇文章不是一个“Hello world!”类型的NDK”教程。尽管我仍将简要介绍ndk构建的基本知识，但这并不是本文的重点。相反，我将总结一些非常有用的NDK技巧和我在项目中使用的技巧。希望这些建议对于那些想要建立一些实际项目的人来说是非常有用的，而不是一个学习NDK的玩具项目。因此，目标读者是中或高级Android开发人员。这篇文章包含两个部分: 第1部分:ndk-build 在这一部分中，我们将讨论如何灵活地使用ndk-build来构建您的项目，以及如何组织您的项目的文件结构。 第2部分:独立的工具链 在第2部分中，将讨论独立工具链的设置和使用。 所有例子的源代码可以在这里找到:https://github.com/robertwgh/mastering-ndk。","text":"[翻译]掌握Android NDK构建系统——第1部分:使用ndk-build技巧原英文文章 这篇文章不是一个“Hello world!”类型的NDK”教程。尽管我仍将简要介绍ndk构建的基本知识，但这并不是本文的重点。相反，我将总结一些非常有用的NDK技巧和我在项目中使用的技巧。希望这些建议对于那些想要建立一些实际项目的人来说是非常有用的，而不是一个学习NDK的玩具项目。因此，目标读者是中或高级Android开发人员。这篇文章包含两个部分: 第1部分:ndk-build 在这一部分中，我们将讨论如何灵活地使用ndk-build来构建您的项目，以及如何组织您的项目的文件结构。 第2部分:独立的工具链 在第2部分中，将讨论独立工具链的设置和使用。 所有例子的源代码可以在这里找到:https://github.com/robertwgh/mastering-ndk。 目录 介绍 先决条件 ndk-build的基本知识 使用NDK构建本地可执行文件 有用的技术 如何在jni目录中编译源代码 去掉jni文件夹 为makefile使用自定义名称 使用include嵌入.mk文件 关于LOCAL_PATH和CLEAR_VARS 如何调试.mk makefile 针对多个目标体系结构的构建 总结 介绍Android NDK(本地开发工具包)是Android应用程序开发人员的一种强大工具，他们想要高效和高性能的本地代码，或者需要处理底层硬件细节(如OpenGL、OpenCL等)。 Android NDK官方文档(在线版本)是OK的，如果你已经使用NDK工作过一段时间了。不过，它并不是专门为刚开始使用Android NDK开发的人设计的。官方文件的问题是没有重点，因此重要的信息很容易被忽视。 还有许多在线教程和文章展示了NDK的基础和NDK构建工具的使用。然而，这些信息到处都是。没有一个地方可以深入地讨论这些主题和技术。希望本文能涵盖其中的一些内容。 先决条件在本文中，我提出以下假设: 你知道NDK是什么; 你了解C/C++; 你已经在电脑上安装了Android NDK。在我的设置中，我安装在D:\\development\\android-ndk-r10d下面。在本文的后面部分，我将调用这条路径NDK_ROOT。 为了避免使用ndk-build时的长路径名，我将NDK_ROOT添加到系统PATH环境变量中。 ndk-build的基本知识当然，使用Android NDK的第一步是从Android开发者网络下载NDK安装包。在安装NDK包之后，这些是您得到的: NDK_ROOT\\ndk-build.cmd脚本; NDK_ROOT\\docs 文档; 工具链和编译器; 一些本地库的源代码; 一些示例代码。 如果您想了解基本的设置和NDK的makefile的语法，那么示例代码可能非常有用。通过NDK提供的示例代码，您将发现大多数代码示例，如果您正在开发一个Android应用程序项目，并将使用NDK来构建Android应用程序的JNI部分。这就是为什么您注意到所有的项目都在jni文件夹下放置c/c++源代码和makefile。 以下是NDK示例的典型文件结构: structure1234567+-- project_root| +-- jni| +-- Android.mk| +-- Application.mk| +-- main.c| +-- obj| +-- libs 如您所见，jni目录是整个NDK项目的核心，它包含c/c++源代码，两个makefile Android.mk和Application.mk。稍后将讨论，您将看到c/c++源代码并不需要放在jni文件夹中。此外，您不需要为makefile提供完全相同的名称。但作为一个起点，使用ndroid.mk和Application.mk将是最简单的方法，可以为你节省大量的精力，除非你真的不喜欢makefile的当前名称。默认情况下，ndk-build将尝试定位 另外两个文件夹obj和libs是由NDK构建系统生成的，它们分别包含中间文件和最终的二进制代码。 Android.mk和Application.mk是NDK项目最重要的makefile文件。 Android.mk更像是一个传统的makefile，定义源代码、包含头文件的路径、链接器的路径来定位库、模块名、构建类型等等。 Application.mk定义了Android应用程序相关的属性，如Android SDK版本、调试或发布模式、目标平台ABI(架构二进制接口)、标准c/c++库等。 一个典型的Android.mk 12345LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := &lt;module_name&gt; # 命名你的模块.LOCAL_SRC_FILES := main.cinclude $(BUILD_SHARED_LIBRARY) 最小Application.mk 1APP_ABI := all 为了构建这样的项目，我们可以访问project_root，并输入ndk-build(假设您在系统PATH中有NDK_ROOT)，NDK构建脚本将自动找到jni文件夹下的本地代码。 12$ cd project_root$ ndk-build 如果代码中没有bug，那么编译后的共享库lib&lt;module_name&gt;.so将会在libs/&lt;abi&gt;/ 目录下生成。一旦你得到了这个共享库文件，你的Android应用程序构建系统将把它打包到最终的APK安装文件中。您将能够在JAVA代码中使用JNI调用本地函数。 在本文中，我们将更多地关注如何使用NDK构建可执行的二进制文件，因为我们将更容易以这种方式测试我们的结果。但是请记住，这里所讨论的所有技术都是相同的，并且可以直接应用到共享库项目中，而不需要任何更改。 使用NDK构建本地可执行文件让我们先建立一个“Hello World！””测试。项目结构将是这样的: structure12345+-- ex1_helloworld| +-- jni| +-- Android.mk| +-- Application.mk| +-- hello.c Hello.cpp 1234567#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl; return 0;&#125; Android.mk 请注意，在.mk文件注释以“#”开头。 123456LOCAL_PATH:= $(call my-dir) # 获取项目的本地路径.include $(CLEAR_VARS) # 用前缀\"LOCAL_\"清除所有变量LOCAL_SRC_FILES:=hello.cpp # 包含源代码.LOCAL_MODULE:= hello # 二进制的名称.include $(BUILD_EXECUTABLE) # 告诉ndk-build，我们想要构建一个本地可执行文件. _ Application.mk_ 12345APP_OPTIM := debug # 在调试模式下构建目标.APP_ABI := armeabi-v7a # 将目标架构定义为ARM.APP_STL := stlport_static # 我们使用stlport作为标准的c/c++库.APP_CPPFLAGS := -frtti -fexceptions # 这是你启用异常的地方.APP_PLATFORM := android-19 # 定义本地应用程序的Android版本. 您可能已经发现，共享库项目和本地项目之间的主要区别仅仅是Android.mk中的一行。 对于一个共享的库，我们使用: 1include $(BUILD_SHARED_LIBRARY) 对于可执行的二进制文件，我们使用:1include $(BUILD_EXECUTABLE) 在这一点上，我们可以构建我们的“Hello World！”NDK项目: 123456$ cd project_root$ ndk-build[armeabi-v7a] Cygwin : Generating dependency file converter script[armeabi-v7a] Compile++ thumb: hello &lt;= hello.cpp[armeabi-v7a] Executable : hello[armeabi-v7a] Install : hello =&gt; libs/armeabi-v7a/hello 然后，我们可以将hello本机程序推到Android设备上运行它(为了实现这一点，我们需要Android ADB工具。请安装Android SDK，并将ANDROID_SDK_ROOT/platform-tools设置为系统PATH。当然，如果您不想费心安装Android SDK，也可以从网上找到ADB安装包。) 12345$ adb root$ adb shell \"mkdir -p /data/mastering_ndk &amp;&amp; chmod 777 /data/mastering_ndk\"$ adb push ./libs/armeabi-v7a/hello /data/mastering_ndk$ adb shell \"cd /data/mastering_ndk &amp;&amp; chmod 777 ./hello &amp;&amp; ./hello\"$ Hello World! 提示:上面的命令只适用于Root设备。如果你没有root权限设备，你可以使用Android原生程序启动工具在任何Android设备上启动本机可执行文件。 我们已经回忆了ndk-build的基本知识。在下一节中，我们将展示一些技术，以便更好地利用NDK构建系统来完成一些更大的项目。 有用的技术如何在jni目录中编译源代码假设您有一个大型项目，可能是一个跨平台的项目，因此很可能您无法轻松地将所有源代码移动到jni文件夹下。实际上需要对现有的Android.mk makefile进行了一些小的修改。下面的例子将展示如何实现这一点。您可以在示例2中找到完整的项目:ex2_src_not_in_jni_folder。 项目结构: structure123456+-- ex2_src_not_in_jni_folder| +-- jni| +-- Android.mk| +-- Application.mk| +-- src| +-- hello.c Android.mk 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= ../src/hello.cppLOCAL_MODULE:= helloinclude $(BUILD_EXECUTABLE) Application.mk是相同的。我们可以构建项目并使用与示例1相同的方式来执行二进制文件。 去掉jni文件夹jni文件夹对于Android应用程序项目中的jni本机项目更有意义。如果我们想要对我们的项目有更有意义的东西，我们可以去掉默认的ndk-build所使用的那个特定文件夹。为了实现这一点，需要适当地设置makefile中的几个变量。以下步骤将实现这一目标。完整的示例项目可以在示例3中找到。 项目结构: structure12345+-- ex3_get_rid_of_jni_folder| +-- Android.mk| +-- Application.mk| +-- src| +-- hello.c 如您所见，我们删除了jni文件夹，并将Android.mk和Application.mk移到project_root文件夹中。 新的Android.mk 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= src/hello.cpp # 这改变了!LOCAL_MODULE:= helloinclude $(BUILD_EXECUTABLE) 新的 Application.mk 123456APP_OPTIM := debugAPP_ABI := armeabi-v7aAPP_STL := stlport_staticAPP_CPPFLAGS := -frtti -fexceptionsAPP_PLATFORM := android-19APP_BUILD_SCRIPT := Android.mk # 这行是新的! 请注意，APP_BUILD_SCRIPT指示整个应用程序的主要makefile条目。在我们的例子中，它是Android.mk。到目前为止，一切看起来都很好，然后，我们使用下面的命令来构建项目，请注意我们在ndk-build命令中添加了NDK_APPLICATION_MK变量，告诉ndk-build在哪里可以找到Application.mk。在本例中，我们使用以下命令: 1$ ndk-build NDK_APPLICATION_MK=./Application.mk 然而，我们将会有以下错误: 1234$ ndk-build NDK_APPLICATION_MK=./Application.mkAndroid NDK: Could not find application project directory !Android NDK: Please define the NDK_PROJECT_PATH variable to point to it./cygdrive/d/development/android-ndk-r10d/build/core/build-local.mk:148: *** Android NDK: Aborting . Stop. NDK_PROJECT_PATH是一个系统环境变量。让我们将它定义到Application.mk所在的位置并重新构建。 123456$ export NDK_PROJECT_PATH=.$ ndk-build NDK_APPLICATION_MK=./Application.mk[armeabi-v7a] Cygwin : Generating dependency file converter script[armeabi-v7a] Compile++ thumb: hello &lt;= hello.cpp[armeabi-v7a] Executable : hello[armeabi-v7a] Install : hello =&gt; libs/armeabi-v7a/hello 还有另一种方法可以修复上面的构建错误。解决方案是在与Application.mk相同的文件夹中创建一个空的AndroidManifest.xml文件 在添加这个虚拟的AndroidManifest.xml文件之后，我们可以在不定义NDK_PROJECT_PATH变量的情况下构建项目。最终的项目结构是: structure123456+-- ex3_get_rid_of_jni_folder| +-- Android.mk| +-- AndroidManifest.xml| +-- Application.mk| +-- src| +-- hello.c 为makefile使用自定义名称我们可以进一步推进前面的技术来定义我们自己的makefile。下面的例子可以在示例4中找到。 在下面的示例中，我们将应用程序makefile重命名为MyApplication.mk，并将模块makefile文件重命名为MyAndroid.mk。 项目结构: structure123456+-- ex4_custom_make_files| +-- MyAndroid.mk| +-- AndroidManifest.xml| +-- MyApplication.mk| +-- src| +-- hello.c MyAndroid.mk和之前的Android.mk是一样的。 新MyApplication.mk 123456APP_OPTIM := debugAPP_ABI := armeabi-v7aAPP_STL := stlport_staticAPP_CPPFLAGS := -frtti -fexceptionsAPP_PLATFORM := android-19APP_BUILD_SCRIPT := MyAndroid.mk 构建命令就变成: 1234$ ndk-build NDK_APPLICATION_MK=./MyApplication.mk[armeabi-v7a] Compile++ thumb: hello &lt;= hello.cpp[armeabi-v7a] Executable : hello[armeabi-v7a] Install : hello =&gt; libs/armeabi-v7a/hello 一切都很好，我们成功地得到了二进制的hello。 使用include嵌入.mk文件为了更好地处理包含多个子模块的大型项目，以静态库、共享库或预构建文件的形式，NDK构建系统允许makefile包含另一个makefile。下面是语法: 1include PATH_TO_MK_FILE/Android.mk 这将包括在PATH_TO_MK_FILE目录下的Android.mk文件到当前makefile。这个“include”特性为我们提供了巨大的灵活性，可以创建一些非常有创意的方式来利用建筑系统。 让我们看一个简单的例子(示例5)，看看它是如何工作的。请注意，这个示例包含一个非常简单的makefile。有了“include”的强大功能，我相信您可以创建更加复杂的构建脚本，无论项目多么复杂，它几乎可以为任何项目做任何事情。 在下面的示例项目中，我们在源文件compute.cpp中有一个main()函数，它调用add()和mul()函数来执行输入号上的添加和乘法。我们在两个子模块中定义add()和mul()函数，并将它们编译成两个静态库。最后，当构建可执行文件时，链接器将把所有内容链接在一起，并生成最终可执行的二进制文件。 因此，为了更好地处理子模块，并将每个子模块分开，在这个项目中，我们为每个模块创建了一个Android.mk。正如您将很快看到的，通过以这种方式组织makefile，项目现在有了一个非常可伸缩的结构。更具体地说，如果您想要在同一个项目中添加一个子小部件，您只需添加另一个子模块文件夹(不管它是什么，比方说，divide)，然后为新的子模块“divide”创建一个新的Android.mk。然后，您只需要在主模块的makefile中更改一行。所有现有的子模块都保持不变。这个项目很容易维护和扩展，以支持更多的功能。 顶层首先，让我们看一下项目结构，并有一个整体的图景: structure1234567891011121314151617+-- ex5_using_include_to_embed_make_files| +-- makefiles| +-- Android.mk| +-- Application.mk| +-- src| +-- main| +-- compute.cpp| +-- Android.mk| +-- submodules| +-- add| +-- add.cpp| +-- Android.mk| +-- mul| +-- mul.cpp| +-- Android.mk | +-- Android.mk | +-- AndroidManifest.xml makefiles/Application.mk 123456APP_OPTIM := debugAPP_ABI := armeabi-v7aAPP_STL := stlport_staticAPP_CPPFLAGS := -frtti -fexceptionsAPP_PLATFORM := android-19APP_BUILD_SCRIPT := makefiles/Android.mk makefiles/Android.mk 12345TOP_LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)include $(TOP_LOCAL_PATH)/../src/submodules/Android.mkinclude $(TOP_LOCAL_PATH)/../src/main/Android.mk 在这里，这个Android.mk作为顶级makefile，包含另外两个Android.mk，一个用于子模块，另一个用于主模块。 主要模块: compute我们首先看一下主模块。 src/main/`compute.cpp` 12345678910111213141516#include &lt;iostream&gt;int add(int a, int b);int mul(int a, int b);int main()&#123; int a = 2; int b = 3; std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; \"add(a, b) = \" &lt;&lt; add(a, b) &lt;&lt; std::endl; std::cout &lt;&lt; \"mul(a, b) = \" &lt;&lt; mul(a, b) &lt;&lt; std::endl; return 0;&#125; src/main/`Android.mk` 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= compute.cppLOCAL_MODULE:= computeLOCAL_STATIC_LIBRARIES:= add mulinclude $(BUILD_EXECUTABLE) 我们通过定义$include $(BUILD_EXECUTABLE)来构建主模块作为一个可执行文件。我们还定义了LOCAL_STATIC_LIBRARIES add mul，这意味着这个主模块依赖于两个静态库，分别使用模块名add和mul。但是这两个模块的定义是什么，让我们继续看一下子模块。 子模块：add和mulsrc/submodules/`Android.mk` 1include $(call all-subdir-makefiles) 这里，在submodules文件夹中，makefile只包含一行，它在NDK构建系统中调用一个函数。这个命令包括include $(call all-subdir-makefiles)，基本上等同于将所有的Android.mk文件手动地包含在所有子目录中。在我们的例子中,这将帮助我们包括src/submodules/add/Android.mk和src/submodules/mul/Android.mk。 让我们看一下子模块add。 src/submodules/add/`add.cpp` 1234int add(int a, int b)&#123; return a + b;&#125; src/submodules/add/`Android.mk` 12345LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= ./add.cppLOCAL_MODULE:= addinclude $(BUILD_STATIC_LIBRARY) 我们将模块add定义为一个静态库。 类似地，我们还有子模块mul，它几乎拥有与add模块相同的makefile。 src/submodules/mul/`mul.cpp` 1234int mul(int a, int b)&#123; return a * b;&#125; src/submodules/mul/`Android.mk` 12345LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= ./mul.cppLOCAL_MODULE:= mulinclude $(BUILD_STATIC_LIBRARY) 到目前为止，我们已经列出了项目中的所有文件。构建流程清晰地显示如下: 使用add.cpp构建静态库add; 使用mul.cpp构建静态库mul; 使用compute.cpp构建主模块compute; 将compute链接到静态库libadd.a和libmul.a。生成可执行的compute。 构建和执行我们使用前面示例中的相同命令来构建项目。 123456789$ ndk-build NDK_APPLICATION_MK=./makefiles/Application.mk[armeabi-v7a] Cygwin : Generating dependency file converter script[armeabi-v7a] Compile++ thumb: compute &lt;= compute.cpp[armeabi-v7a] Compile++ thumb: add &lt;= add.cpp[armeabi-v7a] StaticLibrary : libadd.a[armeabi-v7a] Compile++ thumb: mul &lt;= mul.cpp[armeabi-v7a] StaticLibrary : libmul.a[armeabi-v7a] Executable : compute[armeabi-v7a] Install : compute =&gt; libs/armeabi-v7a/compute 我们执行的二进制。 1234567$ adb shell \"mkdir -p /data/mastering_ndk &amp;&amp; chmod 777 /data/mastering_ndk\"$ adb push ./libs/armeabi-v7a/compute /data/mastering_ndk$ adb shell \"cd /data/mastering_ndk &amp;&amp; chmod 777 ./compute &amp;&amp; ./compute\"a = 2b = 3add(a, b) = 5mul(a, b) = 6 我们可以看到结果正是我们所期望的。显然，通过使用“include”，项目变得更加结构化。所有的模块都是单独构建的，但是有能力在makefile中共享变量。可以想象，在大型项目中，必须有更多的设置，比如LOCAL_C_INCLUDES, LOCAL_CFLAGS, LOCAL_LDFLAGS, LOCAL_LDLIBS等等。许多子小管在这些设置中可能具有相同的值。在这些情况下，我们可以提取公共部分并将常见的部分放入一个普通makefile中，然后将其包含到每个子模块的makefile中。这样做可以节省大量的编码工作，并且可以使makefile更容易修改和维护。在添加新的子模块时，编写新的makefile的工作量将是最小的。 关于LOCAL_PATH和CLEAR_VARS以下两个NDK内置函数非常重要: 12LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS) 第一个(LOCAL_PATH:= $(call my-dir))检索Android.mk文件的当前本地路径，以便同一文件中的所有变量都可以根据本地路径生成绝对路径。命令include $(CLEAR_VARS)清除了以LOCAL_开头的所有NDK内置变量，如LOCAL_SRC_FILES, LOCAL_C_INCLUDES, LOCAL_CFLAGS, LOCAL_LDFLAGS, LOCAL_LDLIBS等，除了LOCAL_PATH。 当你在这个项目中只有一个Android.mk时，这个功能就非常好了。但是，如果您使用“include”来将多个makefile放在一起，那么您需要注意上面的两个命令。 原因是LOCAL_PATH变量可以被随后的命令调用LOCAL_PATH:= $(call my-dir)覆盖。例如，在以下情况下: 12345LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)include subfolder/Android.mkLOCAL_SRC_FILES:= $(LOCAL_PATH)/test.cpp 上述makefile的问题在于，在“include”之后，在subfolder/Android.mk中，LOCAL_PATH可能会被包含的Android.mk修改。然后，当您试图定位test.cpp，ndk-build将会失败，因为现在文件的路径是错误的。 如果您对示例5进行了足够的关注，您将看到一个小技巧已经在那里使用了。让我们看一下示例5的顶级makefile。 ex5_using_include_to_embed_make_files/makefiles/`Android.mk` 12345TOP_LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)include $(TOP_LOCAL_PATH)/../src/submodules/Android.mkinclude $(TOP_LOCAL_PATH)/../src/main/Android.mk 为了避免使用错误的LOCAL_PATH，我定义了TOP_LOCAL_PATH，以保证这两种方法包括使用相同的本地路径。 有些人使用了另一个技巧，在include Android.mk中，第一件事是将LOCAL_PATH变量备份到一个临时变量，在退出之前，恢复LOCAL_PATH。例如: 12345LOCAL_PATH_BACK_UP := $(LOCAL_PATH)LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)...LOCAL_PATH:=$(LOCAL_PATH_BACK_UP ) 类似地，如果您的模块共享一些公共设置，请小心使用include $(CLEAR_VARS)，只有当您知道它是安全且必需的时才使用它。 如何调试.mk makefile对于一个小项目，在makefile中查找问题可能更容易。然而，随着您的项目越来越大，尤其是当您包含了多个模块，包括共享库、静态库和可执行程序时，情况变得更加复杂。您可能会遇到诸如“无法找到构建foo的规则”或“不能链接库bar”之类的问题。有时，这可能只是由于某个角落出现了打印错误，但可能会导致您花上几个小时来查找，因为ndk-build提供的信息确实非常有限，而且常常是不够的。 幸运的是，有一些非常有用的工具: 123$(error error message)$(warning warning message)$(info information message) 这些命令可以插入到您的Android.mk或Application.mk。 这三个命令之间有一些差异。 $(info)命令简单地打印出一些信息，比如在c中的printf()。 $(warning)命令不仅打印信息，还插入行号，指示发出警告的位置。 $(error)命令将打印信息，并停止后续的构建过程。 通常，$(info)足以显示我们感兴趣的信息，例如，如果我们想要检查当前LOCAL_PATH变量，我们可以执行以下操作: 1$(info LOCAL_PATH=$(LOCAL_PATH)) 或者，如果我们在androidmk文件中定义一个变量，我们也可以检查它的值: 123BUILD_MODE:=NATIVE_MODEDEVICE_NAME:=NEXUS-5$(info BUILD_MODE is $(BUILD_MODE) for device $(BUILD_MODE)) 另一种方法另一种帮助调试makefile的有用方法是使用ndk-build的V=1选项。例如，在我们的示例5中，如果我们使用ndk-build V=1，以下就是我们将看到的: 1234567$ ndk-build NDK_APPLICATION_MK=./MyApplication.mk V=1[Robert: Here I have skipped some print information...][armeabi-v7a] Executable : hello/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-g++ -Wl,--gc-sections -Wl,-z,nocopyreloc --sysroot=D:/development/android-ndk-r10d/platforms/android-19/arch-arm -Wl,-rpath-link=D:/development/android-ndk-r10d/platforms/android-19/arch-arm/usr/lib -Wl,-rpath-link=./obj/local/armeabi-v7a ./obj/local/armeabi-v7a/objs-debug/hello/src/hello.o D:/development/android-ndk-r10d/sources/cxx-stl/stlport/libs/armeabi-v7a/thumb/libstlport_static.a -lgcc -no-canonical-prefixes -march=armv7-a -Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -fPIE -pie -lc -lm -o ./obj/local/armeabi-v7a/hello[armeabi-v7a] Install : hello =&gt; libs/armeabi-v7a/helloinstall -p ./obj/local/armeabi-v7a/hello ./libs/armeabi-v7a/hello/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-strip --strip-unneeded ./libs/armeabi-v7a/hello 最有用的部分是直接起动/cygdrive/d/development/android-ndk-r10d/toolchains/arm-linux-androideabi-4.8/prebuilt/windows-x86_64/bin/arm-linux-androideabi-g++。这基本上显示了用于构建目标输出的命令行。您可以在这里看到所有的编译和链接信息。对于一个复杂的项目，尤其是带有嵌入式makefile的项目，这将允许我们检查库的路径、头文件的路径和项目依赖关系是否正确设置。 针对多个目标体系结构的构建最后，我们将讨论为多个目标ABIs(AABI=Architecture Binary Interface)构建二进制文件的方法。当您想要为多个平台发布您的本地程序时，这将非常有用，例如arm v5、arm v7、x86等等。在为Android应用程序构建原生JNI共享库时，这将非常有用，因为在这种情况下，您需要认真考虑如何发布和发布最终的应用程序。您构建本地库并发布它们的方法将影响您的应用程序的兼容性。 对于一个没有连接external/3rd-party共享库的典型项目，可以通过在Application.mk中设置APP_ABI变量来轻松实现这一点。这已经在官方NDK文档中详细讨论了:Android Native CPU ABI Management。基本上，我们可以在Application.mk的一行中选择目标ABI: 1APP_ABI := armeabi armeabi-v7a mips x86 您可以简单地设置APP_ABI := all来为上面的目标ABIs构建本地代码。 这种方法非常适合那些不依赖于任何外部库的项目。通常情况下，我们需要将一些现有的libs与我们的项目联系起来。这意味着有可能以二进制格式提供外部的libs。这将使问题变得棘手。在这些情况下，我们需要检测当前构建的当前目标APP_ABI，然后根据该架构执行正确的操作。 我将用一个非常实际的问题作为例子来说明为什么这是不简单的。我遇到的问题是在开发Android应用程序时，使用了OpenCL加速的本地代码。(对于那些不知道OpenCL的人来说:OpenCL是由Khronos组织维护的异构计算的开放规范;大多数现代桌面CPU，GPU和最新一代的移动GPU支持OpenCL，因此，你可以利用OpenCL来利用GPU并行架构的强大功能来加速你的算法。)OpenCL的工作方式是SoC芯片供应商实现OpenCL软件堆栈，包括驱动程序和共享库中的编译器。这里的问题是，对于不同厂商提供的应用SoC芯片组的不同设备，OpenCL支持是由驱动程序库支持的，它通常是一个共享的库，驻留在目录中，如/system/vendor/lib, 或/system/lib，或其他目录。因此，对于在移动设备(智能手机或平板电脑)中使用的不同芯片组，共享库将会非常不同。构建OepnCL程序的一个问题是，您需要动态链接到这些OpenCL驱动程序库，这样，您的应用程序调用的OpenCL API函数可以在链接时解决。 下表显示了一些主要的移动SoC芯片厂商的移动GPU的OpenCL库。 SoC芯片组 GPU Arch OpenCL库 三星Exynos(5420 或 5433) ARM Mali T628 或 T760 ARM /system/vendor/lib/egl/libGLES_mali.so 高通骁龙800,801,805,810 Adreno A330, A420, A430 ARM /system/vendor/lib/libOpenCL.so 英特尔原子Z3560 PowerVR G6430 x86 /system/vendor/lib/libPVROCL.so 我们可以很容易地看到，共享库位于Android系统的不同位置，它们的名称不同，甚至具有不同的架构。如果您想要构建一个应用程序来支持以上所有的平台，那么您可以使用正确的动态链接来构建本地部分。 我们可以使用TARGET_ARCH变量或TARGET_ARCH_ABI变量来实现这一目标，这些变量表示当前的目标体系结构或目标体系结构ABIs。 TARGET_ARCH和TARGET_ARCH_ABI略有不同:TARGET_ARCH报告体系结构名称;TARGET_ARCH_ABI报告体系结构和指令集版本。例如，如果当前的APP_ABI是“armeabi-v7a”，TARGET_ARCH只显示“arm”，而TARGET_ARCH_ABI将是“armeabi-v7a”。请记住这一点，这样您就可以充分利用这两个变量。 下面是一个示例，其中我们构建一个本地程序(或JNI使用的共享库)，目标是支持多个体系结构: 1234567891011121314151617181920212223242526272829ifeq ($(TARGET_ARCH),x86) GPU_FAMILY=powervr OPENCL_LIB := PVROCL OPENCL_INC_DIR := $(OPENCL_COMMON)/include/CL12/ OPENCL_LIB_DIR := $(OPENCL_COMMON)/libs/$(GPU_FAMILY)_$(TARGET_ARCH)/ LOCAL_LDLIBS := -llog -L$(OPENCL_LIB_DIR) -l$(OPENCL_LIB) MYMODULE_NAME:=mymodule_$(GPU_FAMILY) include OTHER_MK_FILES.mkendififeq ($(TARGET_ARCH),arm) #Adreno GPU_FAMILY:=adreno OPENCL_LIB := OpenCL OPENCL_INC_DIR := $(OPENCL_COMMON)/include/CL12/ OPENCL_LIB_DIR := $(OPENCL_COMMON)/libs/$(GPU_FAMILY)_$(TARGET_ARCH)/ LOCAL_LDLIBS := -llog -L$(OPENCL_LIB_DIR) -l$(OPENCL_LIB) MYMODULE_NAME:=mymodule_$(GPU_FAMILY) include OTHER_MK_FILES.mk #Mali GPU_FAMILY:=mali OPENCL_LIB := GLES_mali OPENCL_INC_DIR := $(OPENCL_COMMON)/include/CL11/ OPENCL_LIB_DIR := $(OPENCL_COMMON)/libs/$(GPU_FAMILY)_$(TARGET_ARCH)/ LOCAL_LDLIBS := -llog -L$(OPENCL_LIB_DIR) -l$(OPENCL_LIB) MYMODULE_NAME:=mymodule_$(GPU_FAMILY) include OTHER_MK_FILES.mkendif 这是完整makefile的一部分，它只显示了使用TARGET_ARCH变量的部分。在本节之后，我们将包含一些makefile来执行常规的构建过程。请注意，$(OPENCL_COMMON)文件夹包含用于不同目标架构的共享库(我们可以从实际设备中adb pull它们)。 通过这样做，我们基本上实现了本地代码的几个不同版本。假定本地程序的模块名是“mymodule”。然后，最终生成的二进制文件将具有以下结构。 structure123456+-- libs| +-- armeabi-v7a| +-- libmymodule_adreno.so| +-- libmymodule_mali.so| +-- x86| +-- libmymodule_powervr.so 这些库将被打包到Android APK安装程序中。在安装过程中，正确的架构版本将基于给定设备的主ABI属性(请参阅这里的详细信息)安装。 在我们的示例中，如果我们将APK安装在带有ARM CPU的设备上，那么前两个.so，文件将被安装。在您的程序中，您可以很容易地检测到设备芯片供应商，并加载相应的共享库。如果APK安装在x86设备上，那么唯一的x86库将被安装，并在应用程序执行时自动加载。 当然，您需要在JAVA代码中调用System.loadLibrary()函数，或者使用dlopen()和dlsym()函数在本机代码中动态地链接共享库，但是一旦我们获得了以上的库，加载正确库的工作量就变得微不足道了。 总结在本文中，我们介绍了ndk-build的基础知识，接着讨论了ndk-build系统中的一些半隐藏特性或技术，我个人认为这非常有用。我希望这篇文章对Android NDK开发者有用。 尽管每一种技术都可能简单而直接，但是当您将它们组合在一起时，我确信您将能够创建一些不仅强大而且高效的构建脚本。请下载github上的示例，并尝试一下，你需要的只是Android NDK和Android设备(或者像Genymotion这样的虚拟设备)。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"https://jigangduan.github.io/categories/Android/NDK/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"ndk","slug":"ndk","permalink":"https://jigangduan.github.io/tags/ndk/"},{"name":"翻译","slug":"翻译","permalink":"https://jigangduan.github.io/tags/翻译/"}]},{"title":"Android原生程序启动工具","slug":"AndroidNDKNativeProgramLauncher","date":"2017-11-01T08:38:27.000Z","updated":"2020-07-25T02:57:18.147Z","comments":true,"path":"2017/11/01/AndroidNDKNativeProgramLauncher/","link":"","permalink":"https://jigangduan.github.io/2017/11/01/AndroidNDKNativeProgramLauncher/","excerpt":"[翻译]Android原生程序启动工具 介绍 主要功能 入门指南 下载地址 提供了什么? 使用说明 一些细节 示例 示例1 示例2","text":"[翻译]Android原生程序启动工具 介绍 主要功能 入门指南 下载地址 提供了什么? 使用说明 一些细节 示例 示例1 示例2 介绍在使用原生代码开发Android应用程序时，我们通常需要使用纯原生模式来调试它(使用NDK编译代码，生成可执行文件，并通过adb shell执行它)。有时，我们甚至不想花时间开发Android应用，因为我们只是想测试一些原生函数。 以处理OpenCL和GPU为例。编写的程序中超过80%将是性能和基准代码。由于它们直接操作系统驱动程序或硬件，所以通过ADB以纯原生模式运行它们非常自然。我享受着原生程序带给我的效率和速度。 但是，纯原生代码可能无法在Android设备上运行。比如以下遇到的一些情况: 设备没有被ROOT。因此，由于缺少权限，您不能将原生程序推到/data/文件夹下。您不能通过使用chmod+x文件来给原生可执行文件提供执行权限，因此，在设备上运行它是不可能的。 你的设备已经ROOT了。您可以通过ADB来运行代码。然而，当使用ADB运行代码时，您必须使用USB电缆将您的设备连接到计算机。如果你用一些外部功率计来测量系统功耗呢?由于USB电缆为设备提供了额外的电源输入，所以连接到USB电缆使功率测量变得不可能。 对于某些设备，您甚至没有正确的ADB驱动程序。 一些未知的情况下… 在所有这些情况下，我们需要特定的工具来帮助我们在没有ROOT、独立的、没有usb连接的设备上运行本机程序。 主要功能 不需要root权限。 你可以在没有ADB和USB连接到电脑的情况下运行原生代码。 支持从sdcard中加载本机程序。 支持命令行参数。 允许用户设置LD_LIBRARY_PATH。 支持子目录。原生程序装入的输入文件和配置可以放在子目录中，在原生程序中，使用相对路径来访问它们。 输出文件的支持。可以从工作目录中检索输出文件。 入门指南下载地址AndroidNativeLauncher@github. 提供了什么? 一个APK安装程序。 一些示例NDK项目，以及构建脚本。 使用说明 将您的原生程序(由ndk-build编译)复制到您的sdcard上的一个文件夹中，例如 /sdcard/test/。 将所有依赖的共享库(.so)复制到该文件夹。 将输入文件复制到同一个文件夹。 按下“载入原生程序”按钮。 如果有的话，设置命令行参数。 按下“运行”按钮来执行程序。 检查你文件夹下的结果，例如/sdcard/test/。 一些细节 问:工作目录在哪里? 答:工作目录是可执行文件的目录。 问:如何设置LD_LIBRARY_PATH?库的装载顺序是什么? 答:在textedit字段中，键入您的自定义库路径。请注意，您的工作目录将自动添加到LD_LIBRARY_PATH。例如，如果您在字段中输入“mylib”，那么LD_LIBRARY_PATH将被设置为LD_LIBRARY_PATH=mypath:workingdirectory:$LD_LIBRARY_PATH。 问:如何使用子目录? 答: 子文件夹可以通过相对路径访问。例如，如果我们在工作目录中有一个名为“image”的文件夹，其中包含一个输入图片“lena.png”。在你的代码中，你可以通过imag/lena.png来访问它。您的输出文件也将在工作目录下。 示例提供了两个示例来演示原生程序启动程序的功能。您可以在bin目录中找到预编译的二进制文件。 如果需要，还可以使用NDK编译代码。我提供一个build_examples.sh脚本简化这个过程，请安装NDK并确保在系统路径中进行NDK构建，然后您就可以使用构建下面的示例: 12$ cd examples$ ./build_examples.sh 编译完代码后，让我们将二进制文件推入到sdcard中 12$ adb shell \"mkdir -p /sdcard/examples\"$ adb push bin /sdcard/example 然后，您可以使用NativeLauncher应用程序来加载本地程序并执行它。 – 让我们来看看两个例子的细节。 示例1test1.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;fstream&gt;int main(int argc, char ** argv)&#123; if(argc &gt; 1) &#123; std::cout &lt;&lt; \"argc: \" &lt;&lt; argc &lt;&lt; std::endl; for(int i = 0; i &lt; argc; i ++) &#123; std::cout &lt;&lt; \"argv[\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; argv[i] &lt;&lt; std::endl; &#125; std::cout &lt;&lt; std::endl; &#125; std::cout &lt;&lt; \"cout: Hello world!\" &lt;&lt; std::endl; std::cerr &lt;&lt; \"cerr: Hello world!\" &lt;&lt; std::endl; std::cout &lt;&lt; \"\\nTest:\\n\" &lt;&lt; std::endl; for(int i = 0; i &lt; 20; i ++) &#123; for(int j = 0; j &lt; i; j ++) std::cout &lt;&lt; \"*\"; std::cout &lt;&lt; std::endl; &#125; std::ofstream ofs(\"results.txt\"); if(ofs.is_open())&#123; ofs &lt;&lt; \"This is just a test.\" &lt;&lt; std::endl; ofs.close(); std::cout &lt;&lt; \"results.txt is generated.\" &lt;&lt; std::endl; &#125; return 0;&#125; 正如您所看到的，这个演示基本上打印出命令行参数、一些测试消息、一个使用的简单图形，最后保存一个results.txt文件到sdcard。 我们使用以下makefile编译test1.cpp: Android.mk 12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := test1LOCAL_LDLIBS = -llogLOCAL_CFLAGS += -fPIELOCAL_LDFLAGS += -fPIE -pieLOCAL_SRC_FILES := test1.cppinclude $(BUILD_EXECUTABLE) 示例2这个例子展示了对共享库和LD_LIBRARY_PATH的支持。我们定义一个add()函数并将其编译成一个共享库。然后在main()函数中，我们从共享库调用add()函数来执行计算。 addfunc.cpp 1234int add(int a, int b)&#123; return a + b;&#125; test2.cpp 1234567891011121314#include &lt;iostream&gt;extern int add(int, int);int main(int argc, char ** argv)&#123; std::cout &lt;&lt; \"Test shared library.\" &lt;&lt; std::endl; int a = 1; int b = 2; std::cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; std::endl &lt;&lt;\"b=\" &lt;&lt; b &lt;&lt; std::endl &lt;&lt; \"add(a, b)=\" &lt;&lt; add(a, b) &lt;&lt; std::endl; return 0;&#125; Android.mk 12345678910111213LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := addfuncLOCAL_SRC_FILES := addfunc.cppinclude $(BUILD_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := test2LOCAL_SRC_FILES := test2.cppLOCAL_CFLAGS := -fPIELOCAL_LDFLAGS := -fPIE -pieLOCAL_LDLIBS := -L$(LOCAL_PATH)/../libs/$(TARGET_ARCH_ABI)/ -laddfuncinclude $(BUILD_EXECUTABLE) 因为libaddfunc.so和test2在同一个文件夹中，当您加载test2可执行文件时，共享库libaddfunc.so自动加载。因此，当您运行程序时，您将看到正确的输出: 1234Test shared library.a=1b=2add(a,b)=3 但是，如果我们移动libaddfunc.so到一个名为lib的子目录： 1234$ adb shell$ cd sdcard/example/example2$ mkdir lib$ mv libaddfunc.so lib/ 然后，如果我们再次执行本机程序，因为这一次共享库不在搜索路径中，我们将看到以下消息: 1CANNOT LINK EXECUTABLE: could not load library &quot;libaddfunc.so&quot; needed by &quot;.test2&quot;; caused by library &quot;libaddfunc.so&quot; not found. 为了解决这个问题，我们可以在LD_LIBRARY_PATH文本字段中输入lib。也就是说，当前的图书馆搜索路径变成了: 1LD_LIBRARY_PATH=lib:working_directory:$LD_LIBRARY_PATH 在这里，工作目录是您的本机程序所在的文件夹。 通过这样做，我们可以再次按下“Run”按钮运行原生程序，我们应该能够看到正确的输出消息。这意味着已经找到并加载了共享库。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"https://jigangduan.github.io/categories/Android/NDK/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"ndk","slug":"ndk","permalink":"https://jigangduan.github.io/tags/ndk/"},{"name":"翻译","slug":"翻译","permalink":"https://jigangduan.github.io/tags/翻译/"}]},{"title":"App研发录 笔记二: App开发中的高级技巧","slug":"App研发录-笔记-二","date":"2017-10-27T09:50:58.000Z","updated":"2020-07-25T02:57:18.148Z","comments":true,"path":"2017/10/27/App研发录-笔记-二/","link":"","permalink":"https://jigangduan.github.io/2017/10/27/App研发录-笔记-二/","excerpt":"第二部分 App开发中的高级技巧","text":"第二部分 App开发中的高级技巧 Crash 异常收集与统计异常收集UncaughtExceptionHandler - 用于处理未捕获的异常 (App级别) 1","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"读书笔记","slug":"Android/读书笔记","permalink":"https://jigangduan.github.io/categories/Android/读书笔记/"},{"name":"App研发录","slug":"Android/读书笔记/App研发录","permalink":"https://jigangduan.github.io/categories/Android/读书笔记/App研发录/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"notes","slug":"notes","permalink":"https://jigangduan.github.io/tags/notes/"},{"name":"app","slug":"app","permalink":"https://jigangduan.github.io/tags/app/"}]},{"title":"RxSwift 警告","slug":"RxSwift-Warnings","date":"2017-10-27T06:02:45.000Z","updated":"2020-07-25T02:57:18.163Z","comments":true,"path":"2017/10/27/RxSwift-Warnings/","link":"","permalink":"https://jigangduan.github.io/2017/10/27/RxSwift-Warnings/","excerpt":"警告 未使用 disposable 未使用 observable 序列","text":"警告 未使用 disposable 未使用 observable 序列 未使用 disposable (unused-disposable)下面的内容对于subscribe*、bind*和drive*家族函数 返回Disposable。 你会收到这样的警告: 1234567891011let xs: Observable&lt;E&gt; ....xs .filter &#123; ... &#125; .map &#123; ... &#125; .switchLatest() .subscribe(onNext: &#123; ... &#125;, onError: &#123; ... &#125;) subscribe函数返回一个Disposable，可以用来取消计算和释放资源。但是，不使用它将导致一个错误。 终止这些流畅调用的首选方法是使用DisposeBag，或者通过链接调用.disposed(by: disposeBag)或者直接把disposable加到bag。 12345678910111213let xs: Observable&lt;E&gt; ....let disposeBag = DisposeBag()xs .filter &#123; ... &#125; .map &#123; ... &#125; .switchLatest() .subscribe(onNext: &#123; ... &#125;, onError: &#123; ... &#125;) .disposed(by: disposeBag) // &lt;--- note `.disposed(by:)` 当disposeBag被释放时，它里面包含的disposables也会被自动处理掉。 如果xs以一种可预测的方式以Completed 或 Error的方式终止，不处理订阅Disposable不会泄漏任何资源. 然而，即使在这种情况下，使用一个disposeBag仍然是处理订阅处理问题的首选方法. 它确保了元素计算总是在可预见的时刻终止，并且使您的代码健壮和将来的证明，因为即使xs的实现改变，资源也会得到适当的处理. 另一种确保订阅和资源与某个对象的生命周期相关联的方法是使用takeUntil操作符 12345678910111213let xs: Observable&lt;E&gt; ....let someObject: NSObject ..._ = xs .filter &#123; ... &#125; .map &#123; ... &#125; .switchLatest() .takeUntil(someObject.deallocated) // &lt;-- note the `takeUntil` operator .subscribe(onNext: &#123; ... &#125;, onError: &#123; ... &#125;) 如果忽略订阅Disposable是期望的行为，这就是如何使编译器警告保持沉默。 1234567891011let xs: Observable&lt;E&gt; ...._ = xs // &lt;-- note the underscore .filter &#123; ... &#125; .map &#123; ... &#125; .switchLatest() .subscribe(onNext: &#123; ... &#125;, onError: &#123; ... &#125;) 未使用 observable 序列 (unused-observable)你会收到这样的警告: 12345let xs: Observable&lt;E&gt; ....xs .filter &#123; ... &#125; .map &#123; ... &#125; 这段代码定义了一个observable序列，该序列从xs序列中过滤并映射，但随后忽略了结果。 因为这段代码只定义了一个observable序列，然后忽略它，它实际上什么也不做。 您的意图可能是存储observable序列定义并随后使用它 … 12345let xs: Observable&lt;E&gt; ....let ys = xs // &lt;--- names definition as `ys` .filter &#123; ... &#125; .map &#123; ... &#125; … 或者根据这个定义开始计算 1234567891011let xs: Observable&lt;E&gt; ....let disposeBag = DisposeBag()xs .filter &#123; ... &#125; .map &#123; ... &#125; .subscribe(onNext: &#123; nextElement in // &lt;-- note the `subscribe*` method // use the element print(nextElement) &#125;) .disposed(by: disposeBag)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 特征","slug":"RxSwift-Traits","date":"2017-10-27T03:26:51.000Z","updated":"2020-07-25T02:57:18.163Z","comments":true,"path":"2017/10/27/RxSwift-Traits/","link":"","permalink":"https://jigangduan.github.io/2017/10/27/RxSwift-Traits/","excerpt":"特征(以前的单位)本文将尝试描述什么是特征，为什么它们是一个有用的概念，以及如何使用和创建它们。 概括 为什么 它们是如何工作的 RxSwift 特征 Single 创建Single Completable 创建Completable Maybe 创建Maybe RxCocoa 特征 Driver 为什么它被命名为 Driver 实际使用的例子 ControlProperty / ControlEvent","text":"特征(以前的单位)本文将尝试描述什么是特征，为什么它们是一个有用的概念，以及如何使用和创建它们。 概括 为什么 它们是如何工作的 RxSwift 特征 Single 创建Single Completable 创建Completable Maybe 创建Maybe RxCocoa 特征 Driver 为什么它被命名为 Driver 实际使用的例子 ControlProperty / ControlEvent 概括为什么Swift有一个强大的类型系统，可以用来提高应用程序的正确性和稳定性，并使使用Rx更加直观和直观. 特征有助于沟通和确保observable序列属性的接口边界，以及提供上下文意义、语法糖和更具体的用例目标。 出于这个原因，特征完全是可选的。在您的程序中，您可以自由地使用原始的可观察序列，因为所有的核心rxswift/rxcocoa api都支持它们。 注意:本文档中描述的一些特征(如Driver)是特定只对RxCocoa项目,有些是通用的一部分项目RxSwift。但是，如果有必要，同样的原则也可以很容易地在其他Rx实现中实现。不需要私有API 它们是如何工作的特征仅仅是一个包装器结构，带有一个只读的Observable序列属性。 12345678struct Single&lt;Element&gt; &#123; let source: Observable&lt;Element&gt;&#125;struct Driver&lt;Element&gt; &#123; let source: Observable&lt;Element&gt;&#125;... 您可以将它们看作是Observable序列的构建器模式实现。当一个特征被建立起来时，调用.asObservable()将把它转换成一个普通的可观察的序列。 RxSwift traitsSingleSingle是Observable的变体，不是发射一系列的元素，它总是保证会发射单个元素或一个错误。 只释放一个元素，或者一个错误 不共享副作用 使用Single的一个常见的用例是执行HTTP请求，这些请求只能返回响应或错误, 但是，Single可以用于对任何只关心单个元素的情况进行建模，而不是对无限的元素流进行建模. 创建Single创建一个Single类似于创建一个Observable。一个简单的例子就是这样的: 1234567891011121314151617181920212223func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; &#123; return Single&lt;[String: Any]&gt;.create &#123; single in let task = URLSession.shared.dataTask(with: URL(string: \"https://api.github.com/repos/\\(repo)\")!) &#123; data, _, error in if let error = error &#123; single(.error(error)) return &#125; guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves), let result = json as? [String: Any] else &#123; single(.error(DataError.cantParseJSON)) return &#125; single(.success(result)) &#125; task.resume() return Disposables.create &#123; task.cancel() &#125; &#125;&#125; 之后你可以用以下方法来使用它: 12345678910getRepo(\"ReactiveX/RxSwift\") .subscribe &#123; event in switch event &#123; case .success(let json): print(\"JSON: \", json) case .error(let error): print(\"Error: \", error) &#125; &#125; .disposed(by: disposeBag) 或者通过使用subscribe(onSuccess:onError:)如下: 12345678getRepo(\"ReactiveX/RxSwift\") .subscribe(onSuccess: &#123; json in print(\"JSON: \", json) &#125;, onError: &#123; error in print(\"Error: \", error) &#125;) .disposed(by: disposeBag) 订阅提供了SingleEvent枚举，它可以是.success包含Single类型的元素，也可以是.error。在第一个事件之后，不会再发生进一步的事件。 在原始的Observable序列中使用.asSingle()也可以将其转换为Single. CompletableCompletable是Observable的变体，它只能complete或发射一个error。它保证不会发射任何元素. 发射零元素 发射一个completion事件或一个error 不共享副作用 Completable的一个有用的事例，是对任何我们只关心操作已经完成的事实的情况建模，但是不关心由该完成所导致的一个元素.你可以将它与不能发射元素的Observable&lt;Void&gt;相比较. 创建Completable创建一个Completable类似于创建一个Observable。一个简单的例子就是这样的: 123456789101112131415func cacheLocally() -&gt; Completable &#123; return Completable.create &#123; completable in // Store some data locally ... ... guard success else &#123; completable(.error(CacheError.failedCaching)) return Disposables.create &#123;&#125; &#125; completable(.completed) return Disposables.create &#123;&#125; &#125;&#125; 之后你可以用以下方法来使用它: 12345678910cacheLocally() .subscribe &#123; completable in switch completable &#123; case .completed: print(\"Completed with no error\") case .error(let error): print(\"Completed with an error: \\(error.localizedDescription)\") &#125; &#125; .disposed(by: disposeBag) 或者通过使用subscribe(onSuccess:onError:)如下: 12345678cacheLocally() .subscribe(onCompleted: &#123; print(\"Completed with no error\") &#125;, onError: &#123; error in print(\"Completed with an error: \\(error.localizedDescription)\") &#125;) .disposed(by: disposeBag) 订阅提供了一个CompletableEvent枚举，可以是.completed表示没有错误的操作，也可以是.error。在第一个事件之后，不会再发生进一步的事件 MaybeMaybe可能是一种Observable的变体，在Single和Completable的之间。它既可以释放单个元素，也可以释放completed元素，也可以释放一个错误. 发出一个completed事件，一个元素或一个错误 不共享副作用 您可以使用Maybe来模拟任何可以释放元素的操作，但是不一定要释放一个元素。 创建 Maybe创建Maybe类似于创建一个Observable。一个简单的例子就是这样的: 123456789101112131415func generateString() -&gt; Maybe&lt;String&gt; &#123; return Maybe&lt;String&gt;.create &#123; maybe in maybe(.success(\"RxSwift\")) // OR maybe(.completed) // OR maybe(.error(error)) return Disposables.create &#123;&#125; &#125;&#125; 之后你可以用以下方法来使用它: 123456789101112generateString() .subscribe &#123; maybe in switch maybe &#123; case .success(let element): print(\"Completed with element \\(element)\") case .completed: print(\"Completed with no element\") case .error(let error): print(\"Completed with an error \\(error.localizedDescription)\") &#125; &#125; .disposed(by: disposeBag) 或者通过使用subscribe(onSuccess:onError:)如下: 1234567891011generateString() .subscribe(onSuccess: &#123; element in print(\"Completed with element \\(element)\") &#125;, onError: &#123; error in print(\"Completed with an error \\(error.localizedDescription)\") &#125;, onCompleted: &#123; print(\"Completed with no element\") &#125;) .disposed(by: disposeBag) 在原始的Observable序列中使用. asMaybe()也可以将其转换为Maybe. RxCocoa 特征Driver这是最复杂的特征。它的目的是提供一种直观的方式来在UI层中编写响应性代码，或者在任何情况下，您想要为您的应用程序建模 Driving的数据流。 不能错误 主调度器上的观察 共享副作用 (shareReplayLatestWhileConnected) 为什么它被命名为 Driver它的目标用例是对驱动应用程序的序列进行建模。 如 驱动 UI 从CoreData model 使用来自其他UI元素(绑定的)的值来驱动UI… 与正常的操作系统驱动一样，如果出现序列错误，您的应用程序将停止响应用户输入。 同样重要的是，这些元素在主线程上被观察到，因为UI元素和应用程序逻辑通常不是线程安全的。 另外，一个Driver构建一个observable序列，并共享副作用。 如 实际使用的例子这是一个典型的初学者例子. 12345678910111213141516let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) &#125;results .map &#123; \"\\($0.count)\" &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag) 这段代码的意图是: 节流用户输入 连接服务器，获取用户结果列表(每次查询一次) 将结果绑定到两个UI元素:结果表视图和一个显示结果数量的标签 那么，这段代码有什么问题呢?: 如果fetchAutoCompleteItemsobservable序列错误(连接失败或解析错误)，这个错误将解绑所有的东西，UI将不会对新的查询作出任何响应. 如果fetchAutoCompleteItems返回一些后台线程的结果，结果将被绑定到后台线程的UI元素，这些元素可能导致非确定性崩溃. 结果被绑定到两个UI元素，这意味着对于每个用户查询，将创建两个HTTP请求，用于每个UI元素，这不是预期的行为. 更合适的代码版本应该是这样的: 1234567891011121314151617181920let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .observeOn(MainScheduler.instance) // 在MainScheduler返回结果 .catchErrorJustReturn([]) // 在最坏的情况下，会处理错误 &#125; .shareReplay(1) // HTTP请求被共享，结果被重新播放给所有UI元素 //results .map &#123; \"\\($0.count)\" &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag) 确保在大型系统中正确地处理所有这些需求是很有挑战性的，但是使用编译器和特性来证明这些需求是可以实现的，这是一种更简单的方法. 下面的代码看起来几乎是一样的: 1234567891011121314151617let results = query.rx.text.asDriver() // 这将一个正常的序列转换为一个`Driver`序列. .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .asDriver(onErrorJustReturn: []) // 构建器只需要知道在发生错误时需要返回什么信息. &#125;results .map &#123; \"\\($0.count)\" &#125; .drive(resultCount.rx.text) // 如果有一个`drive`方法可用，而不是bindTo, .disposed(by: disposeBag) // 这意味着编译器已经证明了所有属性都是满意的 //results .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag) 那么这里发生了什么? 第一个asDriver方法将ControlProperty特征转换为Driver特征。 1query.rx.text.asDriver() 请注意，没有什么特别的事情需要做。Driver拥有ControlProperty特性的所有属性，再加上一些属性。潜在的可观察序列被包装成一个Driver特征，就是这样。 第二个变化是: 1.asDriver(onErrorJustReturn: []) 任何observable序列都可以转换为Driver特性，只要它满足3个属性: 不能错误 在主调度器上观察 共享副作用(shareReplayLatestWhileConnected) 那么如何确保这些属性得到满足呢?只要使用普通的Rx操作符。asDriver(onErrorJustReturn: [])相当于下面的代码。 12345let safeSequence = xs .observeOn(MainScheduler.instance) // 在主调度器上观察事件 .catchErrorJustReturn(onErrorJustReturn) // 不能错误 .shareReplayLatestWhileConnected() // 副作用分享return Driver(raw: safeSequence) // 包起来 最后一个部分是使用drive，而不是使用bindTo。 drive只在Driver特性上定义。这意味着，如果您在代码的某个地方看到drive，observable序列永远不会出错，并且它在主线程上观察到，这对于绑定到UI元素是安全的。 但是请注意，从理论上讲，有人仍然可以定义一个drive方法来使用ObservableType或其他接口，因此为了获得额外的安全，可以创建一个临时的定义let results: Driver&lt;[Results]&gt; = ...。在绑定到UI元素之前，对于完整的证明是必要的。但是，我们将留给读者来决定这是否是一个现实的场景。 ControlProperty / ControlEvent 不能错误 在主调度器上进行订阅 主调度器上的观察 共享副作用","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 调度器","slug":"RxSwift-Schedulers","date":"2017-10-27T01:56:45.000Z","updated":"2020-07-25T02:57:18.162Z","comments":true,"path":"2017/10/27/RxSwift-Schedulers/","link":"","permalink":"https://jigangduan.github.io/2017/10/27/RxSwift-Schedulers/","excerpt":"调度器 串行和并行调度器 定制的调度器 内置的调度器","text":"调度器 串行和并行调度器 定制的调度器 内置的调度器 调度器抽象出执行工作的机制. 执行工作的不同机制包括当前线程、调度队列、操作队列、新线程、线程池和运行循环. 有两个主要的操作符与调度器有关，observeOn和subscribeOn. 如果您想在不同的调度器上执行工作，只需使用observeOn(scheduler)操作符. 你通常会比subscribeOn更频繁地使用observeOn. 如果没有显式地指定observeOn，那么将在生成的任何线程/调度器上执行工作. 使用observeOn操作符的例子: 123456789sequence1 .observeOn(backgroundScheduler) .map &#123; n in print(&quot;This is performed on the background scheduler&quot;) &#125; .observeOn(MainScheduler.instance) .map &#123; n in print(&quot;This is performed on the main scheduler&quot;) &#125; 如果您想要启动序列生成(subscribe方法)并在特定的调度器上调用处理，请使用subscribeOn(scheduler). 如果没有显式地指定subscribeOn，则subscribe闭包(通过Observable.create的闭包)将在同一线程/调度器上调用，在subscribe(onNext:) 或 subscribe被调用. 如果没有显式地指定subscribeOn，则dispose方法将在启动处理的同一线程/调度器上调用。. 简而言之，如果没有选择显式调度器，这些方法将在当前线程/调度器中调用. 串行和并行调度器因为调度器确实可以是任何东西，并且所有转换序列的操作符都需要保留额外的隐式保证，所以您要创建什么样的调度程序是很重要的。 如果调度器是并发的，Rx的observeOn和subscribeOn操作符将确保所有的操作都是完美的. 如果您使用的调度器，Rx可以证明是串行的，它将能够执行额外的优化. 到目前为止，它只对分派队列调度器执行这些优化. 在串行调度队列调度器的情况下，observeOn仅对一个简单的dispatch_async调用进行了优化. 定制的调度器除了当前的调度器之外，您还可以编写自己的调度器. 如果您只是想描述谁需要立即执行工作，您可以通过实现ImmediateScheduler协议来创建自己的调度器. 123public protocol ImmediateScheduler &#123; func schedule&lt;StateType&gt;(state: StateType, action: (/*ImmediateScheduler,*/ StateType) -&gt; RxResult&lt;Disposable&gt;) -&gt; RxResult&lt;Disposable&gt;&#125; 如果您想要创建一个支持基于时间的操作的新调度程序，那么您需要实现Scheduler协议: 12345678910public protocol Scheduler: ImmediateScheduler &#123; associatedtype TimeInterval associatedtype Time var now : Time &#123; get &#125; func scheduleRelative&lt;StateType&gt;(state: StateType, dueTime: TimeInterval, action: (StateType) -&gt; RxResult&lt;Disposable&gt;) -&gt; RxResult&lt;Disposable&gt;&#125; 如果调度器只有周期性调度功能，那么您可以通过实现PeriodicScheduler协议通知Rx: 123public protocol PeriodicScheduler : Scheduler &#123; func schedulePeriodic&lt;StateType&gt;(state: StateType, startAfter: TimeInterval, period: TimeInterval, action: (StateType) -&gt; StateType) -&gt; RxResult&lt;Disposable&gt;&#125; 如果调度程序不支持PeriodicScheduling功能，那么Rx将会透明地模拟周期性调度. 内置的调度器Rx可以使用所有类型的调度程序，但是它也可以执行一些额外的优化，如果它能够证明调度程序是串行的. 这些是当前支持的调度器: CurrentThreadScheduler (串行调度器)在当前线程上调度工作单元.这是用于生成元素的操作符的默认调度器. 这个调度器有时也被称为”trampoline scheduler”. 如果CurrentThreadScheduler.instance.schedule(state) { }第一次在一些线程被调用,预定行为将立即执行,将会创建一个隐藏的队列,所有递归地行动将临时加入队列. 如果调用堆栈上的一些父框架已经运行的CurrentThreadScheduler.instance.schedule(state) { },预定行为将入队和当前运行时执行的行动和完成所有先前入队操作. MainScheduler (串行调度器)抽象工作需要在MainThread上执行。如果schedule方法是从主线程调用的，那么它将在没有调度的情况下立即执行该操作. 这个调度器通常用于执行UI工作. SerialDispatchQueueScheduler (串行调度器)对需要在特定dispatch_queue_t上执行的抽象工作。它将确保即使一个并发调度队列被传递，它也会被转换为一个串行化队列. 串行调度程序支持对observeOn的某些优化. 主要的调度器是SerialDispatchQueueScheduler的一个实例`. ConcurrentDispatchQueueScheduler (并行调度器)对需要在特定dispatch_queue_t上执行的抽象工作。您也可以通过一个串行调度队列，它不应该引起任何问题. 当需要在后台执行某些工作时，这个调度器是合适的. OperationQueueScheduler (并行调度器)抽象需要在特定的NSOperationQueue上执行的工作. 此调度器适合情况有一些大的工作需要在后台执行的,并且你想要调整并发处理使用maxConcurrentOperationCount.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 背后的数学","slug":"RxSwift-MathBehindRx","date":"2017-10-27T01:39:57.000Z","updated":"2020-07-25T02:57:18.162Z","comments":true,"path":"2017/10/27/RxSwift-MathBehindRx/","link":"","permalink":"https://jigangduan.github.io/2017/10/27/RxSwift-MathBehindRx/","excerpt":"Rx背后的数学观察者和迭代器/迭代器/生成器/序列之间的二元性","text":"Rx背后的数学观察者和迭代器/迭代器/生成器/序列之间的二元性 在观察者和生成器模式之间有一个对偶性。这使我们能够从异步回调世界过渡到序列转换的同步世界. 简而言之，迭代器和观察者模式都描述了序列。为什么迭代器定义一个序列是很明显的，但是观察者稍微复杂一点. 然而，有一个非常简单的例子，不需要太多的数学知识。假设在给定的时间，您正在观察鼠标光标在屏幕上的位置。随着时间的推移，这些鼠标位置形成了一个序列。这是一个可观察的序列. 可以访问一个序列的两种基本方法: 推(Push)接口 - 观察者(观察到的元素随着时间的推移形成一个序列) 拉(Pull)接口-迭代器/枚举器/生成器 你们也可以在这个视频中看到更正式的解释: 专家:Erik Meijer和Erik Meijer——.NET响应框架(Rx)的内部(视频) 响应式编程概述(来自Netflix的Jafar Husain)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 热&冷Observables","slug":"RxSwift-HotAndColdObservables","date":"2017-10-27T01:14:19.000Z","updated":"2020-07-25T02:57:18.162Z","comments":true,"path":"2017/10/27/RxSwift-HotAndColdObservables/","link":"","permalink":"https://jigangduan.github.io/2017/10/27/RxSwift-HotAndColdObservables/","excerpt":"热&amp;冷 Observables","text":"热&amp;冷 Observables 建议更多地把它看作是序列的属性而不是单独的类型，因为它们是由相同的抽象来表示的，它们是完全符合Observable序列. 这是ReactiveX.io的一个定义 一个Observable什么时候开始发射它的序列?这取决于这个Observable。一个“热”的Observable可以在它被创建的时候就开始发射，所以任何后来订阅这个Observable的观察者都可以开始在中间的某个地方观察这个序列。另一方面，一个“冷”的Observable，在它开始发出元素之前，等待观察者订阅它，这样观察者就能保证从一开始就看到整个序列. 热 Observables 冷 observables … 是序列 … 是序列 使用资源(“生产热”)无论是否有任何观察者订阅. 在观察者订阅之前不要使用资源(不要产生热). 变量/属性/常量，点击坐标，鼠标坐标，UI控制值，当前时间 异步操作、HTTP连接、TCP连接、流 通常包含 ~ N 个元素 通常包含~ 1个元素 不管是否有观察者订阅，序列元素都是被生成的. 只有当有订阅的观察者才会产生序列元素. 序列计算资源通常在所有已订阅的观察者之间共享. 序列计算资源通常分配给每个订阅的观察者. 通常有状态 通常无状态","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 入门指南","slug":"RxSwift-GettingStarted","date":"2017-10-26T04:28:14.000Z","updated":"2020-07-25T02:57:18.162Z","comments":true,"path":"2017/10/26/RxSwift-GettingStarted/","link":"","permalink":"https://jigangduan.github.io/2017/10/26/RxSwift-GettingStarted/","excerpt":"RxSwift试图与ReactiveX.io保持一致.在RxSwift的情况下，通用跨平台的文档和教程也应该是有效的. Observables又叫序列 Disposing Observable的隐式保障 创造你自己的 Observable (observable序列) 创造一个 Observable 执行工作 共享订阅和shareReplay操作符 操作符 Playgrounds 自定义操作符 错误处理 调试编译错误 调试 调试内存泄漏 启用调试模式 KVO UI层提示 HTTP请求 RxDataSources Driver 特征: Driver, Single, Maybe, Completable 例子","text":"RxSwift试图与ReactiveX.io保持一致.在RxSwift的情况下，通用跨平台的文档和教程也应该是有效的. Observables又叫序列 Disposing Observable的隐式保障 创造你自己的 Observable (observable序列) 创造一个 Observable 执行工作 共享订阅和shareReplay操作符 操作符 Playgrounds 自定义操作符 错误处理 调试编译错误 调试 调试内存泄漏 启用调试模式 KVO UI层提示 HTTP请求 RxDataSources Driver 特征: Driver, Single, Maybe, Completable 例子 Observables又叫序列基础知识观察者模式(Observable&lt;Element&gt;序列)和普通序列(Sequence)的等价性是理解Rx最重要的东西。 每一个Observable序列就像是一个序列。Observable 对比 Swift的 Sequence的关键优势在于，它还可以异步地接收元素。这是RxSwift的核心，这里的文档是关于我们如何扩展这个想法的。 Observable(ObservableType) 相当于 Sequence ObservableType.subscribe 方法是相当于 Sequence.makeIterator 方法. 观察者(callback)需要通过ObservableType.subscribe方法接收序列元素，而不是在返回的迭代器上调用next()。 序列是一个简单而又熟悉的概念，很容易理解。 人类是有着巨大视觉纹理的生物。当我们可以很容易地看到一个概念时，它就容易多了。 我们可以从试图模拟每个Rx操作符中的事件状态机到高级别操作，从而提升许多认知. 如果我们不使用Rx，但在模型异步系统，这可能意味着我们的代码中充满了状态机和临时状态，我们需要模拟而不是抽象出来. 列表和序列可能是数学家和程序员学习的第一个概念. 这是一系列的数字: 1--1--2--3--4--5--6--| // 正常终止 另一个序列,字符: 1--a--b--a--a--a---d---X // 终止在错误上 一些序列是有限的，而另一些则是无限的，就像一个按钮点击序列: 1---tap-tap-------tap---&gt; 这些被称为大理石图表。还有更多的大理石图表在 rxmarbles.com. 如果我们把序列语法指定为正则表达式，它看起来就像: next* (error | completed)? 描述如下: 序列可以有0个或多个元素. 一旦接收到 error 或 completed 的事件, 序列就无法生成任何其他元素. Rx中的序列由一个push接口(即callback)描述. 12345678910111213enum Event&lt;Element&gt; &#123; case next(Element) // 序列的下一个元素 case error(Swift.Error) // 序列失败的错误 case completed // 成功终止序列&#125;class Observable&lt;Element&gt; &#123; func subscribe(_ observer: Observer&lt;Element&gt;) -&gt; Disposable&#125;protocol ObserverType &#123; func on(_ event: Event&lt;Element&gt;)&#125; 当一个序列发送completed或error事件时，所有计算序列元素的内部资源将被释放. 要立即取消序列元素和释放资源的产生，请在返回的订阅中调用dispose. 如果一个序列在有限的时间内终止，则不调用dispose或不使用disposed(by: disposeBag)不会造成任何永久性的资源泄漏。但是，这些资源将被使用，直到序列完成，要么完成元素的生产，要么返回一个错误。 如果一个序列没有自动终止，例如使用一个按钮点击的系列，资源将被永久地分配，除非是手动调用dispose，自动地在disposeBag内，使用takeUntil 操作符,或者以另一种方式进行操作。 使用disposeBag或takeUntil操作符是一种可靠的方法，确保资源被清理干净。我们建议在生产环境中使用它们,即使序列在有限时间内终止 如果你好奇为什么Swift.Error不使用一般的错误类型，你可以在这里找到解释. Disposing有一种额外的方法可以被observed序列终止。当我们完成一个序列，并且我们想要释放 分配用来计算 即将到来的元素的所有资源时，我们可以在订阅中调用dispose。 这是一个带有interval操作符的例子. 123456789let scheduler = SerialDispatchQueueScheduler(qos: .default)let subscription = Observable&lt;Int&gt;.interval(0.3, scheduler: scheduler) .subscribe &#123; event in print(event) &#125;Thread.sleep(forTimeInterval: 2.0)subscription.dispose() 将打印: 123456012345 注意，您通常不希望手动调用dispose;这只是一个教育的例子。手动调用dispose通常是一种糟糕的代码气味。有更好的方式来处理订阅，比如DisposeBag，或者takeUntil操作符，或者其他的一些机制。 那么，在执行了dispose调用之后，这段代码可以打印出什么东西吗?答案是:这取决于 如果 scheduler 是一个 串行调度程序器 (ex. MainScheduler) 并且 dispose被调用在相同的串行调度程序器, 答案是no. 否则它是 yes. 你可以找到更多关于调度器的信息 这里. 你只需要并行地进行两个过程. 一个是生产元素 另一种是处理订阅 问题是不同的调度器在这些不同过程中“什么东西可以印出来?”都没有什么意义 “在不同的调度程序中，这些过程是不合理的。” 再来几个例子 (observeOn 的解释在 这里). 如果我们有类似的东西: 123456789let subscription = Observable&lt;Int&gt;.interval(0.3, scheduler: scheduler) .observeOn(MainScheduler.instance) .subscribe &#123; event in print(event) &#125;// ....subscription.dispose() // 从主线程调用 在dispose调用返回之后，没有任何东西会被打印出来。这是保证的. 同时,在这种情况下: 123456789let subscription = Observable&lt;Int&gt;.interval(0.3, scheduler: scheduler) .observeOn(serialScheduler) .subscribe &#123; event in print(event) &#125;// ...subscription.dispose() // 执行在相同的`serialScheduler` 在dispose调用返回之后，没有任何东西会被打印出来。这是保证的. Dispose BagsDispose bags就像RX的ARC行为. 当一个DisposeBag被释放时，它将调用dispose 对每一个添加了disposables项的进行处理. 它没有dispose方法，因此不允许明确地显式调用。如果需要立即进行清理，我们可以创建一个新bag。 1self.disposeBag = DisposeBag() 这将清除旧的引用，并导致资源的处置. If that explicit manual disposal is still wanted, use CompositeDisposable. It has the wanted behavior but once that dispose method is called, it will immediately dispose any newly added disposable. Take until在dealloc中自动处理订阅的另一种方法是使用takeUntil操作符. 12345sequence .takeUntil(self.rx.deallocated) .subscribe &#123; print($0) &#125; Observable的隐式保障还有一些额外的保证，所有序列的生产者(Observables)都必须遵守. 它们在哪个线程上生成元素无关紧要，但是如果它们生成一个元素并将其发送给观察者observer.on(.next(nextElement)), 它们不能发送下一个元素,直到observer.on方法已完成. 生产者也不能发送终止.completed或.error在.next`事件还没有结束的情况. 简而言之，考虑一下这个例子: 123456someObservable .subscribe &#123; (e: Event&lt;Element&gt;) in print(\"Event processing started\") // processing print(\"Event processing ended\") &#125; 总是会打印: 123456Event processing startedEvent processing endedEvent processing startedEvent processing endedEvent processing startedEvent processing ended 它不能打印: 1234Event processing startedEvent processing startedEvent processing endedEvent processing ended 创造你自己的 Observable (observable序列)关于observables有一件重要的事情要理解. 当一个observable被创建时，它不会仅仅因为它已经被创建而执行任何工作. 的确，Observable可以有许多方法产生元素。它们中的一些会产生副作用，其中一些会利用现有的运行过程，比如点击鼠标事件等等. 但是，如果您只是调用一个Observable的方法，那么就不会执行任何序列生成，并且没有副作用。Observable只是定义了序列是如何生成的，以及为元素生成使用了哪些参数。当调用了订阅方法时，序列生成才开始. 假设，你有一个类似prototype的方法: 1func searchWikipedia(searchTerm: String) -&gt; Observable&lt;Results&gt; &#123;&#125; 123456789let searchForMe = searchWikipedia(\"me\")// 没有执行请求，没有工作，没有发送URL请求let cancel = searchForMe // 序列生成现在开始，URL请求被触发 .subscribe(onNext: &#123; results in print(results) &#125;) 有很多方法可以创建你自己的Observable 序列。最简单的方法可能是使用create函数. 让我们编写一个函数来创建一个序列，该序列在订阅时返回一个元素。这个函数被称为’just’. 这是实际的实现 123456789101112func myJust&lt;E&gt;(_ element: E) -&gt; Observable&lt;E&gt; &#123; return Observable.create &#123; observer in observer.on(.next(element)) observer.on(.completed) return Disposables.create() &#125;&#125;myJust(0) .subscribe(onNext: &#123; n in print(n) &#125;) 将打印: 10 那么什么是create函数呢? 它只是一种方便的方法，它使您能够使用Swift闭包方便地实现subscribe方法。就像 subscribe方法一样，它需要一个参数，一个observer，然后返回disposable. 这样实现的顺序实际上是同步的。它将生成元素，并在终止之前subscribe调用返回disposable。因为它的返回并不重要所以生成元素的过程不会被打断. 在生成同步序列时，通常使用的disposable返回是NopDisposable实例. 现在让我们创建一个可以从数组中返回元素的observable. 实际的实现 123456789101112131415161718192021222324252627282930func myFrom&lt;E&gt;(_ sequence: [E]) -&gt; Observable&lt;E&gt; &#123; return Observable.create &#123; observer in for element in sequence &#123; observer.on(.next(element)) &#125; observer.on(.completed) return Disposables.create() &#125;&#125;let stringCounter = myFrom([\"first\", \"second\"])print(\"Started ----\")// first timestringCounter .subscribe(onNext: &#123; n in print(n) &#125;)print(\"----\")// againstringCounter .subscribe(onNext: &#123; n in print(n) &#125;)print(\"Ended ----\") 将打印: 1234567Started ----firstsecond----firstsecondEnded ---- 创造一个 Observable 执行工作好了，现在更有趣了。我们来创建之前例子中使用的interval操作符. 这相当于分派队列调度程序的实际实现 123456789101112131415161718192021222324func myInterval(_ interval: TimeInterval) -&gt; Observable&lt;Int&gt; &#123; return Observable.create &#123; observer in print(\"Subscribed\") let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.global()) timer.scheduleRepeating(deadline: DispatchTime.now() + interval, interval: interval) let cancel = Disposables.create &#123; print(\"Disposed\") timer.cancel() &#125; var next = 0 timer.setEventHandler &#123; if cancel.isDisposed &#123; return &#125; observer.on(.next(next)) next += 1 &#125; timer.resume() return cancel &#125;&#125; 123456789101112131415let counter = myInterval(0.1)print(\"Started ----\")let subscription = counter .subscribe(onNext: &#123; n in print(n) &#125;)Thread.sleep(forTimeInterval: 0.5)subscription.dispose()print(\"Ended ----\") 将打印 123456789Started ----Subscribed01234DisposedEnded ---- 如果你想写 12345678910111213141516171819202122let counter = myInterval(0.1)print(\"Started ----\")let subscription1 = counter .subscribe(onNext: &#123; n in print(\"First \\(n)\") &#125;)let subscription2 = counter .subscribe(onNext: &#123; n in print(\"Second \\(n)\") &#125;)Thread.sleep(forTimeInterval: 0.5)subscription1.dispose()Thread.sleep(forTimeInterval: 0.5)subscription2.dispose()print(\"Ended ----\") 将打印: 123456789101112131415161718192021Started ----SubscribedSubscribedFirst 0Second 0First 1Second 1First 2Second 2First 3Second 3First 4Second 4DisposedSecond 5Second 6Second 7Second 8Second 9DisposedEnded ---- 订阅的每个订阅者通常会生成它自己的单独的元素序列。默认情况下，操作符是无状态的。有很多无状态的操作符比有状态的多. 共享订阅和shareReplay操作符但是，如果您希望多个观察者只从一个订阅中共享事件(元素)，该怎么办呢? 有两件事需要定义。 在新用户对它们感兴趣之前,如何处理以前接收到的过去的元素(仅重放最新、重放所有、重放最后n个) 如何决定何时触发共享订阅(refCount、手动或其他算法) 通常的选择是replay(1).refCount() 也可以 shareReplay(). 1234567891011121314151617181920212223let counter = myInterval(0.1) .shareReplay(1)print(\"Started ----\")let subscription1 = counter .subscribe(onNext: &#123; n in print(\"First \\(n)\") &#125;)let subscription2 = counter .subscribe(onNext: &#123; n in print(\"Second \\(n)\") &#125;)Thread.sleep(forTimeInterval: 0.5)subscription1.dispose()Thread.sleep(forTimeInterval: 0.5)subscription2.dispose()print(\"Ended ----\") 将打印 1234567891011121314151617181920Started ----SubscribedFirst 0Second 0First 1Second 1First 2Second 2First 3Second 3First 4Second 4First 5Second 5Second 6Second 7Second 8Second 9DisposedEnded ---- 注意，现在只有一个Subscribed和Disposed事件. URL observables的行为是一样的. 这就是在Rx中封装HTTP请求的方式。它和interval操作符的模式是一样的. 1234567891011121314151617181920212223242526extension Reactive where Base: URLSession &#123; public func response(_ request: URLRequest) -&gt; Observable&lt;(Data, HTTPURLResponse)&gt; &#123; return Observable.create &#123; observer in let task = self.dataTaskWithRequest(request) &#123; (data, response, error) in guard let response = response, let data = data else &#123; observer.on(.error(error ?? RxCocoaURLError.Unknown)) return &#125; guard let httpResponse = response as? HTTPURLResponse else &#123; observer.on(.error(RxCocoaURLError.nonHTTPResponse(response: response))) return &#125; observer.on(.next(data, httpResponse)) observer.on(.completed) &#125; task.resume() return Disposables.create &#123; task.cancel() &#125; &#125; &#125;&#125; 操作符在RxSwift中实现了许多操作符. 所有操作符的大理石图表都可以在 ReactiveX.io 几乎所有的运算符都在 Playgrounds. 要使用playgrounds，请打开Rx.xcworkspace，构建RxSwift-macOS scheme，然后在Rx.xcworkspace上打开playgrounds的树视图. 如果你需要一个操作符，不知道怎么找到它，这有一个操作符树. 自定义操作符如何创建自定义操作符有两种方法. 简单的方法所有的内部代码都使用了高度优化的操作符，因此它们并不是最好的教程材料。这就是为什么使用标准操作符的原因. 幸运的是，有一种更简单的方法来创建操作符。创建新的运算符实际上是关于创建observables，而之前的章节已经描述了如何做到这一点. 让我们看看如何实现一个未优化的映射操作符. 12345678910111213141516171819extension ObservableType &#123; func myMap&lt;R&gt;(transform: @escaping (E) -&gt; R) -&gt; Observable&lt;R&gt; &#123; return Observable.create &#123; observer in let subscription = self.subscribe &#123; e in switch e &#123; case .next(let value): let result = transform(value) observer.on(.next(result)) case .error(let error): observer.on(.error(error)) case .completed: observer.on(.completed) &#125; &#125; return subscription &#125; &#125;&#125; 现在你可以使用自己的map了: 1234567let subscription = myInterval(0.1) .myMap &#123; e in return \"This is simply \\(e)\" &#125; .subscribe(onNext: &#123; n in print(n) &#125;) 将打印: 1234567891011SubscribedThis is simply 0This is simply 1This is simply 2This is simply 3This is simply 4This is simply 5This is simply 6This is simply 7This is simply 8... Life happens那么，如果不用自定义操作符来解决某些情况会怎么样呢? 您可以退出单个Rx，在真实世界中执行活动，然后使用Subjects将结果再次使用到Rx. 这不是应该经常练习的东西，而且是一种不好的代码味道，但你可以这样做. 123456789101112131415161718192021222324252627let magicBeings: Observable&lt;MagicBeing&gt; = summonFromMiddleEarth()magicBeings .subscribe(onNext: &#123; being in // exit the Rx monad self.doSomeStateMagic(being) &#125;) .disposed(by: disposeBag)//// Mess//let kitten = globalParty( // calculate something in messy world being, UIApplication.delegate.dataSomething.attendees)kittens.on(.next(kitten)) // send result back to rx//// Another mess//let kittens = Variable(firstKitten) // again back in Rx monadkittens.asObservable() .map &#123; kitten in return kitten.purr() &#125; // .... 每次你这么做的时候，有人可能会把这个代码写在某个地方: 12345kittens .subscribe(onNext: &#123; kitten in // do something with kitten &#125;) .disposed(by: disposeBag) 所以请尽量不要这样做. Playgrounds如果你不确定其中的一些操作符是如何工作的，playgrounds包含几乎所有的操作符，都已经准备好了演示他们行为的小例子. 要使用playgrounds，请打开Rx.xcworkspace，构建RxSwift-macOS scheme，然后在Rx.xcworkspace上打开playgrounds的树视图. 要查看playgrounds上的示例结果，请打开Assistant Editor。您可以通过点击View &gt; Assistant Editor &gt; Show Assistant Editor来打开Assistant Editor 错误处理有两种错误机制. observables中的异步错误处理机制错误处理非常简单。如果一个序列以错误结束，那么所有依赖序列都将以错误结束。这是通常的短路逻辑。 您可以通过使用catch操作符来恢复overloads的故障。有各种重载使您能够详细地指定恢复. 还有retry操作符，可以在出现错误序列时进行重试. 调试编译错误在编写优雅的rxswift/rxcocoa代码时，您可能非常依赖于编译器来推断Observable的类型。这就是为什么Swift很棒的原因之一，但有时也会让人沮丧. 12345678images = word .filter &#123; $0.containsString(\"important\") &#125; .flatMap &#123; word in return self.api.loadFlickrFeed(\"karate\") .catchError &#123; error in return just(JSON(1)) &#125; &#125; 如果编译器报告在这个表达式的某个地方有一个错误，我建议首先注释返回类型. 12345678images = word .filter &#123; s -&gt; Bool in s.containsString(\"important\") &#125; .flatMap &#123; word -&gt; Observable&lt;JSON&gt; in return self.api.loadFlickrFeed(\"karate\") .catchError &#123; error -&gt; Observable&lt;JSON&gt; in return just(JSON(1)) &#125; &#125; 如果这不起作用，您可以继续添加更多类型注释，直到将错误本地化. 12345678images = word .filter &#123; (s: String) -&gt; Bool in s.containsString(\"important\") &#125; .flatMap &#123; (word: String) -&gt; Observable&lt;JSON&gt; in return self.api.loadFlickrFeed(\"karate\") .catchError &#123; (error: Error) -&gt; Observable&lt;JSON&gt; in return just(JSON(1)) &#125; &#125; 我建议首先注释返回类型和闭包的参数. 通常在您修复了错误之后，您可以删除类型注释来重新清理您的代码. 调试单独使用调试器是很有用的，但是通常使用debug会更有效。debug操作符将把所有事件打印到标准输出中，您还可以添加标记这些事件。. debug就像一个探针。这里有一个使用它的例子: 123456789101112let subscription = myInterval(0.1) .debug(\"my probe\") .map &#123; e in return \"This is simply \\(e)\" &#125; .subscribe(onNext: &#123; n in print(n) &#125;)Thread.sleepForTimeInterval(0.5)subscription.dispose() 将打印 1234567891011121314[my probe] subscribedSubscribed[my probe] -&gt; Event next(Box(0))This is simply 0[my probe] -&gt; Event next(Box(1))This is simply 1[my probe] -&gt; Event next(Box(2))This is simply 2[my probe] -&gt; Event next(Box(3))This is simply 3[my probe] -&gt; Event next(Box(4))This is simply 4[my probe] disposeDisposed 您还可以轻松地创建debug操作符的版本. 123456789101112131415161718192021222324extension ObservableType &#123; public func myDebug(identifier: String) -&gt; Observable&lt;Self.E&gt; &#123; return Observable.create &#123; observer in print(\"subscribed \\(identifier)\") let subscription = self.subscribe &#123; e in print(\"event \\(identifier) \\(e)\") switch e &#123; case .next(let value): observer.on(.next(value)) case .error(let error): observer.on(.error(error)) case .completed: observer.on(.completed) &#125; &#125; return Disposables.create &#123; print(\"disposing \\(identifier)\") subscription.dispose() &#125; &#125; &#125; &#125; 启用调试模式使用RxSwift.Resources来调试内存泄漏或自动记录所有HTTP请求，您必须启用调试模式. 为了启用调试模式，必须将一个TRACE_RESOURCES标志添加到RxSwift目标构建设置中，在Other Swift Flags下. 有关如何用Cocoapods &amp; Carthage设置TRACE_RESOURCES标志的进一步讨论和指导，请参阅 #378 调试内存泄漏在调试模式下，Rx在全局变量Resources.total中跟踪所有分配的资源. 如果您想要有一些资源泄漏检测逻辑，最简单的方法就是打印RxSwift.Resources.total周期性的输出. 1234567/* add somewhere infunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil)*/_ = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .subscribe(onNext: &#123; _ in print(\"Resource count \\(RxSwift.Resources.total)\") &#125;) 测试内存泄漏的最有效方法是: 导航到你的屏幕并使用它 导航返回 观察初始资源数 第二次浏览你的屏幕并使用它 导航返回 观察最终的资源数 如果在初始资源和最终资源计数之间存在差异，可能会出现内存泄漏. 之所以建议2个导航，是因为第一个导航强制加载了惰性资源. VariablesVariables表示一些observable状态。不包含值的Variable不能存在，所以需要初始值. Variable封装Subject。更具体地说，这是一个BehaviorSubject。与BehaviorSubject不同，它只显示值接口，因此variable永远不能以错误结束. 它还会在订阅中立即播放它的当前价. 在variable被释放后，它将完成从.asObservable()返回observable序列. 1234567891011121314151617181920212223242526272829let variable = Variable(0)print(\"Before first subscription ---\")_ = variable.asObservable() .subscribe(onNext: &#123; n in print(\"First \\(n)\") &#125;, onCompleted: &#123; print(\"Completed 1\") &#125;)print(\"Before send 1\")variable.value = 1print(\"Before second subscription ---\")_ = variable.asObservable() .subscribe(onNext: &#123; n in print(\"Second \\(n)\") &#125;, onCompleted: &#123; print(\"Completed 2\") &#125;)print(\"Before send 2\")variable.value = 2print(\"End ---\") 将打印 123456789101112Before first subscription ---First 0Before send 1First 1Before second subscription ---Second 1Before send 2First 2Second 2End ---Completed 1Completed 2 KVOKVO是一种Objective-C机制。这意味着它并不是在考虑类型安全的情况下建立起来的。这个项目试图解决一些问题。 这个库支持KVO的方式有两种。 1234567891011// KVOextension Reactive where Base: NSObject &#123; public func observe&lt;E&gt;(type: E.Type, _ keyPath: String, options: KeyValueObservingOptions, retainSelf: Bool = true) -&gt; Observable&lt;E?&gt; &#123;&#125;&#125;#if !DISABLE_SWIZZLING// KVOextension Reactive where Base: NSObject &#123; public func observeWeakly&lt;E&gt;(type: E.Type, _ keyPath: String, options: KeyValueObservingOptions) -&gt; Observable&lt;E?&gt; &#123;&#125;&#125;#endif 例如如何观察UIView的frame. 警告:UIKit不是KVO兼容的，但这是可行的. 12345view .rx.observe(CGRect.self, \"frame\") .subscribe(onNext: &#123; frame in ... &#125;) 或 12345view .rx.observeWeakly(CGRect.self, \"frame\") .subscribe(onNext: &#123; frame in ... &#125;) rx.observerx.observe更有性能，因为它只是围绕KVO机制的一个简单包装，但它的使用场景更有限 它可以用于observe路径开始于来自self或来自所有权的祖先 (retainSelf = false) 它可以用于observe路径开始于从所有权中的后代 (retainSelf = true) 路径必须只包含 strong属性，否则，在dealloc之前，您可能会冒着破坏系统的风险. 如 1self.rx.observe(CGRect.self, \"view.frame\", retainSelf: false) rx.observeWeaklyrx.observeWeakly的速度比rx.observe慢一些。观察因为它必须在弱引用的情况下处理对象的交易. 它可以在rx.observe的所有情况下使用 因为它不会持有observed的目标，它可以用来observe任意的对象，它的所有权关系是未知的 它可以用来观察weak属性 如 1someSuspiciousViewController.rx.observeWeakly(Bool.self, \"behavingOk\") 观察结构KVO是一种Objective-C机制，因此它非常依赖于NSValue. RxCocoa为KVO提供了对CGRect、CGSize和CGPoint结构的支持. 当观察其他结构体时，必须手动从NSValue中提取这些结构。 RxCocoa/Foundation/KVORepresentable+CoreGraphics.swift)是如何扩展示例KVO观察机制和rx.observe*的方法，通过实现KVORepresentable协议。 UI层提示当绑定到UIKit控件时你的Observables 的一些东西在UI层中需要满足. 线程Observables需要在MainScheduler(UIThread)上发送值。这只是普通的UIKit/Cocoa需求. 对于您的api来说，在MainScheduler上返回结果通常是一个好主意。如果您试图从后台线程中绑定某个东西，在调试构建RxCocoa中通常会抛出一个异常来通知您这一点 要解决这个问题，您需要添加observeOn(MainScheduler.instance). URLSession扩展在默认情况下不会返回MainScheduler. 错误你不能将失败绑定到UIKit控件因为这是未定义的行为. 如果你不知道Observable可能失败,您可以使用catchErrorJustReturn(valueThatIsReturnedWhenErrorHappens)确保它不能失败,但是，在发生错误之后，底层的序列仍然会完成. 如果想要的行为是底层序列继续生成元素，则需要某些版本的retry操作符. 分享订阅您通常希望在UI层中共享订阅。您不需要单独进行HTTP调用来将相同的数据绑定到多个UI元素. 假设你有这样的东西: 12345678910let searchResults = searchText .throttle(0.3, $.mainScheduler) .distinctUntilChanged .flatMapLatest &#123; query in API.getSearchResults(query) .retry(3) .startWith([]) // clears results on new search term .catchErrorJustReturn([]) &#125; .shareReplay(1) // &lt;- notice the `shareReplay` operator 你通常想要的是分享搜索结果。这就是shareReplay的意思。 在UI层中，在转换链的末尾添加shareReplay通常是一个很好的经验法则，因为您确实想要共享计算结果。当将搜索结果绑定到多个UI元素时，您不希望触发单独的HTTP连接。 再看一下Driver单元。它被设计为透明地包装这些共享调用，确保在主UI线程上观察到元素，并且没有错误可以绑定到UI。 HTTP请求http请求是人们尝试的第一件事。 首先需要构建一个表示需要完成的工作的URLRequest对象. 请求确定是GET请求，还是POST请求，请求主体是什么，查询参数 … 这就是如何创建一个简单的GET请求 1let req = URLRequest(url: URL(string: \"http://en.wikipedia.org/w/api.php?action=parse&amp;page=Pizza&amp;format=json\")) 如果您想在组合之外执行其他observables的请求，那么这就是需要做的事情。 123456789101112131415let responseJSON = URLSession.shared.rx.json(request: req)// 没有任何请求会被执行到responseJSON,只是一个描述如何获取响应let cancelRequest = responseJSON // this will fire the request .subscribe(onNext: &#123; json in print(json) &#125;)Thread.sleep(forTimeInterval: 3.0)// 如果你想在3秒后取消请求cancelRequest.dispose() URLSession扩展不会在默认情况下返回MainScheduler. 如果您想要一个更低级别访问响应，您可以使用: 12345678910111213141516171819URLSession.shared.rx.response(myURLRequest) .debug(\"my request\") // 将把信息打印到控制台 .flatMap &#123; (data: NSData, response: URLResponse) -&gt; Observable&lt;String&gt; in if let response = response as? HTTPURLResponse &#123; if 200 ..&lt; 300 ~= response.statusCode &#123; return just(transform(data)) &#125; else &#123; return Observable.error(yourNSError) &#125; &#125; else &#123; rxFatalError(\"response = nil\") return Observable.error(yourNSError) &#125; &#125; .subscribe &#123; event in print(event) // 如果发生错误，也会将错误输出到控制台 &#125; 日志记录HTTP流量在调试模式下，RxCocoa将默认将所有HTTP请求记录到控制台。如果您想要改变这种行为，请设置Logging.URLRequests的过滤器。. 123456789101112// 读自己的配置public struct Logging &#123; public typealias LogURLRequest = (URLRequest) -&gt; Bool public static var URLRequests: LogURLRequest = &#123; _ in #if DEBUG return true #else return false #endif &#125;&#125; RxDataSources… 是一组为UITableView s和UICollectionView提供全功能的响应式数据源的类。 RxDataSources被绑定在 这里. 在RxExample项目中包含了如何使用它们的功能完整的演示。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 例子","slug":"RxSwift-Examples","date":"2017-10-26T02:21:15.000Z","updated":"2020-07-25T02:57:18.161Z","comments":true,"path":"2017/10/26/RxSwift-Examples/","link":"","permalink":"https://jigangduan.github.io/2017/10/26/RxSwift-Examples/","excerpt":"计算变量 简单的UI绑定 自动输入验证","text":"计算变量 简单的UI绑定 自动输入验证 计算变量首先，让我们从一些命令式代码开始。本例的目的是将标识符c绑定到从a和b计算的值，在满足某些条件下。 下面是计算c值的命令式代码: 12345678// 标准的命令式代码var c: Stringvar a = 1 // 只是赋值`1`到`a`一次var b = 2 // 只是赋值`2`到`b`一次if a + b &gt;= 0 &#123; c = \"\\(a + b) is positive\" // 只是赋值`c`一次&#125; c新的值是3 is positive. 然而，如果我们将a的值更改为4，那么c仍然会包含旧的值。 12a = 4 // `c` 仍然等于 \"3 is positive\", 这是不好的 // 我们想让 `c` 等于 \"6 is positive\" 因为 4 + 2 = 6 这不是我们想要的行为. 使用RxSwift改进的逻辑: 12345678910111213141516171819202122232425262728293031let a /*: Observable&lt;Int&gt;*/ = Variable(1) // a = 1let b /*: Observable&lt;Int&gt;*/ = Variable(2) // b = 2// 使用`+`组合最新`a`和`b`的变量值let c = Observable.combineLatest(a.asObservable(), b.asObservable()) &#123; $0 + $1 &#125; .filter &#123; $0 &gt;= 0 &#125; // 如果 `a + b &gt;= 0` 是 `true`, `a + b` 被传递给 `map` 操作符 .map &#123; \"\\($0) is positive\" &#125; // maps `a + b` 后为 \"\\(a + b) is positive\"// 因为初始值是a=1和b=2// 1 + 2 = 3 是 &gt;= 0, 所以 `c` 一开始等于 \"3 is positive\"// 要从Rx `Observable`中提取值，请从`c`的值订阅// `subscribe(onNext:)` 意味着订阅`c`的下一个(新)值// 这也包括初始值 \"3 is positive\".c.subscribe(onNext: &#123; print($0) &#125;) // 打印: \"3 is positive\"// 现在，让我们改变`a`的值a.value = 4 // 打印: 6 is positive// 最新值的总和, `4` + `2`, 是 `6`.// 因为 `&gt;= 0`, `map` 产生 \"6 is positive\"// 这个结果被赋值给 `c`.// 由于`c`的值改变了, `&#123; print($0) &#125;` 将被执行,// \"6 is positive\" 将被打印出来.// 现在，让我们改变`b`的值b.value = -8 // 没有任何打印// 最新值的总和, `4 + (-8)`, 是 `-4`.// 因为这不是 `&gt;= 0`, `map` 没有被执行.// 这意味着 `c` 仍然包含 \"6 is positive\"// 由于`c`没有被更新，所以没有产生新的“next”值// `&#123; print($0) &#125;` 不会被调用. 简单的UI绑定 不再是绑定变量, 让我们绑定UITextField的值使用rx.text属性 然后, map 类型 String 到类型 Int 使用异步API确定这个数字是否为质数 如果在异步调用完成之前修改了文本，那么一个新的async调用将通过concat来替代它 将结果绑定到 UILabel 12345678910111213let subscription/*: Disposable */ = primeTextField.rx.text // 类型是 Observable&lt;String&gt; .map &#123; WolframAlphaIsPrime(Int($0) ?? 0) &#125; // 类型是 Observable&lt;Observable&lt;Prime&gt;&gt; .concat() // 类型是 Observable&lt;Prime&gt; .map &#123; \"number \\($0.n) is prime? \\($0.isPrime)\" &#125; // 类型是 Observable&lt;String&gt; .bind(to: resultLabel.rx.text) // 返回 Disposable 可用于解除所有内容// 这将设置 `resultLabel.text` 为 \"number 43 is prime? true\" 在服务器调用完成后primeTextField.text = \"43\"// ...// 要解绑所有，只需调用它subscription.dispose() 本例中使用的所有操作符都是和第一个示例中使用的操作符一样的。没有什么特别的. 自动输入验证如果您是Rx的新手，那么下一个例子可能会有点让人难以抗拒。但是，这里是为了演示RxSwift代码在现实世界中的样子. 这个示例包含复杂的async UI验证逻辑，其中包含了进度通知。所有的操作都被disposeBag取消了。 让我们来试一试. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566enum Availability &#123; case available(message: String) case taken(message: String) case invalid(message: String) case pending(message: String) var message: String &#123; switch self &#123; case .available(message: let message), .taken(message: let message), .invalid(message: let message), .pending(message: let message): return message &#125; &#125;&#125;// 直接绑定UI控制值// 使用`usernameOutlet`的`username`作为username的值源self.usernameOutlet.rx.text .map &#123; username in // 同步验证，这里没有什么特别的 if username.isEmpty &#123; // 构建同步结果的方便性. // 如果在同一个方法中有混合的同步和异步代码, // 那么这将构造一个立即解析的异步结果. return Observable.just(Availability.invalid(message: \"Username can't be empty.\")) &#125; // ... // 当异步操作执行时，用户界面应该显示一些状态 let loadingValue = Availability.pending(message: \"Checking availability ...\") // 这将触发一个服务器调用来检查用户名是否已经存在. // 它的类型是 `Observable&lt;ValidationResult&gt;` return API.usernameAvailable(username) .map &#123; available in if available &#123; return Availability.available(message: \"Username available\") &#125; else &#123; return Availability.unavailable(message: \"Username already taken\") &#125; &#125; // 使用 `loadingValue` 直到服务器响应 .startWith(loadingValue) &#125;// 因为我们现在有 `Observable&lt;Observable&lt;ValidationResult&gt;&gt;`// 我们需要返回一个简单的 `Observable&lt;ValidationResult&gt;`.// 我们可以使用第二个示例中的concat操作符，但是如果提供了一个新的用户名，我们确实希望取消正在等待的异步操作。// 这就为什么使用 `switchLatest` 了. .switchLatest()// 现在我们需要将它绑定到用户界面.// 好的旧方法 `subscribe(onNext:)` 能够实现.// 这就是`Observable`链的末端. .subscribe(onNext: &#123; validity in errorLabel.textColor = validationColor(validity) errorLabel.text = validity.message &#125;)// 这将生成一个`Disposable`对象，能解绑所有事并取消正在等待的异步操作。// 而不是手动操作，这很麻烦,// 让我们在view controller dealloc时自动处理一切. .disposed(by: disposeBag)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift 设计原理","slug":"RxSwift-DesignRationale","date":"2017-10-26T02:13:53.000Z","updated":"2020-07-25T02:57:18.161Z","comments":true,"path":"2017/10/26/RxSwift-DesignRationale/","link":"","permalink":"https://jigangduan.github.io/2017/10/26/RxSwift-DesignRationale/","excerpt":"为什么不使用普通的错误类型","text":"为什么不使用普通的错误类型 12345enum Event&lt;Element&gt; &#123; case next(Element) // next element of a sequence case error(Error) // sequence failed with error case completed // sequence terminated successfully&#125; 让我们讨论一下Error的优点和缺点。 如果您有一个通用的错误类型，您将在两个observables之间创建额外的阻抗失配。 假设你有: Observable&lt;String, E1&gt; 和 Observable&lt;String, E2&gt; 如果不知道最终的错误类型将会是什么，那么就没有多少可以做的了。 是E1，E2还是一些新的E3呢?你需要一套新的运算符来解决阻抗失配。 这损害了合成属性，Rx不关心为什么一个序列失败了，它通常会在observable链上进一步向前推进。 还有一个额外的问题，在某些情况下，由于某些内部错误，操作符可能会失败，在这种情况下，您将无法构造一个典型错误并报告失败。 但是，我们先不管它，假设我们可以用它来对不出错的序列进行建模。它对这个目的有用吗? 是的，它有可能是，但是让我们考虑一下为什么你想要使用不会出错的序列。 一个典型的应用是在UI层中保持流，驱动整个UI。当您考虑这种情况时，仅仅使用编译器来证明序列不会出错，这还不够，您还需要证明其他属性。例如，在MainScheduler上观察到这些元素。 你真正需要的是一种通用的方法来证明observable序列的特征。有很多你可能感兴趣的属性。例如: 序列在有限时间内终止(服务器端) 序列只包含一个元素(如果您正在运行一些计算) 序列不会出错，也不会终止，并且元素在主调度器(UI) 序列不会出错，永远不会终止，并且元素在主调度器上传递，并且重新计算共享(UI) 序列不会出错，也不会终止，并且元素在特定的后台调度程序中被传送(音频引擎) 你真正想要的是一个用于observable序列的一般的编译器强制系统，以及一组用于那些想要属性的不变量运算符。 一个比较好的类比: 121, 3.14, e, 2.79, 1 + 1i &lt;-&gt; Observable&lt;E&gt;1m/s, 1T, 5kg, 1.3 pounds &lt;-&gt; 无错误observable, UI observable, 有限 observable ... 在Swift中有很多方法可以通过使用组合或继承observables来完成这样的事情。 使用单元系统的另一个好处是，您可以证明UI代码在相同的调度器上执行，因此在所有转换中使用无锁的操作符。 因为RxSwift已经没有了单个序列操作的锁，并且所有存在的锁都是有状态的组件(例如UI)，所以RxSwift代码中几乎没有锁，这使得编译器可以强制执行这些细节。 在保留Rx组合语义的情况下，使用Error错误不能以其他更干净的方式实现，这是没有好处的。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"RxSwift","slug":"RxSwift","date":"2017-10-24T06:36:35.000Z","updated":"2020-07-25T02:57:18.164Z","comments":true,"path":"2017/10/24/RxSwift/","link":"","permalink":"https://jigangduan.github.io/2017/10/24/RxSwift/","excerpt":"介绍 为什么使用RxSwift 概念 Observables和observers(观察者)(aka subscribers 订阅者)(aka subscribers 订阅者)) 创建和订阅Observables never empty just of from create range repeatElement generate deferred error doOn Subjects PublishSubject ReplaySubject BehaviorSubject Variable 合并操作符 switchLatest combineLatest zip merge startWith 转换操作符 map flatMap 和 flatMapLatest scan 过滤和条件运算符 filter distinctUntilChanged elementAt single take takeLast takeWhile takeUntil skip skipWhile skipWhileWithIndex skipUntil 数学运算及聚合操作符 toArray reduce concat 连接操作符 错误处理操作符 catchErrorJustReturn catchError retry retry(_:) 调试操作符 debug RxSwift.Resources.total 使能RxSwift.Resources.total","text":"介绍 为什么使用RxSwift 概念 Observables和observers(观察者)(aka subscribers 订阅者)(aka subscribers 订阅者)) 创建和订阅Observables never empty just of from create range repeatElement generate deferred error doOn Subjects PublishSubject ReplaySubject BehaviorSubject Variable 合并操作符 switchLatest combineLatest zip merge startWith 转换操作符 map flatMap 和 flatMapLatest scan 过滤和条件运算符 filter distinctUntilChanged elementAt single take takeLast takeWhile takeUntil skip skipWhile skipWhileWithIndex skipUntil 数学运算及聚合操作符 toArray reduce concat 连接操作符 错误处理操作符 catchErrorJustReturn catchError retry retry(_:) 调试操作符 debug RxSwift.Resources.total 使能RxSwift.Resources.total 介绍为什么使用RxSwift ?我们编写的绝大多数代码都会涉及到对外部事件的响应。 当用户操作一个control时，我们需要编写一个@IBAction方法处理响应。 当键盘何时改变位置时，我们需要观察通知来检测。 当URL会话响应网络数据时，我们必须提供闭包来执行。 我们还可以使用KVO来检测变量的变化。 所有这些不同的方法使我们的代码变得不必要地复杂。如果有一个一致性的方式来处理我们的所有的调用/响应，难道不是更好吗?Rx就是这样一个机制。 RxSwift是 Reactive（Rx）的正式实现, 大多数主要语言和平台都有。 概念 每个可观察(Observable)实例都是一个序列(Sequence)。 可观察(Observable)序列与Swift序列的关键优势在于，它还可以异步地接收元素。这就是RxSwift的精髓所在。其他的一切都扩展了这个概念。 一个Observable(ObservableType)相当于一个序列(Sequence)。 ObservableType.subscribe(_:)方法相当于Sequence.makeIterator()。 ObservableType.subscribe(_:)接收一个observer(观察者)(ObserverType)参数，它将被订阅自动接收由Observable发射的序列事件和元素，而不是在返回的生成器上手动调用next()。 如果一个Observable发出了next事件(Event.next(Element))，它可以继续发出更多的事件。但是，如果Observable发出了一个error事件(Event.error(ErrorType))或一个completed事件(Event.completed)，Observable序列就不能再向订阅者发出其它的事件了。 顺序语法更简明地解释了这一点: next* (error | completed)? 这也可以用图表来更直观地解释: 12345--1--2--3--4--5--6--|----&gt; // &quot;|&quot; = 正常终止--a--b--c--d--e--f--X----&gt; // &quot;X&quot; = 终止与一个错误--tap--tap----------tap--&gt; // &quot;|&quot; = 无限期地继续下去，比如按钮按下的序列 这些图表被称为大理石图表。你可以在RxMarbles.com上了解更多关于他们的信息。 Observables和observers(观察者)(aka subscribers 订阅者)除非有订阅者，否则Observables不会执行他们的订阅闭包。在下面的示例中，Observable的闭包将永远不会被执行，因为没有订阅者: 12345678example(\"Observable with no subscribers\") &#123; _ = Observable&lt;String&gt;.create &#123; observerOfString -&gt; Disposable in print(\"This will never be printed\") observerOfString.on(.next(\"😬\")) observerOfString.on(.completed) return Disposables.create() &#125;&#125; 在下面的例子中，当subscribe(_:)被调用时，闭包将被执行。 1234567891011example(\"Observable with subscriber\") &#123; _ = Observable&lt;String&gt;.create &#123; observerOfString in print(\"Observable created\") observerOfString.on(.next(\"😉\")) observerOfString.on(.completed) return Disposables.create() &#125; .subscribe &#123; event in print(event) &#125;&#125; subscribe(_:)返回一个Disposable实例，该实例表示一个可使用的资源，如订阅。在前面的简单示例中，它被忽略了，但是应该正常地处理它。这通常意味着将它添加到一个DisposeBag实例中。所有的例子都将包括正确的处理，因为，实践是永久的🙂。您可以在入门指南的处理部分中了解更多关于此的信息。 创建和订阅Observables有几种方法可以创建和订阅Observable序列。 never创建一个永不终止且从不发出任何事件的序列。更多信息 1234567891011example(\"never\") &#123; let disposeBag = DisposeBag() let neverSequence = Observable&lt;String&gt;.never() let neverSequenceSubscription = neverSequence .subscribe &#123; _ in print(\"This will never be printed\") &#125; neverSequenceSubscription.disposed(by: disposeBag)&#125; empty创建一个空的可观察序列，它只会发出一个已完成的事件。更多信息 123456789example(\"empty\") &#123; let disposeBag = DisposeBag() Observable&lt;Int&gt;.empty() .subscribe &#123; event in print(event) &#125; .disposed(by: disposeBag)&#125; 这个例子还介绍了连接创建和订阅可观察序列的链接。 just用一个元素创建一个可观察序列。更多信息 123456789example(\"just\") &#123; let disposeBag = DisposeBag() Observable.just(\"🔴\") .subscribe &#123; event in print(event) &#125; .disposed(by: disposeBag)&#125; of用固定数量的元素创建一个可观察序列。 123456789example(\"of\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\") .subscribe(onNext: &#123; element in print(element) &#125;) .disposed(by: disposeBag)&#125; 这个例子还介绍了使用subscribe(onNext:)便利方法。不同于subscribe(:)，它订阅了所有事件类型的事件(Next, Error, Completed)，subscribe(onNext:)订阅一种元素，它将忽略Error和Completed的事件，并且只生成Next事件元素。还有subscribe(onError:)和subscribe(on:)的便利方法。和有一个subscribe(onNext:onError:oncomplete:onDisposed:)的方法,你可以对一个或多个事件类型和订阅时由于任何原因终止,或处理: Example 1234567&gt; someObservable.subscribe( onNext: &#123; print(&quot;Element:&quot;, $0) &#125;, onError: &#123; print(&quot;Error:&quot;, $0) &#125;, onCompleted: &#123; print(&quot;Completed&quot;) &#125;, onDisposed: &#123; print(&quot;Disposed&quot;) &#125;)&gt; from从集合中创建一个可观察的序列，如Array、Dictionary或Set。 1234567example(\"from\") &#123; let disposeBag = DisposeBag() Observable.from([\"🐶\", \"🐱\", \"🐭\", \"🐹\"]) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 这个例子还演示了使用默认参数$0而不是显式地命名参数。 create创建一个自定义的可观察序列。更多信息 123456789101112131415example(\"create\") &#123; let disposeBag = DisposeBag() let myJust = &#123; (element: String) -&gt; Observable&lt;String&gt; in return Observable.create &#123; observer in observer.on(.next(element)) observer.on(.completed) return Disposables.create() &#125; &#125; myJust(\"🔴\") .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)&#125; range创建一个可观察序列，它会释放一系列顺序的整数，然后终止。更多信息 1234567example(\"range\") &#123; let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)&#125; repeatElement创建一个可观察的序列，它可以无限地释放给定的元素。更多信息 12345678example(\"repeatElement\") &#123; let disposeBag = DisposeBag() Observable.repeatElement(\"🔴\") .take(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 这个例子还介绍了使用take操作符从一个序列开始返回指定数量的元素。 generate创建一个可观察序列，只要提供的条件值为true，就可以生成值。 1234567891011example(\"generate\") &#123; let disposeBag = DisposeBag() Observable.generate( initialState: 0, condition: &#123; $0 &lt; 3 &#125;, iterate: &#123; $0 + 1 &#125; ) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; deferred为每个订阅者创建一个新的可观察序列。更多信息 12345678910111213141516171819202122232425example(\"deferred\") &#123; let disposeBag = DisposeBag() var count = 1 let deferredSequence = Observable&lt;String&gt;.deferred &#123; print(\"Creating \\(count)\") count += 1 return Observable.create &#123; observer in print(\"Emitting...\") observer.onNext(\"🐶\") observer.onNext(\"🐱\") observer.onNext(\"🐵\") return Disposables.create() &#125; &#125; deferredSequence .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) deferredSequence .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; error创建一个可观察序列，该序列不会发送任何条目，并立即终止错误。 1234567example(\"error\") &#123; let disposeBag = DisposeBag() Observable&lt;Int&gt;.error(TestError.test) .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)&#125; doOn为每个发出的事件调用一个副操作，并返回(通过)原始事件。更多信息 12345678example(\"doOn\") &#123; let disposeBag = DisposeBag() Observable.of(\"🍎\", \"🍐\", \"🍊\", \"🍋\") .do(onNext: &#123; print(\"Intercepted:\", $0) &#125;, onError: &#123; print(\"Intercepted error:\", $0) &#125;, onCompleted: &#123; print(\"Completed\") &#125;) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 还有 doOnNext(:), doOnError(:), doOnCompleted(_:)便利方法拦截这些特定事件,和doOn(onNext:onError:oncomplete)拦截一个或多个事件。 Subjects主题 主题是一种桥梁或代理，它在Rx的某些实现中可用，它既是观察者(observer)，也是可观察对象(Observable)。因为它是一个观察者，它可以订阅一个或多个可观察对象，因为它是一个可观察对象，它可以通过它所观察到的事件重新发射它们，它也可以发射新的事件。更多信息 1234567891011121314151617extension ObservableType &#123; /** Add observer with `id` and print each emitted event. - parameter id: an identifier for the subscription. */ func addObserver(_ id: String) -&gt; Disposable &#123; return subscribe &#123; print(\"Subscription:\", id, \"Event:\", $0) &#125; &#125;&#125;func writeSequenceToConsole&lt;O: ObservableType&gt;(name: String, sequence: O) -&gt; Disposable &#123; return sequence.subscribe &#123; event in print(\"Subscription: \\(name), event: \\(event)\") &#125;&#125; PublishSubject向所有的观察者广播新的事件，从他们订阅时开始。 123456789101112example(\"PublishSubject\") &#123; let disposeBag = DisposeBag() let subject = PublishSubject&lt;String&gt;() subject.addObserver(\"1\").disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.addObserver(\"2\").disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\")&#125; 这个例子还介绍了使用onNext(:)便利方法，它等价于on(.next(:)，它会将一个新事件发送给带有所提供元素的订阅者。还有onError(:)和onCompleted()便利方法，它们分别对应于on(.error(:))和on(.completed)。 ReplaySubject向所有订阅者广播新事件，并向新订户指定特定缓冲区大小的先前事件。 123456789101112example(\"ReplaySubject\") &#123; let disposeBag = DisposeBag() let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) subject.addObserver(\"1\").disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.addObserver(\"2\").disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\")&#125; BehaviorSubject向所有订阅者广播新事件，以及最近(或最初)对新订户的事件。 12345678910111213141516example(\"BehaviorSubject\") &#123; let disposeBag = DisposeBag() let subject = BehaviorSubject(value: \"🔴\") subject.addObserver(\"1\").disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.addObserver(\"2\").disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") subject.addObserver(\"3\").disposed(by: disposeBag) subject.onNext(\"🍐\") subject.onNext(\"🍊\")&#125; 注意前面的例子中遗漏了什么?一个完整的事件。PublishSubject、ReplaySubject和BehaviorSubject在即将disposed时不会自动发出Completed事件。 Variable包装一个BehaviorSubject，因此它将向新订户发送最新(或初始)值。变量也保持当前的值状态。变量永远不会发出错误事件。但是，它将自动发出一个已完成的事件，并在deinit上终止。 123456789101112example(\"Variable\") &#123; let disposeBag = DisposeBag() let variable = Variable(\"🔴\") variable.asObservable().addObserver(\"1\").disposed(by: disposeBag) variable.value = \"🐶\" variable.value = \"🐱\" variable.asObservable().addObserver(\"2\").disposed(by: disposeBag) variable.value = \"🅰️\" variable.value = \"🅱️\"&#125; 在一个Variable实例上调用asObservable()可以访问其基础的BehaviorSubject序列。变量没有实现on运算符(或onNext(:))，而是公开一个可用于获取当前值的value属性，并设置一个新值。设置一个新值也会将该值添加到其基础BehaviorSubject序列中。 合并操作符将多个源Observables组合成一个Observable的操作符。 startWith在可观察的源开始发射元素之前，发射指定的元素序列。更多信息 12345678910example(\"startWith\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\") .startWith(\"1️⃣\") .startWith(\"2️⃣\") .startWith(\"3️⃣\", \"🅰️\", \"🅱️\") .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; merge将源可观察序列中的元素组合成一个新的可观察序列，并在每个源可观察序列中释放出每个元素。更多信息 1234567891011121314151617181920212223example(\"merge\") &#123; let disposeBag = DisposeBag() let subject1 = PublishSubject&lt;String&gt;() let subject2 = PublishSubject&lt;String&gt;() Observable.of(subject1, subject2) .merge() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) subject1.onNext(\"🅰️\") subject1.onNext(\"🅱️\") subject2.onNext(\"①\") subject2.onNext(\"②\") subject1.onNext(\"🆎\") subject2.onNext(\"③\")&#125; zip将多达8个源可观察序列组合成一个新的可观察序列，并将从组合的可观察序列中发射出相应的可观察序列的各个元素。更多信息 12345678910111213141516171819202122example(\"zip\") &#123; let disposeBag = DisposeBag() let stringSubject = PublishSubject&lt;String&gt;() let intSubject = PublishSubject&lt;Int&gt;() Observable.zip(stringSubject, intSubject) &#123; stringElement, intElement in \"\\(stringElement) \\(intElement)\" &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) stringSubject.onNext(\"🅰️\") stringSubject.onNext(\"🅱️\") intSubject.onNext(1) intSubject.onNext(2) stringSubject.onNext(\"🆎\") intSubject.onNext(3)&#125; combineLatest将最多8个源可观察序列组合成一个新的可观察序列序列,并将开始发出联合可观察序列的每个源的最新元素可观测序列一旦所有排放源序列至少有一个元素,并且当源可观测序列发出的任何一个新元素。更多信息 123456789101112131415161718192021example(\"combineLatest\") &#123; let disposeBag = DisposeBag() let stringSubject = PublishSubject&lt;String&gt;() let intSubject = PublishSubject&lt;Int&gt;() Observable.combineLatest(stringSubject, intSubject) &#123; stringElement, intElement in \"\\(stringElement) \\(intElement)\" &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) stringSubject.onNext(\"🅰️\") stringSubject.onNext(\"🅱️\") intSubject.onNext(1) intSubject.onNext(2) stringSubject.onNext(\"🆎\")&#125; 还有一个combineLatest的变体，它使用一个数组(或任何其他可观察序列的集合): 12345678910111213example(\"Array.combineLatest\") &#123; let disposeBag = DisposeBag() let stringObservable = Observable.just(\"❤️\") let fruitObservable = Observable.from([\"🍎\", \"🍐\", \"🍊\"]) let animalObservable = Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\") Observable.combineLatest([stringObservable, fruitObservable, animalObservable]) &#123; \"\\($0[0]) \\($0[1]) \\($0[2])\" &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 由于combineLatest变体采用将数组传递给选择器函数，所以它要求所有的源可观察序列都是相同类型的。 switchLatest将可观察序列发射的元素转换成可观察的序列，并从最近的内部可观察序列中释放出元素。更多信息 12345678910111213141516171819202122example(\"switchLatest\") &#123; let disposeBag = DisposeBag() let subject1 = BehaviorSubject(value: \"⚽️\") let subject2 = BehaviorSubject(value: \"🍎\") let variable = Variable(subject1) variable.asObservable() .switchLatest() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) subject1.onNext(\"🏈\") subject1.onNext(\"🏀\") variable.value = subject2 subject1.onNext(\"⚾️\") subject2.onNext(\"🍐\")&#125; 在本例中，在设置variable.value为subject2后添加⚾️到subject1没有效果，因为只有最近的内可观察序列(subject2)才会发射元素。 转换操作符通过可观察的序列对下一个事件元素进行转换的操作符。 1234567example(\"map\") &#123; let disposeBag = DisposeBag() Observable.of(1, 2, 3) .map &#123; $0 * $0 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; map将一个转换闭包应用到可观察序列所发射的元素上，并返回转换后的元素的一个新的可观察序列。更多信息 flatMap 和 flatMapLatest将可观察序列发射的元素转换成可观察的序列，并将两个可观测序列的排放量合并成一个可观察的序列。当你有一个可观察的序列，它本身会发出可观测的序列，你想要能够对任何可观察序列的新排放做出反应，这也是很有用的。flatMap和flatMapLatest的区别在于，flatMapLatest只会从最近的内部可观察序列中发射出元素。更多信息 12345678910111213141516171819202122232425example(\"flatMap and flatMapLatest\") &#123; let disposeBag = DisposeBag() struct Player &#123; var score: Variable&lt;Int&gt; &#125; let 👦🏻 = Player(score: Variable(80)) let 👧🏼 = Player(score: Variable(90)) let player = Variable(👦🏻) player.asObservable() .flatMap &#123; $0.score.asObservable() &#125; // Change flatMap to flatMapLatest and observe change in printed output .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) 👦🏻.score.value = 85 player.value = 👧🏼 👦🏻.score.value = 95 // Will be printed when using flatMap, but will not be printed when using flatMapLatest 👧🏼.score.value = 100&#125; flatMapLatest实际上是map和switchLatest操作符的结合。 scan从一个初始值开始，然后对一个可观察序列发射的每个元素应用一个累加器闭包，并将每个中间结果作为一个单元素可观察的序列返回。更多信息 12345678910example(\"scan\") &#123; let disposeBag = DisposeBag() Observable.of(10, 100, 1000) .scan(1) &#123; aggregateValue, newValue in aggregateValue + newValue &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 过滤和条件运算符有选择性地从一个可观察到的序列中发射元素的操作者。 filter只从可观察的序列中发射出符合指定条件的元素。更多信息 12345678910111213example(\"filter\") &#123; let disposeBag = DisposeBag() Observable.of( \"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐱\", \"🐰\", \"🐹\", \"🐸\", \"🐱\") .filter &#123; $0 == \"🐱\" &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; distinctUntilChanged抑制可观察序列发出的序列重复元素。更多信息 12345678example(\"distinctUntilChanged\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐷\", \"🐱\", \"🐱\", \"🐱\", \"🐵\", \"🐱\") .distinctUntilChanged() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 1&quot;🐱&quot; &quot;🐷&quot; &quot;🐱&quot; &quot;🐵&quot; &quot;🐱&quot; elementAt只在一个可观察序列所发射指定索引中的元素。更多信息 12345678example(\"elementAt\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .elementAt(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 1&quot;🐸&quot; single只发出由可观察序列发出的第一个元素(或第一个符合条件的元素)。如果可观测的序列不发射一个元素，就会抛出一个错误。 123456789101112131415161718192021222324252627example(\"single\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .single() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125;example(\"single with conditions\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .single &#123; $0 == \"🐸\" &#125; .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐱\", \"🐰\", \"🐶\") .single &#123; $0 == \"🐰\" &#125; .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .single &#123; $0 == \"🔵\" &#125; .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)&#125; take只从可观察序列的开头发出指定数量的元素。更多信息 12345678example(\"take\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .take(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 1&quot;🐱&quot; &quot;🐰&quot; &quot;🐶&quot; takeLast只从可观察序列的末尾发出指定数量的元素。更多信息 12345678example(\"takeLast\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .takeLast(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 1&quot;🐸&quot; &quot;🐷&quot; &quot;🐵&quot; takeWhile只从可观察序列的开头发出,要指定条件的值为true 元素。更多信息 12345678example(\"takeWhile\") &#123; let disposeBag = DisposeBag() Observable.of(1, 2, 3, 4, 5, 6) .takeWhile &#123; $0 &lt; 4 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; takeUntil从一个源可观察序列中发射元素，直到一个可观察的序列释放出一个元素。更多信息 123456789101112131415161718192021example(\"takeUntil\") &#123; let disposeBag = DisposeBag() let sourceSequence = PublishSubject&lt;String&gt;() let referenceSequence = PublishSubject&lt;String&gt;() sourceSequence .takeUntil(referenceSequence) .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) sourceSequence.onNext(\"🐱\") sourceSequence.onNext(\"🐰\") sourceSequence.onNext(\"🐶\") referenceSequence.onNext(\"🔴\") sourceSequence.onNext(\"🐸\") sourceSequence.onNext(\"🐷\") sourceSequence.onNext(\"🐵\")&#125; 1&quot;🐱&quot; &quot;🐰&quot; &quot;🐶&quot; skip从一个可观察序列开始，抑制发射指定数量的元素。更多信息 12345678example(\"skip\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .skip(2) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; skipWhile从一个可观察到的序列的开始,抑制满足指定条件的元素。更多信息 12345678example(\"skipWhile\") &#123; let disposeBag = DisposeBag() Observable.of(1, 2, 3, 4, 5, 6) .skipWhile &#123; $0 &lt; 4 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; skipWhileWithIndex抑制从一个可观察到的序列的开始，满足指定条件的元素，并发射剩下的元素。闭包参数包含每个元素的索引。 12345678910example(\"skipWhileWithIndex\") &#123; let disposeBag = DisposeBag() Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .skipWhileWithIndex &#123; element, index in index &lt; 3 &#125; .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; skipUntil抑制元素从一个可观察序列中发射出来，直到一个可观察序列发射出一个元素。更多信息 123456789101112131415161718192021example(\"skipUntil\") &#123; let disposeBag = DisposeBag() let sourceSequence = PublishSubject&lt;String&gt;() let referenceSequence = PublishSubject&lt;String&gt;() sourceSequence .skipUntil(referenceSequence) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag) sourceSequence.onNext(\"🐱\") sourceSequence.onNext(\"🐰\") sourceSequence.onNext(\"🐶\") referenceSequence.onNext(\"🔴\") sourceSequence.onNext(\"🐸\") sourceSequence.onNext(\"🐷\") sourceSequence.onNext(\"🐵\")&#125; 数学运算及聚合操作符转换每个可观察元素成单个Observable的操作。 toArray将可观察序列转换为数组，将该数组作为一个新的单元素可观察序列发射，然后终止。更多信息 12345678example(\"toArray\") &#123; let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .toArray() .subscribe &#123; print($0) &#125; .disposed(by: disposeBag)&#125; reduce从一个初始值开始，然后将一个累加闭包应用到一个可观察序列所发射的所有元素上，并将总结果作为一个单元素可观察的序列返回。更多信息 12345678example(\"reduce\") &#123; let disposeBag = DisposeBag() Observable.of(10, 100, 1000) .reduce(1, accumulator: +) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; concat从序列的可观察序列的内可观察序列中加入元素，等待每个序列在从下一个序列中释放元素之前成功终止。更多信息 12345678910111213141516171819202122232425example(\"concat\") &#123; let disposeBag = DisposeBag() let subject1 = BehaviorSubject(value: \"🍎\") let subject2 = BehaviorSubject(value: \"🐶\") let variable = Variable(subject1) variable.asObservable() .concat() .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) subject1.onNext(\"🍐\") subject1.onNext(\"🍊\") variable.value = subject2 subject2.onNext(\"I would be ignored\") subject2.onNext(\"🐱\") subject1.onCompleted() subject2.onNext(\"🐭\")&#125; 连接操作符可连接的可观察序列与普通观察序列类似，只不过它们不是在订阅时开始发射元素，而是在调用connect()方法时才开始发射元素。通过这种方式，您可以等待所有预定的订阅者在开始发出元素之前订阅一个可连接的可观察序列。 在学习连接操作符之前，我们先来看一个非连接操作符的示例: 123456789101112131415func sampleWithoutConnectableOperators() &#123; printExampleHeader(#function) let interval = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) _ = interval .subscribe(onNext: &#123; print(\"Subscription: 1, Event: \\($0)\") &#125;) delay(5) &#123; _ = interval .subscribe(onNext: &#123; print(\"Subscription: 2, Event: \\($0)\") &#125;) &#125;&#125;//sampleWithoutConnectableOperators() // ⚠️ Uncomment to run this example; comment to stop running publish将源可观察序列转换为连接序列。更多信息 1234567891011121314151617181920212223func sampleWithPublish() &#123; printExampleHeader(#function) let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .publish() _ = intSequence .subscribe(onNext: &#123; print(\"Subscription 1:, Event: \\($0)\") &#125;) delay(2) &#123; _ = intSequence.connect() &#125; delay(4) &#123; _ = intSequence .subscribe(onNext: &#123; print(\"Subscription 2:, Event: \\($0)\") &#125;) &#125; delay(6) &#123; _ = intSequence .subscribe(onNext: &#123; print(\"Subscription 3:, Event: \\($0)\") &#125;) &#125;&#125;//sampleWithPublish() // ⚠️ Uncomment to run this example; comment to stop running replay将源可观察序列转换为连接序列，并将先前排放的缓冲区大小重放给每个新订户。更多信息 1234567891011121314151617181920212223func sampleWithReplayBuffer() &#123; printExampleHeader(#function) let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .replay(5) _ = intSequence .subscribe(onNext: &#123; print(\"Subscription 1:, Event: \\($0)\") &#125;) delay(2) &#123; _ = intSequence.connect() &#125; delay(4) &#123; _ = intSequence .subscribe(onNext: &#123; print(\"Subscription 2:, Event: \\($0)\") &#125;) &#125; delay(8) &#123; _ = intSequence .subscribe(onNext: &#123; print(\"Subscription 3:, Event: \\($0)\") &#125;) &#125;&#125;// sampleWithReplayBuffer() // ⚠️ Uncomment to run this example; comment to stop running multicast将可观察的序列转换成可连接的序列，并通过指定的主题广播其发射。 12345678910111213141516171819202122232425262728func sampleWithMulticast() &#123; printExampleHeader(#function) let subject = PublishSubject&lt;Int&gt;() _ = subject .subscribe(onNext: &#123; print(\"Subject: \\($0)\") &#125;) let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) .multicast(subject) _ = intSequence .subscribe(onNext: &#123; print(\"\\tSubscription 1:, Event: \\($0)\") &#125;) delay(2) &#123; _ = intSequence.connect() &#125; delay(4) &#123; _ = intSequence .subscribe(onNext: &#123; print(\"\\tSubscription 2:, Event: \\($0)\") &#125;) &#125; delay(6) &#123; _ = intSequence .subscribe(onNext: &#123; print(\"\\tSubscription 3:, Event: \\($0)\") &#125;) &#125;&#125;//sampleWithMulticast() // ⚠️ Uncomment to run this example; comment to stop running 错误处理操作符帮助从Observable的错误通知中恢复的操作符。 catchErrorJustReturn从错误事件中恢复，返回一个可观察序列，该序列释放一个元素，然后终止。更多信息 12345678910111213141516example(\"catchErrorJustReturn\") &#123; let disposeBag = DisposeBag() let sequenceThatFails = PublishSubject&lt;String&gt;() sequenceThatFails .catchErrorJustReturn(\"😊\") .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) sequenceThatFails.onNext(\"😬\") sequenceThatFails.onNext(\"😨\") sequenceThatFails.onNext(\"😡\") sequenceThatFails.onNext(\"🔴\") sequenceThatFails.onError(TestError.test)&#125; catchError通过切换到所提供的恢复可观察序列来从错误事件中恢复。更多信息 12345678910111213141516171819202122example(\"catchError\") &#123; let disposeBag = DisposeBag() let sequenceThatFails = PublishSubject&lt;String&gt;() let recoverySequence = PublishSubject&lt;String&gt;() sequenceThatFails .catchError &#123; print(\"Error:\", $0) return recoverySequence &#125; .subscribe &#123; print($0) &#125; .disposed(by: disposeBag) sequenceThatFails.onNext(\"😬\") sequenceThatFails.onNext(\"😨\") sequenceThatFails.onNext(\"😡\") sequenceThatFails.onNext(\"🔴\") sequenceThatFails.onError(TestError.test) recoverySequence.onNext(\"😊\")&#125; retry通过重新订阅可观察的序列，可以无限地恢复重复的错误事件。更多信息 12345678910111213141516171819202122232425262728example(\"retry\") &#123; let disposeBag = DisposeBag() var count = 1 let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in observer.onNext(\"🍎\") observer.onNext(\"🍐\") observer.onNext(\"🍊\") if count == 1 &#123; observer.onError(TestError.test) print(\"Error encountered\") count += 1 &#125; observer.onNext(\"🐶\") observer.onNext(\"🐱\") observer.onNext(\"🐭\") observer.onCompleted() return Disposables.create() &#125; sequenceThatErrors .retry() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; retry(_:)通过重新订阅可观察到的序列，再从错误事件中恢复，直到max重试次数的重试次数。更多信息 12345678910111213141516171819202122232425262728example(\"retry maxAttemptCount\") &#123; let disposeBag = DisposeBag() var count = 1 let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in observer.onNext(\"🍎\") observer.onNext(\"🍐\") observer.onNext(\"🍊\") if count &lt; 5 &#123; observer.onError(TestError.test) print(\"Error encountered\") count += 1 &#125; observer.onNext(\"🐶\") observer.onNext(\"🐱\") observer.onNext(\"🐭\") observer.onCompleted() return Disposables.create() &#125; sequenceThatErrors .retry(3) .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; 调试操作符帮助调试Rx代码的操作符。 debug打印出所有订阅、事件和disposals。 1234567891011121314151617181920212223242526272829example(\"debug\") &#123; let disposeBag = DisposeBag() var count = 1 let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in observer.onNext(\"🍎\") observer.onNext(\"🍐\") observer.onNext(\"🍊\") if count &lt; 5 &#123; observer.onError(TestError.test) print(\"Error encountered\") count += 1 &#125; observer.onNext(\"🐶\") observer.onNext(\"🐱\") observer.onNext(\"🐭\") observer.onCompleted() return Disposables.create() &#125; sequenceThatErrors .retry(3) .debug() .subscribe(onNext: &#123; print($0) &#125;) .disposed(by: disposeBag)&#125; RxSwift.Resources.total提供所有Rx资源分配的计数，这对于开发期间检测泄漏非常有用。 123456789101112131415161718192021222324252627282930#if NOT_IN_PLAYGROUND#elseexample(\"RxSwift.Resources.total\") &#123; print(RxSwift.Resources.total) let disposeBag = DisposeBag() print(RxSwift.Resources.total) let variable = Variable(\"🍎\") let subscription1 = variable.asObservable().subscribe(onNext: &#123; print($0) &#125;) print(RxSwift.Resources.total) let subscription2 = variable.asObservable().subscribe(onNext: &#123; print($0) &#125;) print(RxSwift.Resources.total) subscription1.dispose() print(RxSwift.Resources.total) subscription2.dispose() print(RxSwift.Resources.total)&#125;print(RxSwift.Resources.total)#endif 使能RxSwift.Resources.total在您的项目中，按照下列指示来启用RxSwift.Resources.total: CocoaPods 在你的Podfile中添加一个post_install, 如下所示: 运行 pod update 构建项目(Product -&gt; Build) Podfile： 123456789101112131415target &apos;AppTarget&apos; dopod &apos;RxSwift&apos;endpost_install do |installer| installer.pods_project.targets.each do |target| if target.name == &apos;RxSwift&apos; target.build_configurations.each do |config| if config.name == &apos;Debug&apos; config.build_settings[&apos;OTHER_SWIFT_FLAGS&apos;] ||= [&apos;-D&apos;, &apos;TRACE_RESOURCES&apos;] end end end endend Carthage 运行 carthage build –configuration Debug 构建工程(Product -&gt; Build)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"}]},{"title":"App研发录 笔记(一): 高效App框架设计与重构","slug":"《App研发录》笔记-第一部分-高效App框架设计与重构","date":"2017-10-20T08:11:59.000Z","updated":"2020-07-25T02:57:18.235Z","comments":true,"path":"2017/10/20/《App研发录》笔记-第一部分-高效App框架设计与重构/","link":"","permalink":"https://jigangduan.github.io/2017/10/20/《App研发录》笔记-第一部分-高效App框架设计与重构/","excerpt":"第一部分 高效App框架设计与重构","text":"第一部分 高效App框架设计与重构 第1章 重构 对于 App 来说，要么就一次性把它设计好，否则，就只能重构了。 重新规划 Android 项目的目录结构 建立 AndroidLib 类库，将与业务无关的逻辑转移到 AndroidLib。 com.infrastructure.activity: 业务无关的 Activity 基类 AndroidLib 下的基类 BaseActivity 封装的是业务无关的公用逻辑 AppBaseActivity 基类封装的是业务相关的公用逻辑 com.infrastructure.net: 网络底层封装 com.infrastructure.cache: 缓存数据和图片的相关处理 com.infrastructure.ui: 自定义控件 com.infrastructure.utils: 各种与业务无关的公用方法，比如对 SharedPreferences 的封装 主项目中的类分门别类地进行划分 activity:我们按照模块继续拆分，将不同模块的 Activity 划分到不同的包下。  adapter:所有适配器都放在一起 entity:将所有的实体都放在一起 db:SQLLite 相关逻辑的封装 engine:将业务相关的类都放在一起 ui:将自定义控件都放在这个包中 utils:将所有的公用方法都放在这里 interfaces:真正意义上的接口，命名以 I 作为开头 listener:基于 Listener 的接口，命名以 On 作为开头 每个文件只有一个单独的类，不要有嵌套类，比如在 Activity 中嵌套 Adapter、Entity 将 Activity 按照模块拆分归类后，可以迅速定位具体的一个页面。此外，将开发人员按照模块划分后，每个开发人员都只负责自己的那个包，开发边界线很清晰。 为 Activity 定义新的生命周期 单一职责:一个类或方法，只做一件事情 initVariables: 初始化变量，包括 Intent 带的数据和 Activity 内的变量 initViews: 加载 layout 布局文件，初始化控件，为控件挂上事件方法 loadData: 调用 MobileAPI 获取数据 AndroidLib 这个类库的 BaseActivity 中，重写 onCreate 方法 统一事件编程模型实体化编程使用 fastJSON 或 GSON 实体生成器 在页面跳转中使用实体 Adapter 模板BaseAdapter getCount() getItem() getItemId() getView() ViewHolder内置一个 Holder 嵌套类，用于存放 ListView 中每一行中的控件。ViewHolder 的存在，可以避免频繁创建同一个列表项，从而极大地节省内存。 1234class ViewHolder &#123; TextView tvCinemaName; TextView tvCinemaId;&#125; 类型安全转换函数 因为类型转换不正确导致的崩溃占了很大的比例 空类型 区域越界 第2章 Android 网络底层框架设计网络低层封装抛弃 AsyncTask 缺点，不能灵活控制其内部的线程池 没有暴露 出取消这些请求的方法 ThreadPoolExecutor + Runnable + Handler UrlConfigManager MobileAPI 接口的信息都 放在 url.xml 文件中: 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;Node Key=\"getWeatherInfo\" Expires=\"300\" NetType=\"get\" Url=\"http://www.weather.com.cn/data/sk/101010100.html\" /&gt; &lt;Node Key=\"login\" Expires=\"0\" NetType=\"post\" Url=\"http://www.weather.com.cn/data/login.api\" /&gt;&lt;/url&gt; 通过 UrlConfigManager 的 findURL 方法找到节点 RemoteService 和 RequestCallback、RequestParameter 12345678910111213141516171819202122@Overrideprotected void loadData() &#123; weatherCallback = new RequestCallback() &#123; @Override public void onSuccess(String content) &#123; //TODO: &#125; @Override public void onFail(String errorMessage) &#123; //TODO: &#125; &#125;; ArrayList&lt;RequestParameter&gt; params = new ArrayList&lt;RequestParameter&gt;(); RequestParameter rp1 = new RequestParameter(\"cityId\", \"111\"); RequestParameter rp2 = new RequestParameter(\"cityName\", \"Beijing\"); params.add(rp1); params.add(rp2); RemoteService.getInstance().invoke(this, \"getWeatherInfo\", params, weatherCallback);&#125; RemoteService 这个单例是用来发起请求的，它会创建一个 request，并将其添加到 RequestManager 中，然后放到 DefaultThreadPool 的一个线程中去执行这个 request. RequestManager RequestManager 这个集合类是用于取消请求(cancelRequest)的 DefaultThreadPool 对 ThreadPoolExecutor 和 ArrayBlockingQueue 的简单封装 HttpRequest HttpRequest 是发起 Http 请求的地方，它实现了 Runnable 网络底层的一些优化工作onFail 的统一处理机制 如果访问 MobileAPI 请求失败，我们一般希望只是在 App 上简单地弹出一个提示框，告 诉用户网络有异常。 自定义类 AbstractRequestCallback 12345678910111213public abstract class AppBaseActivity extends BaseActivity &#123; public abstract class AbstractRequestCallback implements RequestCallback &#123; public abstract void onSuccess(String content); public void onFail(String errorMessage) &#123; new AlertDialog.Builder(AppBaseActivity.this) .setTitle(\" 出错啦 \").setMessage(errorMessage) .setPositiveButton(\" 确定 \", null).show(); &#125; &#125;&#125; UrlConfigManager 的优化 在 App 启动时，一次性将 url.xml 文件都读取到内存，把所有 的 UrlData 实体保存在一个集合中，然后每次调用 MobileAPI 接口，直接从内存的这个集 合中查找。 不是每个请求都需要回调的 ProgressBar 的处理 App 数据缓存设计数据缓存策略 对于 App 而言，它是感受不到取的是缓存数据还是调用 MobileAPI。具体工作由网络底层完成。 在 url.xml 中为每一个 MobileAPI 接口配置缓存时间 Expired。对于 post，一律设置为 0，因为 post 不需要缓存。 在 HttpRequest 类中的 run 方法中，改动 3 个地方: 写一个排序算法 sortKeys，对 URL 中的 key 进行排序。 将 newUrl 作为 key，检查缓存中是否有数据，有则直接返回;否则，继续调用MobileAPI 接口。 MobileAPI 接口返回数据后，将数据存入缓存。 CacheManager 用于操作读写缓存数据，并判断缓存数据是否过期。缓存中存放的实 体就是 CacheItem。 在 App 项目中，创建 YoungHeartApplication 这个 Application 级别的类，在程序启动 时，初始化缓存的目录，如果不存在则创建之。 强制更新 App MockService用户登录自动登录Cookie Cookie 过期的统一处理防止黑客刷库一种安全解决方案是为登录接口增加第三个参数，验证码。每次登录 都必须输入验证码，其实就是为了防止被黑客刷库 防止黑客刷库HTTP 头中的奥妙acceptaccept-languagereferreruser-agentaccept-encodingcheck-value: AppId ClientType MD5 时间校准 Date 永远使用UTC 时间 开启 gzip 压缩第3章 Android 经典场景设计App 缓存分为两部分，数据缓存和图片缓存。 App 图片缓存设计ImageLoader 设计原理 ImageLoader 的目的是为了实现异步的网络图片 加载、缓存及显示，支持多线程异步加载。 ImageLoader 的工作原理 : 在显示图片的时候，先在内存中查找; 如果没有，就去本地查找;如果还没有，就开一个新的线程去下载这张图片，下载成功会把图片同时缓存到内存和本地。 每次退出一个页面的时候，把 ImageLoader 内存中的缓存全都清除，这样就节省了大量内存。 ImageLoader 对图片是软引用的形式，所以内存中的图片会在内存不足的时 候被系统回收(内存足够的时候不会对其进行垃圾回收)。 ImageLoader 优化 在 AppBaseActivity 中的 onDestroy 方法中，执行 ImageLoader 的 clearMemoryCache 方法，以确保页面销毁时，把为了显示这个页面而增加的内存缓存清除。 图片加载利器 FrescoFresco 的原理是，设计了一个 Image Pipeline 的概念，它负责先后检查内存、磁盘文件 (Disk)，如果都没有再老老实实从网络下载图片. Fresco 有3个线程池，其中 3个线程用于网络下载图片，2个线程用于磁盘文件的读写， 还有 2个线程用于 CPU相关操作，比如图片解码、转换，以及放在后台执行的一些费时操作. Fresco 三层缓存: 第一层:Bitmap 缓存 Android 5.0 系统中, Bitmap 缓存位于 Java 的堆(heap)中 Android 4.x 和更低的系统，Bitmap 缓存位于 ashmem。创建和回收不会引发过多的 GC 当 App 切换到后台时，Bitmap 缓存会被清空。 第二层:内存缓存 内存缓存中存储了图片的原始压缩格式。从内存缓存中取出的图片，在显示前必须先解码。当 App 切换到后台时，内存缓存也会被清空。 第三层:磁盘缓存 磁盘缓存，又名本地存储。磁盘缓存中存储的也是图片的原始压缩格式。在使用前也要 先解码。当 App 切换到后台时，磁盘缓存不会丢失，即使关机也不会。 对网络流量进行优化API 层面进行优化: 要使用 gzip 进行压缩。注意:大于 1KB 才进行压缩， 否则得不偿失。经过 gzip 压缩后，返回的数据量大幅减少 JSON 格式 或 ProtoBuffer 少网络 访问次数，能调用一次 MobileAPI 接口就能取到数据的，就不要调用两次 TCP 长连接，以提高访问 的速度。缺点是一台服务器能支持的长连接个数不多，所以需要更多的服务器集成 要建立取消网络请求的机制 增加重试机制，get 请求配置重试机制，比如 get 请求失败后重试 3 次 图片策略优化 要确保下载的每张图，都符合 ImageView 控件的大小 http://www.aaa.com/a.png?width=100&amp;height=50 低流量模式 在 2G 和 3G 网络环境下，我们应该适当降低图片的质量。降低图片质量，相应的图片 大小也会降低，我们称为低流量模式。 极速模式 在 2G 和 3G 网络环境下，用户大多对图片不感兴趣，他们可能就是想 快速下单并支付，我们需要额外设计一些页面，区别于正常模式下图文并茂的页面，这些只有文字的页面称为极速模式。 城市列表的设计 本地保存 线上最新的城市列表数据(序列化后的)以及对应的版本号。每次发版前做一次城市数据同步。 每次进入到城市列表这个页面时，将本地城市列表数据对应的版本号 version 传入到 MobileAPI 接口，根据返回的 isMatch 值来决定是否版本号一致。如果一致，则直接从本地 文件中加载城市列表数据;否则，就解析 MobileAPI 接口返回的数据，在显示列表的同时， 记得要把最新的城市列表数据和版本号保存到本地。 如果 MobileAPI 接口没有调用成功，也是直接从本地文件中加载城市列表数据，以 确保主流程是畅通的。 每次调用 MobileAPI 时，会获取到大量的数据，一般我们会打开 gzip 对数据进行压 缩，以确保传输的数据量最小 城市列表数据的增量更新机制 App 与 HTML5 的交互App 操作 HTML5 页面的方法 首先要定好通信协议，也就是 App 要调用的 HTML5 页面中 JavaScript 的方法名称。 HTML5: 12345&lt;script type=\"text/javascript\"&gt; function changeColor (color) &#123; document.body.style.backgroundColor = color; &#125;&lt;/script&gt; Android: 12345678910wvAds.getSettings().setJavaScriptEnabled(true);wvAds.loadUrl(\"file:// /android_asset/104.html\");btnShowAlert.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String color = \"#00ee00\"; wvAds.loadUrl(\"javascript: changeColor ('\" + color + \"');\"); &#125;&#125;); HTML5 页面操作 App 页面的方法 仍然是先定义通信协议，这次定义的是 JavaScript 要调用的 Android 中方法名称。 HTML5: 12&lt;a onclick=\"baobao.callAndroidMethod(100,100,'ccc',true)\"&gt; CallAndroidMethod&lt;/a&gt; Android: 1234567891011class JSInteface1 &#123; public void callAndroidMethod(int a, float b, String c, boolean d) &#123; if (d) &#123; String strMessage = \"-\" + (a + 1) + \"-\" + (b + 1) + \"-\" + c + \"-\" + d; new AlertDialog.Builder(MainActivity.this) .setTitle(\"title\") .setMessage(strMessage).show(); &#125; &#125;&#125; 注册 baobao 和 JSInterface1 的对应关系: 1wvAds.addJavascriptInterface(new JSInteface1(), &quot;baobao&quot;); App 和 HTML5 之间定义跳转协议 在这个 HTML5 页面中，我们可以定义各种 JavaScript 点击事件，从而跳转回 App 的任 意 Native 页面。 在 App 中内置 HTML5 页面 灵活切换 Native 和 HTML5 页面的策略 经常改动的页面，做成HTML5页面， WebView的形式加载。避免了 Native页面每次修改，都要等一次迭代上线后才能看到。 HTML5 开发周期短 HTML5 的缺点是慢 需要做一个后台，根据版本进行配置每个页面是使用 Native 页面还是 HTML5 页面。 在 App 启动的时候，从 MobileAPI 获取到每个页面是 Native 还是 HTML5。 在 App 的代码层面，页面之间要实现松耦合。为此，我们要设计一个导航器Navigator，由它来控制该跳转到 Native 页面还是 HTML5 页面。最大的挑战是页面间参数传递，字典是一种比较好的形式，消除了不同页面对参数类型的不同要求。 页面分发器 1234&lt;a onclick=\"baobao.gotoAnyWhere( 'com.example.youngheart.MovieDetailActivity, iOS.MovieDetailViewController:movieId=(int)123')\"&gt; gotoAnyWhere&lt;/a&gt; 12345678910111213141516171819202122public class BaseActivity extends Activity &#123; public void gotoAnyWhere(String url) &#123; if (url == null) return; String pageName = getAndroidPageName(url); if (pageName == null || pageName.trim() == \"\") return; Intent intent = new Intent(); ... try &#123; intent.setClass(this, Class.forName(pageName)); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; startActivity(intent); &#125;&#125; 消灭全局变量重现场景就是在 App切换到后台，闲置了一段时间后再继 续使用时，就会崩溃。尤其是一些配置很低的手机， 罪魁祸首就是全局变量 想彻底解决这个问题，就一定要使用序列化技术 把数据作为 Intent 的参数传递 把全局变量序列化到本地 序列化只是过渡型解决方案，有几个硬伤 类型 是否支持序列化 简单类型 int, String, Boolean 等 支持 String[] 支持 Boolean[] 支持 int[] 支持 String[][] 支持 int[][] 支持 ArrayList 支持 Calendar 支持 JSONObject 不支持 JSONArray 不支持 HashMap&lt;String, Objeject&gt; 因为 Object 可能是不支持序列化的 JSONObject 类型，所以HashMap&lt;String, Object&gt; 不一定支持序列化 ArrayList&lt;HashMap&lt;String, Object&gt;&gt; 因为 Object 可能是不支持序列化的 JSONObject 类型，所以 ArrayList&lt;HashMap&lt;String, Object&gt;&gt; 不一定支持序列化 如果 Activity 也被销毁了呢 如果内存不足导致当前 Activity 也被销毁了呢?比如说旋转屏幕从竖屏到横屏。 即使 Activity 被销毁了，传递到这个 Activity 的 Intent 并不会丢失，在重新执行 Activity 的 onCreate 方法时，Intent 携带的 bundle 参数还是在的。 onSaveInstanceState()* onRestoreInstanceState() 如何看待 SharedPreferences SharedPreferences 是全局变量序列化到本地的另一种形式 User 是唯一例外的全局变量 第4章 Android 命名规范和编码规范 尽量简单，多写注释 Android 命名规范Java 类文件命名规范： Activity: 以Activity作为后缀，比如 PersonActivity Adapter: 以Adapter作为后缀，比如 PersonAdapter Entity: 以Entity作为后缀，比如 PersonEntity 资源文件命名规范： layout 页面布局文件： act_为前缀，以Activity所在的 Package 为中缀，以Activity的名称(去掉Activity)作为后缀。都是小写。比如 act_person_customer.xml ListView中的item布局文件：item_为前缀，ListView控件名称为后缀。 比如控件名称lvUserList时item_lv_user_list.xml Dialog布局文件：dlg_ + 名称 drawable 对于只在一个页面使用的资源，以该页面的名称为前缀 对于只在一个模块下多个页面使用的资源，以该模块的名称为前缀 对于在各个模块，各个页面都有可能使用的资源，比如下导航，下导航，以common作为前缀 Java类中控件对象的命名规范 控件类型缩写 + 控件的逻辑名称（首字母大写） 比如登录按钮：btnLogin 控 件 缩写 LayoutView lv RelativeView rv TextView tv Button btn ImageButton img ImageView iv CheckBox chk RadioButton rb DatePicker dp EditText et TimePicker tp toggleButton tb ProgressBar pb WebView wv RantingBar rb Tab tab List lv MapView mv Layout 中控件对象的命名规范 控件的逻辑名称（小写） + 控件类型 比如： login_button string.xml 中常量的命名规范 loginActivity_btnLogin_text common_ Java 中的常量命名 只能包括字母和下划线_，字母全大写，单词之间用 _ 隔空 Android 编程规范 不能为了规范而规范 要分门别类存放各种类 要怎么使用findViewById语句？ Layout中的常量，要在资源strings.xml中定义 Layout中的所有控件的字体大小，在dimens.xml中 在Acitivity中定义新的生命周期，拆分onCreate (initVariables -&gt; initViews -&gt; loadData) 使用fastJSON实体化数据 页面之间传值，使用Intent携带序列化实体数据 为控件添加事件，统一使用方法 Activity中不要嵌套内部类，尽量独立出来 Adapter 所有Adapter，都放在 adapter 包中 Adapter绑定的数据，一律为 ArrayList&lt;自定义可序列化实体&gt; 在Adapter中创建适合于列表自身的ViewHolder实体类，统一命名为 ViewHolder 实体不要在不同模块间共享，但可以在同一模块下的不同页面间共享 为节省内存，请使用ArrayList&lt;自定义实体&gt;，而不是HashMap 图片处理，请使用第三方库 什么时候使用SharedPreferences？ 简单配置信息 尽量使用ApplicationContext代替Context，防止内存泄漏 数据类型转换一定要进行校验，防止空指针或类型转换失败 使用常量代替枚举 统一代码格式Android源码中包含了一份 android-formatting.xml, 专门用于统一代码格式。导入 IDE后，使用快捷键，就可以调整代码格式 自动检查工具 checkstyle","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"读书笔记","slug":"Android/读书笔记","permalink":"https://jigangduan.github.io/categories/Android/读书笔记/"},{"name":"App研发录","slug":"Android/读书笔记/App研发录","permalink":"https://jigangduan.github.io/categories/Android/读书笔记/App研发录/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"notes","slug":"notes","permalink":"https://jigangduan.github.io/tags/notes/"},{"name":"app","slug":"app","permalink":"https://jigangduan.github.io/tags/app/"}]},{"title":"TCLMOVE 技术选型","slug":"TCLMOVE-技术选型","date":"2017-10-19T11:50:15.000Z","updated":"2020-07-25T02:57:18.170Z","comments":true,"path":"2017/10/19/TCLMOVE-技术选型/","link":"","permalink":"https://jigangduan.github.io/2017/10/19/TCLMOVE-技术选型/","excerpt":"Swift Storyboard RxSwfit Rleam R.Swfit Moya+Alamofire+ObjectMapper SwiftyBeaver Kingfisher CocoPod …","text":"Swift Storyboard RxSwfit Rleam R.Swfit Moya+Alamofire+ObjectMapper SwiftyBeaver Kingfisher CocoPod … 编程语言选择 Swift Object-C Swift的优势： 趋势 苹果已经明确，Swift将是未来的主力开发语言 Swift定位是安全，快速，跨平台的语言 gitHub上新增的第三方开源库，Swift版本要多余Object-C的版本 Swift的缺点： 不支持Runtime 编译速度慢 Swift核心库会打包在APP中，增加了APP体积 建议： 对于新项目尽量采用Swift，对于业务复杂的旧项目Object-C继续维持 代码手写 UI 和 Storyboard 之间的取舍构建 UI 方式的争论就在 Cocoa 开发者社区里一直发生着，Storyboard 被诟病最多的 是冲突风险和加载速度。 冲突风险 Storyboard 一直在进步，在 Xcode 7 引入了 SB reference 以后，「SB 容易冲突」已经得到很好的解决了。 加载速度 编译过程中，项目里用到的 SB 文件也会被编译，并以 storyboardc 为扩展名保存在最终的 app 包内。这个是一个文件夹，里面存储了一系列 .nib 文件。SB 中的每个对象将会被编译为一个单独的 .nib。 Storyboard 优势 Storyboard可以简化UI的开发，属性设置和布局都可以简单化，实现和逻辑代码的分离，不会污染代码。 建议： 采用Storyboard RxSwiftRxSwift是Swift函数响应式编程的一个开源库，由Github的ReactiveX组织开发，维护。 RxSwift的优点 Composable 可组合，在设计模式中有一种模式叫做组合模式，你可以方便的用不同的组合实现不同的类 Reusable 代码可重用，原因很简单，对应RxSwift，就是一堆Obserable Declarative 响应式的，因为状态不可变，只有数据变化 Understandable and concise 简洁，容易理解。 Stable 稳定，因为RxSwift写出的代码，单元测试时分方便 Less stateful “无”状态性，因为对于响应式编程，你的应用程序就是一堆数据流 Without leaks 没有泄漏，因为资源管理非常简单 RleamRealm是由Y Combinator孵化的创业团队开源出来的一款可以用于iOS(同样适用于Swift&amp;Objective-C)和Android的跨平台移动数据库。 跨平台：支持的平台包括Java，Objective-C，Swift，React Native，Xamarin。 简单易用：Core Data 和 SQLite 冗余、繁杂的知识和代码，而Realm，可以极大地减少学习成本，立即学会本地化存储的方法。 可视化：Realm 还提供了一个轻量级的数据库查看工具，可以查看数据库当中的内容，执行简单的插入和删除数据的操作。 R.SwfitR.Swfit 在Swift项目中自动生成资源（像图片，字体，转场）相关的强类型变量，可以优雅的获取资源，仿Android资源文件使用的方法。 相关资源： Swift-颜色设置技巧和(.clr)文件的创建和使用 Sip：做屏幕取色没人比我强 Moya+Alamofire+ObjectMapperMoya的基本思想是，提供一些网络抽象层，它们被充分的封装了且实际上直接调用了Alamofire. 它不仅在普通的简单的事情上很容易使用，而且在综合的复杂的事情上也容易使用 如果你使用 Alamofire 来抽象 URLSession, 那为什么不使用一些方式来抽象URLs和parameters等等的本质呢?Moya的一些特色功能: 对正确的API端点访问进行编译时检查. 让您使用关联的枚举值定义不同端点的清晰用法. 把test stub作为一等公民，所以单元测试超级简单. Alamofire 是一个用Swift编写的HTTP网络库. 特性： 链式的请求/响应方法 URL/JSON/plist参数编码 上传文件/数据/流/MultipartFormData 使用请求或恢复数据下载文件 身份验证使用URLCredential HTTP响应验证 上传和下载进度闭包 cURL命令输出 动态调整和重试请求 TLS证书和公钥固定 网络可达性 综合单元和集成测试覆盖 完整的文档 ObjectMapper是一个用Swift编写的框架，它使您可以很容易地将模型对象(类和结构)转换为JSON。 特性： JSON对象映射 将对象映射到JSON 嵌套对象(在数组或字典中单独使用) 自定义转换期间映射 结构支持 常量的支持 SwiftyBeaverSwiftyBeaver，Swift多彩日志记录。 特性: 开发期间: 彩色记录到Xcode控制台 开发期间: 彩色记录文件 发布期间: 加密记录到SwiftyBeaver平台 通过Mac App来浏览、搜索和过滤 KingfisherKingfisher是一个轻量级的、纯Swift的库，用于从web上下载和缓存图像。这个项目深受流行的SDWebImage的启发。 特性: 异步图像下载和缓存。 基于URLSession。基本的图像处理器和过滤器。 用于内存和磁盘的多层缓存。 可取消下载和处理任务以提高性能。 独立的组件。根据需要分别使用下载程序或缓存系统。 预取图像并在必要时从缓存中显示它们。 用于UIImageView、NSImage和UIButton的扩展，可以直接从URL中设置图像。 设置映像时内置的转换动画。 可定制的占位符，同时载入图片。 可扩展的图像处理和图像格式支持 CocoPodsCocoaPods iOS端的依赖管理工具。 使用CocoPods作项目依赖库的管理工具，包括第三方和本地的。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"架构设计","slug":"iOS/架构设计","permalink":"https://jigangduan.github.io/categories/iOS/架构设计/"},{"name":"TCLMOVE","slug":"iOS/架构设计/TCLMOVE","permalink":"https://jigangduan.github.io/categories/iOS/架构设计/TCLMOVE/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"}]},{"title":"TCLMOVE 架构设计","slug":"TCLMOVE-架构设计","date":"2017-10-19T11:49:52.000Z","updated":"2020-07-25T02:57:18.171Z","comments":true,"path":"2017/10/19/TCLMOVE-架构设计/","link":"","permalink":"https://jigangduan.github.io/2017/10/19/TCLMOVE-架构设计/","excerpt":"架构，就是对软件复杂度的管理。","text":"架构，就是对软件复杂度的管理。 层次划分 三层结构框架 UI Layer Logic Layer Persistence Layer UI Layer 展现层UI Layer 采用MVVM框架。 View V对应View，责任只负责显示，不保存任何状态，保证View的无状态性，states 只能来源于外部，同样的states设置，View 显示显示内容一样。 View最主要的是实现组件化，与其它组件和模块保持最大化的隔离，对内的接口只有states,对外的接口只有events. 比如 基于Rx的方式 : 12view.rx.statesview.rx.events.click View的复杂度在于自身的实现(复杂的绘制／动画)，以及Views之间的组合，组件之间的最大化的隔离是防止复杂度的膨胀。 ViewModel VM对应ViewModel, 负责绑定数据和Views。MVVM的机制是VM实现V和M的数据绑定，双向绑定或单向绑定，由于要实现View的无状态，在此只作单向的数据绑定，数据来源于M，单向流于view的states。 ViewModel对应一个ViewController,此Scene中所有的views状态设置都集中在其中，统一处理，避免代码分散在ViewController各处，造成逻辑混乱；views的enents也是经由此地，产生Actions. ViewModel会分担大部分ViewController上的逻辑代码，但也只是UI层面的，主要工作是states和events的分发和中间状态的转化，一些简单的限制判断和states的组合／分解，仅此而已。 Model M对应Model，UI Layer以下对应MVVM的Model. V和VM负责展现层上的部分，作到无状态化。而所有的状态都在Model之中，状态改变UI呈现改变。 Logic Layer 业务层Logic Layer会根据业务划分出许多功能模块，业务层应该最先进入详细设计，对比需求分析有效的分离出独立的功能模块。 业务层主要有三个角色： Manager 管理者 Worker Protocl 工作协议 Worker 工作者 以下我们将以公司组织结构类比的方式介绍业务层和三个角色。 业务层会根据业务需求划分出相应的功能模块，就像公司的各个不同的职能部门，各自有自己的分工与协作。 各部门组织成员都有Manager和Worker，有自己的职责。 Manager 主要职责是 管理Workers, 分发任务， 协调任务， 与上层交互。Manager 不会处理具体的工作，具体工作由Worker来实现。 Worker只关心一个单独的任务，其它的事情不涉及，而且只对他自己的Manager负责。Worker所需要的资源和工具来源于下游。 工作任务由Manager下派，通过工作清单即Worker Protocl。Worker Protocl是工作规范（即接口也叫协议），指明了需要实现的操作。而能够完成这些规范的Workers，不只一个，比如经理(Manager)需要存储一份文档，一个小秘(Worker)说她可以存储在本地，一个码农(Worker)说他可以上传存储到服务器，至于使用那个Worker由Manager决定。 部门之间的协作也是由Manager完成，部门经理会向其它部门获取结果。如果一项工作需要几个部门协作完成，可以产生一个更高级的Manager，管理这几个部门的Managers。 Persistence Layer 持久层持久层是对接基础设施，资源的出入口，也可以叫资源层。 其主要包括： HTTP Client 数据库 BLE 本地文件 资源文件 … HTTP Client 服务器端采用HTTP/RESTful，移动端对应采用API层和Client层。 Client层 对应HTTP客户端功能，完成HTTP网络请求功能。 API层 对应Rest，完成接口定义，让上层通过接口直接操作资源。 还需要完成本地缓存功能，配合服务端的HTTP缓存机制，和自己的离线缓存。 数据库 数据库实现DAO（数据访问对象），统一数据库的数据操作标准。 数据库采用ORM(对象关系映射)框架，屏蔽SQL的操作步骤。 Change Events,当数据库数据改变时，产生相应的通知事件。 BLE File Manage Resource Manage 三层之间的桥梁三层结构UI Layer，Logic Layer，Persistence Layer如上所述，各自有各自的职责，彼此之间也是隔离的，这样就可以分配给不同的开发人员，独立的单元测试。而它们之间需求建立沟通的桥梁。 App StatesApp States的思想来源与Flux架构，实现它的有前端的Redux。【可参考 Redux】 App States是一个状态管理器，如上所述UI层是无状态的，而它的状态来源是App States，并且作状态的统一管理。 App States保存了所有的状态，通过View Model绑定View，当状态发生变化时相应的View会发生改变。 这里最大的难度是states。归纳states需要即要全面也要精准,那些值可以是state那些不是请慎重考虑。比如业务数据中的小孩子信息是一定在states中，还有像 正在获取销毁信息的状态 也是一个布尔的state，但像小孩子的数目这种值，已经可以从组织size中知道，就不应该在states，这些值会照成states冗余的，使得管理复杂化。 然后，记住以下几点： State 是只读的 惟一改变 State 的方法就是触发 action，通过 reducers 改变 states states的结构尽量扁平化，不要有太多的嵌套。 RepositoryRepository采用外观模式。 Repository对接Persistence Layer，提供一组一致的接口，定义一个高层接口，上层不关心数据来源于那里（那个网络服务器或蓝牙或数据库），它只关心它要的数据。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"架构设计","slug":"iOS/架构设计","permalink":"https://jigangduan.github.io/categories/iOS/架构设计/"},{"name":"TCLMOVE","slug":"iOS/架构设计/TCLMOVE","permalink":"https://jigangduan.github.io/categories/iOS/架构设计/TCLMOVE/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"}]},{"title":"PlantUML","slug":"PlantUML","date":"2017-10-17T06:34:26.000Z","updated":"2020-07-25T02:57:18.160Z","comments":true,"path":"2017/10/17/PlantUML/","link":"","permalink":"https://jigangduan.github.io/2017/10/17/PlantUML/","excerpt":"","text":"PlantUML是一个开源项目，支持快速绘制： 时序图 Sequence diagram 用例图 Usecase diagram 类图 Class diagram 活动图 Activity diagram 组件图 Component diagram 状态图 State diagram 部署图 Deployment diagram 对象图 Object diagram 线框图形界面 wireframe graphical interface 时序图 Timing Diagram 使用方式请参考如下文档： _官网_ 使用 PlantUML 绘制的 UML 安装PlantUML 显示依赖 Graphviz , 需要先安装 Graphviz Mac 安装 Graphviz 1brew install Graphviz Ubuntu 安装 Graphviz 1apt-get install graphviz Windows 下使用choco来安装Graphviz 在cmd中安装chocolatey 1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;http://bit.ly/psChocInstall&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%systemdrive%\\chocolatey\\bin 在cmd中安装Graphviz 1choco install Graphviz 在Atom中安装安装两个Package : language-plantuml、 plantuml-preview 在IDE中安装安装插件 PlantUML integration 使用在Atom中使用 新建文件，保存为.pu文件 1234567891011121314151617181920212223242526@startumlabstract class AbstractListabstract AbstractCollectioninterface Listinterface CollectionList &lt;|-- AbstractListCollection &lt;|-- AbstractCollectionCollection &lt;|- ListAbstractCollection &lt;|- AbstractListAbstractList &lt;|-- ArrayListclass ArrayList &#123; Object[] elementData size()&#125;enum TimeUnit &#123; DAYS HOURS MINUTES&#125;@enduml 打开 plantuml-preview 如果出现下列错误情况，是需要指定plantuml.jar plantuml.jar 可以通过PlantUML官网下载 设置 plantuml-preview 的 plantuml.jar 对应的UML图如下所示 在IDE中使用通过File菜单打开： 示例效果展示效果如下： 以下为一个框架图 PlantUML code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213@startumltitle TCLMOVE 架构图skinparam backgroundColor #DBDBD8skinparam handwritten trueskinparam package &#123; backgroundColor&lt;&lt;Scenes&gt;&gt; #7BD2F7 borderColor&lt;&lt;Scenes&gt;&gt; #90D2F7 fontSize&lt;&lt;Scenes&gt;&gt; 13 backgroundColor&lt;&lt;Servers&gt;&gt; #DBEAD0 borderColor&lt;&lt;Servers&gt;&gt; #DBEAD0 backgroundColor&lt;&lt;Models&gt;&gt; #FEFECE borderColor&lt;&lt;Models&gt;&gt; #FEFEAE&#125;skinparam folder &#123; backgroundColor&lt;&lt;Managers&gt;&gt; #BBDAC0 borderColor&lt;&lt;Managers&gt;&gt; #DBEAD0 backgroundColor&lt;&lt;Workers&gt;&gt; #DBEAA0 borderColor&lt;&lt;Workers&gt;&gt; #DBEAD0&#125;skinparam interface &#123; backgroundColor RosyBrown borderColor orange&#125;skinparam entity &#123; backgroundColor RosyBrown borderColor orange&#125;skinparam cloud &#123; backgroundColor #00 borderColor #00&#125;skinparam database &#123; backgroundColor #B1BFC3 borderColor #B1BFE3&#125;skinparam component &#123; backgroundColor #5ABAA7 borderColor #7ABAA7&#125;skinparam node &#123; backgroundColor #E68274 borderColor #E68274&#125;package &quot;UI Layer&quot; &lt;&lt;Scenes&gt;&gt; &#123; [View1] as v1 [ViewModel1] as vm1 v1 -(0)- vm1 [View2] as v2 [ViewModel2] as vm2 v2 -(0)- vm2 [View3] as v3 [ViewModel3] as vm3 v3 -(0)- vm3 component &quot;View&quot; as v component &quot;ViewModel&quot; as vm v -(0)- vm&#125;node &quot;State&quot; &#123; component &quot;App State&quot; as state component &quot;Reducer&quot; as reducer component &quot;Action&quot; as action component &quot;Action Creator&quot; as creator state &lt;- reducer reducer &lt;-- action creator -&gt; action&#125;vm &lt;... statevm1 &lt;.. statevm2 &lt;.. statevm3 &lt;.. statepackage &quot;Logic Layer&quot; &lt;&lt;Servers&gt;&gt; &#123;folder Managers &lt;&lt;Managers&gt;&gt; &#123; [Account Manager] as am [Device Manager] as dm [Location Manager] as lm [Message Manager] as mm [Notification Manager] as nm [... Manager] as om&#125;creator &lt;-- amcreator &lt;-- dmcreator &lt;-- lmcreator &lt;-- mmcreator &lt;- nmcreator &lt;- omfolder Workers &lt;&lt;Workers&gt;&gt; as workers &#123; interface &quot;Account Worker Protocl&quot; as awp [Account Worker] as aw awp ^-- aw interface &quot;Device Worker Protocl&quot; as dwp [Device Worker] as dw dwp ^-- dw interface &quot;Location Worker Protocl&quot; as lwp [Location Worker] as lw lwp ^-- lw interface &quot;Message Worker Protocl&quot; as mwp [Message Worker] as mw mwp ^-- mw interface &quot;Notification Worker Protocl&quot; as nwp [Notification Worker] as nw nwp ^-- nw interface &quot;... Worker Protocl&quot; as owp [... Worker] as ow owp ^-- ow&#125;am --&gt; awpdm --&gt; dwplm --&gt; lwpmm --&gt; mwpnm --&gt; nwpom --&gt; owp&#125;node &quot;Repository&quot; as repositoryskinparam rectangle &#123; roundCorner&lt;&lt;API&gt;&gt; 25 roundCorner&lt;&lt;BLE&gt;&gt; 8 roundCorner&lt;&lt;DAO&gt;&gt; 12 roundCorner&lt;&lt;...&gt;&gt; 35 backgroundColor&lt;&lt;API&gt;&gt; #C4DADF borderColor&lt;&lt;API&gt;&gt; #E0DADF backgroundColor&lt;&lt;BLE&gt;&gt; #C4DFDA borderColor&lt;&lt;BLE&gt;&gt; #E4DFDA backgroundColor&lt;&lt;DAO&gt;&gt; #DFC4DA borderColor&lt;&lt;DAO&gt;&gt; #DFC4EA backgroundColor #AFC4DA borderColor #AFC4EA&#125;package &quot;Persistence Layer&quot; &lt;&lt;Models&gt;&gt; as models &#123; rectangle &quot;... Managements&quot; &lt;&lt;...&gt;&gt; &#123; rectangle &quot;...&quot; &lt;&lt;...&gt;&gt; &#125; rectangle &quot;BLE Managements&quot; &lt;&lt;BLE&gt;&gt; as blem &#123; rectangle &quot;BLE attributes&quot; &lt;&lt;BLE&gt;&gt; as ble rectangle &quot;Local Storage&quot; rectangle &quot;Events&quot; &#125; rectangle &quot;DAO Managements&quot; &lt;&lt;DAO&gt;&gt; as daom &#123; rectangle &quot;DAO&quot; &lt;&lt;DAO&gt;&gt; as dao rectangle &quot;Change Events&quot; &#125; rectangle &quot;API Managements&quot; &lt;&lt;API&gt;&gt; as apim &#123; rectangle &quot;Resource APIs&quot; &lt;&lt;API&gt;&gt; as rapis rectangle &quot;Local Cache&quot; &#125; [Http Client] as httpclient [database orm] as orm [BLE 外设] as blew rapis &lt;-- httpclient dao &lt;-- orm ble &lt;-- blew&#125;aw --&gt; repositorydw --&gt; repositorylw --&gt; repositorymw --&gt; repositorynw --&gt; repositoryow --&gt; repositoryrepository --&gt; apimrepository --&gt; daomrepository --&gt; blemcloud Cloud as clouddatabase &quot;database&quot; as databaseentity &quot;BLE&quot; as ble_entityhttpclient --&gt; cloudorm --&gt; databaseblew --&gt; ble_entity@enduml","categories":[{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/categories/工具/"}],"tags":[{"name":"atom","slug":"atom","permalink":"https://jigangduan.github.io/tags/atom/"},{"name":"idea","slug":"idea","permalink":"https://jigangduan.github.io/tags/idea/"},{"name":"uml","slug":"uml","permalink":"https://jigangduan.github.io/tags/uml/"}]},{"title":"impress.js","slug":"ImportJs","date":"2017-10-11T03:18:41.000Z","updated":"2020-07-25T02:57:18.157Z","comments":true,"path":"2017/10/11/ImportJs/","link":"","permalink":"https://jigangduan.github.io/2017/10/11/ImportJs/","excerpt":"impress.js 是一个Javascript程序包，它的功能是让你制作出令人眩目的内容展示效果，主要里利用了CSS 3D Transforms 里的旋转，扭曲，缩放等特性。简言之，代替ppt。","text":"impress.js 是一个Javascript程序包，它的功能是让你制作出令人眩目的内容展示效果，主要里利用了CSS 3D Transforms 里的旋转，扭曲，缩放等特性。简言之，代替ppt。 对比： nodeppt 文档: impress.js——用HTML“写”幻灯片 impress.js初体验 - 前端装X利器 impress.js 中文版 学习","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"幻灯片","slug":"前端/幻灯片","permalink":"https://jigangduan.github.io/categories/前端/幻灯片/"}],"tags":[{"name":"ppt","slug":"ppt","permalink":"https://jigangduan.github.io/tags/ppt/"},{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/tags/工具/"}]},{"title":"android 代码优化 - 注解检查","slug":"android-code-lint","date":"2017-10-10T06:16:32.000Z","updated":"2020-07-25T02:57:18.172Z","comments":true,"path":"2017/10/10/android-code-lint/","link":"","permalink":"https://jigangduan.github.io/2017/10/10/android-code-lint/","excerpt":"","text":"使用 Lint 改进您的代码 使用注解改进代码检查 android.support.annotation 资源类注解: 注释 参数 字段 方法返回值 方法 类 描述 e.g. AnimatorRes 👌 👌 👌 ❌ ❌ 动画资源引用 android.R.animator.fade_in AnimRes 👌 👌 👌 ❌ ❌ anim资源引用 android.R.animator.fade_in AnyRes 👌 👌 👌 ❌ ❌ 任何类型的资源引用 - ArrayRes 👌 👌 👌 ❌ ❌ 数组资源引用 android.R.array.phoneTypes AttrRes 👌 👌 👌 ❌ ❌ 属性引用 android.R.attr.action BoolRes 👌 👌 👌 ❌ ❌ 布尔资源引用 - ColorRes 👌 👌 👌 ❌ ❌ 颜色资源引用 android.R.color.black DimenRes 👌 👌 👌 ❌ ❌ 尺寸资源引用 android.R.dimen.app_icon_size DrawableRes 👌 👌 👌 ❌ ❌ Drawable资源引用 android.R.attr.alertDialogIcon FontRes 👌 👌 👌 ❌ ❌ 字体资源引用 R.font.myfont StringRes 👌 👌 👌 ❌ ❌ String资源引用 android.R.string.ok StyleableRes 👌 👌 👌 ❌ ❌ styleable资源引用 android.R.styleable.TextView_text StyleRes 👌 👌 👌 ❌ ❌ style资源引用 android.R.style.TextAppearance TransitionRes 👌 👌 👌 ❌ ❌ transition资源引用 - LayoutRes 👌 👌 👌 ❌ ❌ 布局资源引用 android.R.layout.list_content MenuRes 👌 👌 👌 ❌ ❌ 菜单资源引用 - NavigationRes 👌 👌 👌 ❌ ❌ 导航资源引用 R.navigation.flow PluralsRes 👌 👌 👌 ❌ ❌ 复数的资源引用 - RawRes 👌 👌 👌 ❌ ❌ raw资源引用 - XmlRes 👌 👌 👌 ❌ ❌ XML资源引用 - 特定类型值相关注解： 注释 参数 字段 方法返回值 方法 类 描述 ColorInt 👌 👌 👌 ❌ ❌ 填充色的int，AARRGGBB ColorLong 👌 👌 👌 ❌ ❌ 填充Color的long Dimension 👌 👌 👌 ❌ ❌ 表示一个尺寸 Px 👌 👌 👌 ❌ ❌ 表示一个像素维度 线程相关注解： 注释 参数 字段 方法返回值 方法 类 描述 AnyThread ❌ ❌ ❌ 👌 👌 表示可以从任何线程调用带注释的方法(例如，它是“线程安全的”)。如果带注释的元素是一个类，那么类中的所有方法都可以从任何线程调用。 BinderThread ❌ ❌ ❌ 👌 👌 在Binder线程上调用 MainThread ❌ ❌ ❌ 👌 👌 应该在主线程上调用 UiThread ❌ ❌ ❌ 👌 👌 应该在UI线程上调用 WorkerThread ❌ ❌ ❌ 👌 👌 应该只在工作线程上调用 12@AnyThreadpublic void deliverResult(D data) &#123; ... &#125; 四个线程相关注解的差异 参考这里 取值范围注解： 注释 参数 字段 方法返回值 方法 类 描述 FloatRange ❌ 浮点数或双精度数给定范围内 IntRange ❌ int或long给定范围内 1234@FloatRange(from=0.0,to=1.0)public float getAlpha() &#123; ...&#125; 空指针检查: 注释 参数 字段 方法返回值 方法 类 描述 NonNull 👌 👌 👌 ❌ ❌ 永远不能为空 Nullable 👌 👌 👌 ❌ ❌ 可以为null 权限相关注解： 注释 参数 字段 方法返回值 方法 类 描述 RequiresPermission ❌ 👌 ❌ 👌 👌 需要(或可能需要)一个或多个权限 RequiresPermission.Read ❌ 👌 ❌ 👌 👌 指定的权限是读操作所必需的 RequiresPermission.Write ❌ 👌 ❌ 👌 👌 指定的权限是写操作所必需的 可见性相关注解： 注释 参数 字段 方法返回值 方法 类 描述 RequiresApi ❌ ❌ ❌ 👌 👌 在给定的API级别或更高级别上调用 RestrictTo ❌ ❌ ❌ 👌 👌 应该只从一个特定的范围内访问(由RestrictTo.Scope定义) VisibleForTesting ❌ 👌 ❌ 👌 👌 测试可见 其他注解： 注释 参数 字段 方法返回值 方法 类 描述 CallSuper ❌ ❌ ❌ 👌 ❌ 表示任何复写方法都应该调用此方法 Keep ❌ ❌ ❌ 👌 👌 表示当代码在构建时被压缩时，不应该删除带注释的元素。这通常用于方法和类，这些方法和类只能通过反射来访问，因此编译器可能认为代码是未使用的。 注释 参数 字段 方法返回值 方法 类 描述 StringDef 👌 👌 👌 ❌ ❌ 表示一个逻辑类型，它的值应该是一个显式命名的常量 123456789101112@Retention(SOURCE) @StringDef(&#123; POWER_SERVICE, WINDOW_SERVICE, LAYOUT_INFLATER_SERVICE &#125;) public @interface ServiceName &#123;&#125; public static final String POWER_SERVICE = \"power\"; public static final String WINDOW_SERVICE = \"window\"; public static final String LAYOUT_INFLATER_SERVICE = \"layout_inflater\"; ... public abstract Object getSystemService(@ServiceName String name); 注释 参数 字段 方法返回值 方法 类 描述 Size 👌 ❌ 👌 ❌ ❌ 复数的资源引用,用于数组或集合，指定大小或长度 123public void getLocationInWindow(@Size(2) int[] location) &#123; ...&#125; 注释 参数 字段 方法返回值 方法 类 描述 CheckResult ❌ ❌ 👌 ❌ ❌ 表示带注释的方法返回一个结果,通常用于没有副作用的方法 CheckResult(suggest) ❌ ❌ ❌ 👌 ❌ 建议的方法的名称 123456789public @CheckResult String trim(String s) &#123; return s.trim(); &#125; ... s.trim(); // this is probably an error s = s.trim(); // ok // CheckResult(suggest) @CheckResult(suggest=\"#redirectErrorStream(boolean)\") public boolean redirectErrorStream() &#123; ... &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android优化","slug":"Android/Android优化","permalink":"https://jigangduan.github.io/categories/Android/Android优化/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"}]},{"title":"Android Theme 和 Style","slug":"android-theme-style","date":"2017-10-09T09:02:11.000Z","updated":"2020-07-25T02:57:18.173Z","comments":true,"path":"2017/10/09/android-theme-style/","link":"","permalink":"https://jigangduan.github.io/2017/10/09/android-theme-style/","excerpt":"Android 5.0 带来了新的功能，允许你为视图(以及任何后代)指定一个覆盖主题。下面介绍如何使用它以及为什么要使用它。","text":"Android 5.0 带来了新的功能，允许你为视图(以及任何后代)指定一个覆盖主题。下面介绍如何使用它以及为什么要使用它。 为什么?您可能已经在不知道的情况下使用了这个功能:Theme.Holo.Light.DarkActionBar。 考虑一下Light.DarkActionBar主题。内容是亮系的主题(背景是亮的，前景是暗的)，但是动作条使用了一个暗的主题(暗背景和亮前景色)。 如果不能提供一个单独的主题，您需要手动将文本颜色和其他前景颜色设置为某种相反色。 这里就是旧的actionBarWidgetTheme属性出现的地方，它允许你指定只用于你的操作栏的主题。以下是一个该平台的DarkActionBar主题: 123&lt;style name=\"Theme.Holo.Light.DarkActionBar\"&gt; &lt;item name=\"android:actionBarWidgetTheme\"&gt;@android:style/Theme.Holo&lt;/item&gt;&lt;/style&gt; 因此，你可以在action bar上使用暗主题。 基本功能如何工作的呢?简单地说，它是API v1的一个可用的ContextThemeWrapper类。这是一个很简单的类，它的作用是: 它包装在现有的Context (比如Activity)，然后将一个新主题覆盖到该Context的主题之上。这一点很重要，因为这将导致…… ThemeOverlay您可能已经在Lollipop SDK中看到了这些主题。有两种主要的覆盖: ThemeOverlay.Material.Light ThemeOverlay.Material.Dark 那么这些是什么呢?同样，线索在名称中，它们与ContextThemeWrapper的工作方式是直接匹配的。 它们是特殊的主题，覆盖了正常的Theme.Material主题，覆盖了相关的属性，使它们变得亮/暗。 ThemeOverlay + ActionBar你敏锐的眼睛也会看到ActionBar ThemeOverlay衍生品: ThemeOverlay.Material.Light.ActionBar ThemeOverlay.Material.Dark.ActionBar 这些只应该通过新的actionBarTheme属性与Action Bar一起使用，或者直接设置在您的Toolbar上(见下面)。 目前对他们的父母来说，唯一不同的是，他们将colorControlNormal更改为android:textColorPrimary，从而使任何文本和图标都不透明。 android:theme让我们回到新的Lollipop功能。正如前面提到的，现在可以直接在布局中指定一个主题。最常见的使用(可能)是使用Toolbar: 12345&lt;Toolbar android:layout_height=\"?android:attr/actionBarSize\" android:layout_width=\"match_parent\" android:background=\"?android:attr/colorPrimaryDark\" android:theme=\"@android:style/ThemeOverlay.Material.Dark.ActionBar\" /&gt; 希望你们现在能看到它们是如何结合在一起的。我们现在已经让Toolbar有了一个黑色的主题，确保它的内容是浅色的，并且与黑暗背景形成对比。 有一点需要注意的是，在Lollipop上的android:theme有效于所有在布局中声明的孩子们: 123456&lt;LinearLayout android:theme=\"@android:style/ThemeOverlay.Material.Dark\"&gt; &lt;!-- Anything here will also have a dark theme --&gt;&lt;/LinearLayout&gt; 如果需要，你的孩子可以设定自己的主题。 例子让我们来总结一下我最近被问到的一个问题: 我如何设置android:colorEdgeEffect，使它只在一个视图上生效? colorEdgeEffect属性是Android 5.0中的一个新主题属性，用于自定义列表的超滚动效果的颜色。 因为这是一个主题属性，您不能直接在视图上设置它。相反，我们需要使用一个定制的theme叠加来使用android:theme。我们的自定义覆盖只是将android:colorEdgeEffect设为红色。然后我们将这个主题设置为视图，这样它就会生效。 res/values/themes.xml 123&lt;style name=\"RedThemeOverlay\" parent=\"android:ThemeOverlay.Material\"&gt; &lt;item name=\"android:colorEdgeEffect\"&gt;#FF0000&lt;/item&gt;&lt;/style&gt; res/layout/fragment_list.xml 123&lt;ListView ... android:theme=\"RedThemeOverlay\" /&gt; 需要注意的是，colorEdgeEffect只是一个例子，这个技术可以与所有的主题属性一起使用。 Theme 和 Style那么区别是什么呢?它们都是以完全相同的方式声明的(你已经知道了)，它们的区别在于它们是如何被使用的。 主题是为你的应用程序设计的全局样式，新功能并没有改变，它只是允许你根据每个视图进行调整。 样式是在一个视图级别上应用的。在内部，当您在视图上设置样式时，LayoutInflater将读取该样式并在任何显式属性之前将其应用到AttributeSet(这允许您在视图上覆盖样式值)。 属性集中的值可以引用视图的主题中的值。 主题是全局的，风格是局部的。 AppCompat那么AppCompat是如何适应这一情况的呢?很明显，它会返回一些新的颜色主题属性。 它还支持某些widgets的android:theme功能，目前只有android.support.v7.widget.Toolbar。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"}]},{"title":"Java界的神器-使用Lombok来消除你的冗余代码量","slug":"Java界的神器-使用Lombok来消除你的冗余代码量","date":"2017-10-09T03:23:46.000Z","updated":"2020-07-25T02:57:18.158Z","comments":true,"path":"2017/10/09/Java界的神器-使用Lombok来消除你的冗余代码量/","link":"","permalink":"https://jigangduan.github.io/2017/10/09/Java界的神器-使用Lombok来消除你的冗余代码量/","excerpt":"简介他是一个通过注解方式来减少你的POJO类的getter和setter等方法的一个工具，我这里演示的在Android Studio中的使用方式，当然如果你使用的是idea那么这方法也通用，如果你用的是eclipse，那么官网也有视频教程，我这里就不演示了","text":"简介他是一个通过注解方式来减少你的POJO类的getter和setter等方法的一个工具，我这里演示的在Android Studio中的使用方式，当然如果你使用的是idea那么这方法也通用，如果你用的是eclipse，那么官网也有视频教程，我这里就不演示了 安装依赖众所周知在在Android Studio中添加依赖有直接下载jar包和使用cradle的dependencies方法，我们这里直接使用dependencies方法 添加gradle依赖在你的项目的build.grade文件中添加 1provided &apos;org.projectlombok:lombok:1.12.6&apos; 至于为什么是provided而不是compile，因为这个框架是在将java编译为class前处理代码了，意思是在生成的class文件中已经生成了getter和setter，所以这个依赖是我们在编译的时候使用，不需要打包到apk中 安装Lombok插件虽然我们添加了依赖，但是Android Studio他知道怎么处理这个文件吗，肯定是不知道啦，所以我们的安装一个插件来告诉他怎么处理 Preferences &gt; Plugins &gt; Browse repositories 在输入框内输入combo，可看到已经搜索出来了这个插件，我们点击旁边的安装，安装完成后重启插件我们就安装完毕了，它的使用使用说明可以查看插件主页 现在插件虽然安装完了，但是Android Studio他怎么知道什么时候来使用这个插件呢，他是不是有个开关什么的，没错！你猜对了 开启项目的Annotation process首先我们打开项目的设置，要强调的是项目的，而不是工具全局的设置，如下图 打开后按照下图勾选Enable annotation processing 配置文件 lombok.config然后在Module根目录下新建一个lombok.config配置文件，加入两行配置 lombok.anyConstructor.suppressConstructorProperties = truelombok.addGeneratedAnnotation = false 两个配置的作用是禁用掉一些在android上不存在的类，这些类在标准java中才存在。 到这里为止，工具和基本环境我们基本配置完了，接下来我们需要创建一个项目来测试 一些常用注解@Getter and @Setter可以很直观的从名字看出这个两个是分别用来生成Getter和Setter方法的 1234public class User &#123; @Getter @Setter private boolean employed = true; @Setter(AccessLevel.PROTECTED) private String name;&#125; 相当于 1234567891011121314151617181920public class User &#123; private boolean employed = true; private String name; public User() &#123; &#125; public boolean isEmployed() &#123; return this.employed; &#125; public void setEmployed(boolean employed) &#123; this.employed = employed; &#125; protected void setName(String name) &#123; this.name = name; &#125;&#125; 到这里，大家肯定要问了，你说相当就等啊，或者上面相等的代码是怎么来的呢，其他我们可以直接反编译生成的class文件查看，打开Android Studio的class目录下的User.class文件，可以看到 同样下面的实例代码你可以这样查看，当然我们也可用通过Android Studio的 从上图我们发现我们没有在源代码写一些Getter方法，但是从Structure窗口看到这些方法已经自动生成了，是不是很神奇 @NonNull提供一个参数的非空判断 12@Getter @Setter @NonNullprivate List&lt;String&gt; members; 等同于 123456789101112131415@NonNullprivate List&lt;String&gt; members;@NonNullpublic List&lt;String&gt; getMembers() &#123; return this.members;&#125;public void setMembers(@NonNull List&lt;String&gt; members) &#123; if(members == null) &#123; throw new NullPointerException(&quot;members&quot;); &#125; else &#123; this.members = members; &#125;&#125; @ToString123456789101112@ToString(exclude=&quot;name&quot;)public class User &#123; @Getter @Setter private boolean employed = true; @Setter(AccessLevel.PROTECTED) private String name; @Getter @Setter @NonNull private List&lt;String&gt; members;&#125; 等同于 123public String toString() &#123; return &quot;User(employed=&quot; + this.isEmployed() + &quot;, members=&quot; + this.getMembers() + &quot;)&quot;;&#125; @EqualsAndHashCode123456789101112@EqualsAndHashCode(exclude=&#123;&quot;name&quot;&#125;)public class User &#123; @Getter @Setter private boolean employed = true; @Setter(AccessLevel.PROTECTED) private String name; @Getter @Setter @NonNull private List&lt;String&gt; members;&#125; 等同于 123456789101112131415161718192021222324252627282930313233343536 public boolean equals(Object o) &#123; if(o == this) &#123; return true; &#125; else if(!(o instanceof User)) &#123; return false; &#125; else &#123; User other = (User)o; if(!other.canEqual(this)) &#123; return false; &#125; else if(this.isEmployed() != other.isEmployed()) &#123; return false; &#125; else &#123; List this$members = this.getMembers(); List other$members = other.getMembers(); if(this$members == null) &#123; if(other$members != null) &#123; return false; &#125; &#125; else if(!this$members.equals(other$members)) &#123; return false; &#125; return true; &#125; &#125;&#125;public boolean canEqual(Object other) &#123; return other instanceof User;&#125;public int hashCode() &#123; boolean PRIME = true; byte result = 1; int result1 = result * 59 + (this.isEmployed()?79:97); List $members = this.getMembers(); result1 = result1 * 59 + ($members == null?0:$members.hashCode()); return result1;&#125; @Data这个注解相当于同时使用@ToString, @EqualsAndHashCode, @Getter和@Setter 123456@Datapublic class User &#123; private boolean employed = true; private String name; private List&lt;String&gt; members;&#125; 等同于 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 public class User &#123; private boolean employed = true; private String name; private List&lt;String&gt; members; public User() &#123; &#125; public boolean isEmployed() &#123; return this.employed; &#125; public String getName() &#123; return this.name; &#125; public List&lt;String&gt; getMembers() &#123; return this.members; &#125; public void setEmployed(boolean employed) &#123; this.employed = employed; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setMembers(List&lt;String&gt; members) &#123; this.members = members; &#125; public boolean equals(Object o) &#123; if(o == this) &#123; return true; &#125; else if(!(o instanceof User)) &#123; return false; &#125; else &#123; User other = (User)o; if(!other.canEqual(this)) &#123; return false; &#125; else if(this.isEmployed() != other.isEmployed()) &#123; return false; &#125; else &#123; String this$name = this.getName(); String other$name = other.getName(); if(this$name == null) &#123; if(other$name != null) &#123; return false; &#125; &#125; else if(!this$name.equals(other$name)) &#123; return false; &#125; List this$members = this.getMembers(); List other$members = other.getMembers(); if(this$members == null) &#123; if(other$members != null) &#123; return false; &#125; &#125; else if(!this$members.equals(other$members)) &#123; return false; &#125; return true; &#125; &#125; &#125; public boolean canEqual(Object other) &#123; return other instanceof User; &#125; public int hashCode() &#123; boolean PRIME = true; byte result = 1; int result1 = result * 59 + (this.isEmployed()?79:97); String $name = this.getName(); result1 = result1 * 59 + ($name == null?0:$name.hashCode()); List $members = this.getMembers(); result1 = result1 * 59 + ($members == null?0:$members.hashCode()); return result1; &#125; public String toString() &#123; return &quot;User(employed=&quot; + this.isEmployed() + &quot;, name=&quot; + this.getName() + &quot;, members=&quot; + this.getMembers() + &quot;)&quot;; &#125;&#125; @Cleanup他可以帮我们在需要释放的资源位置自动加上释放代码 123456789 public void testCleanUp() &#123; try &#123; @Cleanup ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(new byte[] &#123;&apos;Y&apos;,&apos;e&apos;,&apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 等同于 123456789101112131415 public void testCleanUp() &#123; try &#123; ByteArrayOutputStream e = new ByteArrayOutputStream(); try &#123; e.write(new byte[]&#123;(byte)89, (byte)101, (byte)115&#125;); System.out.println(e.toString()); &#125; finally &#123; if(Collections.singletonList(e).get(0) != null) &#123; e.close(); &#125; &#125; &#125; catch (IOException var6) &#123; var6.printStackTrace(); &#125;&#125; @Synchronized可以帮我们在方法上添加同步代码块 1234567 public class TestSync &#123; private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;); @Synchronized public String synchronizedFormat(Date date) &#123; return format.format(date); &#125;&#125; 等同于 123456789101112 public class TestSync &#123; private final Object $lock = new Object[0]; private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;); public TestSync() &#123; &#125; public String synchronizedFormat(Date date) &#123; Object var2 = this.$lock; synchronized(this.$lock) &#123; return this.format.format(date); &#125; &#125;&#125; 基本的使用就介绍到这里，下面一份完整代码User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.woblog.testlombok;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.List;import lombok.AccessLevel;import lombok.Cleanup;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.Getter;import lombok.NonNull;import lombok.Setter;import lombok.SneakyThrows;import lombok.Synchronized;import lombok.ToString;/** * Created by renpingqing on 16/6/18. */@Data@ToString(callSuper = true)/** * 这里如果不写false,会报错, * Error:(21, 1) 警告: Generating equals/hashCode implementation but without a call to superclass, * even though this class does not extend java.lang.Object. If this is intentional, * add &apos;@EqualsAndHashCode(callSuper=false)&apos; to your type. */@EqualsAndHashCode(callSuper = false)public class User extends BasePOJO &#123; private final Object lockObj = new Object(); /** * userid只生成getUserId */ private @Getter String userId; private String username; private int gender; private float price; @Setter(AccessLevel.PROTECTED) private boolean vip = false; //vip,或者isVip都会生成isVip private List&lt;String&gt; members; /** * name不能为空 * * @param name * @return */ private String sayHello(@NonNull String name) &#123; return String.format(&quot;hi %s&quot;, name); &#125; @SneakyThrows(IOException.class) public void closeabale() &#123; @Cleanup InputStream is = new ByteArrayInputStream(&quot;hello world&quot;.getBytes()); System.out.println(is.available()); &#125; @Synchronized(&quot;lockObj&quot;) public void lockMethod() &#123; System.out.println(&quot;test lock method&quot;); &#125;&#125; 他生成的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.woblog.testlombok;import com.woblog.testlombok.BasePOJO;import java.io.ByteArrayInputStream;import java.io.IOException;import java.util.Collections;import java.util.List;import lombok.NonNull;public class User extends BasePOJO &#123; private final Object lockObj = new Object(); private String userId; private String username; private int gender; private float price; private boolean vip = false; private List&lt;String&gt; members; private String sayHello(@NonNull String name) &#123; if(name == null) &#123; throw new NullPointerException(&quot;name&quot;); &#125; else &#123; return String.format(&quot;hi %s&quot;, new Object[]&#123;name&#125;); &#125; &#125; public void closeabale() &#123; try &#123; ByteArrayInputStream $ex = new ByteArrayInputStream(&quot;hello world&quot;.getBytes()); try &#123; System.out.println($ex.available()); &#125; finally &#123; if(Collections.singletonList($ex).get(0) != null) &#123; $ex.close(); &#125; &#125; &#125; catch (IOException var6) &#123; throw var6; &#125; &#125; public void lockMethod() &#123; Object var1 = this.lockObj; synchronized(this.lockObj) &#123; System.out.println(&quot;test lock method&quot;); &#125; &#125; public User() &#123; &#125; public Object getLockObj() &#123; return this.lockObj; &#125; public String getUsername() &#123; return this.username; &#125; public int getGender() &#123; return this.gender; &#125; public float getPrice() &#123; return this.price; &#125; public boolean isVip() &#123; return this.vip; &#125; public List&lt;String&gt; getMembers() &#123; return this.members; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public void setMembers(List&lt;String&gt; members) &#123; this.members = members; &#125; public String toString() &#123; return &quot;User(super=&quot; + super.toString() + &quot;, lockObj=&quot; + this.getLockObj() + &quot;, userId=&quot; + this.getUserId() + &quot;, username=&quot; + this.getUsername() + &quot;, gender=&quot; + this.getGender() + &quot;, price=&quot; + this.getPrice() + &quot;, vip=&quot; + this.isVip() + &quot;, members=&quot; + this.getMembers() + &quot;)&quot;; &#125; public boolean equals(Object o) &#123; if(o == this) &#123; return true; &#125; else if(!(o instanceof User)) &#123; return false; &#125; else &#123; User other = (User)o; if(!other.canEqual(this)) &#123; return false; &#125; else &#123; label71: &#123; Object this$lockObj = this.getLockObj(); Object other$lockObj = other.getLockObj(); if(this$lockObj == null) &#123; if(other$lockObj == null) &#123; break label71; &#125; &#125; else if(this$lockObj.equals(other$lockObj)) &#123; break label71; &#125; return false; &#125; String this$userId = this.getUserId(); String other$userId = other.getUserId(); if(this$userId == null) &#123; if(other$userId != null) &#123; return false; &#125; &#125; else if(!this$userId.equals(other$userId)) &#123; return false; &#125; label57: &#123; String this$username = this.getUsername(); String other$username = other.getUsername(); if(this$username == null) &#123; if(other$username == null) &#123; break label57; &#125; &#125; else if(this$username.equals(other$username)) &#123; break label57; &#125; return false; &#125; if(this.getGender() != other.getGender()) &#123; return false; &#125; else if(Float.compare(this.getPrice(), other.getPrice()) != 0) &#123; return false; &#125; else if(this.isVip() != other.isVip()) &#123; return false; &#125; else &#123; List this$members = this.getMembers(); List other$members = other.getMembers(); if(this$members == null) &#123; if(other$members != null) &#123; return false; &#125; &#125; else if(!this$members.equals(other$members)) &#123; return false; &#125; return true; &#125; &#125; &#125; &#125; public boolean canEqual(Object other) &#123; return other instanceof User; &#125; public int hashCode() &#123; boolean PRIME = true; byte result = 1; Object $lockObj = this.getLockObj(); int result1 = result * 59 + ($lockObj == null?0:$lockObj.hashCode()); String $userId = this.getUserId(); result1 = result1 * 59 + ($userId == null?0:$userId.hashCode()); String $username = this.getUsername(); result1 = result1 * 59 + ($username == null?0:$username.hashCode()); result1 = result1 * 59 + this.getGender(); result1 = result1 * 59 + Float.floatToIntBits(this.getPrice()); result1 = result1 * 59 + (this.isVip()?79:97); List $members = this.getMembers(); result1 = result1 * 59 + ($members == null?0:$members.hashCode()); return result1; &#125; public String getUserId() &#123; return this.userId; &#125; protected void setVip(boolean vip) &#123; this.vip = vip; &#125;&#125; 可以看到代码量差不多缩减了三倍，但是他也有一些缺点，比如： 大大降低了源代码文件的可读性和完整性，降低了阅读源代码的舒适度。","categories":[{"name":"Java","slug":"Java","permalink":"https://jigangduan.github.io/categories/Java/"},{"name":"第三方库","slug":"Java/第三方库","permalink":"https://jigangduan.github.io/categories/Java/第三方库/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"}]},{"title":"自定义视图(4) —— 优化视图","slug":"custom-views-optimizing-view","date":"2017-08-13T06:50:46.000Z","updated":"2020-07-25T02:57:18.197Z","comments":true,"path":"2017/08/13/custom-views-optimizing-view/","link":"","permalink":"https://jigangduan.github.io/2017/08/13/custom-views-optimizing-view/","excerpt":"现在，您已经有了一个设计良好的视图，可以响应状态之间的手势和转换，确保视图运行得很快。为了避免在回放期间感觉迟钝或停滞的UI，确保动画始终以每秒60帧的速度运行。","text":"现在，您已经有了一个设计良好的视图，可以响应状态之间的手势和转换，确保视图运行得很快。为了避免在回放期间感觉迟钝或停滞的UI，确保动画始终以每秒60帧的速度运行。 少做事，频率少为了加快视图的速度，从经常调用的例程中删除不必要的代码。先从onDraw()开始，这将给你最大的回报。特别是您应该消除onDraw()中的分配，因为分配可能会导致垃圾收集，从而导致口吃。在初始化期间或在动画之间分配对象。当动画运行时，不要进行分配。 除了使onDraw()更精简，也要确保它被尽可能少地调用。大多数对onDraw()的调用都是调用invalidate()的结果，因此消除不必要的invalidate()调用。 另一个非常昂贵的操作是遍历布局。每当视图调用requestLayout()时，Android UI系统需要遍历整个视图层次结构，以找出每个视图需要多大的大小。如果发现冲突的度量，可能需要多次遍历层次结构。UI设计人员有时会创建嵌套的ViewGroup对象的深层层次结构，以便让UI正常工作。这些深层视图层次结构会导致性能问题。使您的视图层次尽可能地浅。 如果您有一个复杂的UI，请考虑编写一个自定义的ViewGroup来执行它的布局。与内置视图不同，您的自定义视图可以对其子的大小和形状做出特定于应用程序的假设，因此避免遍历其子来计算度量。PieChart的例子展示了如何将ViewGroup扩展为自定义视图的一部分。PieChart有孩子的观点，但从来没有衡量他们的观点。相反，它直接根据自己的定制布局算法来设置它们的大小。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 用户界面的最佳实践","slug":"Android/Android-用户界面的最佳实践","permalink":"https://jigangduan.github.io/categories/Android/Android-用户界面的最佳实践/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"}]},{"title":"自定义视图(3) —— 视图交互","slug":"custom-views-making-interactive","date":"2017-08-13T05:28:45.000Z","updated":"2020-07-25T02:57:18.196Z","comments":true,"path":"2017/08/13/custom-views-making-interactive/","link":"","permalink":"https://jigangduan.github.io/2017/08/13/custom-views-making-interactive/","excerpt":"绘制UI只是创建自定义视图的一部分。您还需要让您的视图以一种与您模拟的实际操作非常相似的方式对用户输入作出响应。对象应该以与实际对象相同的方式操作。例如，图像不应该立即跳出存在并重新出现在其他地方，因为现实世界中的物体不这样做。相反，图像应该从一个地方移动到另一个地方。 用户还可以在界面中感知微妙的行为或感觉，并对模仿真实世界的细微差别做出最好的反应。例如，当用户fling一个UI对象时，他们应该在开始时感觉到摩擦力，从而延迟了这个动作，然后在结束时感觉的动量，使这个动作超越了fling。 这个课程演示了如何使用Android框架的特性将这些真实的行为添加到您的自定义视图中。","text":"绘制UI只是创建自定义视图的一部分。您还需要让您的视图以一种与您模拟的实际操作非常相似的方式对用户输入作出响应。对象应该以与实际对象相同的方式操作。例如，图像不应该立即跳出存在并重新出现在其他地方，因为现实世界中的物体不这样做。相反，图像应该从一个地方移动到另一个地方。 用户还可以在界面中感知微妙的行为或感觉，并对模仿真实世界的细微差别做出最好的反应。例如，当用户fling一个UI对象时，他们应该在开始时感觉到摩擦力，从而延迟了这个动作，然后在结束时感觉的动量，使这个动作超越了fling。 这个课程演示了如何使用Android框架的特性将这些真实的行为添加到您的自定义视图中。 处理输入的手势与许多其他的UI框架一样，Android支持输入事件模型。用户操作被转换为触发回调的事件，您可以覆盖回调，以定制应用程序对用户的响应。Android系统中最常见的输入事件是触摸，它触发onTouchEvent(android.view.motionevent))。覆盖该方法来处理事件: 1234@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return super.onTouchEvent(event);&#125; 触摸事件本身并不是特别有用。现代的触摸UIs定义了交互作用，比如点击、拉动、推送、投掷和缩放等。为了将原始的触摸事件转化为手势，Android提供了手势探测器(GestureDetector)。 通过传递一个实现GestureDetector.OnGestureListener的类的实例来构造一个手势检测器。如果您只想处理一些手势，您可以扩展GestureDetector.SimpleOnGestureListener，而不是实现GestureDetector.OnGestureListener接口。例如，这段代码创建了一个扩展GestureDetector.SimpleOnGestureListener和覆盖onDown(MotionEvent))的类。 1234567class mListener extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onDown(MotionEvent e) &#123; return true; &#125;&#125;mDetector = new GestureDetector(PieChart.this.getContext(), new mListener()); 无论您是否使用GestureDetector.SimpleOnGestureListener，您必须始终实现一个返回true的onDown())方法。这一步是必要的，因为所有的手势都是从onDown()消息开始的。如果onDown()返回false，如GestureDetector.OnGestureListener所做的那样，系统假定您想要忽略该手势的其余部分，而GestureDetector.OnGestureListener的其他方法则永远不会被调用。如果您真的想忽略一个完整的手势，那么惟一时间是onDown()返回false的。一旦您实现了GestureDetector.OnGestureListener并创建了一个手势检测器的实例，您就可以使用您的手势检测器来解释您在onTouchEvent())中接收到的触摸事件。 1234567891011@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; boolean result = mDetector.onTouchEvent(event); if (!result) &#123; if (event.getAction() == MotionEvent.ACTION_UP) &#123; stopScrolling(); result = true; &#125; &#125; return result;&#125; 当您通过onTouchEvent()一个触摸事件时，它不承认它是一个手势的一部分，它返回false。然后你可以运行你自己的自定义手势检测代码。 创建物理上合理的运动手势是控制触屏设备的一种强有力的方式，但它们可能是违反直觉的，而且很难记住，除非它们产生了看似合理的结果。一个很好的例子就是“fling”手势，用户可以快速地将手指移动到屏幕上，然后抬起它。如果UI的响应是快速移动到fling的方向，然后减速，就像用户推着一个飞轮并让它旋转一样，这个手势是有意义的。 然而，模拟飞轮的感觉并不简单。需要大量的物理和数学才能使飞轮模型正常工作。幸运的是，Android提供了帮助类来模拟这个和其他行为。Scroller类是处理飞轮式风格的投掷动作的基础。 要开始一个投掷，调用fling())以初始速度和最小值和最大值x和y值。对于速度值，可以使用手势检测器计算的值。 12345@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; mScroller.fling(currentX, currentY, velocityX / SCALE, velocityY / SCALE, minX, minY, maxX, maxY); postInvalidate();&#125; ⚠️:虽然手势检测的速度是物理精确的，但是很多开发者认为使用这个值会让动画的速度太快。把x和y的速度除以4到8是很常见的。 fling()的调用建立了投掷动作的物理模型。然后，您需要通过定期调用Scroller.computeScrollOffset())来更新Scroller。通过读取当前时间和使用物理模型来计算x和y的位置，computeScrollOffset()更新Scroller对象的内部状态。调用getCurrX()和getCurrY()来检索这些值。 大多数视图将Scroller对象的x和y位置直接传递给scrollTo()。PieChart的例子有一点不同:它使用当前的scroll y轴来设置图表的旋转角度。 1234if (!mScroller.isFinished()) &#123; mScroller.computeScrollOffset(); setPieRotation(mScroller.getCurrY());&#125; Scroller类为您计算滚动位置，但它不会自动将这些位置应用到您的视图中。你的责任是确保你得到并应用新的坐标，使滚动的动画看起来很平滑。有两种方法可以做到这一点: 在调用fling()之后调用postInvalidate()，以强制重新绘制。该技术要求您在onDraw()中计算滚动偏移量，并在每次滚动偏移量变化时调用postInvalidate()。 在fling的持续时间设置一个ValueAnimator，并添加一个侦听器，通过调用addUpdateListener()来处理动画更新。 PieChart的例子使用了第二种方法。这种技术的设置稍微复杂一些，但是它与动画系统更紧密地合作，并且不需要潜在的不必要的视图失效。缺点是，ValueAnimator在API级别11之前是不可用的，所以这种技术不能用于运行Android版本低于3.0的设备上。 注意:您可以在针对较低API级别的应用程序中使用ValueAnimator。您只需要确保在运行时检查当前的API级别，如果当前级别低于11，就忽略对视图动画系统的调用。 1234567891011121314mScroller = new Scroller(getContext(), null, true); mScrollAnimator = ValueAnimator.ofFloat(0,1); mScrollAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; if (!mScroller.isFinished()) &#123; mScroller.computeScrollOffset(); setPieRotation(mScroller.getCurrY()); &#125; else &#123; mScrollAnimator.cancel(); onScrollFinished(); &#125; &#125; &#125;); 让你的过渡平滑用户期望一个现代的UI在状态之间平稳地过渡。UI元素会淡入淡出，而不是出现和消失。运动的开始和结束都很顺利，而不是突然开始和停止。Android 3.0版本的Android属性动画框架使得流畅的过渡变得容易。 要使用动画系统，只要属性更改会影响视图的外观，就不要直接更改属性。相反，使用ValueAnimator来进行更改。在下面的例子中，修改当前选中的饼图在PieChart中会使整个图表旋转，以便选择指针位于所选的切片中。ValueAnimator会在几百毫秒内改变旋转，而不是立即设置新的旋转值。 1234mAutoCenterAnimator = ObjectAnimator.ofInt(PieChart.this, \"PieRotation\", 0);mAutoCenterAnimator.setIntValues(targetAngle);mAutoCenterAnimator.setDuration(AUTOCENTER_ANIM_DURATION);mAutoCenterAnimator.start(); 如果您想要更改的值是基本视图属性之一，那么做动画就更容易了，因为视图有一个内置的ViewPropertyAnimator，它针对多个属性的同步动画进行了优化。例如: 1animate().rotation(targetAngle).setDuration(ANIM_DURATION).start();","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 用户界面的最佳实践","slug":"Android/Android-用户界面的最佳实践","permalink":"https://jigangduan.github.io/categories/Android/Android-用户界面的最佳实践/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"}]},{"title":"自定义视图(2) —— 自定义绘制","slug":"custom-views-custom-drawing","date":"2017-08-13T04:40:03.000Z","updated":"2020-07-25T02:57:18.196Z","comments":true,"path":"2017/08/13/custom-views-custom-drawing/","link":"","permalink":"https://jigangduan.github.io/2017/08/13/custom-views-custom-drawing/","excerpt":"自定义视图最重要的部分是它的外观。根据您的应用程序的需要，自定义绘制可以很简单或复杂。这一课涵盖了一些最常见的操作。","text":"自定义视图最重要的部分是它的外观。根据您的应用程序的需要，自定义绘制可以很简单或复杂。这一课涵盖了一些最常见的操作。 覆写onDraw()绘制自定义视图最重要的步骤是覆盖onDraw())方法。onDraw()的参数是一个画布对象，视图可以使用它来绘制自己。Canvas类定义了用于绘制文本、行、位图和许多其他图形原语的方法。您可以在onDraw()中使用这些方法来创建定制的用户界面(UI)。 不过，在您调用任何绘图方法之前，需要创建一个Paint对象。下一节将更详细地讨论Paint 创建绘图对象android.graphics框架将绘图分为两个领域: 画什么，用Canvas来处理 如何画，用Paint来处理 例如，Canvas提供了一种绘制线条的方法，而Paint则提供了定义线条颜色的方法。Canvas有一个绘制矩形的方法，而Paint则定义了是用一个颜色填充这个矩形，还是把它留空。简单地说，Canvas定义了你可以在屏幕上绘制的图形，而Paint则定义了你所绘制的每一个图形的颜色、样式、字体等等。 因此，在绘制任何东西之前，您需要创建一个或多个Paint对象。PieChart的例子在一个名为init的方法中这样做，这个方法在构造函数中调用的: 123456789101112131415161718private void init() &#123; mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mTextPaint.setColor(mTextColor); if (mTextHeight == 0) &#123; mTextHeight = mTextPaint.getTextSize(); &#125; else &#123; mTextPaint.setTextSize(mTextHeight); &#125; mPiePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPiePaint.setStyle(Paint.Style.FILL); mPiePaint.setTextSize(mTextHeight); mShadowPaint = new Paint(0); mShadowPaint.setColor(0xff101010); mShadowPaint.setMaskFilter(new BlurMaskFilter(8, BlurMaskFilter.Blur.NORMAL)); ... 提前创建对象是一个重要的优化。视图经常被重新绘制，许多绘图对象需要昂贵的初始化。在onDraw()方法中创建绘图对象可以显著降低性能，并使UI显得迟缓。 处理布局事件为了正确地绘制您的自定义视图，您需要知道它的大小。复杂的自定义视图通常需要根据屏幕上的区域的大小和形状来执行多个布局计算。你不应该在屏幕上对视图的大小做出假设。即使只有一个应用程序使用你的视图，这个应用程序也需要处理不同的屏幕大小，屏幕密度，以及横向和横向模式的不同方面的比率。 尽管视图有许多用于处理度量的方法，但它们中的大多数不需要被覆盖。如果您的视图不需要对它的大小进行特殊的控制，那么您只需覆盖一个方法:onSizeChanged())。 onSizeChanged())是在您的视图第一次分配一个大小时调用的，如果您的视图的大小因任何原因而发生变化，则调用onSizeChanged()。在onSizeChanged()中计算位置、维度和其他与视图大小相关的值，而不是每次绘制时都重新计算它们。在PieChart的例子中，onSizeChanged()是PieChart视图计算饼图的边界矩形和文本标签和其他可视元素的相对位置的地方。 当您的视图被分配一个大小时，布局管理器假设这个大小包含了所有视图的padding。在计算视图的大小时，必须处理padding值。下面是PieChart.onSizeChanged()的一个片段，展示了如何做到这一点: 123456789101112// Account for paddingfloat xpad = (float)(getPaddingLeft() + getPaddingRight());float ypad = (float)(getPaddingTop() + getPaddingBottom());// Account for the labelif (mShowText) xpad += mTextWidth;float ww = (float)w - xpad;float hh = (float)h - ypad;// Figure out how big we can make the pie.float diameter = Math.min(ww, hh); 如果您需要更好地控制视图的布局参数，那么可以实现onMeasure()。这个方法的参数是View.MeasureSpec值，它告诉你视图的父视图有多大，它的大小是一个硬的最大值还是一个建议。作为一个优化，这些值被存储为打包的整数，您使用View.MeasureSpec的静态方法来解存储在每个整数中的信息。 下面是onMeasure()的一个示例实现。在这个实现中，PieChart试图让它的区域足够大，使这个馅饼和它的label一样大: 12345678910111213@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Try for a width based on our minimum int minw = getPaddingLeft() + getPaddingRight() + getSuggestedMinimumWidth(); int w = resolveSizeAndState(minw, widthMeasureSpec, 1); // Whatever the width ends up being, ask for a height that would let the pie // get as big as it can int minh = MeasureSpec.getSize(w) - (int)mTextWidth + getPaddingBottom() + getPaddingTop(); int h = resolveSizeAndState(MeasureSpec.getSize(w) - (int)mTextWidth, heightMeasureSpec, 0); setMeasuredDimension(w, h);&#125; 在这段代码中有三件重要的事情需要注意: 计算考虑到视图的填充。正如前面提到的，这是视图的责任。 助手方法resolveSizeAndState())用于创建最终的宽度和高度值。通过将视图所需的大小与传递给onMeasure())的规范相比较，这个助手返回一个适当的View.MeasureSpec值。 onMeasure()没有返回值。相反，该方法通过调用setMeasuredDimension())来传递其结果。调用此方法是强制性的。如果省略了这个调用，视图类会抛出一个运行时异常。 绘制一旦您创建了对象创建和度量代码，您就可以实现onDraw()。每个视图都以不同的方式实现onDraw()，但是有一些常见的操作是大多数视图共享的: 绘制文本使用drawText())。通过调用setTypeface()来指定字体，并通过调用setColor()来指定文本颜色。 使用drawRect())、drawOval())和drawArc()绘制原始图形。通过调用setStyle()来改变这些形状是否填充、概括或两者都有。 使用Path类绘制更复杂的图形。通过向路径对象添加行和曲线来定义一个形状，然后使用drawPath())来绘制图形。就像原始的形状一样，可以根据setStyle()对路径进行概述、填充，或者两者都可以。 通过创建LinearGradient对象来定义渐变填充。调用setShader()在填充的图形上使用你的线性渐变。 绘制位图使用drawBitmap())。 例如，这里是绘制PieChart的代码。它使用了文本、线条和形状的混合。 1234567891011121314151617181920212223242526protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // Draw the shadow canvas.drawOval( mShadowBounds, mShadowPaint ); // Draw the label text canvas.drawText(mData.get(mCurrentItem).mLabel, mTextX, mTextY, mTextPaint); // Draw the pie slices for (int i = 0; i &lt; mData.size(); ++i) &#123; Item it = mData.get(i); mPiePaint.setShader(it.mShader); canvas.drawArc(mBounds, 360 - it.mEndAngle, it.mEndAngle - it.mStartAngle, true, mPiePaint); &#125; // Draw the pointer canvas.drawLine(mTextX, mPointerY, mPointerX, mPointerY, mTextPaint); canvas.drawCircle(mPointerX, mPointerY, mPointerSize, mTextPaint);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 用户界面的最佳实践","slug":"Android/Android-用户界面的最佳实践","permalink":"https://jigangduan.github.io/categories/Android/Android-用户界面的最佳实践/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"}]},{"title":"自定义视图(1) —— 创建自定义视图类","slug":"custom-views","date":"2017-08-10T12:02:30.000Z","updated":"2020-07-25T02:57:18.197Z","comments":true,"path":"2017/08/10/custom-views/","link":"","permalink":"https://jigangduan.github.io/2017/08/10/custom-views/","excerpt":"一个设计良好的自定义视图与其他设计良好的类非常相似。它封装了一个特定的功能集，它使用了一个简单的接口，它有效地使用CPU和内存，等等。除了是一个设计良好的类之外，自定义视图应该是: 符合Android标准 提供与Android XML布局兼容的定制样式属性 发送访问事件 与多个Android平台兼容 Android框架提供了一组基类和XML标记，以帮助您创建满足所有这些需求的视图。本课程将讨论如何使用Android框架来创建视图类的核心功能。","text":"一个设计良好的自定义视图与其他设计良好的类非常相似。它封装了一个特定的功能集，它使用了一个简单的接口，它有效地使用CPU和内存，等等。除了是一个设计良好的类之外，自定义视图应该是: 符合Android标准 提供与Android XML布局兼容的定制样式属性 发送访问事件 与多个Android平台兼容 Android框架提供了一组基类和XML标记，以帮助您创建满足所有这些需求的视图。本课程将讨论如何使用Android框架来创建视图类的核心功能。 子类化View在Android框架中定义的所有视图类都扩展View。您的自定义视图也可以直接扩展View，或者您可以通过扩展现有的视图子类，例如Button来节省时间。 为了让Android Studio能够与视图交互，至少必须提供一个构造函数，该构造函数将Context和AttributeSet对象作为参数。这个构造函数允许布局编辑器创建和编辑视图的实例。 12345class PieChart extends View &#123; public PieChart(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 定义自定义属性要向用户界面添加内置视图，需要在XML元素中指定它，并使用元素属性控制其外观和行为。编写良好的自定义视图也可以通过XML添加和样式化。要在您的自定义视图中启用该行为，您必须: 在&lt;declare-styleable&gt;资源元素中为视图定义定制属性 为XML布局中的属性指定值 在运行时检索属性值 将检索到的属性值应用到您的视图中 本节讨论如何定义自定义属性并指定它们的值。下一节将讨论如何在运行时检索和应用这些值。 要定义自定义属性，请将&lt;declare-styleable&gt;资源添加到项目中。按照惯例将这些资源放入一个res/values/attrs.xml文件中。下面是一个attrs.xml文件的例子: 123456789&lt;resources&gt; &lt;declare-styleable name=\"PieChart\"&gt; &lt;attr name=\"showText\" format=\"boolean\" /&gt; &lt;attr name=\"labelPosition\" format=\"enum\"&gt; &lt;enum name=\"left\" value=\"0\"/&gt; &lt;enum name=\"right\" value=\"1\"/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这段代码声明了两个自定义属性，showText和labelPosition，它们属于一个名为PieChart的样式实体。根据惯例，样式化实体的名称与定义自定义视图的类的名称相同。虽然没有必要遵循这个惯例，但是许多流行的代码编辑器都依赖于这个命名约定来提供语句完成。 一旦定义了定制属性，就可以在布局XML文件中使用它们，就像内置的属性一样。惟一的区别是，您的自定义属性属于不同的名称空间。而不是属于http://schemas.android.com/apk/res/android名称空间,他们属于http://schemas.android.com/apk/res/(你的包名称)。例如，下面是如何使用为PieChart定义的属性: 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:custom=\"http://schemas.android.com/apk/res/com.example.customviews\"&gt; &lt;com.example.customviews.charting.PieChart custom:showText=\"true\" custom:labelPosition=\"left\" /&gt;&lt;/LinearLayout&gt; 为了避免重复冗长的名称空间URI，该示例使用了xmlns指令。这个指令分配别名定义命名空间http://schemas.android.com/apk/res/com.example.customviews。您可以为您的命名空间选择任何别名。 请注意将自定义视图添加到布局的XML标记的名称。它是自定义视图类的完全限定名。如果您的视图类是内部类，则必须使用视图的外层类的名称进一步限定它。进一步。例如，PieChart类有一个名为PieView的内部类。使用这个类的自定义属性,可以使用标签com.example.customviews.charting.PieChart$PieView。 应用自定义属性当从XML布局创建视图时，XML标记中的所有属性都是从资源包中读取的，并作为AttributeSet传递到视图的构造函数中。虽然可以直接从AttributeSet中读取值，但是这样做有一些缺点: 属性值中的资源引用没有被解析 不能应用风格 相反，将AttributeSet传递到obtainStyledAttributes())。这个方法传递了一个已经被取消和样式化的值的TypedArray数组。 Android资源编译器为您做了很多工作，使调用obtainStyledAttributes()更容易。对于res目录中的每个资源，生成的R.java定义了一个属性id数组和一组常量，这些常量为数组中的每个属性定义索引。您可以使用预定义的常量来读取TypedArray的属性。下面是压电图类如何读取它的属性: 1234567891011121314public PieChart(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray a = context.getTheme().obtainStyledAttributes( attrs, R.styleable.PieChart, 0, 0); try &#123; mShowText = a.getBoolean(R.styleable.PieChart_showText, false); mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, 0); &#125; finally &#123; a.recycle(); &#125;&#125; 注意，TypedArray对象是一个共享资源，必须在使用后回收。 添加属性和事件属性是控制视图的行为和外观的一种强大的方式，但是只有在视图初始化时才能读取它们。为了提供动态行为，为每个定制属性公开一个属性对 getter和setter。下面的代码片段展示了PieChart如何公开一个名为showText的属性: 123456789public boolean isShowText() &#123; return mShowText;&#125;public void setShowText(boolean showText) &#123; mShowText = showText; invalidate(); requestLayout();&#125; 注意，setShowText调用invalidate())和requestLayout())。这些调用对于确保视图的行为可靠是至关重要的。您必须在对可能更改其外观的属性进行任何更改之后，使视图invalidate，以便系统知道需要重新绘制它。同样地，如果属性更改可能影响视图的大小或形状，则需要请求一个新的布局。忘记这些方法调用会导致难以找到的bug。 自定义视图还应该支持事件侦听器来通信重要事件。例如，PieChart公开一个名为OnCurrentItemChanged的自定义事件，以通知侦听器告知，用户已经将饼图转到一个新的饼图上。 很容易忘记暴露属性和事件，尤其是当您是自定义视图的唯一用户时。花一些时间仔细地定义视图的接口可以减少将来的维护成本。一个好的规则是始终公开任何影响您的自定义视图的可见外观或行为的属性。 可访问性的设计您的自定义视图应该支持最广泛的用户。这包括有残疾的用户阻止他们看到或使用触摸屏。为了支持残疾用户，您应该: 标签你输入字段使用android:contentDescription属性 在适当的时候，通过调用sendAccessibilityEvent()) 来发送可访问性事件。 支持备用控制器，如D-pad和轨迹球 有关创建可访问视图的更多信息，请参见在Android开发人员指南中可访问的应用程序。","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 用户界面的最佳实践","slug":"Android/Android-用户界面的最佳实践","permalink":"https://jigangduan.github.io/categories/Android/Android-用户界面的最佳实践/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"}]},{"title":"用户界面的最佳实践","slug":"best-practices-user-interface","date":"2017-08-10T11:41:39.000Z","updated":"2020-07-25T02:57:18.194Z","comments":true,"path":"2017/08/10/best-practices-user-interface/","link":"","permalink":"https://jigangduan.github.io/2017/08/10/best-practices-user-interface/","excerpt":"这类教程教你如何使用Android布局为所有类型的设备建立一个用户界面。Android为UI设计提供了一个灵活的框架，让你的应用可以显示不同设备的不同布局，创建定制的UI小部件，甚至可以控制应用窗口之外的系统UI。","text":"这类教程教你如何使用Android布局为所有类型的设备建立一个用户界面。Android为UI设计提供了一个灵活的框架，让你的应用可以显示不同设备的不同布局，创建定制的UI小部件，甚至可以控制应用窗口之外的系统UI。 多屏设计如何构建一个足够灵活的用户界面，能够完美地适应任何屏幕，以及如何创建针对不同屏幕大小进行优化的不同交互模式。 支持不同的屏幕尺寸 支持不同的屏幕密度 实现自适应UI流 使用约束布局构建响应性的UI如何使用约束布局和Android Studio布局编辑器来构建布局。 添加应用栏如何使用支持库的toolbar小部件来实现一个应用栏，在各种设备上正确显示。 设置应用栏 添加和处理Actions 添加Up Action Action Views和Action Providers 显示弹出式消息如何使用支持库的Snackbar小部件来显示一个简短的弹出消息。 构建并显示弹出消息 向消息中添加Action 创建自定义视图Android框架有大量的View类，用于与用户进行交互，并显示各种类型的数据。但有时你的应用程序有独特的需求，没有内置视图的覆盖。本文向您展示了如何创建您自己的视图，这些视图是健壮且可重用的。 创建自定义视图类 创建一个类似内置视图的类，带有自定义属性和支持Android Studio布局编辑器。 实现自定义绘制 使用Android图形系统使你的视图具有视觉上的与众不同。 视图交互 用户希望视图能够平稳、自然地响应输入手势。这个课程将讨论如何使用手势检测、物理和动画来给用户界面提供专业的感觉。 优化视图 不管你的UI有多漂亮，用户都不会喜欢它，如果它不以一贯的高帧率运行的话。学习如何避免常见的性能问题，以及如何使用硬件加速使您的自定义图形运行得更快。 创建向后兼容UIs如何在最新版本的Android中使用UI组件和其他APIs，同时与旧版本的平台兼容。 抽象新APIs 代理新APIs 使用旧的APIs创建实现 使用版本感知组件 实现可访问性如何让你的应用程序能够被视力障碍或其他身体残疾的用户访问。 开发可访问性服务 测试您的应用程序的可访问性 管理系统用户界面如何隐藏和显示不同版本Android的状态和导航条，同时管理其他屏幕组件的显示。 模糊系统栏 隐藏状态栏 隐藏导航栏 使用侵入式的全屏模式 对UI可见性变化做出响应 创建Material Design应用程序如何在Android上实现Material Design。 开始 使用Material主题 创建列表和卡片 定义阴影和剪切视图 使用画板 定义自定义动画 保持兼容性 使用调色板API选择颜色 使用设计支持库","categories":[{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android 用户界面的最佳实践","slug":"Android/Android-用户界面的最佳实践","permalink":"https://jigangduan.github.io/categories/Android/Android-用户界面的最佳实践/"}],"tags":[{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"}]},{"title":"Python多版本配置","slug":"Python多版本-1","date":"2017-07-15T07:47:10.000Z","updated":"2020-07-25T02:57:18.161Z","comments":true,"path":"2017/07/15/Python多版本-1/","link":"","permalink":"https://jigangduan.github.io/2017/07/15/Python多版本-1/","excerpt":"Python易用，但用好却不易，其中比较头疼的就是包管理和Python不同版本的问题。为了解决这些问题，有不少发行版的Python，比如WinPython、Anaconda等，这些发行版将python和许多常用的package打包，方便pythoners直接使用，此外，还有virtualenv、pyenv等工具管理虚拟环境。 一般网上比较多的是使用pip + pyenv + virtualenv。开始尝试pyenv，但安装过程中遇见很多的坑，最终选择了Anaconda。","text":"Python易用，但用好却不易，其中比较头疼的就是包管理和Python不同版本的问题。为了解决这些问题，有不少发行版的Python，比如WinPython、Anaconda等，这些发行版将python和许多常用的package打包，方便pythoners直接使用，此外，还有virtualenv、pyenv等工具管理虚拟环境。 一般网上比较多的是使用pip + pyenv + virtualenv。开始尝试pyenv，但安装过程中遇见很多的坑，最终选择了Anaconda。 pyenv经常遇到这样的情况： 系统自带的Python是2.x，自己需要Python 3.x，测试尝鲜； 系统是2.6.x，开发环境是2.7.x 由于Mac机器系统保护的原因，默认的Python中无法对PIP一些包升级，需要组建新的Python环境。 此时需要在系统中安装多个Python，但又不能影响系统自带的Python，即需要实现Python的多版本共存。pyenv就是这样一个Python版本管理器。 安装pyenv1brew install pyenv 查看当前激活的是那个版本的Python12$ pyenv versionsystem (set by /Users/jiang.duan/.pyenv/version) 查看已经安装了那些版本的Python12$ pyenv versions* system (set by /Users/jiang.duan/.pyenv/version) 安装指定版本的Python1pyenv install 3.5.0 遇到下面错误： 1234567891011121314151617181920Downloading Python-3.5.0.tar.xz...-&gt; https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xzInstalling Python-3.5.0...BUILD FAILED (OS X 10.12.6 using python-build 20160602)Inspect or clean up the working tree at /var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115092041.13510Results logged to /var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115092041.13510.logLast 10 log lines: File &quot;/private/var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115092041.13510/Python-3.5.0/Lib/ensurepip/__main__.py&quot;, line 4, in &lt;module&gt; ensurepip._main() File &quot;/private/var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115092041.13510/Python-3.5.0/Lib/ensurepip/__init__.py&quot;, line 209, in _main default_pip=args.default_pip, File &quot;/private/var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115092041.13510/Python-3.5.0/Lib/ensurepip/__init__.py&quot;, line 116, in bootstrap _run_pip(args + [p[0] for p in _PROJECTS], additional_paths) File &quot;/private/var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115092041.13510/Python-3.5.0/Lib/ensurepip/__init__.py&quot;, line 40, in _run_pip import pipzipimport.ZipImportError: can&apos;t decompress data; zlib not availablemake: *** [install] Error 1 原因： 1zipimport.ZipImportError: can&apos;t decompress data; zlib not available 详情看这里：issues/25 执行下面的代码即可解决这个问题： 1CFLAGS=\"-I$(xcrun --show-sdk-path)/usr/include\" pyenv install -v 3.5.0 遇到下面错误：1234567891011121314warning: xz not found; consider installing `xz` package/var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115122939.26443/Python-3.5.0 /var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115122939.26443 ~/WorkSpace/js/hexo/jigang-duan.github.io/hexo/jigangchecking build system type... x86_64-apple-darwin16.7.0checking host system type... x86_64-apple-darwin16.7.0checking for --enable-universalsdk... nochecking for --with-universal-archs... nochecking MACHDEP... darwinchecking for --without-gcc... nochecking for gcc... clangchecking whether the C compiler works... noconfigure: error: in `/var/folders/ks/yhszh_sx2qzb22rn46b145xr0000gn/T/python-build.20171115122939.26443/Python-3.5.0&apos;:configure: error: C compiler cannot create executablesSee `config.log&apos; for more detailsmake: *** No targets specified and no makefile found. Stop. 详情看这里：issues/843 从中发现了Anaconda, pyenv坑多，所以放弃，改用Anaconda。 Anaconda介绍 是不是在开始时就遇到各种麻烦呢？ 到底该装 Python2 呢还是 Python3 ？ 为什么安装 Python 时总是出错？ 怎么安装工具包呢？ 为什么提示说在安装这个工具前必须先安装一堆其他不明所以的工具？ Anaconda的安装Anaconda的下载页参见官网下载，Linux、Mac、Windows均支持。 下载命令行版本 ： macOS installer 安装： 1bash ~/Downloads/Anaconda2-5.0.1-MacOSX-x86_64.sh 对于Mac、Linux系统，Anaconda安装好后，实际上就是在主目录下多了个文件夹（~/anaconda）而已，Windows会写入注册表。安装时，安装程序会把bin目录加入PATH（Linux/Mac写入~/.bashrc，Windows添加到系统变量PATH），这些操作也完全可以自己完成。以Linux/Mac为例，安装完成后设置PATH的操作是 1234# 将anaconda的bin目录加入PATH，根据版本不同，也可能是~/anaconda3/binecho 'export PATH=\"~/anaconda3/bin:$PATH\"' &gt;&gt; ~/.bashrc# 更新bashrc以立即生效source ~/.bashrc 检查是否正确 1234$ conda --versionconda 4.3.30$ python --versionPython 3.6.3 :: Anaconda, Inc. Conda的环境管理创建一个名为python27的环境，指定Python版本是2.7（不用管是2.7.x，conda会为我们自动寻找2.7.x中的最新版本） 123$ conda create --name py27 python=2.7Package plan for installation in environment /Users/jiang.duan/anaconda3/envs/py27: 显示所有的环境： 12345$ conda env list# conda environments:#py27 /Users/jiang.duan/anaconda3/envs/py27root * /Users/jiang.duan/anaconda3 安装好后，使用activate激活某个环境: 1$ source activate py27 查看环境： 1234567(py27) $ conda env list# conda environments:#py27 * /Users/jiang.duan/anaconda3/envs/py27root /Users/jiang.duan/anaconda3(py27) $ python --versionPython 2.7.14 :: Anaconda, Inc. 退出当前环境： 1$ source deactivate 删除名为 py27 的环境： 123$ conda env remove -n py27Package plan for package removal in environment /Users/jiang.duan/anaconda3/envs/py27: 查看环境： 1234jiangduandeiMac:py jiang.duan$ conda env list# conda environments:#root * /Users/jiang.duan/anaconda3 用户安装的不同python环境都会被放在目录~/anaconda/envs下，可以在命令中运行conda info -e查看已安装的环境，当前被激活的环境会显示有一个星号或者括号。 Conda的包管理Conda的包管理就比较好理解了，这部分功能与pip类似。 conda的一些常用操作如下： 12345678910111213141516171819# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如 123456789# 更新conda，保持conda最新conda update conda# 更新anacondaconda update anaconda# 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 补充：如果创建新的python环境，比如2.7，运行conda create -n python27 python=2.7之后，conda仅安装python 2.7相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要： 123456# 在当前环境下安装anaconda包集合conda install anaconda# 结合创建环境的命令，以上操作可以合并为conda create -n python34 python=3.4 anaconda# 也可以不用全部安装，根据需求安装自己需要的package即可 分享环境当分享代码的时候，同时也需要将运行环境分享给大家，执行如下命令可以将当前环境下的 package 信息存入名为 environment 的 YAML 文件中。 1conda env export &gt; environment.yaml 同样，当执行他人的代码时，也需要配置相应的环境。这时你可以用对方分享的 YAML 文件来创建一摸一样的运行环境。 1conda env create -f environment.yaml","categories":[{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"包管理器","slug":"Python/包管理器","permalink":"https://jigangduan.github.io/categories/Python/包管理器/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"}]},{"title":"Spring 指南","slug":"spring-guides","date":"2017-07-14T06:07:38.000Z","updated":"2020-07-25T02:57:18.228Z","comments":true,"path":"2017/07/14/spring-guides/","link":"","permalink":"https://jigangduan.github.io/2017/07/14/spring-guides/","excerpt":"无论您在构建什么，这些指导都是为了让您尽可能快地工作，使用Spring团队推荐的最新Spring项目发布和技术。","text":"无论您在构建什么，这些指导都是为了让您尽可能快地工作，使用Spring团队推荐的最新Spring项目发布和技术。 入门指南这些指南为在15-30分钟内完成，提供了快速、实用的指导，用于构建Spring的任何开发任务的“Hello World”。在大多数情况下，惟一的先决条件是JDK和文本编辑器。 构建RESTful Web服务 学习如何使用Spring创建一个RESTful的web服务。 使用Gradle构建Java项目 学习如何使用Gradle构建Java项目。 文件上传 学习如何构建一个接受multi-part文件上传的Spring应用程序。 Redis 消息传递 学习如何使用Redis作为消息代理。 访问Twitter数据 学习如何从Twitter访问用户数据。 验证表单输入 学习如何使用Spring执行表单验证。 创建批处理服务 学习如何创建一个基本的批处理解决方案。 GemFire访问数据 学习如何使用Gemfire的数据结构来构建一个应用程序。 管理事务 学习如何用事务包装代码的关键部分。 使用Spring MVC服务Web内容 学习如何使用Spring MVC创建一个web页面。 处理表单提交 学习如何使用Spring创建和提交web表单。 使用STS工作 入门指南 学习如何使用Spring工具套件(STS)导入入门指南。 使用jQuery消费RESTful Web服务 学习如何使用jQuery检索web页面数据。 用Maven构建Spring YARN项目 学习如何用Maven构建一个Spring YARN项目 批处理YARN应用程序 学习如何构建一个Spring批处理YARN应用程序 使用REST访问JPA数据 学习如何使用Spring Data REST来处理基于RESTful、基于超媒体的持久性数据。 使用REST访问Neo4j数据 学习如何使用Spring Data REST来处理RESTful的、基于超媒体的持久性数据。 使用REST访问GemFire数据 学习如何使用Spring Data REST来处理基于RESTful的、基于超媒体的持久性数据。 Spring缓存数据 学习如何在内存中使用Spring缓存数据 用IntelliJ IDEA开始一个入门指南 学习如何使用IntelliJ IDEA开始入门指南。 集中配置 学习如何从外部的、集中的源管理应用程序设置 使用Ribbon和Spring Cloud的客户端负载平衡 动态支持服务在不中断客户端的情况下进行 创建一个多模块项目 学习如何构建一个库，并在Spring Boot应用程序中对其进行打包 调度任务 学习如何用Spring安排任务。 使用Maven构建Java项目 学习如何使用Maven构建Java项目。 使用LDAP对用户进行身份验证 学习如何使用LDAP保护应用程序。 用Twitter注册一个应用程序 学习如何用Twitter注册应用程序。 访问Facebook的数据 学习如何从应用程序中访问Facebook信息。 使用Spring Boot Actuator构建一个RESTful Web服务 学习如何使用Spring Boot Actuator创建一个RESTful Web服务。 保护Web应用程序 学习如何使用Spring Security保护您的web应用程序。 整合数据 学习如何构建一个使用Spring Integration来获取数据、处理它并将其写入文件的应用程序。 使用JPA访问数据 学习如何使用Spring data JPA访问JPA持久化数据。 将Spring Boot JAR应用程序转换为WAR 学习如何将Spring Boot应用程序转换为WAR文件。 使用Spring Boot构建应用程序 学习如何用最少的配置构建一个应用程序。 使用AngularJS消费RESTful Web服务 学习如何使用AngularJS检索web页面数据。 支持RESTful Web服务的跨源请求 学习如何使用Spring创建一个支持跨源资源共享(CORS)的RESTful web服务。 简单的YARN应用程序 学习如何构建一个简单的Spring YARN应用程序 可重启的批处理YARN 应用程序 学习如何构建一个可重启的Spring批处理YARN 应用程序 生成一个SOAP web服务 学习如何使用Spring创建基于SOAP的web服务。 从STS部署到云计算 学习如何将Spring应用程序从STS部署到云计算上 使用Vaadin创建CRUD UI 使用Vaadin和Spring Data JPA构建一个动态的UI 路由和过滤 学习如何使用Netflix Zuul的微服务来发送和过滤请求 测试Web层 学习如何测试Spring Boot应用程序和MVC控制器。 使用Restdocs创建API文档 学习如何使用Spring Restdocs为HTTP端点生成文档 消费RESTful Web服务 学习如何使用Spring的RestTemplate检索web页面数据。 Spring使用JDBC访问关系数据 学习如何使用Spring访问关系数据。 使用Facebook注册一个应用程序 学习如何注册一个应用程序来与Facebook集成。 RabbitMQ 消息传递 学习如何使用Spring和RabbitMQ创建一个简单的发布-订阅应用程序。 Neo4j访问数据 学习如何在Neo4j的NoSQL数据存储中持久化对象和建立关系。 JMS消息传递 学习如何使用JMS代理发布和订阅消息。 构建超媒体驱动的RESTful Web服务 学习如何使用Spring创建一个超媒体驱动的RESTful Web服务。 GemFire缓存数据 学习如何在GemFire中缓存数据。 MongoDB访问数据 学习如何在MongoDB中持久化数据。 创建异步方法 学习如何创建异步服务方法。 使用WebSocket来构建一个交互式web应用程序 学习如何通过WebSocket在浏览器和服务器之间发送和接收消息 使用rest.js消费RESTful Web服务 学习如何使用rest.js检索web页面数据。 使用Gradle 构建Spring YARN项目 学习如何使用Gradle构建一个Spring YARN项目 测试YARN应用程序 学习如何测试一个Spring YARN应用程序 消费SOAP web服务 学习如何创建一个使用消费基于WSDL服务的客户端 使用REST访问MongoDB数据 学习如何使用Spring Data REST来处理基于RESTful的、基于超媒体的持久性数据。 简单YARN应用 学习如何构建一个简单的Spring YARN应用程序 Spring Boot与Docker 学习如何使用Maven或Gradle从Spring Boot应用程序中创建Docker容器 服务注册和发现 学习使用Eureka如何注册并找到服务 断路器 学习如何使用Hystrix优雅降级服务 MySQL访问数据 学习如何在MySQL中设置和管理用户帐户，以及如何配置Spring Boot以在运行时连接到它。 局部指南在一小时或更短的时间内，被设计成阅读和理解，提供比入门指南更广泛或更主观的内容。 Spring安全架构 关于Spring Security的局部指南，这些位是如何组合在一起的，以及它们如何与Spring Boot交互 教程这些指南将在2-3个小时内完成，这些指南提供了企业应用程序开发主题的更深入的、上下文相关的探索，让您准备好实现实际的解决方案。 使用Spring构建REST服务 学习如何使用Spring轻松构建、测试和安全的RESTful服务 Spring Boot和OAuth2 关于Facebook和Github的“社交”登录和单登录的教程 Spring Security和Angular 关于如何使用带有各种后端体系结构的单一页面应用程序来使用Spring安全性的教程，从简单的单一服务器到带有OAuth2身份验证的API网关。 React.js和Spring Data REST 5个博客系列的教程","categories":[{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"指南","slug":"Spring/指南","permalink":"https://jigangduan.github.io/categories/Spring/指南/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"}]},{"title":"oneM2M 技术规范","slug":"oneM2M-技术规范","date":"2017-05-03T04:18:05.000Z","updated":"2020-07-25T02:57:18.224Z","comments":true,"path":"2017/05/03/oneM2M-技术规范/","link":"","permalink":"https://jigangduan.github.io/2017/05/03/oneM2M-技术规范/","excerpt":"官网 原文地址 文档编号 TS-0001-V2.10.0 文档标题 功能架构 日期 2016 - 8月30日 摘要: 这篇文档详细说明oneM2M服务平台的功能体系结构。 (此版本文档是 TS-0001-V2.9.1的升级，包含“维护”和“校正” ARC# 24会议) 本规范仅供oneM2M内未来发展工作。合作伙伴接受不责任对于任何使用本规范。 当前文档没有受到任何审批程序由oneM2M伙伴1型。发表oneM2M规范实施和报告应通过oneM2M获得合作伙伴的出版物的办公室。","text":"官网 原文地址 文档编号 TS-0001-V2.10.0 文档标题 功能架构 日期 2016 - 8月30日 摘要: 这篇文档详细说明oneM2M服务平台的功能体系结构。 (此版本文档是 TS-0001-V2.9.1的升级，包含“维护”和“校正” ARC# 24会议) 本规范仅供oneM2M内未来发展工作。合作伙伴接受不责任对于任何使用本规范。 当前文档没有受到任何审批程序由oneM2M伙伴1型。发表oneM2M规范实施和报告应通过oneM2M获得合作伙伴的出版物的办公室。 关于oneM2MoneM2M的目的和目标是开发技术规范处理需要一个共同的M2M很容易嵌入到各种服务层硬件和软件,并依靠连接各种设备领域M2M应用服务器。 更多信息oneM2M可能发现:http / / www.oneM2M.org 1. 范围本文档描述了端到端oneM2M功能体系结构,包括的描述功能实体和相关的参考点。 oneM2M功能体系结构侧重于服务层方面,潜在的网络视图端到端服务。底层网络用于传输数据和潜在的其他服务。 2. 引用2.1. 引用标准以下引用文档是当前文档的应用程序所必需的。 [1] oneM2M TS-0011: “常见术语”. [2] oneM2M TS-0003: “ 安全解决方案”. [3] oneM2M TS-0004: “核心服务层协议规范”. [4] W3C RDF 1.1 概念和抽象语法. [5] W3C SPARQL 1.1 查询语言. [6] oneM2M TS-0012: “oneM2M 基础本体论”. [7] oneM2M TS-0021: “oneM2M AllJoyn互相配合”. [8] oneM2M TS-0023: “家电信息模型和映射”. 2.2. 有益的参考以下引用文档不是当前文档的应用程序所必需的但他们协助用户对特定主题领域。 [i.1] oneM2M TS-0002: “需求”. [i.2] Broadband Forum TR-069: “CPE广域网管理协议问题”: 1 修改 5日11月2013年 [i.3] OMA-DM: “OMA设备管理协议”, 1.3版本,开放移动联盟. [i.4] LWM2M: “OMA LightweightM2M”, 1.0版本,开放移动联盟. [i.5] OMA-TS-MLP-V3-4-20130226-C: “移动位置协议”, 3.4版. [i.6] OMA-TS-REST-NetAPI_TerminalLocation-V1_0-20130924-A: “网络RESTful API终端位置”, 1.0版. [i.7] IETF RFC 1035: “域名-实施和规范”. [i.8] IETF RFC 3588: “直径基本协议”. [i.9] IETF RFC 3596: “DNS扩展支持IPv6”. [i.10] IETF RFC 3986: “统一资源标识符(URI):一般语法”. [i.11] IETF RFC 4006: “直径一些控制信贷增长的应用程序”. [i.12] IETF RFC 6895: “域名系统(DNS)IANA的考虑”. [i.13] GSMA-IR.67: “DNS / ENU表示指南服务提供商&amp; GRX / IPX提供者”. [i.14] 3GPP TS 23.682: “A架构增强促进与分组数据通信网络和应用程序(13)发布”. [i.15] ETSI TS 132 240: “数字蜂窝通信系统(2 +阶段);通用移动通信系统(UMTS);LTE通信管理;充电充电管理;体系结构和原则(3 GPP TS 32.240)”. [i.16] ETSI TS 132 299: “数字蜂窝通信系统(2 +阶段);通用移动通信系统(UMTS);LTE通信管理;充电管理;直径收费应用程序(3 GPP TS 32.299)”. [i.17] 3GPP2 .S0068: “网络增强的机器对机器(M2M)”.[i.18] JNI 6.0 API 规范: “Java Native Interface 6.0规范”. [i.19] 3GPP TS 23.401: “通用分组无线服务(GPRS)为发展普遍增强陆地无线接入网(E-UTRAN)访问”. [i.20] 3GPP TS 23.402: “non-3GPP访问架构增强”. [i.21] 3GPP TS 23.060: “通用分组无线业务(GPRS);服务描述;第二阶段”. [i.22] 3GPP TS 22.368: “机器类型通信服务需求(MTC);1阶段”. [i.23] 3GPP TS 23.003: “编号、寻址和识别”. [i.24] Recommendation ITU-T X.660 | ISO/IEC 9834-1: “信息技术——程序操作对象标识符的登记机关:一般程序和顶级的弧线国际树对象标识符”. [i.25] oneM2M TR-0008: “分析oneM2M安全解决方案的系统”. [i.26] IETF RFC 4122: “一个全局惟一的标识符(UUID)缸名称空间”. [i.27] oneM2M 起草规则.注意: Available at http://www.onem2m.org/images/files/oneM2M-Drafting-Rules.pdf [i.28] oneM2M TR-0007: “抽象和语义支持的研究”. [i.29] 3GPP TS 22.101: 服务方面,服务原则(发布13). [i.30] 3GPP TS 22.115: 服务方面;充电和计费(发布13). [i.31] 3GPP TS 29.336: 家庭用户服务器(HSS)直径接口与数据包交互工作数据网络和应用程序发布(13). [i.32] OMA-TS-REST-NetAPI-CommunicationPatterns-V1-0: ‘“网络RESTful API通信模式’”, 1.0版本开放移动联盟. 3. 定义和缩写3.1 定义本文档的目的,下列术语和定义适用: 访问控制属性:发起人设置的参数,目标资源和环境的可以访问控制规则评估 访问决定:授权达到当一个实体的特权,以及其他访问控制属性评估 应用程序层:包括oneM2M应用程序和相关的业务和操作逻辑 属性:存储有关的信息资源 公共服务层:由oneM2M服务功能,使oneM2M应用程序(例如,管理,发现和策略执行) 公共服务功能(CSF):信息体系结构构造的概念组织在一起的项子功能 基于内容的发现:发现操作资源相匹配的条件有关内容属性的&lt; contentInstance&gt;资源在特定&lt;容器&gt; 执行环境:逻辑实体,代表一个环境能够运行软件模块 托管CSE:CSE解决资源托管 M2M服务提供者域:M2M系统的一部分,与一个特定的M2M服务提供者 托管实体:可以是一个M2M装置,M2M网关,或M2M区域网络设备或M2M应用程序层或M2M服务层的软件组件 管理代理:实体内的设备管理架构,结合管理客户端,之间充当中介管理服务器和代理管理客户端 网络服务层:提供运输、连接和服务功能 节点:M2M系统可识别的逻辑实体 non-oneM2M节点:节点不包含oneM2M实体 通知:托管CSE启动通知通知订阅/通知框架或目标非阻塞asynchoronous方案 通知目标:是一个AE或CSE接收通知的通知","categories":[],"tags":[]},{"title":"远和近","slug":"远和近","date":"2017-04-05T04:37:51.000Z","updated":"2020-07-25T02:57:18.236Z","comments":true,"path":"2017/04/05/远和近/","link":"","permalink":"https://jigangduan.github.io/2017/04/05/远和近/","excerpt":"","text":"你， 一会儿看我， 一会儿看云。 我觉得， 你看我时很远， 你看云时很近。","categories":[{"name":"顾城","slug":"顾城","permalink":"https://jigangduan.github.io/categories/顾城/"}],"tags":[{"name":"诗","slug":"诗","permalink":"https://jigangduan.github.io/tags/诗/"},{"name":"顾城","slug":"顾城","permalink":"https://jigangduan.github.io/tags/顾城/"}]},{"title":"小巷","slug":"小巷","date":"2017-04-05T04:25:02.000Z","updated":"2020-07-25T02:57:18.236Z","comments":true,"path":"2017/04/05/小巷/","link":"","permalink":"https://jigangduan.github.io/2017/04/05/小巷/","excerpt":"","text":"小巷 又弯又长 没有门 没有窗 你拿把旧钥匙 敲着厚厚的墙","categories":[{"name":"顾城","slug":"顾城","permalink":"https://jigangduan.github.io/categories/顾城/"}],"tags":[{"name":"诗","slug":"诗","permalink":"https://jigangduan.github.io/tags/诗/"},{"name":"顾城","slug":"顾城","permalink":"https://jigangduan.github.io/tags/顾城/"}]},{"title":"Hexo","slug":"hello-world.1","date":"2017-03-25T04:26:28.000Z","updated":"2020-07-25T02:57:18.207Z","comments":true,"path":"2017/03/25/hello-world.1/","link":"","permalink":"https://jigangduan.github.io/2017/03/25/hello-world.1/","excerpt":"","text":"欢迎使用 Hexo! 这是你的第一个帖子. 查看 文档 了解更多信息. 如果你在使用Hexo时有任何问题, 你可以在这儿故障排除 或访问 GitHub找到答案. 快速入门创建一个新帖子1$ hexo new \"My New Post\" 更多信息: 写作 运行服务器1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: 生成 部署到远程站点1$ hexo deploy 更多信息: 部署","categories":[],"tags":[]},{"title":"Jade - 模板引擎","slug":"jade","date":"2017-03-25T04:26:28.000Z","updated":"2020-07-25T02:57:18.209Z","comments":true,"path":"2017/03/25/jade/","link":"","permalink":"https://jigangduan.github.io/2017/03/25/jade/","excerpt":"Jade - 模板引擎Jade 是一个高性能的模板引擎，它深受 Haml 影响，它是用 JavaScript 实现的, 并且可以供 Node 使用. 翻译: 草依山 等","text":"Jade - 模板引擎Jade 是一个高性能的模板引擎，它深受 Haml 影响，它是用 JavaScript 实现的, 并且可以供 Node 使用. 翻译: 草依山 等 声明从 Jade v0.31.0 开始放弃了对于 &lt;script&gt; 和 &lt;style&gt; 标签的平文本支持. 这个问题你可以在 &lt;script&gt; &lt;style&gt; 标签后加上 . 来解决. 希望这一点能让 Jade 对新手更友好, 同时也不影响到 Jade 本身的能力或者导致过度冗长. 如果你有大量的文件需要转换你可以用下 fix-jade 尝试自动完成这个过程. Test drive你可以在网上试玩 Jade. README 目录 特性 其它实现 安装 浏览器支持 公开 API 语法 行结束标志 标签 标签文本 注释 块注释 内联 块展开 Case 属性 HTML Doctypes 过滤器 代码 循环 条件语句 模板继承 Block append/prepend 包含 Mixins 产生输出 Makefile 的一个例子 命令行的 Jade 教程 License 特性 客户端支持 代码高可读 灵活的缩进 块展开 Mixins 静态包含 属性改写 安全，默认代码是转义的 运行时和编译时上下文错误报告 命令行下编译jade模板 HTML5 模式 (使用 !!! 5 doctype html 文档类型) 在内存中缓存(可选) 合并动态和静态标签类 可以通过 filters 修改树 模板继承 原生支持 Express JS 通过 each 枚举对象、数组甚至是不能枚举的对象 块注释 没有前缀的标签 AST Filters 过滤器 :stylus 必须已经安装 stylus :less 必须已经安装 less.js :markdown 必须已经安装 markdown-js 或者 node-discount :cdata :coffeescript 必须已经安装coffee-script Emacs Mode Vim Syntax TextMate Bundle Coda/SubEtha syntax Mode Screencasts html2jade converter 其它实现 php scala ruby python java 安装通过 NPM: 1npm install jade 浏览器支持把 Jade 编译为一个可供浏览器使用的单文件，只需要简单的执行: 1$ make jade.js 如果你已经安装了 uglifyjs (npm install uglify-js)，你可以执行下面的命令它会生成所有的文件。其实每一个正式版本里都帮你做了这事。 1make jade.min.js 默认情况下，为了方便调试Jade会把模板组织成带有形如 __.lineno = 3 的行号的形式。在浏览器里使用的时候，你可以通过传递一个选项 { compileDebug: false } 来去掉这个。下面的模板 1p Hello #&#123;name&#125; 会被翻译成下面的函数： 12345678function anonymous(locals, attrs, escape, rethrow) &#123; var buf = []; with (locals || &#123;&#125;) &#123; var interp; buf.push('\\n&lt;p&gt;Hello ' + escape((interp = name) == null ? '' : interp) + '\\n&lt;/p&gt;'); &#125; return buf.join(\"\");&#125; 通过使用 Jade 的 ./runtime.js你可以在浏览器使用这些预编译的模板而不需要使用 Jade, 你只需要使用 runtime.js 里的工具函数, 它们会放在 jade.attrs, jade.escape 这些里。 把选项 { client: true } 传递给 jade.compile(), Jade 会把这些帮助函数的引用放在jade.attrs, jade.escape. 123456789function anonymous(locals, attrs, escape, rethrow) &#123; var attrs = jade.attrs, escape = jade.escape, rethrow = jade.rethrow; var buf = []; with (locals || &#123;&#125;) &#123; var interp; buf.push('\\n&lt;p&gt;Hello ' + escape((interp = name) == null ? '' : interp) + '\\n&lt;/p&gt;'); &#125; return buf.join(\"\");&#125; 公开 API12345var jade = require('jade');// Compile a functionvar fn = jade.compile('string of jade', options);fn(locals); 选项 self 使用 self 命名空间来持有本地变量. (默认为 false) locals 本地变量对象 filename 异常发生时使用，includes 时必需 debug 输出 token 和翻译后的函数体 compiler 替换掉 jade 默认的编译器 compileDebug false的时候调试的结构不会被输出 pretty 为输出加上了漂亮的空格缩进 (默认为 false) 语法 行结束标志CRLF 和 CR 会在编译之前被转换为 LF 标签标签就是一个简单的单词: 1html 它会被转换为 &lt;html&gt;&lt;/html&gt; 标签也是可以有 id 的: 1div#container 它会被转换为 &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; 怎么加 class 呢？ 1div.user-details 转换为 &lt;div class=&quot;user-details&quot;&gt;&lt;/div&gt; 多个 class 和 id? 也是可以搞定的: div#foo.bar.baz 转换为 &lt;div id=&quot;foo&quot; class=&quot;bar baz&quot;&gt;&lt;/div&gt; 不停的 div div div 很讨厌啊 , 可以这样: 12#foo.bar 这个算是我们的语法糖，它已经被很好的支持了，上面的会输出： 1&lt;div id=\"foo\"&gt;&lt;/div&gt;&lt;div class=\"bar\"&gt;&lt;/div&gt; 标签文本只需要简单的把内容放在标签之后： 1p wahoo! 它会被渲染为 &lt;p&gt;wahoo!&lt;/p&gt;. 很帅吧，但是大段的文本怎么办呢： 12345p | foo bar baz | rawr rawr | super cool | go jade go 渲染为 &lt;p&gt;foo bar baz rawr.....&lt;/p&gt; 怎么和数据结合起来？ 所有类型的文本展示都可以和数据结合起来，如果我们把 { name: &#39;tj&#39;, email: &#39;tj@vision-media.ca&#39; } 传给编译函数，下面是模板上的写法: 1#user #&#123;name&#125; &amp;lt;#&#123;email&#125;&amp;gt; 它会被渲染为 &lt;div id=&quot;user&quot;&gt;tj &amp;lt;tj@vision-media.ca&amp;gt;&lt;/div&gt; 当就是要输出 #{} 的时候怎么办? 转义一下! p \\#{something} 它会输出 &lt;p&gt;#{something}&lt;/p&gt; 同样可以使用非转义的变量 !{html}, 下面的模板将直接输出一个 &lt;script&gt; 标签: 12- var html = &quot;&lt;script&gt;&lt;/script&gt;&quot;| !&#123;html&#125; 内联标签同样可以使用文本块来包含文本： 123label | Username: input(name=&apos;user[name]&apos;) 或者直接使用标签文本: 12label Username: input(name=&apos;user[name]&apos;) _只_ 包含文本的标签，比如 &lt;script&gt;, &lt;style&gt;, 和 &lt;textarea&gt; 不需要前缀 | 字符, 比如: 123456789html head title Example script if (foo) &#123; bar(); &#125; else &#123; baz(); &#125; 这里还有一种选择，可以使用 . 来开始一段文本块，比如： 123456p. foo asdf asdf asdfasdfaf asdf asd. 会被渲染为: 1234567&lt;p&gt;foo asdfasdf asdfasdfaf asdfasd.&lt;/p&gt; 这和带一个空格的 . 是不一样的, 带空格的会被 Jade 的解析器忽略，当作一个普通的文字: 1p . 渲染为: 1&lt;p&gt;.&lt;/p&gt; 需要注意的是文本块需要两次转义。比如想要输出下面的文本： 1&lt;p&gt;foo\\bar&lt;/p&gt; 使用: 12p. foo\\\\bar 注释单行注释和 JavaScript 里是一样的，通过 // 来开始，并且必须单独一行： 123// just some paragraphsp foop bar 渲染为： 123&lt;!-- just some paragraphs --&gt;&lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt; Jade 同样支持不输出的注释，加一个短横线就行了： 123//- will not output within markupp foop bar 渲染为： 12&lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt; 块注释块注释也是支持的： 1234body // #content h1 Example 渲染为： 1234567&lt;body&gt; &lt;!-- &lt;div id=\"content\"&gt; &lt;h1&gt;Example&lt;/h1&gt; &lt;/div&gt; --&gt;&lt;/body&gt; Jade 同样很好的支持了条件注释： 123body //if IE a(href=&apos;http://www.mozilla.com/en-US/firefox/&apos;) Get Firefox 渲染为： 12345&lt;body&gt; &lt;!--[if IE]&gt; &lt;a href=\"http://www.mozilla.com/en-US/firefox/\"&gt;Get Firefox&lt;/a&gt; &lt;![endif]--&gt;&lt;/body&gt; 内联Jade 支持以自然的方式定义标签嵌套: 1234567ul li.first a(href=&apos;#&apos;) foo li a(href=&apos;#&apos;) bar li.last a(href=&apos;#&apos;) baz 块展开块展开可以帮助你在一行内创建嵌套的标签，下面的例子和上面的是一样的： 1234ul li.first: a(href=&apos;#&apos;) foo li: a(href=&apos;#&apos;) bar li.last: a(href=&apos;#&apos;) baz Casecase 表达式按下面这样的形式写: 12345678910html body friends = 10 case friends when 0 p you have no friends when 1 p you have a friend default p you have #&#123;friends&#125; friends 块展开在这里也可以使用: 12345678friends = 5html body case friends when 0: p you have no friends when 1: p you have a friend default: p you have #&#123;friends&#125; friends 属性Jade 现在支持使用 ( 和 ) 作为属性分隔符 1a(href=&apos;/login&apos;, title=&apos;View login page&apos;) Login 当一个值是 undefined 或者 null 属性 _不_ 会被加上,所以呢，它不会编译出 ‘something=”null”‘. 1div(something=null) Boolean 属性也是支持的: 1input(type=&quot;checkbox&quot;, checked) 使用代码的 Boolean 属性只有当属性为 true 时才会输出： 1input(type=&quot;checkbox&quot;, checked=someValue) 多行同样也是可用的： 123input(type=&apos;checkbox&apos;, name=&apos;agreement&apos;, checked) 多行的时候可以不加逗号： 123input(type=&apos;checkbox&apos; name=&apos;agreement&apos; checked) 加点空格，格式好看一点？同样支持 1234input( type=&apos;checkbox&apos; name=&apos;agreement&apos; checked) 冒号也是支持的: 1rss(xmlns:atom=&quot;atom&quot;) 假如我有一个 user 对象 { id: 12, name: &#39;tobi&#39; }我们希望创建一个指向 /user/12 的链接 href, 我们可以使用普通的 JavaScript 字符串连接，如下: 1a(href=&apos;/user/&apos; + user.id)= user.name 或者我们使用 Jade 的修改方式, 这个我想很多使用 Ruby 或者 CoffeeScript 的人会看起来像普通的 JS..: 1a(href=&apos;/user/#&#123;user.id&#125;&apos;)= user.name class 属性是一个特殊的属性，你可以直接传递一个数组，比如 bodyClasses = [&#39;user&#39;, &#39;authenticated&#39;] : 1body(class=bodyClasses) HTML内联的 HTML 是可以的，我们可以使用管道定义一段文本 : 1234html body | &lt;h1&gt;Title&lt;/h1&gt; | &lt;p&gt;foo bar baz&lt;/p&gt; 或者我们可以使用 . 来告诉 Jade 我们需要一段文本： 1234html body. &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;foo bar baz&lt;/p&gt; 上面的两个例子都会渲染成相同的结果： 123&lt;html&gt;&lt;body&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;foo bar baz&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这条规则适应于在 Jade 里的任何文本： 123html body h1 User &lt;em&gt;#&#123;name&#125;&lt;/em&gt; Doctypes添加文档类型只需要简单的使用 !!!, 或者 doctype 跟上下面的可选项: 1!!! 会渲染出 transitional 文档类型, 或者: 1!!! 5 或 1!!! html 或 1doctype html Doctype 是大小写不敏感的, 所以下面两个是一样的: 12doctype Basicdoctype basic 当然也是可以直接传递一段文档类型的文本： 1doctype html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.1//EN&quot; 渲染后: 1&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\"&gt; 会输出 HTML5 文档类型. 下面的默认的文档类型，可以很简单的扩展： 1234567891011var doctypes = exports.doctypes = &#123; '5': '&lt;!DOCTYPE html&gt;', 'xml': '&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;', 'default': '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;', 'transitional': '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;', 'strict': '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;', 'frameset': '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\"&gt;', '1.1': '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"&gt;', 'basic': '&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\"&gt;', 'mobile': '&lt;!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\"&gt;'&#125;; 通过下面的代码可以很简单的改变默认的文档类型： 1jade.doctypes.default = 'whatever you want'; 过滤器过滤器前缀 :, 比如 :markdown 会把下面块里的文本交给专门的函数进行处理。查看顶部 _特性_ 里有哪些可用的过滤器。 1234body :markdown Woah! jade _and_ markdown, very **cool** we can even link to [stuff](http://google.com) 渲染为: 1&lt;body&gt;&lt;p&gt;Woah! jade &lt;em&gt;and&lt;/em&gt; markdown, very &lt;strong&gt;cool&lt;/strong&gt; we can even link to &lt;a href=\"http://google.com\"&gt;stuff&lt;/a&gt;&lt;/p&gt;&lt;/body&gt; 代码Jade 目前支持三种类型的可执行代码。第一种是前缀 -， 这是不会被输出的： 1- var foo = &apos;bar&apos;; 这可以用在条件语句或者循环中： 12- for (var key in obj) p= obj[key] 由于 Jade 的缓存技术，下面的代码也是可以的： 1234567- if (foo) ul li yay li foo li worked- else p oh no! didnt work 哈哈，甚至是很长的循环也是可以的： - if (items.length) ul - items.forEach(function(item){ li= item - }) 所以你想要的！ 下一步我们要 _转义_ 输出的代码，比如我们返回一个值，只要前缀一个 =： 123- var foo = &apos;bar&apos;= fooh1= foo 它会渲染为 bar&lt;h1&gt;bar&lt;/h1&gt;. 为了安全起见，使用 = 输出的代码默认是转义的,如果想直接输出不转义的值可以使用 !=： 1p!= aVarContainingMoreHTML Jade 同样是设计师友好的，它可以使 JavaScript 更直接更富表现力。比如下面的赋值语句是相等的，同时表达式还是通常的 JavaScript： 12- var foo = &apos;foo &apos; + &apos;bar&apos;foo = &apos;foo &apos; + &apos;bar&apos; Jade 会把 if, else if, else, until, while, unless 同别的优先对待, 但是你得记住它们还是普通的 JavaScript： 1234567if foo == &apos;bar&apos; ul li yay li foo li workedelse p oh no! didnt work 循环尽管已经支持 JavaScript 原生代码，Jade 还是支持了一些特殊的标签，它们可以让模板更加易于理解，其中之一就是 each, 这种形式： 1each VAL[, KEY] in OBJ 一个遍历数组的例子 ： 123- var items = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]each item in items li= item 渲染为: 123&lt;li&gt;one&lt;/li&gt;&lt;li&gt;two&lt;/li&gt;&lt;li&gt;three&lt;/li&gt; 遍历一个数组同时带上索引： 123items = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]each item, i in items li #&#123;item&#125;: #&#123;i&#125; 渲染为: 123&lt;li&gt;one: 0&lt;/li&gt;&lt;li&gt;two: 1&lt;/li&gt;&lt;li&gt;three: 2&lt;/li&gt; 遍历一个数组的键值： 123obj = &#123; foo: &apos;bar&apos; &#125;each val, key in obj li #&#123;key&#125;: #&#123;val&#125; 将会渲染为：&lt;li&gt;foo: bar&lt;/li&gt; Jade 在内部会把这些语句转换成原生的 JavaScript 语句，就像使用 users.forEach(function(user){, 词法作用域和嵌套会像在普通的 JavaScript 中一样： 123each user in users each role in user.roles li= role 如果你喜欢，也可以使用 for ： 123for user in users for role in user.roles li= role 条件语句Jade 条件语句和使用了(-) 前缀的 JavaScript 语句是一致的,然后它允许你不使用圆括号，这样会看上去对设计师更友好一点，同时要在心里记住这个表达式渲染出的是 _常规_ JavaScript： 12345for user in users if user.role == &apos;admin&apos; p #&#123;user.name&#125; is an admin else p= user.name 和下面的使用了常规 JavaScript 的代码是相等的： 12345for user in users - if (user.role == &apos;admin&apos;) p #&#123;user.name&#125; is an admin - else p= user.name Jade 同时支持 unless, 这和 if (!(expr)) 是等价的： 12345for user in users unless user.isAnonymous p | Click to view a(href=&apos;/users/&apos; + user.id)= user.name 模板继承Jade 支持通过 block 和 extends 关键字来实现模板继承。 一个块就是一个 Jade 的 block ，它将在子模板中实现，同时是支持递归的。 Jade 块如果没有内容，Jade 会添加默认内容，下面的代码默认会输出 block scripts, block content, 和 block foot. 12345678910html head h1 My Site - #&#123;title&#125; block scripts script(src=&apos;/jquery.js&apos;) body block content block foot #footer p some footer content 现在我们来继承这个布局，简单创建一个新文件，像下面那样直接使用 extends，给定路径（可以选择带 .jade 扩展名或者不带）. 你可以定义一个或者更多的块来覆盖父级块内容, 注意到这里的 foot 块 _没有_ 定义，所以它还会输出父级的 “some footer content”。 12345678910extends extend-layoutblock scripts script(src=&apos;/jquery.js&apos;) script(src=&apos;/pets.js&apos;)block content h1= title each pet in pets include pet 同样可以在一个子块里添加块，就像下面实现的块 content 里又定义了两个可以被实现的块 sidebar 和 primary，或者子模板直接实现 content。 123456789extends regular-layoutblock content .sidebar block sidebar p nothing .primary block primary p nothing 前置、追加代码块Jade允许你 _替换_ （默认）、 _前置_ 和 _追加_ blocks. 比如，假设你希望在 _所有_ 页面的头部都加上默认的脚本，你可以这么做： 1234567html head block head script(src=&apos;/vendor/jquery.js&apos;) script(src=&apos;/vendor/caustic.js&apos;) body block content 现在假设你有一个Javascript游戏的页面，你希望在默认的脚本之外添加一些游戏相关的脚本，你可以直接append上代码块： 12345extends layoutblock append head script(src=&apos;/vendor/three.js&apos;) script(src=&apos;/game.js&apos;) 使用 block append 或 block prepend 时 block 是可选的: 12345extends layoutappend head script(src=&apos;/vendor/three.js&apos;) script(src=&apos;/game.js&apos;) 包含Includes 允许你静态包含一段 Jade, 或者别的存放在单个文件中的东西比如 CSS, HTML 非常常见的例子是包含头部和页脚。 假设我们有一个下面目录结构的文件夹： 1234./layout.jade./includes/ ./head.jade ./tail.jade 下面是 layout.jade 的内容: 123456html include includes/head body h1 My Site p Welcome to my super amazing site. include includes/foot 这两个包含 includes/head 和 includes/foot 都会读取相对于给 layout.jade 参数filename 的路径的文件, 这是一个绝对路径，不用担心Express帮你搞定这些了。Include 会解析这些文件，并且插入到已经生成的语法树中，然后渲染为你期待的内容： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;My Site&lt;/title&gt; &lt;script src=\"/javascripts/jquery.js\"&gt; &lt;/script&gt;&lt;script src=\"/javascripts/app.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;My Site&lt;/h1&gt; &lt;p&gt;Welcome to my super lame site.&lt;/p&gt; &lt;div id=\"footer\"&gt; &lt;p&gt;Copyright&gt;(c) foobar&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 前面已经提到，include 可以包含比如 HTML 或者 CSS 这样的内容。给定一个扩展名后，Jade 不会把这个文件当作一个 Jade 源代码，并且会把它当作一个普通文本包含进来： 123456789101112html head //- css and js have simple filters that wrap them in &lt;style&gt; and &lt;script&gt; tags, respectively include stylesheet.css include script.js body //- &quot;markdown&quot; files will use the &quot;markdown&quot; filter to convert Markdown to HTML include introduction.markdown //- html files have no filter and are included verbatim include content.html Include 也可以接受块内容，给定的块将会附加到包含文件 _最后_ 的块里。 举个例子，head.jade 包含下面的内容： 12head script(src=&apos;/jquery.js&apos;) 我们可以像下面给include head添加内容, 这里是添加两个脚本. 123456html include head script(src=&apos;/foo.js&apos;) script(src=&apos;/bar.js&apos;) body h1 test 在被包含的模板中，你也可以使用yield语句。yield语句允许你明确地标明include的代码块的放置位置。比如，假设你希望把代码块放在scripts之前，而不是附加在scripts之后： 1234head yield script(src=&apos;/jquery.js&apos;) script(src=&apos;/jquery.ui.js&apos;) 由于被包含的Jade会按字面解析并合并到AST中，词法范围的变量的效果和直接写在同一个文件中的相同。这就意味着include可以用作partial的替代，例如，假设我们有一个引用了user变量的user.jade`文件： 12h1= user.namep= user.occupation 接着，当我们迭代users的时候，只需简单地加上include user。因为在循环中user变量已经被定义了，被包含的模板可以访问它。 12345users = [&#123; name: &apos;Tobi&apos;, occupation: &apos;Ferret&apos; &#125;]each user in users .user include user 以上代码会生成： 1234&lt;div class=\"user\"&gt; &lt;h1&gt;Tobi&lt;/h1&gt; &lt;p&gt;Ferret&lt;/p&gt;&lt;/div&gt; user.jade引用了user变量，如果我们希望使用一个不同的变量user，那么我们可以直接定义一个新变量user = person，如下所示： 1234each person in users .user user = person include user MixinsMixins 在编译的模板里会被 Jade 转换为普通的 JavaScript 函数。 Mixins 可以还参数，但不是必需的： 12345mixin list ul li foo li bar li baz 使用不带参数的 mixin 看上去非常简单，在一个块外： 12h2 Groceriesmixin list Mixins 也可以带一个或者多个参数，参数就是普通的 JavaScript 表达式，比如下面的例子： 123456789mixin pets(pets) ul.pets - each pet in pets li= petmixin profile(user) .user h2= user.name mixin pets(user.pets) 会输出像下面的 HTML: 123456789&lt;div class=\"user\"&gt; &lt;h2&gt;tj&lt;/h2&gt; &lt;ul class=\"pets\"&gt; &lt;li&gt;tobi&lt;/li&gt; &lt;li&gt;loki&lt;/li&gt; &lt;li&gt;jane&lt;/li&gt; &lt;li&gt;manny&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 产生输出假设我们有下面的 Jade 源码： 123- var title = &apos;yay&apos;h1.title #&#123;title&#125;p Just an example 当 compileDebug 选项不是 false, Jade 会编译时会把函数里加上 __.lineno = n;, 这个参数会在编译出错时传递给 rethrow(), 而这个函数会在 Jade 初始输出时给出一个有用的错误信息。 1234567891011121314151617181920212223242526function anonymous(locals) &#123; var __ = &#123; lineno: 1, input: \"- var title = 'yay'\\nh1.title #&#123;title&#125;\\np Just an example\", filename: \"testing/test.js\" &#125;; var rethrow = jade.rethrow; try &#123; var attrs = jade.attrs, escape = jade.escape; var buf = []; with (locals || &#123;&#125;) &#123; var interp; __.lineno = 1; var title = 'yay' __.lineno = 2; buf.push('&lt;h1'); buf.push(attrs(&#123; \"class\": ('title') &#125;)); buf.push('&gt;'); buf.push('' + escape((interp = title) == null ? '' : interp) + ''); buf.push('&lt;/h1&gt;'); __.lineno = 3; buf.push('&lt;p&gt;'); buf.push('Just an example'); buf.push('&lt;/p&gt;'); &#125; return buf.join(\"\"); &#125; catch (err) &#123; rethrow(err, __.input, __.filename, __.lineno); &#125;&#125; 当 compileDebug 参数是 false, 这个参数会被去掉，这样对于轻量级的浏览器端模板是非常有用的。结合 Jade 的参数和当前源码库里的 ./runtime.js 文件，你可以通过 toString() 来编译模板而不需要在浏览器端运行整个 Jade 库，这样可以提高性能，也可以减少载入的 JavaScript 数量。 1234567891011121314151617function anonymous(locals) &#123; var attrs = jade.attrs, escape = jade.escape; var buf = []; with (locals || &#123;&#125;) &#123; var interp; var title = 'yay' buf.push('&lt;h1'); buf.push(attrs(&#123; \"class\": ('title') &#125;)); buf.push('&gt;'); buf.push('' + escape((interp = title) == null ? '' : interp) + ''); buf.push('&lt;/h1&gt;'); buf.push('&lt;p&gt;'); buf.push('Just an example'); buf.push('&lt;/p&gt;'); &#125; return buf.join(\"\");&#125; Makefile 的一个例子通过执行 make， 下面的 Makefile 例子可以把 pages/*.jade 编译为 pages/*.html 。 123456789101112JADE = $(shell find pages/*.jade)HTML = $(JADE:.jade=.html)all: $(HTML)%.html: %.jade jade &lt; $&lt; --path $&lt; &gt; $@clean: rm -f $(HTML).PHONY: clean 这个可以和 watch(1) 命令起来产生像下面的行为： 1$ watch make 命令行的 Jade12345678910111213141516171819202122232425262728293031323334使用: jade [options] [dir|file ...]选项: -h, --help 输出帮助信息 -v, --version 输出版本号 -o, --out &lt;dir&gt; 输出编译后的 HTML 到 &lt;dir&gt; -O, --obj &lt;str&gt; JavaScript 选项 -p, --path &lt;path&gt; 在处理 stdio 时，查找包含文件时的查找路径 -P, --pretty 格式化 HTML 输出 -c, --client 编译浏览器端可用的 runtime.js -D, --no-debug 关闭编译的调试选项(函数会更小) -w, --watch 监视文件改变自动刷新编译结果Examples: # 编译整个目录 $ jade templates # 生成 &#123;foo,bar&#125;.html $ jade &#123;foo,bar&#125;.jade # 在标准IO下使用jade $ jade &lt; my.jade &gt; my.html # 在标准IO下使用jade, 同时指定用于查找包含的文件 $ jade &lt; my.jade -p my.jade &gt; my.html # 在标准IO下使用jade $ echo &quot;h1 Jade!&quot; | jade # foo, bar 目录渲染到 /tmp $ jade foo bar --out /tmp 注意: 从 v0.31.0 的 -o 选项已经指向 --out, -O 相应做了交换 教程 cssdeck interactive Jade syntax tutorial cssdeck interactive Jade logic tutorial in Japanese License(The MIT License) Copyright (c) 2009-2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt; Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions: The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","categories":[{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"模板引擎","slug":"前端/模板引擎","permalink":"https://jigangduan.github.io/categories/前端/模板引擎/"}],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://jigangduan.github.io/tags/模板引擎/"}]},{"title":"Markdown 语法笔记","slug":"Markdown语法笔记","date":"2017-03-20T04:26:28.000Z","updated":"2020-07-25T02:57:18.159Z","comments":true,"path":"2017/03/20/Markdown语法笔记/","link":"","permalink":"https://jigangduan.github.io/2017/03/20/Markdown语法笔记/","excerpt":"关于MarkdownMarkdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。","text":"关于MarkdownMarkdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 Markdown简单语法主要分为区块元素和区段元素。 区块元素1.段落和换行一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。 2.标题用#标识符表示12345# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题 显示如下： 一级标题 二级标题三级标题四级标题五级标题3.区块引用 在段落的第一行最前面加”&gt;” 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; 区块内也可以套用其他的 Markdown 语法，包括加粗、列表、代码区块等 1234&gt;如人以手，指月示人。彼人因指，当因看月。若复观指以为月体。此人岂唯亡失月轮，亦亡其指。何以故，以所标指为明目故，岂唯亡指，亦复不识明之与暗。何以故，即以指体，为月明性，明暗二性，无所了故。&gt;&gt; 《楞严经》 显示如下： 如人以手，指月示人。彼人因指，当因看月。若复观指以为月体。此人岂唯亡失月轮，亦亡其指。何以故，以所标指为明目故，岂唯亡指，亦复不识明之与暗。何以故，即以指体，为月明性，明暗二性，无所了故。 《楞严经》 4.列表有序列表和无序列表 无序列表使用星号、加号或是减号作为列表标记 123* 星号+ 加号- 减号 显示如下： 星号 加号 减号 有序列表则使用数字接着一个英文句点 121. 第一2. 第二 显示如下： 第一 第二 5.代码区块要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以1代码区块 显示如下： 代码区块 6.分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。1*** 1--- 1* * * 区段元素1.链接方块括号后面紧接着圆括号并插入网址链接即可1[我的博客地址](https://jigangduan.github.io) 我的博客地址 2.强调12*强调*_强调_ 强调_强调_1**粗体** 粗体1~~删除线~~ 删除线 空格 Markdown语法会忽略首行开头的空格，如果要体现出首行开头空两个的效果，可以使用 全角符号下的空格 ，windows下使用 shift+空格 切换。 3.行内标记行内标记用反引号把它包起来’ ‘ 4.插入图片1![天黑黑](URL) 反斜杠Markdown可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠 自动邮箱链接Markdown支持以比较简短的自动链接形式来处理电子邮件信箱1&lt;jigang.duan@tcl.com&gt; &#106;&#105;&#103;&#x61;&#x6e;&#x67;&#x2e;&#100;&#x75;&#97;&#x6e;&#64;&#x74;&#x63;&#108;&#46;&#x63;&#111;&#109; 正文1. 内容目录使用[TOC]引用目录 备注： 有一些编辑器不支持[TOC]标记,比如我使用的Atom 2. 加强代码块使用``` + 语言名称 进行标记12345678``` swift// MARK: - Date componentextension Date &#123; var year: Int &#123; return Calendar.current.component(.year, from: self) &#125;&#125; 12345678910显示如下：``` swift// MARK: - Date componentextension Date &#123; var year: Int &#123; return Calendar.current.component(.year, from: self) &#125;&#125; 3. 脚注备注：关于注脚好像每个编辑器表示方式会有所不用 4.标签和分类一般在文首输入tags添加标签，categories添加分类123456tags:- Markdown- 语言categories:- 技术 5. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表 6.表格1234|表头| 1 | 2 || -- | --: | :--: || a | a1 | a2 || b | b1 | b2 | 表头 1 2 a a1 a2 b b1 b2 7.流程图和时序图 流程图 时序图 8. LaTeX 公式参考wowubuntu.com/markdown","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://jigangduan.github.io/tags/markdown/"}]},{"title":"安利","slug":"安利","date":"2017-03-20T04:19:54.000Z","updated":"2020-07-25T02:57:18.235Z","comments":true,"path":"2017/03/20/安利/","link":"","permalink":"https://jigangduan.github.io/2017/03/20/安利/","excerpt":"","text":"GitBook 搜索伯乐在线 githubgithub排名github搜索图灵社区 GitHub 上有哪些值得推荐的开源电子书？ 编程类开放书籍荟萃 GUI应用程序架构的十年变迁:MVC,MVP,MVVM,Unidirectional,Clean iOSSwiftSwiftGG走心的 Swift 翻译组 Swift 学习指引 开发者的第一份 Swift 语言中文学习指南 Swift 语言指南这份指南汇集了 Swift 语言主流学习资源，并以开发者的视角整理编排。对于精选项目及文章，可直接访问《Swift 项目精选》和《Swift 文章精选》。还有开发者们自己维护的《Swift 开发者、项目、最佳实践》。当然也不能错过那些活跃、优秀的《开发者个人资料页》 动画 iOS Core Animation: Advanced Techniques中文译本 A-GUIDE-TO-iOS-ANIMATION Quartz2D 编程指南 工具 CocoaPods使用指南 第三方库 Swift 有哪些优秀的第三方库？ Swift 开源项目精选 awesome-swift Awesome-Swift-Education awesome-ios - ( ゜- ゜)つロ Github-iOS备忘 TimLiu-iOS iOS开发常用三方库、插件、知名博客等等 iOS开源库 有些挺老的了 open-source-ios-apps 盘点国内程序员不常用的热门iOS第三方库:看完,还敢自称”精通iOS开发”吗? R.swift 仿Android资源文件使用 SnapKit 自动布局 SwiftyBeaver Log Moya + ObjectMapper + RxSwift RxSwift Observable RxCocoa/RxDataSources Realm 数据库 Kingfisher 图片下载和缓存库，取代 SDWebImage [IQKeyboardManager] 避免键盘遮挡下方输入框 [DZNEmptyDataSet] 空白页或者出错页封装 OAuthSwift 基于Swift的 OAuth 库 [MJRefresh] 下拉刷新 [AFImageHelper] Image 扩展库 [SVPulsingAnnotationView] Map Annotion View FSCalendar 日历视图 Android Android官方培训课程中文版 创建使用Material Design的应用 Kotlinkotlin-examples 第三方库 TimLiu-Android 总结的Android开源项目及库 前端 前端工程师手册 廖雪峰 教程 JavaScript教程 React React 中文索引 React 入门教程 React-Native学习指南 React Native 中文网 reactnativecn github Redux 中文文档 前端开发 TypeScript Handbook（中文版） 微信小程序 官网 微信小程序（应用号）开发工具+Demo+教程 后端Java并发编程网 - ifeve.com Java后端书架 Spring Cloud中国社区 Node.jsNode.js 新手入门 - CNode技术社区 Node入门 深入浅出Node NVM使用nvm安装管理多个版本的node.js(适用于Mac和Windows系统) Expressz基于 Node.js 平台，快速、开放、极简的 web 开发框架。 Rx 官网 ReactiveX文档中文翻译 RxSwift GitHub RxMarbles RxSwift 学习指导 RxSwift入坑解读-你所需要知道的各种概 RxSwift入坑解读-那些难以理解的细节 RxSwift实战教程-核心用法 PHPSymfony symfonychina ZF2 菜菜鸟Zend Framework 2 不完全学习涂鸦 Python 廖雪峰 教程 Python教程 Python爬虫学习系列教程 工具 Markdown语法说明 版本管理Git 廖雪峰 教程 Git教程 GitHub JetBrains blogNEW LIFE CLAN Eliyar’s Blog Coding I as limboy 胡凯 Android Huewan 关注但不限于 Android、iOS、nodejs","categories":[],"tags":[]}],"categories":[{"name":"Numpy","slug":"Numpy","permalink":"https://jigangduan.github.io/categories/Numpy/"},{"name":"Python","slug":"Numpy/Python","permalink":"https://jigangduan.github.io/categories/Numpy/Python/"},{"name":"Crawler","slug":"Crawler","permalink":"https://jigangduan.github.io/categories/Crawler/"},{"name":"Python","slug":"Crawler/Python","permalink":"https://jigangduan.github.io/categories/Crawler/Python/"},{"name":"K.K 音標","slug":"K-K-音標","permalink":"https://jigangduan.github.io/categories/K-K-音標/"},{"name":"英语","slug":"K-K-音標/英语","permalink":"https://jigangduan.github.io/categories/K-K-音標/英语/"},{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/categories/SQL/"},{"name":"SQL语句","slug":"SQL/SQL语句","permalink":"https://jigangduan.github.io/categories/SQL/SQL语句/"},{"name":"笔记","slug":"笔记","permalink":"https://jigangduan.github.io/categories/笔记/"},{"name":"推荐","slug":"笔记/推荐","permalink":"https://jigangduan.github.io/categories/笔记/推荐/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"https://jigangduan.github.io/categories/虚拟环境/"},{"name":"Python","slug":"虚拟环境/Python","permalink":"https://jigangduan.github.io/categories/虚拟环境/Python/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jigangduan.github.io/categories/Node-js/"},{"name":"Web","slug":"Node-js/Web","permalink":"https://jigangduan.github.io/categories/Node-js/Web/"},{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/categories/golang/"},{"name":"文档","slug":"文档","permalink":"https://jigangduan.github.io/categories/文档/"},{"name":"Java","slug":"Java","permalink":"https://jigangduan.github.io/categories/Java/"},{"name":"高并发","slug":"Java/高并发","permalink":"https://jigangduan.github.io/categories/Java/高并发/"},{"name":"Spring Cloud Alibaba","slug":"Spring-Cloud-Alibaba","permalink":"https://jigangduan.github.io/categories/Spring-Cloud-Alibaba/"},{"name":"Spring Cloud","slug":"Spring-Cloud-Alibaba/Spring-Cloud","permalink":"https://jigangduan.github.io/categories/Spring-Cloud-Alibaba/Spring-Cloud/"},{"name":"Spring","slug":"Spring-Cloud-Alibaba/Spring-Cloud/Spring","permalink":"https://jigangduan.github.io/categories/Spring-Cloud-Alibaba/Spring-Cloud/Spring/"},{"name":"React","slug":"React","permalink":"https://jigangduan.github.io/categories/React/"},{"name":"React 解析","slug":"React/React-解析","permalink":"https://jigangduan.github.io/categories/React/React-解析/"},{"name":"MySQL","slug":"MySQL","permalink":"https://jigangduan.github.io/categories/MySQL/"},{"name":"MySQL 笔记","slug":"MySQL/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL-笔记/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://jigangduan.github.io/categories/VS-Code/"},{"name":"MySQL 笔记","slug":"VS-Code/MySQL-笔记","permalink":"https://jigangduan.github.io/categories/VS-Code/MySQL-笔记/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://jigangduan.github.io/categories/前端/CSS/"},{"name":"CSS讲解","slug":"前端/CSS/CSS讲解","permalink":"https://jigangduan.github.io/categories/前端/CSS/CSS讲解/"},{"name":"学习CSS布局","slug":"前端/CSS/学习CSS布局","permalink":"https://jigangduan.github.io/categories/前端/CSS/学习CSS布局/"},{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/categories/工具/"},{"name":"GitHub精选","slug":"golang/GitHub精选","permalink":"https://jigangduan.github.io/categories/golang/GitHub精选/"},{"name":"Python","slug":"Python","permalink":"https://jigangduan.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"https://jigangduan.github.io/categories/Python/Django/"},{"name":"Django入门指南","slug":"Python/Django/Django入门指南","permalink":"https://jigangduan.github.io/categories/Python/Django/Django入门指南/"},{"name":"JSON API","slug":"JSON-API","permalink":"https://jigangduan.github.io/categories/JSON-API/"},{"name":"规范","slug":"JSON-API/规范","permalink":"https://jigangduan.github.io/categories/JSON-API/规范/"},{"name":"实例","slug":"实例","permalink":"https://jigangduan.github.io/categories/实例/"},{"name":"GitHub精选","slug":"前端/GitHub精选","permalink":"https://jigangduan.github.io/categories/前端/GitHub精选/"},{"name":"Android","slug":"Android","permalink":"https://jigangduan.github.io/categories/Android/"},{"name":"Android Jetpack","slug":"Android/Android-Jetpack","permalink":"https://jigangduan.github.io/categories/Android/Android-Jetpack/"},{"name":"GitHub 精选","slug":"Android/Android-Jetpack/GitHub-精选","permalink":"https://jigangduan.github.io/categories/Android/Android-Jetpack/GitHub-精选/"},{"name":"Kafka","slug":"Kafka","permalink":"https://jigangduan.github.io/categories/Kafka/"},{"name":"Kafka并不难学","slug":"Kafka/Kafka并不难学","permalink":"https://jigangduan.github.io/categories/Kafka/Kafka并不难学/"},{"name":"Spring","slug":"Spring","permalink":"https://jigangduan.github.io/categories/Spring/"},{"name":"Spring Boot","slug":"Spring/Spring-Boot","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/"},{"name":"精髓","slug":"Spring/Spring-Boot/精髓","permalink":"https://jigangduan.github.io/categories/Spring/Spring-Boot/精髓/"},{"name":"ORY编辑器","slug":"React/ORY编辑器","permalink":"https://jigangduan.github.io/categories/React/ORY编辑器/"},{"name":"第三方库","slug":"React/第三方库","permalink":"https://jigangduan.github.io/categories/React/第三方库/"},{"name":"GitHub精选","slug":"GitHub精选","permalink":"https://jigangduan.github.io/categories/GitHub精选/"},{"name":"Kafka微服务","slug":"Kafka/Kafka微服务","permalink":"https://jigangduan.github.io/categories/Kafka/Kafka微服务/"},{"name":"IoT","slug":"IoT","permalink":"https://jigangduan.github.io/categories/IoT/"},{"name":"消息队列","slug":"IoT/消息队列","permalink":"https://jigangduan.github.io/categories/IoT/消息队列/"},{"name":"shell","slug":"shell","permalink":"https://jigangduan.github.io/categories/shell/"},{"name":"oh-my-zsh","slug":"shell/oh-my-zsh","permalink":"https://jigangduan.github.io/categories/shell/oh-my-zsh/"},{"name":"SQL Server","slug":"VS-Code/SQL-Server","permalink":"https://jigangduan.github.io/categories/VS-Code/SQL-Server/"},{"name":"编写自己的Yeoman生成器","slug":"Node-js/编写自己的Yeoman生成器","permalink":"https://jigangduan.github.io/categories/Node-js/编写自己的Yeoman生成器/"},{"name":"插件","slug":"VS-Code/插件","permalink":"https://jigangduan.github.io/categories/VS-Code/插件/"},{"name":"开发范例代码大全","slug":"Spring/开发范例代码大全","permalink":"https://jigangduan.github.io/categories/Spring/开发范例代码大全/"},{"name":"CAS企业单点登录","slug":"Spring/CAS企业单点登录","permalink":"https://jigangduan.github.io/categories/Spring/CAS企业单点登录/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jigangduan.github.io/categories/JavaScript/"},{"name":"Pixi.js","slug":"JavaScript/Pixi-js","permalink":"https://jigangduan.github.io/categories/JavaScript/Pixi-js/"},{"name":"WebAPP","slug":"前端/WebAPP","permalink":"https://jigangduan.github.io/categories/前端/WebAPP/"},{"name":"Go微服务","slug":"golang/Go微服务","permalink":"https://jigangduan.github.io/categories/golang/Go微服务/"},{"name":"Redis","slug":"Redis","permalink":"https://jigangduan.github.io/categories/Redis/"},{"name":"数据库","slug":"Redis/数据库","permalink":"https://jigangduan.github.io/categories/Redis/数据库/"},{"name":"go-micro","slug":"golang/go-micro","permalink":"https://jigangduan.github.io/categories/golang/go-micro/"},{"name":"React Native","slug":"React/React-Native","permalink":"https://jigangduan.github.io/categories/React/React-Native/"},{"name":"Expo","slug":"React/React-Native/Expo","permalink":"https://jigangduan.github.io/categories/React/React-Native/Expo/"},{"name":"iOS","slug":"iOS","permalink":"https://jigangduan.github.io/categories/iOS/"},{"name":"iOS第三方库","slug":"iOS/iOS第三方库","permalink":"https://jigangduan.github.io/categories/iOS/iOS第三方库/"},{"name":"PHP","slug":"PHP","permalink":"https://jigangduan.github.io/categories/PHP/"},{"name":"Symfony","slug":"PHP/Symfony","permalink":"https://jigangduan.github.io/categories/PHP/Symfony/"},{"name":"电商","slug":"PHP/Symfony/电商","permalink":"https://jigangduan.github.io/categories/PHP/Symfony/电商/"},{"name":"预研","slug":"Android/预研","permalink":"https://jigangduan.github.io/categories/Android/预研/"},{"name":"逆向","slug":"Android/逆向","permalink":"https://jigangduan.github.io/categories/Android/逆向/"},{"name":"MySQL简单操作","slug":"MySQL/MySQL简单操作","permalink":"https://jigangduan.github.io/categories/MySQL/MySQL简单操作/"},{"name":"Browser Plugin","slug":"Android/Browser-Plugin","permalink":"https://jigangduan.github.io/categories/Android/Browser-Plugin/"},{"name":"包管理器","slug":"包管理器","permalink":"https://jigangduan.github.io/categories/包管理器/"},{"name":"包管理器","slug":"iOS/包管理器","permalink":"https://jigangduan.github.io/categories/iOS/包管理器/"},{"name":"Android 自动化测试","slug":"Android/Android-自动化测试","permalink":"https://jigangduan.github.io/categories/Android/Android-自动化测试/"},{"name":"Android架构组件","slug":"Android/Android架构组件","permalink":"https://jigangduan.github.io/categories/Android/Android架构组件/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://jigangduan.github.io/categories/Kotlin/"},{"name":"Anko","slug":"Kotlin/Anko","permalink":"https://jigangduan.github.io/categories/Kotlin/Anko/"},{"name":"ADB","slug":"Android/ADB","permalink":"https://jigangduan.github.io/categories/Android/ADB/"},{"name":"NDK","slug":"Android/NDK","permalink":"https://jigangduan.github.io/categories/Android/NDK/"},{"name":"读书笔记","slug":"Android/读书笔记","permalink":"https://jigangduan.github.io/categories/Android/读书笔记/"},{"name":"App研发录","slug":"Android/读书笔记/App研发录","permalink":"https://jigangduan.github.io/categories/Android/读书笔记/App研发录/"},{"name":"Swift","slug":"iOS/Swift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/"},{"name":"RxSwift","slug":"iOS/Swift/RxSwift","permalink":"https://jigangduan.github.io/categories/iOS/Swift/RxSwift/"},{"name":"架构设计","slug":"iOS/架构设计","permalink":"https://jigangduan.github.io/categories/iOS/架构设计/"},{"name":"TCLMOVE","slug":"iOS/架构设计/TCLMOVE","permalink":"https://jigangduan.github.io/categories/iOS/架构设计/TCLMOVE/"},{"name":"幻灯片","slug":"前端/幻灯片","permalink":"https://jigangduan.github.io/categories/前端/幻灯片/"},{"name":"Android优化","slug":"Android/Android优化","permalink":"https://jigangduan.github.io/categories/Android/Android优化/"},{"name":"第三方库","slug":"Java/第三方库","permalink":"https://jigangduan.github.io/categories/Java/第三方库/"},{"name":"Android 用户界面的最佳实践","slug":"Android/Android-用户界面的最佳实践","permalink":"https://jigangduan.github.io/categories/Android/Android-用户界面的最佳实践/"},{"name":"包管理器","slug":"Python/包管理器","permalink":"https://jigangduan.github.io/categories/Python/包管理器/"},{"name":"指南","slug":"Spring/指南","permalink":"https://jigangduan.github.io/categories/Spring/指南/"},{"name":"顾城","slug":"顾城","permalink":"https://jigangduan.github.io/categories/顾城/"},{"name":"模板引擎","slug":"前端/模板引擎","permalink":"https://jigangduan.github.io/categories/前端/模板引擎/"}],"tags":[{"name":"python","slug":"python","permalink":"https://jigangduan.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://jigangduan.github.io/tags/numpy/"},{"name":"爬虫","slug":"爬虫","permalink":"https://jigangduan.github.io/tags/爬虫/"},{"name":"K.K 音標","slug":"K-K-音標","permalink":"https://jigangduan.github.io/tags/K-K-音標/"},{"name":"SQL","slug":"SQL","permalink":"https://jigangduan.github.io/tags/SQL/"},{"name":"推荐","slug":"推荐","permalink":"https://jigangduan.github.io/tags/推荐/"},{"name":"javascript","slug":"javascript","permalink":"https://jigangduan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://jigangduan.github.io/tags/nodejs/"},{"name":"golang","slug":"golang","permalink":"https://jigangduan.github.io/tags/golang/"},{"name":"文档","slug":"文档","permalink":"https://jigangduan.github.io/tags/文档/"},{"name":"java","slug":"java","permalink":"https://jigangduan.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://jigangduan.github.io/tags/spring/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://jigangduan.github.io/tags/spring-cloud/"},{"name":"nacos","slug":"nacos","permalink":"https://jigangduan.github.io/tags/nacos/"},{"name":"前端","slug":"前端","permalink":"https://jigangduan.github.io/tags/前端/"},{"name":"reactjs","slug":"reactjs","permalink":"https://jigangduan.github.io/tags/reactjs/"},{"name":"mysql","slug":"mysql","permalink":"https://jigangduan.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://jigangduan.github.io/tags/sql/"},{"name":"css","slug":"css","permalink":"https://jigangduan.github.io/tags/css/"},{"name":"工具","slug":"工具","permalink":"https://jigangduan.github.io/tags/工具/"},{"name":"linux","slug":"linux","permalink":"https://jigangduan.github.io/tags/linux/"},{"name":"django","slug":"django","permalink":"https://jigangduan.github.io/tags/django/"},{"name":"api","slug":"api","permalink":"https://jigangduan.github.io/tags/api/"},{"name":"实例","slug":"实例","permalink":"https://jigangduan.github.io/tags/实例/"},{"name":"github","slug":"github","permalink":"https://jigangduan.github.io/tags/github/"},{"name":"android","slug":"android","permalink":"https://jigangduan.github.io/tags/android/"},{"name":"jetpack","slug":"jetpack","permalink":"https://jigangduan.github.io/tags/jetpack/"},{"name":"kafka","slug":"kafka","permalink":"https://jigangduan.github.io/tags/kafka/"},{"name":"maps","slug":"maps","permalink":"https://jigangduan.github.io/tags/maps/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://jigangduan.github.io/tags/spring-boot/"},{"name":"httpie","slug":"httpie","permalink":"https://jigangduan.github.io/tags/httpie/"},{"name":"editor","slug":"editor","permalink":"https://jigangduan.github.io/tags/editor/"},{"name":"sites","slug":"sites","permalink":"https://jigangduan.github.io/tags/sites/"},{"name":"blog","slug":"blog","permalink":"https://jigangduan.github.io/tags/blog/"},{"name":"oos","slug":"oos","permalink":"https://jigangduan.github.io/tags/oos/"},{"name":"minio","slug":"minio","permalink":"https://jigangduan.github.io/tags/minio/"},{"name":"翻译","slug":"翻译","permalink":"https://jigangduan.github.io/tags/翻译/"},{"name":"iot","slug":"iot","permalink":"https://jigangduan.github.io/tags/iot/"},{"name":"mq","slug":"mq","permalink":"https://jigangduan.github.io/tags/mq/"},{"name":"paas","slug":"paas","permalink":"https://jigangduan.github.io/tags/paas/"},{"name":"shell","slug":"shell","permalink":"https://jigangduan.github.io/tags/shell/"},{"name":"vscode","slug":"vscode","permalink":"https://jigangduan.github.io/tags/vscode/"},{"name":"sql-server","slug":"sql-server","permalink":"https://jigangduan.github.io/tags/sql-server/"},{"name":"yeoman","slug":"yeoman","permalink":"https://jigangduan.github.io/tags/yeoman/"},{"name":"extension","slug":"extension","permalink":"https://jigangduan.github.io/tags/extension/"},{"name":"单点登录","slug":"单点登录","permalink":"https://jigangduan.github.io/tags/单点登录/"},{"name":"pixijs","slug":"pixijs","permalink":"https://jigangduan.github.io/tags/pixijs/"},{"name":"游戏","slug":"游戏","permalink":"https://jigangduan.github.io/tags/游戏/"},{"name":"hexi","slug":"hexi","permalink":"https://jigangduan.github.io/tags/hexi/"},{"name":"webapp","slug":"webapp","permalink":"https://jigangduan.github.io/tags/webapp/"},{"name":"go-micro","slug":"go-micro","permalink":"https://jigangduan.github.io/tags/go-micro/"},{"name":"redis","slug":"redis","permalink":"https://jigangduan.github.io/tags/redis/"},{"name":"react-native","slug":"react-native","permalink":"https://jigangduan.github.io/tags/react-native/"},{"name":"expo","slug":"expo","permalink":"https://jigangduan.github.io/tags/expo/"},{"name":"ios","slug":"ios","permalink":"https://jigangduan.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://jigangduan.github.io/tags/swift/"},{"name":"php","slug":"php","permalink":"https://jigangduan.github.io/tags/php/"},{"name":"symfony","slug":"symfony","permalink":"https://jigangduan.github.io/tags/symfony/"},{"name":"电商","slug":"电商","permalink":"https://jigangduan.github.io/tags/电商/"},{"name":"逆向","slug":"逆向","permalink":"https://jigangduan.github.io/tags/逆向/"},{"name":"反编译","slug":"反编译","permalink":"https://jigangduan.github.io/tags/反编译/"},{"name":"jvm","slug":"jvm","permalink":"https://jigangduan.github.io/tags/jvm/"},{"name":"cocoapods","slug":"cocoapods","permalink":"https://jigangduan.github.io/tags/cocoapods/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://jigangduan.github.io/tags/自动化测试/"},{"name":"架构设计","slug":"架构设计","permalink":"https://jigangduan.github.io/tags/架构设计/"},{"name":"kotlin","slug":"kotlin","permalink":"https://jigangduan.github.io/tags/kotlin/"},{"name":"kotlinx.coroutines","slug":"kotlinx-coroutines","permalink":"https://jigangduan.github.io/tags/kotlinx-coroutines/"},{"name":"anko","slug":"anko","permalink":"https://jigangduan.github.io/tags/anko/"},{"name":"adb","slug":"adb","permalink":"https://jigangduan.github.io/tags/adb/"},{"name":"ndk","slug":"ndk","permalink":"https://jigangduan.github.io/tags/ndk/"},{"name":"notes","slug":"notes","permalink":"https://jigangduan.github.io/tags/notes/"},{"name":"app","slug":"app","permalink":"https://jigangduan.github.io/tags/app/"},{"name":"rxswift","slug":"rxswift","permalink":"https://jigangduan.github.io/tags/rxswift/"},{"name":"atom","slug":"atom","permalink":"https://jigangduan.github.io/tags/atom/"},{"name":"idea","slug":"idea","permalink":"https://jigangduan.github.io/tags/idea/"},{"name":"uml","slug":"uml","permalink":"https://jigangduan.github.io/tags/uml/"},{"name":"ppt","slug":"ppt","permalink":"https://jigangduan.github.io/tags/ppt/"},{"name":"android-ui","slug":"android-ui","permalink":"https://jigangduan.github.io/tags/android-ui/"},{"name":"诗","slug":"诗","permalink":"https://jigangduan.github.io/tags/诗/"},{"name":"顾城","slug":"顾城","permalink":"https://jigangduan.github.io/tags/顾城/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://jigangduan.github.io/tags/模板引擎/"},{"name":"markdown","slug":"markdown","permalink":"https://jigangduan.github.io/tags/markdown/"}]}