<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>kotlinx.coroutines入门指南示例 | 朝着牛逼的道路一路狂奔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="androidkotlinkotlinx.coroutines">
  
  
  
  
  <meta name="description" content="这是一个关于kotlinx.coroutines核心特性的简短指南，有一系列的例子。 介绍和设置作为一种语言，Kotlin在其标准库中只提供了最低限度的低级api，以使各种其他库能够利用这些库。与其他具有类似功能的语言不同，async和await在Kotlin中不是关键字，甚至都不是它的标准库的一部分。 kotlinx.coroutines是一个如此丰富的库。它包含了许多高级的可支持内核的原语，">
<meta name="keywords" content="android,kotlin,kotlinx.coroutines">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlinx.coroutines入门指南示例">
<meta property="og:url" content="https://jigangduan.github.io/2017/11/06/GuideToKotlinxCoroutinesByExample/index.html">
<meta property="og:site_name" content="朝着牛逼的道路一路狂奔">
<meta property="og:description" content="这是一个关于kotlinx.coroutines核心特性的简短指南，有一系列的例子。 介绍和设置作为一种语言，Kotlin在其标准库中只提供了最低限度的低级api，以使各种其他库能够利用这些库。与其他具有类似功能的语言不同，async和await在Kotlin中不是关键字，甚至都不是它的标准库的一部分。 kotlinx.coroutines是一个如此丰富的库。它包含了许多高级的可支持内核的原语，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/831804/201603/831804-20160323231701386-1892583268.png">
<meta property="og:updated_time" content="2020-07-25T02:57:18.152Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kotlinx.coroutines入门指南示例">
<meta name="twitter:description" content="这是一个关于kotlinx.coroutines核心特性的简短指南，有一系列的例子。 介绍和设置作为一种语言，Kotlin在其标准库中只提供了最低限度的低级api，以使各种其他库能够利用这些库。与其他具有类似功能的语言不同，async和await在Kotlin中不是关键字，甚至都不是它的标准库的一部分。 kotlinx.coroutines是一个如此丰富的库。它包含了许多高级的可支持内核的原语，">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/831804/201603/831804-20160323231701386-1892583268.png">
  
    <link rel="alternate" href="/atom.xml" title="朝着牛逼的道路一路狂奔" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css">
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-GuideToKotlinxCoroutinesByExample" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      kotlinx.coroutines入门指南示例
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/11/06/GuideToKotlinxCoroutinesByExample/" class="article-date">
	  <time datetime="2017-11-06T11:01:27.000Z" itemprop="datePublished">2017-11-06</time>
	</a>

      
    <a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://images2015.cnblogs.com/blog/831804/201603/831804-20160323231701386-1892583268.png" alt="kotlin"></p>
<p>这是一个关于kotlinx.coroutines核心特性的简短指南，有一系列的例子。</p>
<h2 id="介绍和设置"><a href="#介绍和设置" class="headerlink" title="介绍和设置"></a>介绍和设置</h2><p>作为一种语言，Kotlin在其标准库中只提供了最低限度的低级api，以使各种其他库能够利用这些库。<br>与其他具有类似功能的语言不同，<code>async</code>和<code>await</code>在Kotlin中不是关键字，甚至都不是它的标准库的一部分。</p>
<p>kotlinx.coroutines是一个如此丰富的库。<br>它包含了许多高级的可支持内核的原语，包括<code>async</code>和<code>await</code>。<br>您需要添加对<code>kotlinx-coroutines-core</code>模块的依赖，<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects" target="_blank" rel="noopener">这是</a>在您的项目中使用本指南中的基础。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#coroutine_basics">协程基础</a><ul>
<li><a href="#your_first_coroutine">你的第一个协程</a></li>
<li><a href="#bridging_blocking_nonblocking_worlds">桥接阻塞和非阻塞的世界</a></li>
<li><a href="#waiting_for_job">等待job</a></li>
<li><a href="#extract_function_refactoring">提取函数重构</a></li>
<li><a href="#coroutines_are_light_weight">协程是轻量级的</a></li>
<li><a href="#coroutines_like_daemon_threads">协程就像守护线程</a></li>
</ul>
</li>
<li><a href="#cancellation_timeouts">取消和超时</a><ul>
<li><a href="#cancelling_coroutine_execution">取消协程执行</a></li>
<li><a href="#cancellation_cooperative">取消是需要协作的</a></li>
<li><a href="#making_computation_code_cancellable">使计算代码可取消</a></li>
<li><a href="#closing_resources_with_finally">在finally关闭资源</a></li>
<li><a href="#run_noncancellable_block">运行不可取消块</a></li>
<li><a href="#timeout">超时</a></li>
</ul>
</li>
<li><a href="#composing_suspending_functions">组织挂起函数</a><ul>
<li><a href="#sequential_default">默认顺序</a></li>
<li><a href="#concurrent_using_async">使用async并发</a></li>
<li><a href="#lazily_started_async">懒启动async</a></li>
<li><a href="#async_style_functions">异步式函数</a></li>
</ul>
</li>
<li><a href="#coroutine_context_dispatchers">协程context和分派器</a><ul>
<li><a href="#dispatchers_threads">分派器和线程</a></li>
<li><a href="#unconfined_vs_confined_dispatcher">非限制 vs 限制 分派器</a></li>
<li><a href="#debugging_coroutines_threads">调试协程和线程</a></li>
<li><a href="#jumping_between_threads">线程之间跳转</a></li>
<li><a href="#job_context">context中的job</a></li>
<li><a href="#children_of_a_coroutine">子协程</a></li>
<li><a href="#combining_contexts">结合contexts</a></li>
<li><a href="#parental_responsibilities">父协程责任</a></li>
<li><a href="#naming_coroutines_debugging">命名协程的调试</a></li>
<li><a href="#cancellation_via_explicit_job">取消显式工作</a></li>
</ul>
</li>
<li><a href="#channels">通道</a><ul>
<li><a href="#channel_basics">通道基础知识</a></li>
<li><a href="#closing_iteration_over_channels">通道的关闭和迭代</a></li>
<li><a href="#building_channel_producers">构建通道生成器</a></li>
<li><a href="#pipelines">管道</a></li>
<li><a href="#prime_numbers_pipeline">用管道求素数</a></li>
<li><a href="#Fan-out">扇出</a></li>
<li><a href="#Fan-in">扇入</a></li>
<li><a href="#buffered_channels">缓冲通道</a></li>
<li><a href="#channels_fair">通道是公平的</a></li>
</ul>
</li>
<li><a href="#shared_mutable_state_concurrency">共享的可变状态和并发性</a><ul>
<li><a href="#the_problem">这个问题</a></li>
<li><a href="#volatiles-are-of-no-help">Volatiles毫无用处</a></li>
<li><a href="#thread_safe_data_structures">线程安全的数据结构</a></li>
<li><a href="#thread_confinement_fine_grained">细粒度线程约束</a></li>
<li><a href="#thread_confinement_coarse_grained">粗粒度线程约束</a></li>
<li><a href="#mutual_exclusion">Mutex</a></li>
<li><a href="#actors">参与者</a></li>
</ul>
</li>
<li><a href="#select_expression">Select表达式</a><ul>
<li><a href="#selecting_from_channels">选择通道</a></li>
<li><a href="#selecting_on_close">关闭时的select</a></li>
<li><a href="#selecting_to_send">选择发送</a></li>
<li><a href="#selecting_deferred_values">选择deferred值</a></li>
<li><a href="#switch_over_a_channel_of_deferred_values">切换到deferred值的通道</a></li>
</ul>
</li>
<li><a href="#further_reading">进一步的阅读</a></li>
</ul>
<a id="more"></a>
<h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a><a name="coroutine_basics"></a>协程基础</h2><p>本节介绍基本的协程概念。</p>
<h3 id="你的第一个协程"><a href="#你的第一个协程" class="headerlink" title="你的第一个协程"></a><a name="your_first_coroutine"></a>你的第一个协程</h3><p>运行下面的代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    launch &#123; <span class="comment">// 启动新协程</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// 非阻塞延迟1秒 (默认时间单位是ms)</span></span><br><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// 打印在延迟后</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 主函数继续，而协程延迟</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// 阻塞主线程2秒，以保持JVM的生命</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>运行这段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>
<p>本质上，协程是轻量的线程。<br>它们是由<code>launch</code> 协程构建器启动的。<br>你可以用同样的结果取代<code>launch { ... }</code>，用<code>thread { ... }</code> 和<code>delay(…)</code>，用Thread.sleep(…)。<br>试一试。</p>
<p>如果您开始用<code>thread</code>替换<code>launch</code>，编译器会产生以下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误:Kotlin:挂起函数只允许从一个协程或另一个挂起函数调用</span><br></pre></td></tr></table></figure>
<p>这是因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/delay.html" target="_blank" rel="noopener">delay</a>是一种特殊的挂起函数，它不会阻塞线程，而是挂起了协程，它只能在一个协程中使用。</p>
<h3 id="桥接阻塞和非阻塞的世界"><a href="#桥接阻塞和非阻塞的世界" class="headerlink" title="桥接阻塞和非阻塞的世界"></a><a name="bridging_blocking_nonblocking_worlds"></a>桥接阻塞和非阻塞的世界</h3><p>第一个例子混合了非阻塞<code>delay(...)</code>和阻塞<code>Thread.sleep(...)</code>在相同的mian代码中。<br>很容易迷路。<br>让我们通过使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a>来清楚地分离阻塞和非阻塞的世界。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// 开始主协程</span></span><br><span class="line">    launch &#123; <span class="comment">// 启动新协程</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// 当孩子被延迟时，主协程仍在继续</span></span><br><span class="line">    delay(<span class="number">2000L</span>) <span class="comment">// 非阻塞延迟2秒使JVM存活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>结果是一样的，但是这段代码只使用非阻塞的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/delay.html" target="_blank" rel="noopener">delay</a>。</p>
<p><code>runBlocking { ... }</code> 作为一个适配器，在这里使用它来启动顶级的主协程。<br>runBlocking块之外的常规代码,直到<code>runBlocking</code>内部的协程活跃。</p>
<p>这也是为挂起函数编写单元测试的一种方法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testMySuspendingFunction</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里我们可以使用任何我们喜欢的断言样式来使用挂起函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等待job"><a href="#等待job" class="headerlink" title="等待job"></a><a name="waiting_for_job"></a>等待job</h3><p>拖延一段时间，而另一种协程正在工作，这不是一种好方法。让我们明确地等待(以非阻塞方式)直到我们启动的后台任务完成:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123; <span class="comment">// 启动新的协程，并保持job的引用</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">"World!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>)</span><br><span class="line">    job.join() <span class="comment">// 等到孩子协程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>现在的结果仍然是相同的，但是主协程的代码并没有以任何方式与后台作业的持续时间相关联。<br>好多了。</p>
<h3 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a><a name="extract_function_refactoring"></a>提取函数重构</h3><p>让我们在<code>launch { ... }</code> 中提取代码块到一个单独的函数。<br>当您在这段代码中执行”Extract function”重构时，您将得到一个带有<code>suspend</code>修饰符的新函数。<br>这是你的第一个挂起函数。<br>挂起函数可以像普通函数一样在内部使用，但是它们的附加功能是，它们可以使用其他的挂起函数，比如这个例子中的<code>delay</code>，挂起执行的协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">"Hello,"</span>)</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是你的第一个挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">"World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<h3 id="协程是轻量级的"><a href="#协程是轻量级的" class="headerlink" title="协程是轻量级的"></a><a name="coroutines_are_light_weight"></a>协程是轻量级的</h3><p>运行下面的代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> jobs = List(<span class="number">100_000</span>) &#123; <span class="comment">// 启动大量的协程和他们的jobs列表</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            print(<span class="string">"."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.forEach &#123; it.join() &#125; <span class="comment">// 等待所有的jobs完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-basic-05.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它启动了100K的协程，一秒钟之后，每一个协程就会打印一个点。<br>现在，用线程来试一下。将会发生什么?(很可能你的代码会产生某种内存溢出错误)</p>
<h3 id="协程就像守护线程"><a href="#协程就像守护线程" class="headerlink" title="协程就像守护线程"></a><a name="coroutines_like_daemon_threads"></a>协程就像守护线程</h3><p>下面的代码启动了一个长时间运行的协程，它每秒打印两次”I’m sleeping”，然后在一些delay之后返回main函数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 在延迟之后退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以运行并看到它打印了三行并终止:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m sleeping 0 ...</span><br><span class="line">I&apos;m sleeping 1 ...</span><br><span class="line">I&apos;m sleeping 2 ...</span><br></pre></td></tr></table></figure>
<p>活跃的协程并不能使整个过程保持活跃。<br>它们就像守护进程线程。</p>
<hr>
<h2 id="取消和超时"><a href="#取消和超时" class="headerlink" title="取消和超时"></a><a name="cancellation_timeouts"></a>取消和超时</h2><p>本节介绍协程取消和超时。</p>
<h3 id="取消协程执行"><a href="#取消协程执行" class="headerlink" title="取消协程执行"></a><a name="cancelling_coroutine_execution"></a>取消协程执行</h3><p>在小应用程序中，”main”方法的返回听起来似乎是一个好主意，可以让所有的协程隐式终止。<br>在一个较大的、长期运行的应用程序中，您需要更细粒度的控制。<br>launch函数返回一个可以用来取消运行的协程的Job:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一点</span></span><br><span class="line">    println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">    job.cancel() <span class="comment">// 取消job</span></span><br><span class="line">    job.join() <span class="comment">// 等待job的完成</span></span><br><span class="line">    println(<span class="string">"main: Now I can quit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生以下输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m sleeping 0 ...</span><br><span class="line">I&apos;m sleeping 1 ...</span><br><span class="line">I&apos;m sleeping 2 ...</span><br><span class="line">main: I&apos;m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">只要main调用了`job.cancel`，我们看不到其他协程的输出，因为它被取消了。</span><br><span class="line">还有一个[Job](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html)扩展函数[cancelAndJoin](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/cancel-and-join.html)，它结合了[cancel](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/cancel.html)和[join](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/join.html)调用。</span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;cancellation_cooperative&quot;&gt;&lt;/a&gt;取消是需要协作的</span><br><span class="line"></span><br><span class="line">协程取消是需要协作的。</span><br><span class="line">一个取消的代码必须进行协作。</span><br><span class="line">所有的挂起函数在`kotlinx.coroutines`都是可取消的。</span><br><span class="line">他们检测协程的取消，取消时抛出[CancellationException](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception.html)。</span><br><span class="line">但是，如果一个协程正在计算并且没有检查取消，那么它就不能被取消，就像下面的例子所示:</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (i &lt; 5) &#123; // 循环计算，只是浪费CPU</span><br><span class="line">            // 每秒打印消息两次</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 延迟一点</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // 取消job并等待其完成</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>运行它，看它会继续打印”I’m sleeping”，即使是在取消之后，直到工作完成了五个迭代之后。</p>
<h3 id="使计算代码可取消"><a href="#使计算代码可取消" class="headerlink" title="使计算代码可取消"></a><a name="making_computation_code_cancellable"></a>使计算代码可取消</h3><p>有两种方法可以使计算代码可以被取消。<br>第一个是周期性地调用一个挂起函数来检查取消。<br><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/yield.html" target="_blank" rel="noopener">yield</a>函数是这个目的的一个很好的选择。<br>另一个是显式地检查取消状态。<br>让我们来试试后面的方法。</p>
<p>在前面的例子中用<code>while (isActive)</code>替换while (i &lt; 5)并重新运行它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123; <span class="comment">// 可取消的计算循环</span></span><br><span class="line">            <span class="comment">// 每秒打印消息两次</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">"I'm sleeping <span class="subst">$&#123;i++&#125;</span> ..."</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一点</span></span><br><span class="line">    println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消job并等待其完成</span></span><br><span class="line">    println(<span class="string">"main: Now I can quit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>可以看到，现在这个循环被取消了。<br><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/is-active.html" target="_blank" rel="noopener">isActive</a>是通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a>对象在协程代码中可用的属性。</p>
<h3 id="在finally关闭资源"><a href="#在finally关闭资源" class="headerlink" title=" 在finally关闭资源"></a><a name="closing_resources_with_finally"></a> 在finally关闭资源</h3><p>可取消的挂起函数在协程中抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception.html" target="_blank" rel="noopener">CancellationException</a>的地方可以用通常的方式来处理。<br>例如,<code>try {...} finally {…}</code> 表达式和Kotlin <code>use</code>函数执行它们的终结动作，当协程被取消时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">"I'm running finally"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一点</span></span><br><span class="line">    println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消job并等待其完成</span></span><br><span class="line">    println(<span class="string">"main: Now I can quit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/join.html" target="_blank" rel="noopener">join</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/cancel-and-join.html" target="_blank" rel="noopener">cancelAndJoin</a>等待所有的终结操作完成，因此上面的示例产生以下输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m sleeping 0 ...</span><br><span class="line">I&apos;m sleeping 1 ...</span><br><span class="line">I&apos;m sleeping 2 ...</span><br><span class="line">main: I&apos;m tired of waiting!</span><br><span class="line">I&apos;m running finally</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure>
<h3 id="运行不可取消块"><a href="#运行不可取消块" class="headerlink" title="运行不可取消块"></a><a name="run_noncancellable_block"></a>运行不可取消块</h3><p>在前一个示例的finally块中使用挂起函数的任何尝试都会导致CancellationException，因为运行该代码的协程被取消了。<br>通常，这不是问题，因为所有行为良好的关闭操作(关闭文件、取消job或关闭任何通信通道)通常是非阻塞的，并且不涉及任何挂起函数。<br>然而，在极少数情况下，当您需要在被取消的协程 挂起时，您可以将相应的代码打包在<code>run(NonCancellable) {...}</code>使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run.html" target="_blank" rel="noopener">run</a>函数和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-non-cancellable/index.html" target="_blank" rel="noopener">NonCancellable</a> context，如下面的示例所示:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            run(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">"I'm running finally"</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">"And I've just delayed for 1 sec because I'm non-cancellable"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// 延迟一点</span></span><br><span class="line">    println(<span class="string">"main: I'm tired of waiting!"</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消job并等待其完成</span></span><br><span class="line">    println(<span class="string">"main: Now I can quit."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-05.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a><a name="timeout"></a>超时</h3><p>在实践中取消协程执行的最明显的原因是它的执行时间超过了一些超时。<br>虽然您可以手动跟踪对应Job的引用，并启动一个单独的协程，以便在延迟之后取消跟踪，但是可以使用withTimeout函数来执行它。<br>请看下面的例子:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-06.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生以下输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m sleeping 0 ...</span><br><span class="line">I&apos;m sleeping 1 ...</span><br><span class="line">I&apos;m sleeping 2 ...</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.experimental.TimeoutCancellationException: Timed out waiting for 1300 MILLISECONDS</span><br></pre></td></tr></table></figure>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout.html" target="_blank" rel="noopener">withTimeout</a>抛出的<code>TimeoutCancellationException</code>是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-cancellation-exception.html" target="_blank" rel="noopener">CancellationException</a>的子类。<br>我们还没有看到它的堆栈跟踪在控制台上打印出来。<br>这是因为在被取消的协程里<code>CancellationException</code>被认为是一个正常的原因。<br>但是，在本例中，我们在<code>main</code>函数中使用了<code>withTimeout</code>。</p>
<p>因为取消只是一个异常，所有的资源都将以通常的方式关闭。<br>如果你需要在任何类型的超时上做一些额外的动作,您可以在<code>try {...} catch (e: TimeoutCancellationException) {...}</code>块中使用超时来包装代码,者使用类似于<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout.html" target="_blank" rel="noopener">withTimeout</a>的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/with-timeout-or-null.html" target="_blank" rel="noopener">withTimeoutOrNull</a>函数，但在超时时它返回null，而不是抛出异常：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">"I'm sleeping <span class="variable">$i</span> ..."</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"Done"</span> <span class="comment">// will get cancelled before it produces this result</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Result is <span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-cancel-07.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>运行这段代码时不再出现异常:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m sleeping 0 ...</span><br><span class="line">I&apos;m sleeping 1 ...</span><br><span class="line">I&apos;m sleeping 2 ...</span><br><span class="line">Result is null</span><br></pre></td></tr></table></figure>
<h2 id="组成挂起函数"><a href="#组成挂起函数" class="headerlink" title="组成挂起函数"></a><a name="composing_suspending_functions"></a>组成挂起函数</h2><p>这一节介绍了各种挂起函数的组成。</p>
<h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a><a name="sequential_default"></a>默认顺序</h3><p>假设我们在其他地方定义了两个挂起的函数，它们做一些有用的事情，比如远程服务调用或计算。<br>我们只是假装它们很有用，但实际上每一个都只是为了这个例子的目的延迟了一秒钟：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假装我们在做一些有用的事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假装我们在做一些有用的事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要按顺序调用它们，我们需要做什么?首先是<code>doSomethingUsefulOne</code>，然后是<code>doSomethingUsefulTwo</code>，然后计算它们的结果的总和?<br>在实践中，我们就会这样做，我们使用第一个函数的结果来决定是否需要调用第二个函数，或者决定如何调用它。</p>
<p>我们只是使用常规的顺序调用，因为在协程中的代码，就像常规代码一样，是默认的顺序。下面的例子通过测量执行两个挂起函数的总时间来演示它:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = doSomethingUsefulOne()</span><br><span class="line">        <span class="keyword">val</span> two = doSomethingUsefulTwo()</span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one + two&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生了这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The answer is 42</span><br><span class="line">Completed in 2017 ms</span><br></pre></td></tr></table></figure>
<h3 id="使用async并发"><a href="#使用async并发" class="headerlink" title="使用async并发"></a><a name="concurrent_using_async"></a>使用async并发</h3><p>如果在调用<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>之间没有依赖关系，并且我们希望通过同时执行这两种方法来获得更快的答案?这就是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a>提供帮助的地方。</p>
<p>在概念上，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a>就像<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" target="_blank" rel="noopener">launch</a>一样。<br>它启动了一个单独的协程，它是一个轻量的线程，它可以和所有其他的协同工作。<br>不同的是，<code>launch</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>，并且不带任何结果值，而<code>async</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/index.html" target="_blank" rel="noopener">Deferred</a>——一个轻量级的非阻塞future，它代表了稍后提供一个结果的承诺。<br>您可以使用.await()在一个<code>deferred</code>值上获得它的最终结果，但是<code>Deferred</code>也是一项<code>Job</code>，所以您可以在需要的时候取消它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生了这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The answer is 42</span><br><span class="line">Completed in 1017 ms</span><br></pre></td></tr></table></figure>
<p>速度是两倍，因为我们同时执行了两个协程。<br>注意，与协程的并发性总是很明显的。</p>
<h3 id="懒启动async"><a href="#懒启动async" class="headerlink" title="懒启动async"></a><a name="lazily_started_async"></a>懒启动async</h3><p>使用一个具有<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-start/-l-a-z-y.html" target="_blank" rel="noopener">CoroutineStart.LAZY</a>值的可选<code>start</code>参数，可以使用惰性选项来使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a>。<br>只有当某个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/await.html" target="_blank" rel="noopener">await</a>或某个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/start.html" target="_blank" rel="noopener">start</a>函数被调用时，它才会启动它的协程。<br>运行以下示例与之前的示例不同，仅通过此选项:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生了这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The answer is 42</span><br><span class="line">Completed in 2017 ms</span><br></pre></td></tr></table></figure>
<p>因此，我们回到了顺序执行，因为我们首先<code>start</code>和<code>await</code> <code>one</code>，然后是<code>two</code>。<br>它不是用于懒惰目的的用例。<br>当计算值涉及到挂起函数时，它被设计为替代标准的惰性函数。</p>
<h3 id="异步式函数"><a href="#异步式函数" class="headerlink" title="异步式函数"></a><a name="async_style_functions"></a>异步式函数</h3><p>我们可以定义异步式的函数，使用async协程构建器来异步调用<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>。<br>用”async”前缀来命名这样的函数是一种很好的方式，以强调它们只启动异步计算，并且需要使用产生的延迟值来获得结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asyncSomethingUsefulOne的结果类型是Deferred&lt;Int&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncSomethingUsefulOne</span><span class="params">()</span></span> = async &#123;</span><br><span class="line">    doSomethingUsefulOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncSomethingUsefulTwo的结果类型是Deferred&lt;Int&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncSomethingUsefulTwo</span><span class="params">()</span></span> = async &#123;</span><br><span class="line">    doSomethingUsefulTwo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这些<code>asyncXXX</code>函数<strong>不是</strong>挂起函数。它们可以在任何地方使用。<br>然而，它们的使用总是意味着对调用代码的异步(这里即并发)执行。</p>
<p>下面的例子展示了他们在协程外的使用:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，在本例中，我们没有将`runBlocking`放在`main`的右边</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="comment">// 我们可以在协程外启动异步操作</span></span><br><span class="line">        <span class="keyword">val</span> one = asyncSomethingUsefulOne()</span><br><span class="line">        <span class="keyword">val</span> two = asyncSomethingUsefulTwo()</span><br><span class="line">        <span class="comment">// 但是等待结果必须包括挂起或阻塞.</span></span><br><span class="line">        <span class="comment">// 这里我们在主线程使用`runBlocking &#123; ... &#125;`块等待结果</span></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            println(<span class="string">"The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-compose-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<h2 id="协程context和分派器"><a href="#协程context和分派器" class="headerlink" title="协程context和分派器"></a><a name="coroutine_context_dispatchers"></a>协程context和分派器</h2><p>协程总是在某些context中执行，这些context由<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/" target="_blank" rel="noopener">CoroutineContext</a>类型的值来表示，这是在Kotlin标准库中定义的。</p>
<p>协程context是一组不同的元素。<br>主要的元素是我们之前见过的协程的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>，以及它的分派器，它在这一节中介绍。</p>
<h3 id="分派器和线程"><a href="#分派器和线程" class="headerlink" title="分派器和线程"></a><a name="dispatchers_threads"></a>分派器和线程</h3><p>协程context包括一个协程分派器(请参阅<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-dispatcher/index.html" target="_blank" rel="noopener">CoroutineDispatcher</a>)，它决定了相应的协程执行的线程或线程的使用情况。<br>协程分派器可以将协程执行限制在特定的线程中，将其分派到线程池中，或者让它不受限制地运行。</p>
<p>像<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html" target="_blank" rel="noopener">launch</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html" target="_blank" rel="noopener">async</a>这样的构建器都可以接受一个可选的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/" target="_blank" rel="noopener">CoroutineContext</a>参数，该参数可用于显式地为新的协程和其他context元素指定分派器。</p>
<p>试试下面的例子:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> jobs = arrayListOf&lt;Job&gt;()</span><br><span class="line">    jobs += launch(Unconfined) &#123; <span class="comment">// 不受限制——将工作在主线程</span></span><br><span class="line">        println(<span class="string">"      'Unconfined': I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    jobs += launch(coroutineContext) &#123; <span class="comment">// 父ccontext，runBlocking 协程</span></span><br><span class="line">        println(<span class="string">"'coroutineContext': I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    jobs += launch(CommonPool) &#123; <span class="comment">// 将被分派到ForkJoinPool.commonPool(或同等的)</span></span><br><span class="line">        println(<span class="string">"      'CommonPool': I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    jobs += launch(newSingleThreadContext(<span class="string">"MyOwnThread"</span>)) &#123; <span class="comment">// 将得到它自己的新线程</span></span><br><span class="line">        println(<span class="string">"          'newSTC': I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.forEach &#123; it.join() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生以下输出(可能顺序不同):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      &apos;Unconfined&apos;: I&apos;m working in thread main</span><br><span class="line">      &apos;CommonPool&apos;: I&apos;m working in thread ForkJoinPool.commonPool-worker-1</span><br><span class="line">          &apos;newSTC&apos;: I&apos;m working in thread MyOwnThread</span><br><span class="line">&apos;coroutineContext&apos;: I&apos;m working in thread main</span><br></pre></td></tr></table></figure>
<p>我们在前面的部分中使用的缺省分派器是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-default-dispatcher.html" target="_blank" rel="noopener">DefaultDispatcher</a>，它等于当前实现中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/index.html" target="_blank" rel="noopener">CommonPool</a>。因此，<code>launch { ... }</code> 与<code>launch(DefaultDispather) { ... }</code>相同，与<code>launch(CommonPool) { ... }</code>相同。</p>
<p>稍后将显示<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/coroutine-context.html" target="_blank" rel="noopener">coroutineContext</a>父类与非约束<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-unconfined/index.html" target="_blank" rel="noopener">context</a>之间的区别</p>
<p>注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-single-thread-context.html" target="_blank" rel="noopener">newSingleThreadContext</a>创建了一个新的线程，这是一个非常昂贵的资源。在实际应用程序中，它必须在不再需要时释放，使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-thread-pool-dispatcher/close.html" target="_blank" rel="noopener">close</a>函数，或者存储在顶级变量中，并在整个应用程序中重用。</p>
<h3 id="非限制-vs-限制-分派器"><a href="#非限制-vs-限制-分派器" class="headerlink" title=" 非限制 vs 限制 分派器"></a><a name="unconfined_vs_confined_dispatcher"></a> 非限制 vs 限制 分派器</h3><p>非限制(<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-unconfined/index.html" target="_blank" rel="noopener">Unconfined</a>)的协程分派器在调用者线程中启动了协程，但直到第一个挂起点才开始。<br>挂起之后，它在被调用的挂起函数完全确定的线程中恢复。<br>当协程不消耗CPU时间或更新任何限制在特定线程的共享数据(如UI)时，非限制分派器是合适的。</p>
<p>另一方面，可以通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a>接口在任何协程的块中使用的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/coroutine-context.html" target="_blank" rel="noopener">coroutineContext</a>属性，是对这个特定的协程的context的引用。<br>通过这种方式，可以继承父context。<br>特别是，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a> 协程的缺省调度程序被限制在调用程序线程中，因此继承它的作用是将执行限制在这个线程中，并具有可预测的FIFO调度。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> jobs = arrayListOf&lt;Job&gt;()</span><br><span class="line">    jobs += launch(Unconfined) &#123; <span class="comment">// 不受限制——主要线程的工作</span></span><br><span class="line">        println(<span class="string">"      'Unconfined': I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">"      'Unconfined': After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    jobs += launch(coroutineContext) &#123; <span class="comment">// 父ccontext，runBlocking 协程</span></span><br><span class="line">        println(<span class="string">"'coroutineContext': I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">"'coroutineContext': After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.forEach &#123; it.join() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它产生以下输出(可能顺序不同):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      &apos;Unconfined&apos;: I&apos;m working in thread main</span><br><span class="line">&apos;coroutineContext&apos;: I&apos;m working in thread main</span><br><span class="line">      &apos;Unconfined&apos;: After delay in thread kotlinx.coroutines.DefaultExecutor</span><br><span class="line">&apos;coroutineContext&apos;: After delay in thread main</span><br></pre></td></tr></table></figure>
<p>因此，继承了runBlocking {…} 协程的coroutineContext 继续在主线程中执行，而未限制的线程则在默认的执行程序线程中恢复，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/delay.html" target="_blank" rel="noopener">delay</a>函数正在使用该线程。</p>
<h3 id="调试协程和线程"><a href="#调试协程和线程" class="headerlink" title="调试协程和线程"></a><a name="debugging_coroutines_threads"></a>调试协程和线程</h3><p>协程可以在一个线程上挂起，并在另一个线程上使用非限制(<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-unconfined/index.html" target="_blank" rel="noopener">Unconfined</a>)分派器或默认的多线程分派器。<br>即使是单线程的分派器，也很难弄清楚协程在做什么，在什么地方，什么时候做什么。<br>使用线程调试应用程序的常用方法是在每个日志语句的日志文件中打印线程名。这个特性得到了日志框架的广泛支持。<br>在使用协程时，线程名称本身并没有提供太多context，所以<code>kotlinx.coroutines</code>包括调试工具，使其更容易。</p>
<p>运行下面的代码使用<code>-Dkotlinx.coroutines.debug</code> JVM选项:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> a = async(coroutineContext) &#123;</span><br><span class="line">        log(<span class="string">"I'm computing a piece of the answer"</span>)</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> b = async(coroutineContext) &#123;</span><br><span class="line">        log(<span class="string">"I'm computing another piece of the answer"</span>)</span><br><span class="line">        <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">"The answer is <span class="subst">$&#123;a.await() * b.await()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>有三个协程。<br>主要的协程(#1)—— 一个<code>runBlocking</code>，和两个协程计算deferred值<code>a</code>(#2)和<code>b</code>(#3)。<br>它们都是在<code>runBlocking</code>上下文中执行的，并且仅限于主线程。这段代码的输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#2] I&apos;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&apos;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure>
<p>日志函数在方括号中打印出线程的名称，您可以看到，它是主线程，但是当前执行的协程的标识符被附加。<br>当打开调试模式时，这个标识符被连续地分配给所有创建的协程。</p>
<p>您可以在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-coroutine-context.html" target="_blank" rel="noopener">newCoroutineContext</a>函数的文档中阅读更多关于调试工具的信息。</p>
<h3 id="线程之间跳转"><a href="#线程之间跳转" class="headerlink" title="线程之间跳转"></a><a name="jumping_between_threads"></a>线程之间跳转</h3><p>运行下面的代码使用<code>-Dkotlinx.coroutines.debug</code> JVM选项:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    newSingleThreadContext(<span class="string">"Ctx1"</span>).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(<span class="string">"Ctx2"</span>).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(<span class="string">"Started in ctx1"</span>)</span><br><span class="line">                run(ctx2) &#123;</span><br><span class="line">                    log(<span class="string">"Working in ctx2"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">"Back to ctx1"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它演示了几种新技术。<br>一个是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a>和一个显式指定的context，另一个是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run.html" target="_blank" rel="noopener">run</a>函数来更改一个协程的上下文，同时仍然保持在相同的协程中，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Ctx1 @coroutine#1] Started in ctx1</span><br><span class="line">[Ctx2 @coroutine#1] Working in ctx2</span><br><span class="line">[Ctx1 @coroutine#1] Back to ctx1</span><br></pre></td></tr></table></figure>
<p>注意，这个例子也使用了来自Kotlin标准库的<code>use</code>函数来释放那些在不需要时创建的线程，这些线程是用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/new-single-thread-context.html" target="_blank" rel="noopener">newSingleThreadContext</a>创建的。</p>
<h3 id="context中的job"><a href="#context中的job" class="headerlink" title="context中的job"></a><a name="job_context"></a>context中的job</h3><p>协程的Job是其context的一部分。协程可以使用coroutineContext[Job]表达式从自己的context中检索它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    println(<span class="string">"My job is <span class="subst">$&#123;coroutineContext[Job]&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-05.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>当在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#debugging-coroutines-and-threads" target="_blank" rel="noopener">调试模式</a>下运行时，它会产生这样的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My job is &quot;coroutine#1&quot;:BlockingCoroutine&#123;Active&#125;@6d311334</span><br></pre></td></tr></table></figure>
<p>因此，在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/index.html" target="_blank" rel="noopener">CoroutineScope</a>中，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/is-active.html" target="_blank" rel="noopener">isActive</a>是coroutineContext[Job]的一个便捷的快捷方式!!</p>
<h3 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a><a name="children_of_a_coroutine"></a>子协程</h3><p>当一个协程的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/coroutine-context.html" target="_blank" rel="noopener">coroutineContext</a>被用来<code>launch</code>另一个协程时，新的协程job就变成了父母的子Job。<br>当父协程被取消时，所有的子协程也会被递归地取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// launch a coroutine to process some kind of incoming request</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// it spawns two other jobs, one with its separate context</span></span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">"job1: I have my own context and execute independently!"</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">"job1: I am not affected by cancellation of the request"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// and the other inherits the parent context</span></span><br><span class="line">        <span class="keyword">val</span> job2 = launch(coroutineContext) &#123;</span><br><span class="line">            println(<span class="string">"job2: I am a child of the request coroutine"</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">"job2: I will not execute this line if my parent request is cancelled"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// request completes when both its sub-jobs complete:</span></span><br><span class="line">        job1.join()</span><br><span class="line">        job2.join()</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel() <span class="comment">// cancel processing of the request</span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// delay a second to see what happens</span></span><br><span class="line">    println(<span class="string">"main: Who has survived request cancellation?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-06.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">job1: I have my own context and execute independently!</span><br><span class="line">job2: I am a child of the request coroutine</span><br><span class="line">job1: I am not affected by cancellation of the request</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;combining_contexts&quot;&gt;&lt;/a&gt;组合contexts</span><br><span class="line"></span><br><span class="line">使用`+`操作符可以组合使用协程contexts。</span><br><span class="line">右边的contexts替换了左边的contexts的相关条目。</span><br><span class="line">例如，父Job可以被继承，而它的分派器替换了:</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // 启动一个协程来处理某种类型的传入请求</span><br><span class="line">    val request = launch(coroutineContext) &#123; // 使用`runBlocking`context</span><br><span class="line">        // 在CommonPool中生成cpu密集型的子job !!! </span><br><span class="line">        val job = launch(coroutineContext + CommonPool) &#123;</span><br><span class="line">            println(&quot;job: I am a child of the request coroutine, but with a different dispatcher&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job: I will not execute this line if my parent request is cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        job.join() // 当它的子job完成时，请求就完成了</span><br><span class="line">    &#125;</span><br><span class="line">    delay(500)</span><br><span class="line">    request.cancel() // 取消对请求的处理</span><br><span class="line">    delay(1000) // 延迟一秒看看会发生什么</span><br><span class="line">    println(&quot;main: Who has survived request cancellation?&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-07.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的预期结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job: I am a child of the request coroutine, but with a different dispatcher</span><br><span class="line">main: Who has survived request cancellation?</span><br></pre></td></tr></table></figure>
<h3 id="父协程责任"><a href="#父协程责任" class="headerlink" title="父协程责任"></a><a name="parental_responsibilities"></a>父协程责任</h3><p>一个父协程总是等待所有孩子的完成。<br>父协程不必显式地跟踪它启动的所有子节点，它也不必使用Job.join在最后等待它们:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// launch a coroutine to process some kind of incoming request</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123; i -&gt; <span class="comment">// launch a few children jobs</span></span><br><span class="line">            launch(coroutineContext)  &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// variable delay 200ms, 400ms, 600ms</span></span><br><span class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"request: I'm done and I don't explicitly join my children that are still active"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() <span class="comment">// wait for completion of the request, including all its children</span></span><br><span class="line">    println(<span class="string">"Now processing of the request is complete"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-08.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>结果将是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request: I&apos;m done and I don&apos;t explicitly join my children that are still active</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Coroutine 2 is done</span><br><span class="line">Now processing of the request is complete</span><br></pre></td></tr></table></figure>
<h3 id="命名协程的调试"><a href="#命名协程的调试" class="headerlink" title="命名协程的调试"></a><a name="naming_coroutines_debugging"></a>命名协程的调试</h3><p>自动分配的id通常都很好，而且您只需要将来自相同的协程的日志记录关联起来。<br>然而，当协程与特定的请求或特定的后台任务绑定时，为调试的目的，最好将其命名。<br><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-name/index.html" target="_blank" rel="noopener">CoroutineName</a> context元素提供了与线程名称相同的功能。<br>当<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#debugging-coroutines-and-threads" target="_blank" rel="noopener">调试模式</a>打开时，它将显示在线程名称中，该名称将执行这个协程。</p>
<p>下面的例子演示了这个概念:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking(CoroutineName(<span class="string">"main"</span>)) &#123;</span><br><span class="line">    log(<span class="string">"Started main coroutine"</span>)</span><br><span class="line">    <span class="comment">// run two background value computations</span></span><br><span class="line">    <span class="keyword">val</span> v1 = async(CoroutineName(<span class="string">"v1coroutine"</span>)) &#123;</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        log(<span class="string">"Computing v1"</span>)</span><br><span class="line">        <span class="number">252</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> v2 = async(CoroutineName(<span class="string">"v2coroutine"</span>)) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">"Computing v2"</span>)</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">"The answer for v1 / v2 = <span class="subst">$&#123;v1.await() / v2.await()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-09.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>输出它产生使用<code>-Dkotlinx.coroutines.debug</code> JVM选项类似于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main @main#1] Started main coroutine</span><br><span class="line">[ForkJoinPool.commonPool-worker-1 @v1coroutine#2] Computing v1</span><br><span class="line">[ForkJoinPool.commonPool-worker-2 @v2coroutine#3] Computing v2</span><br><span class="line">[main @main#1] The answer for v1 / v2 = 42</span><br></pre></td></tr></table></figure>
<h3 id="显式取消Job"><a href="#显式取消Job" class="headerlink" title="显式取消Job"></a><a name="cancellation_via_explicit_job"></a>显式取消Job</h3><p>让我们把关于contexts、children和jobs的知识放在一起。<br>假设我们的应用程序有一个具有生命周期的对象，但是这个对象不是一个协程。<br>例如，我们正在编写一个Android应用程序，并在Android activity的环境中launch各种各样的协程，以执行异步操作来获取和更新数据、执行动画等等。<br>当活动被破坏以避免内存泄漏时，必须取消所有这些协程。</p>
<p>我们可以通过创建与activity生命周期相关联的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/index.html" target="_blank" rel="noopener">Job</a>实例来管理我们的协程的生命周期。<br>一个job实例是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job.html" target="_blank" rel="noopener">job()</a>工厂函数创建的，如下面的例子所示。<br>我们需要确保所有的协程都是在这个job的context下启动的。然后，一次<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/cancel.html" target="_blank" rel="noopener">Job.cancel</a>调用就会终止它们。<br>此外,<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-job/join.html" target="_blank" rel="noopener">Job.join</a>等待它们所有完成，因此我们也可以在本例中使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/cancel-and-join.html" target="_blank" rel="noopener">cancelAndJoin</a>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = Job() <span class="comment">// 创建一个job对象来管理我们的生命周期</span></span><br><span class="line">    <span class="comment">// 现在launch 10个coroutines，每个都在不同的时间工作</span></span><br><span class="line">    <span class="keyword">val</span> coroutines = List(<span class="number">10</span>) &#123; i -&gt;</span><br><span class="line">        <span class="comment">// 他们都是我们工作对象的孩子</span></span><br><span class="line">        launch(coroutineContext + job) &#123; <span class="comment">// 我们使用main runBlocking线程的上下文，但是使用我们自己的job对象</span></span><br><span class="line">            delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// variable delay 200ms, 400ms, ... etc</span></span><br><span class="line">            println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Launched <span class="subst">$&#123;coroutines.size&#125;</span> coroutines"</span>)</span><br><span class="line">    delay(<span class="number">500L</span>) <span class="comment">// 延迟半秒</span></span><br><span class="line">    println(<span class="string">"Cancelling the job!"</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消所有的协程，等待它们全部完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-context-10.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这个例子的输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Launched 10 coroutines</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Cancelling the job!</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，只有前三个协程打印了一条消息，而其他的则被单次调用<code>job.cancelAndJoin()</code>取消了。<br>因此，我们在假想的Android应用程序中所需要做的就是在创建activity时创建父Job对象，将其用于子节点，并在活动destroyed时取消它。<br>我们不能在Android生命周期的情况下<code>join</code>它们，因为它是同步的，但是当构建后端服务以确保有界的资源使用时，这种连接能力是很有用的。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a><a name="channels"></a>通道</h2><p>Deferred值提供了一种方便的方法，可以在协程之间传递单个值。<code>通道</code>提供了一种传输数据流的方法。</p>
<h3 id="通道基础知识"><a href="#通道基础知识" class="headerlink" title="通道基础知识"></a><a name="channel_basics"></a>通道基础知识</h3><p>一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-channel/index.html" target="_blank" rel="noopener">通道</a>在概念上非常类似于BlockingQueue。一个关键的区别是，它用挂起的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-send-channel/send.html" target="_blank" rel="noopener">send</a>替代阻塞的put操作，用挂起的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/receive.html" target="_blank" rel="noopener">receive</a> 替代阻塞的take操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// this might be heavy CPU-consuming computation or async logic, we'll just send five squares</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) channel.send(x * x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// here we print five received integers:</span></span><br><span class="line">    repeat(<span class="number">5</span>) &#123; println(channel.receive()) &#125;</span><br><span class="line">    println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>
<h3 id="通道的关闭和迭代"><a href="#通道的关闭和迭代" class="headerlink" title="通道的关闭和迭代"></a><a name="closing_iteration_over_channels"></a>通道的关闭和迭代</h3><p>与队列不同的是，通道可以关闭，以指示不再有更多的元素出现。<br>在接收端，使用常规的<code>for</code>循环从通道接收元素是很方便的。</p>
<p>从概念上说，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-send-channel/close.html" target="_blank" rel="noopener">close</a>就像向通道发送一个特殊的关闭令牌。<br>当接收到这个关闭令牌时，迭代就停止了，因此可以保证所有之前发送的元素都被接收到:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) channel.send(x * x)</span><br><span class="line">        channel.close() <span class="comment">// we're done sending</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// here we print received values using `for` loop (until the channel is closed)</span></span><br><span class="line">    <span class="keyword">for</span> (y <span class="keyword">in</span> channel) println(y)</span><br><span class="line">    println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<h3 id="构建通道生成器"><a href="#构建通道生成器" class="headerlink" title="构建通道生成器"></a><a name="building_channel_producers"></a>构建通道生成器</h3><p>在这种情况下，一种协程生成一系列元素的模式是很常见的。<br>这是在并发代码中经常发现的生产者-消费者模式的一部分。<br>您可以将这样一个生成器抽象为一个以通道为参数的函数，但这与通常的结果相反，即必须从函数返回结果。<br>有一个名为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a>的便利的协程构建器，它使得在生产者端很容易做，并且一个扩展函数<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/consume-each.html" target="_blank" rel="noopener">consumeEach</a>，它替代了消费者端的<code>for</code>循环:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">produceSquares</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) send(x * x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> squares = produceSquares()</span><br><span class="line">    squares.consumeEach &#123; println(it) &#125;</span><br><span class="line">    println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><a name="pipelines"></a>管道</h3><p>管道是一种模式，其中一种可能是无限的值流:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">produceNumbers</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// 从1开始的无限整数流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个协程或多个协程正在消耗这一流，进行一些处理，并产生一些其他的结果。在下面的例子中，数字是平方:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) send(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序启动并连接整个管道:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = produceNumbers() <span class="comment">// 从1和on生成整数</span></span><br><span class="line">    <span class="keyword">val</span> squares = square(numbers) <span class="comment">// 整数平方</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) println(squares.receive()) <span class="comment">// 打印前五</span></span><br><span class="line">    println(<span class="string">"Done!"</span>) <span class="comment">// we are done</span></span><br><span class="line">    squares.cancel() <span class="comment">// 需要在更大的应用程序中取消这些协程</span></span><br><span class="line">    numbers.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>我们不必在这个示例应用程序中取消这些协程，因为<a href="#coroutines-are-like-daemon-threads">协程就像守护线程</a>，但是在一个更大的应用程序中，如果我们不再需要它，我们就需要停止我们的管道。<br>或者，我们可以像下面的例子中演示的那样，将管道协程作为<a href="#children-of-a-coroutine">主协程的孩子</a>运行。</p>
<h3 id="用管道求质数"><a href="#用管道求质数" class="headerlink" title="用管道求质数"></a><a name="prime_numbers_pipeline"></a>用管道求质数</h3><p>让我们用一个例子来说明管道的极端情况，这个例子可以用一个管道来生成质数。<br>我们从一个无限的数字序列开始。<br>这一次，我们引入了一个显式的<code>context</code>参数并将其传递给<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a>建造者，以便调用者可以控制我们的协作程序的运行位置:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbersFrom</span><span class="params">(context: <span class="type">CoroutineContext</span>, start: <span class="type">Int</span>)</span></span> = produce&lt;<span class="built_in">Int</span>&gt;(context) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = start</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// 从start开始的无限整数流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的管道阶段将过滤传入的数字流，删除可以被给定的素数整除的所有数字:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">filter</span><span class="params">(context: <span class="type">CoroutineContext</span>, numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;, prime: <span class="type">Int</span>)</span></span> = produce&lt;<span class="built_in">Int</span>&gt;(context) &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) <span class="keyword">if</span> (x % prime != <span class="number">0</span>) send(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们通过从2启动一个数字流来构建我们的管道，从当前通道中获取一个质数，并为每个找到的素数启动新的管道阶段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ...</span><br></pre></td></tr></table></figure>
<p>下面的例子输出了前10个素数，在主线程的context中运行整个管道。<br>因为所有的协程都是在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/coroutine-context.html" target="_blank" rel="noopener">coroutineContext</a>中作为主要的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/run-blocking.html" target="_blank" rel="noopener">runBlocking</a>协程的孩子发布的，所以我们不需要对我们已经开始的所有的协程有一个明确的列表。<br>我们使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/kotlin.coroutines.experimental.-coroutine-context/cancel-children.html" target="_blank" rel="noopener">cancelChildren</a>扩展函数来取消所有的子协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = numbersFrom(coroutineContext, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> prime = cur.receive()</span><br><span class="line">        println(prime)</span><br><span class="line">        cur = filter(coroutineContext, cur, prime)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() <span class="comment">// cancel all children to let main finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-05.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line">13</span><br><span class="line">17</span><br><span class="line">19</span><br><span class="line">23</span><br><span class="line">29</span><br></pre></td></tr></table></figure>
<p>注意，您可以使用来自标准库的构建器<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-iterator.html" target="_blank" rel="noopener">buildIterator</a>构建相同的管道。<br>用<code>produce</code>换成<code>buildIterator</code>，<code>send</code>换成<code>yield</code>，<code>receive</code>换成<code>next</code>，<code>ReceiveChannel</code> 换成<code>Iterator</code>，并摆脱<code>context</code>。<br>您也不需要<code>runBlocking</code>。<br>但是，使用通道的管道的好处是，如果在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-common-pool/index.html" target="_blank" rel="noopener">CommonPool</a> context中运行它，它实际上可以使用多个CPU内核。</p>
<p>无论如何，这是一种非常不切实际的求质数的方法。<br>在实践中,管道涉及一些其他挂起调用(如异步调用远程服务),这些管道不能使用<code>buildSeqeunce/buildIterator</code>,因为他们不允许任意挂起,像<code>produce</code>,这是完全异步的。</p>
<h3 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a><a name="Fan-out"></a>扇出</h3><p>多个协程可以从相同的通道接收，在它们之间分配工作。让我们从一个定期产生整数的生产者(每秒钟10个数字)开始。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">produceNumbers</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> <span class="comment">// start from 1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        send(x++) <span class="comment">// produce next</span></span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// wait 0.1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以有几个处理器的协程。在本例中，他们只打印他们的id和接收的号码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchProcessor</span><span class="params">(id: <span class="type">Int</span>, channel: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span> = launch &#123;</span><br><span class="line">    channel.consumeEach &#123;</span><br><span class="line">        println(<span class="string">"Processor #<span class="variable">$id</span> received <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，让我们启动5个处理器，让它们工作大约一秒钟。看看会发生什么:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> producer = produceNumbers()</span><br><span class="line">    repeat(<span class="number">5</span>) &#123; launchProcessor(it, producer) &#125;</span><br><span class="line">    delay(<span class="number">950</span>)</span><br><span class="line">    producer.cancel() <span class="comment">// cancel producer coroutine and thus kill them all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-06.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>输出将类似于下面一个，尽管接收每个特定整数的处理器id可能不同:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Processor #2 received 1</span><br><span class="line">Processor #4 received 2</span><br><span class="line">Processor #0 received 3</span><br><span class="line">Processor #1 received 4</span><br><span class="line">Processor #3 received 5</span><br><span class="line">Processor #2 received 6</span><br><span class="line">Processor #4 received 7</span><br><span class="line">Processor #0 received 8</span><br><span class="line">Processor #1 received 9</span><br><span class="line">Processor #3 received 10</span><br></pre></td></tr></table></figure>
<p>请注意，取消一个生产商的协程会关闭它的通道，从而最终终止处理器协程正在进行的通道的迭代。</p>
<h3 id="扇入"><a href="#扇入" class="headerlink" title="扇入"></a><a name="Fan-in"></a>扇入</h3><p>多个协程可以发送到相同的通道。例如，让我们有一个字符串的通道，以及一个挂起函数，它通过指定的延迟将指定的字符串发送到这个通道。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendString</span><span class="params">(channel: <span class="type">SendChannel</span>&lt;<span class="type">String</span>&gt;, s: <span class="type">String</span>, time: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        delay(time)</span><br><span class="line">        channel.send(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，让我们看看如果我们启动了一对发送字符串的协程(在本例中，我们在主线程中作为主协程的子协程启动它们):</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;String&gt;()</span><br><span class="line">    launch(coroutineContext) &#123; sendString(channel, <span class="string">"foo"</span>, <span class="number">200L</span>) &#125;</span><br><span class="line">    launch(coroutineContext) &#123; sendString(channel, <span class="string">"BAR!"</span>, <span class="number">500L</span>) &#125;</span><br><span class="line">    repeat(<span class="number">6</span>) &#123; <span class="comment">// 接收前六</span></span><br><span class="line">        println(channel.receive())</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() <span class="comment">// cancel all children to let main finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-07.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它的输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">BAR!</span><br><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">BAR!</span><br></pre></td></tr></table></figure>
<h3 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a><a name="buffered_channels"></a>缓冲通道</h3><p>到目前为止，所展示的通道没有任何缓冲。<br>当发送方和接收方相遇时，没有缓冲的通道传输元素(也就是会合点)。<br>如果首先调用<code>send</code>，那么它将被挂起，直到<code>receive</code>被调用，如果首先调用<code>receive</code>，它将被挂起，直到<code>send</code>被调用。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-channel.html" target="_blank" rel="noopener">Channel()</a>工厂函数和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" target="_blank" rel="noopener">produce</a>构建器都使用一个可选的<code>capacity</code>参数来指定缓冲区大小。<br>缓冲区允许发送者在挂起之前发送多个元素，类似于具有指定容量的<code>BlockingQueue</code>，在缓冲区满时阻塞。</p>
<p>看看以下代码的行为:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">4</span>) <span class="comment">// create buffered channel</span></span><br><span class="line">    <span class="keyword">val</span> sender = launch(coroutineContext) &#123; <span class="comment">// launch sender coroutine</span></span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            println(<span class="string">"Sending <span class="variable">$it</span>"</span>) <span class="comment">// print before sending each element</span></span><br><span class="line">            channel.send(it) <span class="comment">// will suspend when buffer is full</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// don't receive anything... just wait....</span></span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    sender.cancel() <span class="comment">// cancel sender coroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-08.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它用一个有四个容量的缓冲通道打印“发送”5次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sending 0</span><br><span class="line">Sending 1</span><br><span class="line">Sending 2</span><br><span class="line">Sending 3</span><br><span class="line">Sending 4</span><br></pre></td></tr></table></figure>
<p>前4个元素被添加到缓冲区中，当发送第5个元素时，发送器会挂起。</p>
<h3 id="通道是公平的"><a href="#通道是公平的" class="headerlink" title="通道是公平的"></a><a name="channels_fair"></a>通道是公平的</h3><p>对通道的发送和接收操作是公平的，这与它们从多个协程调用的顺序是公平的。<br>它们以先入先出的顺序服务，例如，第一个调用接收的协程获取元素。<br>在下面的例子中，两个“ping”和“pong”从共享的“table”通道接收到“ball”对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ball</span></span>(<span class="keyword">var</span> hits: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> table = Channel&lt;Ball&gt;() <span class="comment">// a shared table</span></span><br><span class="line">    launch(coroutineContext) &#123; player(<span class="string">"ping"</span>, table) &#125;</span><br><span class="line">    launch(coroutineContext) &#123; player(<span class="string">"pong"</span>, table) &#125;</span><br><span class="line">    table.send(Ball(<span class="number">0</span>)) <span class="comment">// serve the ball</span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// delay 1 second</span></span><br><span class="line">    coroutineContext.cancelChildren() <span class="comment">// game over, cancel them</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">player</span><span class="params">(name: <span class="type">String</span>, table: <span class="type">Channel</span>&lt;<span class="type">Ball</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ball <span class="keyword">in</span> table) &#123; <span class="comment">// receive the ball in a loop</span></span><br><span class="line">        ball.hits++</span><br><span class="line">        println(<span class="string">"<span class="variable">$name</span> <span class="variable">$ball</span>"</span>)</span><br><span class="line">        delay(<span class="number">300</span>) <span class="comment">// wait a bit</span></span><br><span class="line">        table.send(ball) <span class="comment">// send the ball back</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-channel-09.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>“ping”协程是先开始的，所以它是第一个收到球的。<br>即使在把球送回到table的时候，”ping” 协程马上又开始接球，球却被”pong” 协程 所接收，因为它已经在等待它了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping Ball(hits=1)</span><br><span class="line">pong Ball(hits=2)</span><br><span class="line">ping Ball(hits=3)</span><br><span class="line">pong Ball(hits=4)</span><br></pre></td></tr></table></figure>
<p>请注意，有时通道可能会产生由于正在使用的执行器的性质而看起来不公平的执行。请参阅<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/111" target="_blank" rel="noopener">这个问题</a>的详细信息。</p>
<h2 id="共享的可变状态和并发性"><a href="#共享的可变状态和并发性" class="headerlink" title="共享的可变状态和并发性"></a><a name="shared_mutable_state_concurrency"></a>共享的可变状态和并发性</h2><p>可以使用多线程的分派器并发地执行协程，比如默认的CommonPool。<br>它展示了所有常见的并发问题。<br>主要问题是对共享易变状态的访问同步。<br>解决这一问题的方法与多线程世界中的解决方案类似，但也有一些是独特的。</p>
<h3 id="这个问题"><a href="#这个问题" class="headerlink" title="这个问题"></a><a name="the_problem"></a>这个问题</h3><p>让我们发动一千次的协程，一千次做同样的操作(总共有100万次执行)。<br>我们还将测量他们的完成时间来进行进一步的比较:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">massiveRun</span><span class="params">(context: <span class="type">CoroutineContext</span>, action: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = <span class="number">1000</span> <span class="comment">// number of coroutines to launch</span></span><br><span class="line">    <span class="keyword">val</span> k = <span class="number">1000</span> <span class="comment">// times an action is repeated by each coroutine</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> jobs = List(n) &#123;</span><br><span class="line">            launch(context) &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed <span class="subst">$&#123;n * k&#125;</span> actions in <span class="variable">$time</span> ms"</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从一个非常简单的动作开始，它使用多线程的CommonPool context来增加一个共享的可变变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(CommonPool) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$counter</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>它最后会打印什么?<br>它不太可能打印“计数器=1000000”，因为1000个coroutines可以同时从多个线程并行地增加计数器，而不需要任何同步。</p>
<blockquote>
<p>注意:如果您的旧系统中有2个或更少的cpu，那么您将始终看到1000000，因为在本例中，CommonPool只运行一个线程。为了重现这个问题，你需要做出以下的改变:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mtContext = newFixedThreadPoolContext(<span class="number">2</span>, <span class="string">"mtPool"</span>) <span class="comment">// explicitly define context with two threads</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(mtContext) &#123; <span class="comment">// use it instead of CommonPool in this sample and below </span></span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$counter</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-01b.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<h3 id="Volatiles毫无用处"><a href="#Volatiles毫无用处" class="headerlink" title="Volatiles毫无用处"></a><a name="volatiles-are-of-no-help"></a>Volatiles毫无用处</h3><p>有一种常见的误解是，volatile变量可以解决并发性问题。让我们试一试:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Volatile</span> <span class="comment">// in Kotlin `volatile` is an annotation </span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(CommonPool) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$counter</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的工作速度较慢，但最终我们仍然不能得到“Counter=1000000”，因为volatile变量可以保证线性化(这是“原子”的技术术语)，并对相应的变量进行读写操作，但是不提供更大的操作的原子性(在我们的例子中是增加的)。</p>
<h3 id="线程安全的数据结构"><a href="#线程安全的数据结构" class="headerlink" title="线程安全的数据结构"></a><a name="thread_safe_data_structures"></a>线程安全的数据结构</h3><p>对于线程和协程工作的通用解决方案是使用线程安全的(即同步的、线性化的或原子的)数据结构，为需要在共享状态上执行的相应操作提供所有必要的同步。<br>在一个简单的计数器的例子中，我们可以使用<code>AtomicInteger</code>类，它具有原子的递增操作:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = AtomicInteger()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(CommonPool) &#123;</span><br><span class="line">        counter.incrementAndGet()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="subst">$&#123;counter.get()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>对于这个特殊的问题，这是最快的解决方案。<br>它适用于普通的计数器、集合、队列和其他标准数据结构和基本操作。<br>但是，它不容易扩展到复杂的状态，也不容易扩展到没有现成的线程安全实现的复杂操作。</p>
<h3 id="细粒度线程约束"><a href="#细粒度线程约束" class="headerlink" title="细粒度线程约束"></a><a name="thread_confinement_fine_grained"></a>细粒度线程约束</h3><p>线程约束是一种解决共享可变状态问题的方法，在这种状态下，所有对特定共享状态的访问都被限制在一个线程中。<br>它通常在UI应用程序中使用，所有的UI状态都被限制在单一事件分派/应用程序线程中。<br>使用单线程上下文可以很容易地应用于协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counterContext = newSingleThreadContext(<span class="string">"CounterContext"</span>)</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(CommonPool) &#123; <span class="comment">// run each coroutine in CommonPool</span></span><br><span class="line">        run(counterContext) &#123; <span class="comment">// but confine each increment to the single-threaded context</span></span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$counter</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码运行非常缓慢，因为它执行细粒度的线程限制。每个单独的递增从多线程的<code>CommonPool</code>上下文切换到使用<code>run</code>块的单线程上下文。</p>
<h3 id="粗粒度线程约束"><a href="#粗粒度线程约束" class="headerlink" title="粗粒度线程约束"></a><a name="thread_confinement_coarse_grained"></a>粗粒度线程约束</h3><p>在实践中，线程约束是在大块中执行的，例如，状态更新业务逻辑的大片段被限制在单个线程中。<br>下面的例子是这样的，在单线程上下文中运行每个协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counterContext = newSingleThreadContext(<span class="string">"CounterContext"</span>)</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(counterContext) &#123; <span class="comment">// run each coroutine in the single-threaded context</span></span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$counter</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-05.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>现在的工作速度更快，产生了正确的结果。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title=" Mutex"></a><a name="mutual_exclusion"></a> Mutex</h3><p>对于这个问题的互斥解决方案是保护共享状态的所有修改，而这一关键部分不会同时执行。<br>在一个阻塞的世界中，您通常会使用<code>synchronized</code>或<code>ReentrantLock</code>。<br>协程的选择被称为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/-mutex/index.html" target="_blank" rel="noopener">Mutex</a>。<br>它有<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/-mutex/lock.html" target="_blank" rel="noopener">lock</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/-mutex/unlock.html" target="_blank" rel="noopener">unlock</a>函数，以限制临界区。<br>关键的区别在于<code>Mutex.lock</code>是一个挂起函数。<br>它不会阻塞线程。</p>
<p>还有<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.sync/with-lock.html" target="_blank" rel="noopener">withLock</a>扩展函数，它可以方便地表示mutex.lock(); try { … } finally { mutex.unlock() } 模式:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    massiveRun(CommonPool) &#123;</span><br><span class="line">        mutex.withLock &#123;</span><br><span class="line">            counter++        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Counter = <span class="variable">$counter</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-06.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这个例子中的锁定是细粒度的，因此它会付出代价。<br>但是，在某些情况下，这是一个很好的选择，您必须定期修改某些共享状态，但是这个状态并没有被限制的自然线程。</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a><a name="actors"></a>参与者</h3><p><code>参与者(actor)</code>是一种结合在一起的协程，被限制和压缩到这个协程的状态，以及一个外联的沟通渠道。<br>一个简单的参与者可以被编写为一个函数，但是一个具有复杂状态的参与者更适合于一个类。</p>
<p>有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/actor.html" target="_blank" rel="noopener">参与者(actor)</a>协程构建器，它可以方便地将参与者的邮箱通道与它的范围相结合，接收消息，并将发送通道组合到产生的job对象中，这样就可以将单个引用作为它的句柄进行传递。</p>
<p>使用<code>actor</code>的第一步是定义一个参与者将要处理的消息类。<br>Kotlin的<a href="https://kotlinlang.org/docs/reference/sealed-classes.html" target="_blank" rel="noopener">sealed classes</a>非常适合这个目的。<br>我们定义CounterMsg sealed类，并使用<code>IncCounter</code>消息增加计数器和<code>GetCounter</code>消息以获取其值。<br>稍后需要发送响应。<br>一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-completable-deferred/index.html" target="_blank" rel="noopener">CompletableDeferred</a>通信原语，表示将来会被知道(通信)的一个单一值，用于此目的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息类型为counterActor</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterMsg</span></span></span><br><span class="line"><span class="keyword">object</span> IncCounter : CounterMsg() <span class="comment">// 增量计数器单向消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCounter</span></span>(<span class="keyword">val</span> response: CompletableDeferred&lt;<span class="built_in">Int</span>&gt;) : CounterMsg() <span class="comment">// 一个请求与应答</span></span><br></pre></td></tr></table></figure>
<p>然后，我们定义了一个函数，该函数使用参与者协程构建器启动一个参与者:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将启动一个新的计数器参与者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">counterActor</span><span class="params">()</span></span> = actor&lt;CounterMsg&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">// actor state</span></span><br><span class="line">    <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123; <span class="comment">// 遍历传入的消息</span></span><br><span class="line">        <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">            <span class="keyword">is</span> IncCounter -&gt; counter++</span><br><span class="line">            <span class="keyword">is</span> GetCounter -&gt; msg.response.complete(counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序很简单:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> counter = counterActor() <span class="comment">// create the actor</span></span><br><span class="line">    massiveRun(CommonPool) &#123;</span><br><span class="line">        counter.send(IncCounter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send a message to get a counter value from an actor</span></span><br><span class="line">    <span class="keyword">val</span> response = CompletableDeferred&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    counter.send(GetCounter(response))</span><br><span class="line">    println(<span class="string">"Counter = <span class="subst">$&#123;response.await()&#125;</span>"</span>)</span><br><span class="line">    counter.close() <span class="comment">// shutdown the actor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-sync-07.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>参与者自己在什么环境中被执行,这并不重要(对于正确性)。一个参与者是一个协程，而一个协程是按顺序执行的，因此将状态限制到特定的协程是解决共享可变状态问题的一个解决方案。</p>
<p>Actor比在负载下锁定更有效，因为在这种情况下，它总是有工作要做，而且它不需要切换到不同的上下文。</p>
<blockquote>
<p>值得注意的是，一个参与者的协程构建器是一个生产协程构建器的双重角色。一个参与者与它接收消息的通道相关联，而一个生产者与它发送元素的通道相关联。</p>
</blockquote>
<h2 id="Select表达式"><a href="#Select表达式" class="headerlink" title="Select表达式"></a><a name="select_expression"></a>Select表达式</h2><p>Select表达式使得可以同时等待多个挂起函数，并选择第一个可用的函数。</p>
<h3 id="选择通道"><a href="#选择通道" class="headerlink" title="选择通道"></a><a name="selecting_from_channels"></a>选择通道</h3><p>让我们作两个字符串的生产者: fizz和buzz。fizz生产者每300毫秒就会产生”Fizz”的字符串:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fizz</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span> = produce&lt;String&gt;(context) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// sends "Fizz" every 300 ms</span></span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line">        send(<span class="string">"Fizz"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buzz生产者每500毫秒就会产生”Buzz”的字符串:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buzz</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span> = produce&lt;String&gt;(context) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// sends "Buzz!" every 500 ms</span></span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        send(<span class="string">"Buzz!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从一个通道或另一个通道接收挂起函数。<br>但select表达式允许我们同时使用它的onReceive子句:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectFizzBuzz</span><span class="params">(fizz: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, buzz: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// &lt;Unit&gt; means that this select expression does not produce any result </span></span><br><span class="line">        fizz.onReceive &#123; value -&gt;  <span class="comment">// this is the first select clause</span></span><br><span class="line">            println(<span class="string">"fizz -&gt; '<span class="variable">$value</span>'"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        buzz.onReceive &#123; value -&gt;  <span class="comment">// this is the second select clause</span></span><br><span class="line">            println(<span class="string">"buzz -&gt; '<span class="variable">$value</span>'"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来运行它七次:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> fizz = fizz(coroutineContext)</span><br><span class="line">    <span class="keyword">val</span> buzz = buzz(coroutineContext)</span><br><span class="line">    repeat(<span class="number">7</span>) &#123;</span><br><span class="line">        selectFizzBuzz(fizz, buzz)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() <span class="comment">// cancel fizz &amp; buzz coroutines    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-01.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fizz -&gt; &apos;Fizz&apos;</span><br><span class="line">buzz -&gt; &apos;Buzz!&apos;</span><br><span class="line">fizz -&gt; &apos;Fizz&apos;</span><br><span class="line">fizz -&gt; &apos;Fizz&apos;</span><br><span class="line">buzz -&gt; &apos;Buzz!&apos;</span><br><span class="line">fizz -&gt; &apos;Fizz&apos;</span><br><span class="line">buzz -&gt; &apos;Buzz!&apos;</span><br></pre></td></tr></table></figure>
<h3 id="关闭时的select"><a href="#关闭时的select" class="headerlink" title="关闭时的select"></a><a name="selecting_on_close"></a>关闭时的select</h3><p>当通道关闭时，<code>select</code>中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive.html" target="_blank" rel="noopener">onReceive</a>子句失败，相应的select抛出一个异常。<br>当通道关闭时，我们可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive-or-null.html" target="_blank" rel="noopener">onReceiveOrNull</a>子句执行特定的操作。<br>下面的示例还显示了select是返回其所选子句的结果的表达式:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectAorB</span><span class="params">(a: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, b: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String =</span><br><span class="line">    select&lt;String&gt; &#123;</span><br><span class="line">        a.onReceiveOrNull &#123; value -&gt; </span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) </span><br><span class="line">                <span class="string">"Channel 'a' is closed"</span> </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="string">"a -&gt; '<span class="variable">$value</span>'"</span></span><br><span class="line">        &#125;</span><br><span class="line">        b.onReceiveOrNull &#123; value -&gt; </span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) </span><br><span class="line">                <span class="string">"Channel 'b' is closed"</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="string">"b -&gt; '<span class="variable">$value</span>'"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>让我们用通道a生成“Hello”字符串4次，而b通道生成“World”4次:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// we are using the context of the main thread in this example for predictability ... </span></span><br><span class="line">    <span class="keyword">val</span> a = produce&lt;String&gt;(coroutineContext) &#123;</span><br><span class="line">        repeat(<span class="number">4</span>) &#123; send(<span class="string">"Hello <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> b = produce&lt;String&gt;(coroutineContext) &#123;</span><br><span class="line">        repeat(<span class="number">4</span>) &#123; send(<span class="string">"World <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(<span class="number">8</span>) &#123; <span class="comment">// print first eight results</span></span><br><span class="line">        println(selectAorB(a, b))</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-02.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>这段代码的结果非常有趣，所以我们将在模式细节上进行分析:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; &apos;Hello 0&apos;</span><br><span class="line">a -&gt; &apos;Hello 1&apos;</span><br><span class="line">b -&gt; &apos;World 0&apos;</span><br><span class="line">a -&gt; &apos;Hello 2&apos;</span><br><span class="line">a -&gt; &apos;Hello 3&apos;</span><br><span class="line">b -&gt; &apos;World 1&apos;</span><br><span class="line">Channel &apos;a&apos; is closed</span><br><span class="line">Channel &apos;a&apos; is closed</span><br></pre></td></tr></table></figure>
<p>有几条观察结果可以证明这一点。</p>
<p>首先，<code>select</code>对第一个子句有偏爱。<br>当多个子句同时可选时，其中的第一个子句被选中。<br>在这里，两个通道都在不断地生成字符串，因此一个通道，作为select中的第一个子句获胜。<br>然而，由于我们使用的是非缓冲通道，所以<code>a</code>在发送调用时被暂时挂起，并给b发送了一个机会。</p>
<p>第二个观察结果是，当通道已经关闭时，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive-or-null.html" target="_blank" rel="noopener">onReceiveOrNull</a>会立即被选中。</p>
<h3 id="选择发送"><a href="#选择发送" class="headerlink" title="选择发送"></a><a name="selecting_to_send"></a>选择发送</h3><p>Select表达式有<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-send-channel/on-send.html" target="_blank" rel="noopener">onSend</a>子句，它可以用于很好的组合和选择的偏置性。</p>
<p>让我们来编写一个例子，当在主通道上的消费者无法跟上时，将它的值发送到一个侧通道的整数的生产者。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">produceNumbers</span><span class="params">(context: <span class="type">CoroutineContext</span>, side: <span class="type">SendChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span> = produce&lt;<span class="built_in">Int</span>&gt;(context) &#123;</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>) &#123; <span class="comment">// 从1到10产生10个数字</span></span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// every 100 ms</span></span><br><span class="line">        select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">            onSend(num) &#123;&#125; <span class="comment">// 发送到主通道</span></span><br><span class="line">            side.onSend(num) &#123;&#125; <span class="comment">// 或者是侧通道    </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者将会非常缓慢，花费250毫秒来处理每一个数字:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> side = Channel&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// allocate side channel</span></span><br><span class="line">    launch(coroutineContext) &#123; <span class="comment">// 这是侧边通道的一个非常快的消费者</span></span><br><span class="line">        side.consumeEach &#123; println(<span class="string">"Side channel has <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    produceNumbers(coroutineContext, side).consumeEach &#123; </span><br><span class="line">        println(<span class="string">"Consuming <span class="variable">$it</span>"</span>)</span><br><span class="line">        delay(<span class="number">250</span>) <span class="comment">// 让我们适当地消化所消耗的数字，不要着急</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Done consuming"</span>)</span><br><span class="line">    coroutineContext.cancelChildren()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-03.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>让我们看看会发生什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consuming 1</span><br><span class="line">Side channel has 2</span><br><span class="line">Side channel has 3</span><br><span class="line">Consuming 4</span><br><span class="line">Side channel has 5</span><br><span class="line">Side channel has 6</span><br><span class="line">Consuming 7</span><br><span class="line">Side channel has 8</span><br><span class="line">Side channel has 9</span><br><span class="line">Consuming 10</span><br><span class="line">Done consuming</span><br></pre></td></tr></table></figure>
<h3 id="选择deferred值"><a href="#选择deferred值" class="headerlink" title="选择deferred值"></a><a name="selecting_deferred_values"></a>选择deferred值</h3><p>deferred值可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/on-await.html" target="_blank" rel="noopener">onAwait</a>子句来选择。让我们从一个异步函数开始，该函数在随机延迟之后返回deferred字符串值:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncString</span><span class="params">(time: <span class="type">Int</span>)</span></span> = async &#123;</span><br><span class="line">    delay(time.toLong())</span><br><span class="line">    <span class="string">"Waited for <span class="variable">$time</span> ms"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们用随机的延迟来启动一打:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncStringsList</span><span class="params">()</span></span>: List&lt;Deferred&lt;String&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> random = Random(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> List(<span class="number">12</span>) &#123; asyncString(random.nextInt(<span class="number">1000</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，主函数将等待第一个函数完成并计算仍然处于活动状态的deferred值的数量。<br>注意，我们已经在这里使用了<code>select</code>表达式是一个Kotlin DSL，因此我们可以使用任意代码为它提供子句。<br>在本例中，我们迭代了deferred值的列表，为每个延迟值提供<code>onAwait</code>子句。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = asyncStringsList()</span><br><span class="line">    <span class="keyword">val</span> result = select&lt;String&gt; &#123;</span><br><span class="line">        list.withIndex().forEach &#123; (index, deferred) -&gt;</span><br><span class="line">            deferred.onAwait &#123; answer -&gt;</span><br><span class="line">                <span class="string">"Deferred <span class="variable">$index</span> produced answer '<span class="variable">$answer</span>'"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">    <span class="keyword">val</span> countActive = list.count &#123; it.isActive &#125;</span><br><span class="line">    println(<span class="string">"<span class="variable">$countActive</span> coroutines are still active"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-04.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deferred 4 produced answer &apos;Waited for 128 ms&apos;</span><br><span class="line">11 coroutines are still active</span><br></pre></td></tr></table></figure>
<h3 id="切换到deferred值的通道"><a href="#切换到deferred值的通道" class="headerlink" title="切换到deferred值的通道"></a><a name="switch_over_a_channel_of_deferred_values"></a>切换到deferred值的通道</h3><p>让我们编写一个通道生成器函数，该函数使用一个deferred字符串值的通道，等待每个接收到的deferred值，但直到下一次deferred或通道被关闭时才会出现。<br>这个示例将<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-receive-channel/on-receive-or-null.html" target="_blank" rel="noopener">onReceiveOrNull</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/on-await.html" target="_blank" rel="noopener">onAwait</a>子句放在同一个select子句中:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">switchMapDeferreds</span><span class="params">(input: <span class="type">ReceiveChannel</span>&lt;<span class="type">Deferred</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span> = produce&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> current = input.receive() <span class="comment">// start with first received deferred value</span></span><br><span class="line">    <span class="keyword">while</span> (isActive) &#123; <span class="comment">// loop while not cancelled/closed</span></span><br><span class="line">        <span class="keyword">val</span> next = select&lt;Deferred&lt;String&gt;?&gt; &#123; <span class="comment">// return next deferred value from this select or null</span></span><br><span class="line">            input.onReceiveOrNull &#123; update -&gt;</span><br><span class="line">                update <span class="comment">// replaces next value to wait</span></span><br><span class="line">            &#125;</span><br><span class="line">            current.onAwait &#123; value -&gt;  </span><br><span class="line">                send(value) <span class="comment">// send value that current deferred has produced</span></span><br><span class="line">                input.receiveOrNull() <span class="comment">// and use the next deferred from the input channel</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">            println(<span class="string">"Channel was closed"</span>)</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// out of loop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试它，我们将使用一个简单的async函数，它在指定的时间之后解析为指定的字符串:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncString</span><span class="params">(str: <span class="type">String</span>, time: <span class="type">Long</span>)</span></span> = async &#123;</span><br><span class="line">    delay(time)</span><br><span class="line">    str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数是启动一个协程来打印开关的结果，并发送一些测试数据给它:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> chan = Channel&lt;Deferred&lt;String&gt;&gt;() <span class="comment">// the channel for test</span></span><br><span class="line">    launch(coroutineContext) &#123; <span class="comment">// launch printing coroutine</span></span><br><span class="line">        <span class="keyword">for</span> (s <span class="keyword">in</span> switchMapDeferreds(chan)) </span><br><span class="line">            println(s) <span class="comment">// print each received string</span></span><br><span class="line">    &#125;</span><br><span class="line">    chan.send(asyncString(<span class="string">"BEGIN"</span>, <span class="number">100</span>))</span><br><span class="line">    delay(<span class="number">200</span>) <span class="comment">// enough time for "BEGIN" to be produced</span></span><br><span class="line">    chan.send(asyncString(<span class="string">"Slow"</span>, <span class="number">500</span>))</span><br><span class="line">    delay(<span class="number">100</span>) <span class="comment">// not enough time to produce slow</span></span><br><span class="line">    chan.send(asyncString(<span class="string">"Replace"</span>, <span class="number">100</span>))</span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// give it time before the last one</span></span><br><span class="line">    chan.send(asyncString(<span class="string">"END"</span>, <span class="number">500</span>))</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// give it time to process</span></span><br><span class="line">    chan.close() <span class="comment">// close the channel ... </span></span><br><span class="line">    delay(<span class="number">500</span>) <span class="comment">// and wait some time to let it finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/test/kotlin/guide/example-select-05.kt" target="_blank" rel="noopener">这里</a>得到完整的代码</p>
</blockquote>
<p>输出是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">Replace</span><br><span class="line">END</span><br><span class="line">Channel was closed</span><br></pre></td></tr></table></figure>
<h2 id="进一步的阅读"><a href="#进一步的阅读" class="headerlink" title="进一步的阅读"></a><a name="further_reading"></a>进一步的阅读</h2><ul>
<li><a href="/2017/11/06/GuideUIProgrammingCoroutines/">使用协程的UI编程指南</a></li>
<li><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md" target="_blank" rel="noopener">使用协程响应式流的指南</a></li>
<li><a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md" target="_blank" rel="noopener">协程设计文档(保持)</a></li>
<li><a href="http://kotlin.github.io/kotlinx.coroutines" target="_blank" rel="noopener">完整的kotlinx.coroutines API参考</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>段纪刚</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2017/11/06/GuideToKotlinxCoroutinesByExample/" target="_blank" title="kotlinx.coroutines入门指南示例">https://jigangduan.github.io/2017/11/06/GuideToKotlinxCoroutinesByExample/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kotlin/">kotlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kotlinx-coroutines/">kotlinx.coroutines</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/06/GuideUIProgrammingCoroutines/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          使用协程的UI编程指南
        
      </div>
    </a>
  
  
    <a href="/2017/11/03/Anko-Coroutines/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Anko 协程</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍和设置"><span class="nav-number">1.</span> <span class="nav-text">介绍和设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">2.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程基础"><span class="nav-number">3.</span> <span class="nav-text">协程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#你的第一个协程"><span class="nav-number">3.1.</span> <span class="nav-text">你的第一个协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桥接阻塞和非阻塞的世界"><span class="nav-number">3.2.</span> <span class="nav-text">桥接阻塞和非阻塞的世界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待job"><span class="nav-number">3.3.</span> <span class="nav-text">等待job</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提取函数重构"><span class="nav-number">3.4.</span> <span class="nav-text">提取函数重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程是轻量级的"><span class="nav-number">3.5.</span> <span class="nav-text">协程是轻量级的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程就像守护线程"><span class="nav-number">3.6.</span> <span class="nav-text">协程就像守护线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取消和超时"><span class="nav-number">4.</span> <span class="nav-text">取消和超时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#取消协程执行"><span class="nav-number">4.1.</span> <span class="nav-text">取消协程执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使计算代码可取消"><span class="nav-number">4.2.</span> <span class="nav-text">使计算代码可取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在finally关闭资源"><span class="nav-number">4.3.</span> <span class="nav-text"> 在finally关闭资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行不可取消块"><span class="nav-number">4.4.</span> <span class="nav-text">运行不可取消块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超时"><span class="nav-number">4.5.</span> <span class="nav-text">超时</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组成挂起函数"><span class="nav-number">5.</span> <span class="nav-text">组成挂起函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认顺序"><span class="nav-number">5.1.</span> <span class="nav-text">默认顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用async并发"><span class="nav-number">5.2.</span> <span class="nav-text">使用async并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#懒启动async"><span class="nav-number">5.3.</span> <span class="nav-text">懒启动async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步式函数"><span class="nav-number">5.4.</span> <span class="nav-text">异步式函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程context和分派器"><span class="nav-number">6.</span> <span class="nav-text">协程context和分派器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分派器和线程"><span class="nav-number">6.1.</span> <span class="nav-text">分派器和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非限制-vs-限制-分派器"><span class="nav-number">6.2.</span> <span class="nav-text"> 非限制 vs 限制 分派器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试协程和线程"><span class="nav-number">6.3.</span> <span class="nav-text">调试协程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程之间跳转"><span class="nav-number">6.4.</span> <span class="nav-text">线程之间跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#context中的job"><span class="nav-number">6.5.</span> <span class="nav-text">context中的job</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子协程"><span class="nav-number">6.6.</span> <span class="nav-text">子协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父协程责任"><span class="nav-number">6.7.</span> <span class="nav-text">父协程责任</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名协程的调试"><span class="nav-number">6.8.</span> <span class="nav-text">命名协程的调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式取消Job"><span class="nav-number">6.9.</span> <span class="nav-text">显式取消Job</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道"><span class="nav-number">7.</span> <span class="nav-text">通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通道基础知识"><span class="nav-number">7.1.</span> <span class="nav-text">通道基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道的关闭和迭代"><span class="nav-number">7.2.</span> <span class="nav-text">通道的关闭和迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建通道生成器"><span class="nav-number">7.3.</span> <span class="nav-text">构建通道生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道"><span class="nav-number">7.4.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用管道求质数"><span class="nav-number">7.5.</span> <span class="nav-text">用管道求质数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扇出"><span class="nav-number">7.6.</span> <span class="nav-text">扇出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扇入"><span class="nav-number">7.7.</span> <span class="nav-text">扇入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲通道"><span class="nav-number">7.8.</span> <span class="nav-text">缓冲通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道是公平的"><span class="nav-number">7.9.</span> <span class="nav-text">通道是公平的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享的可变状态和并发性"><span class="nav-number">8.</span> <span class="nav-text">共享的可变状态和并发性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#这个问题"><span class="nav-number">8.1.</span> <span class="nav-text">这个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatiles毫无用处"><span class="nav-number">8.2.</span> <span class="nav-text">Volatiles毫无用处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的数据结构"><span class="nav-number">8.3.</span> <span class="nav-text">线程安全的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#细粒度线程约束"><span class="nav-number">8.4.</span> <span class="nav-text">细粒度线程约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#粗粒度线程约束"><span class="nav-number">8.5.</span> <span class="nav-text">粗粒度线程约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex"><span class="nav-number">8.6.</span> <span class="nav-text"> Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参与者"><span class="nav-number">8.7.</span> <span class="nav-text">参与者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Select表达式"><span class="nav-number">9.</span> <span class="nav-text">Select表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择通道"><span class="nav-number">9.1.</span> <span class="nav-text">选择通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭时的select"><span class="nav-number">9.2.</span> <span class="nav-text">关闭时的select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择发送"><span class="nav-number">9.3.</span> <span class="nav-text">选择发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择deferred值"><span class="nav-number">9.4.</span> <span class="nav-text">选择deferred值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切换到deferred值的通道"><span class="nav-number">9.5.</span> <span class="nav-text">切换到deferred值的通道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进一步的阅读"><span class="nav-number">10.</span> <span class="nav-text">进一步的阅读</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2021 朝着牛逼的道路一路狂奔 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            朝着牛逼的道路一路狂奔
          </div>
          <div class="panel-body">
            Copyright © 2021 段纪刚 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>